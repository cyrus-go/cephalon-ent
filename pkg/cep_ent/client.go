// Code generated by ent, DO NOT EDIT.

package cep_ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/artwork"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/artworklike"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/bill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/campaign"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/campaignorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/cdkinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/cloudfile"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/collect"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/device"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/devicegpumission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/devicereboottime"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/earnbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enumcondition"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enummissionstatus"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/extraservice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/extraserviceorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/extraserviceprice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/frpcinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/frpsinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/gpu"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/hmackeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/incomemanage"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/inputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/invite"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/loginrecord"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lotto"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottochancerule"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottogetcountrecord"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottoprize"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottorecord"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottousercount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/mission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionbatch"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missioncategory"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionconsumeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionextraservice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkind"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionproduceorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionproduction"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/outputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/platformaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/price"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitsetting"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/rechargecampaignrule"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/rechargeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/renewalagreement"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/symbol"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/transferorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/troublededuct"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/user"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/userdevice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxsocial"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/wallet"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/withdrawaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/withdrawrecord"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Artwork is the client for interacting with the Artwork builders.
	Artwork *ArtworkClient
	// ArtworkLike is the client for interacting with the ArtworkLike builders.
	ArtworkLike *ArtworkLikeClient
	// Bill is the client for interacting with the Bill builders.
	Bill *BillClient
	// CDKInfo is the client for interacting with the CDKInfo builders.
	CDKInfo *CDKInfoClient
	// Campaign is the client for interacting with the Campaign builders.
	Campaign *CampaignClient
	// CampaignOrder is the client for interacting with the CampaignOrder builders.
	CampaignOrder *CampaignOrderClient
	// CloudFile is the client for interacting with the CloudFile builders.
	CloudFile *CloudFileClient
	// Collect is the client for interacting with the Collect builders.
	Collect *CollectClient
	// CostAccount is the client for interacting with the CostAccount builders.
	CostAccount *CostAccountClient
	// CostBill is the client for interacting with the CostBill builders.
	CostBill *CostBillClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// DeviceGpuMission is the client for interacting with the DeviceGpuMission builders.
	DeviceGpuMission *DeviceGpuMissionClient
	// DeviceRebootTime is the client for interacting with the DeviceRebootTime builders.
	DeviceRebootTime *DeviceRebootTimeClient
	// EarnBill is the client for interacting with the EarnBill builders.
	EarnBill *EarnBillClient
	// EnumCondition is the client for interacting with the EnumCondition builders.
	EnumCondition *EnumConditionClient
	// EnumMissionStatus is the client for interacting with the EnumMissionStatus builders.
	EnumMissionStatus *EnumMissionStatusClient
	// ExtraService is the client for interacting with the ExtraService builders.
	ExtraService *ExtraServiceClient
	// ExtraServiceOrder is the client for interacting with the ExtraServiceOrder builders.
	ExtraServiceOrder *ExtraServiceOrderClient
	// ExtraServicePrice is the client for interacting with the ExtraServicePrice builders.
	ExtraServicePrice *ExtraServicePriceClient
	// FrpcInfo is the client for interacting with the FrpcInfo builders.
	FrpcInfo *FrpcInfoClient
	// FrpsInfo is the client for interacting with the FrpsInfo builders.
	FrpsInfo *FrpsInfoClient
	// Gpu is the client for interacting with the Gpu builders.
	Gpu *GpuClient
	// HmacKeyPair is the client for interacting with the HmacKeyPair builders.
	HmacKeyPair *HmacKeyPairClient
	// IncomeManage is the client for interacting with the IncomeManage builders.
	IncomeManage *IncomeManageClient
	// InputLog is the client for interacting with the InputLog builders.
	InputLog *InputLogClient
	// Invite is the client for interacting with the Invite builders.
	Invite *InviteClient
	// LoginRecord is the client for interacting with the LoginRecord builders.
	LoginRecord *LoginRecordClient
	// Lotto is the client for interacting with the Lotto builders.
	Lotto *LottoClient
	// LottoChanceRule is the client for interacting with the LottoChanceRule builders.
	LottoChanceRule *LottoChanceRuleClient
	// LottoGetCountRecord is the client for interacting with the LottoGetCountRecord builders.
	LottoGetCountRecord *LottoGetCountRecordClient
	// LottoPrize is the client for interacting with the LottoPrize builders.
	LottoPrize *LottoPrizeClient
	// LottoRecord is the client for interacting with the LottoRecord builders.
	LottoRecord *LottoRecordClient
	// LottoUserCount is the client for interacting with the LottoUserCount builders.
	LottoUserCount *LottoUserCountClient
	// Mission is the client for interacting with the Mission builders.
	Mission *MissionClient
	// MissionBatch is the client for interacting with the MissionBatch builders.
	MissionBatch *MissionBatchClient
	// MissionCategory is the client for interacting with the MissionCategory builders.
	MissionCategory *MissionCategoryClient
	// MissionConsumeOrder is the client for interacting with the MissionConsumeOrder builders.
	MissionConsumeOrder *MissionConsumeOrderClient
	// MissionExtraService is the client for interacting with the MissionExtraService builders.
	MissionExtraService *MissionExtraServiceClient
	// MissionKeyPair is the client for interacting with the MissionKeyPair builders.
	MissionKeyPair *MissionKeyPairClient
	// MissionKind is the client for interacting with the MissionKind builders.
	MissionKind *MissionKindClient
	// MissionOrder is the client for interacting with the MissionOrder builders.
	MissionOrder *MissionOrderClient
	// MissionProduceOrder is the client for interacting with the MissionProduceOrder builders.
	MissionProduceOrder *MissionProduceOrderClient
	// MissionProduction is the client for interacting with the MissionProduction builders.
	MissionProduction *MissionProductionClient
	// OutputLog is the client for interacting with the OutputLog builders.
	OutputLog *OutputLogClient
	// PlatformAccount is the client for interacting with the PlatformAccount builders.
	PlatformAccount *PlatformAccountClient
	// Price is the client for interacting with the Price builders.
	Price *PriceClient
	// ProfitAccount is the client for interacting with the ProfitAccount builders.
	ProfitAccount *ProfitAccountClient
	// ProfitSetting is the client for interacting with the ProfitSetting builders.
	ProfitSetting *ProfitSettingClient
	// RechargeCampaignRule is the client for interacting with the RechargeCampaignRule builders.
	RechargeCampaignRule *RechargeCampaignRuleClient
	// RechargeOrder is the client for interacting with the RechargeOrder builders.
	RechargeOrder *RechargeOrderClient
	// RenewalAgreement is the client for interacting with the RenewalAgreement builders.
	RenewalAgreement *RenewalAgreementClient
	// Symbol is the client for interacting with the Symbol builders.
	Symbol *SymbolClient
	// TransferOrder is the client for interacting with the TransferOrder builders.
	TransferOrder *TransferOrderClient
	// TroubleDeduct is the client for interacting with the TroubleDeduct builders.
	TroubleDeduct *TroubleDeductClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserDevice is the client for interacting with the UserDevice builders.
	UserDevice *UserDeviceClient
	// VXAccount is the client for interacting with the VXAccount builders.
	VXAccount *VXAccountClient
	// VXSocial is the client for interacting with the VXSocial builders.
	VXSocial *VXSocialClient
	// Wallet is the client for interacting with the Wallet builders.
	Wallet *WalletClient
	// WithdrawAccount is the client for interacting with the WithdrawAccount builders.
	WithdrawAccount *WithdrawAccountClient
	// WithdrawRecord is the client for interacting with the WithdrawRecord builders.
	WithdrawRecord *WithdrawRecordClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Artwork = NewArtworkClient(c.config)
	c.ArtworkLike = NewArtworkLikeClient(c.config)
	c.Bill = NewBillClient(c.config)
	c.CDKInfo = NewCDKInfoClient(c.config)
	c.Campaign = NewCampaignClient(c.config)
	c.CampaignOrder = NewCampaignOrderClient(c.config)
	c.CloudFile = NewCloudFileClient(c.config)
	c.Collect = NewCollectClient(c.config)
	c.CostAccount = NewCostAccountClient(c.config)
	c.CostBill = NewCostBillClient(c.config)
	c.Device = NewDeviceClient(c.config)
	c.DeviceGpuMission = NewDeviceGpuMissionClient(c.config)
	c.DeviceRebootTime = NewDeviceRebootTimeClient(c.config)
	c.EarnBill = NewEarnBillClient(c.config)
	c.EnumCondition = NewEnumConditionClient(c.config)
	c.EnumMissionStatus = NewEnumMissionStatusClient(c.config)
	c.ExtraService = NewExtraServiceClient(c.config)
	c.ExtraServiceOrder = NewExtraServiceOrderClient(c.config)
	c.ExtraServicePrice = NewExtraServicePriceClient(c.config)
	c.FrpcInfo = NewFrpcInfoClient(c.config)
	c.FrpsInfo = NewFrpsInfoClient(c.config)
	c.Gpu = NewGpuClient(c.config)
	c.HmacKeyPair = NewHmacKeyPairClient(c.config)
	c.IncomeManage = NewIncomeManageClient(c.config)
	c.InputLog = NewInputLogClient(c.config)
	c.Invite = NewInviteClient(c.config)
	c.LoginRecord = NewLoginRecordClient(c.config)
	c.Lotto = NewLottoClient(c.config)
	c.LottoChanceRule = NewLottoChanceRuleClient(c.config)
	c.LottoGetCountRecord = NewLottoGetCountRecordClient(c.config)
	c.LottoPrize = NewLottoPrizeClient(c.config)
	c.LottoRecord = NewLottoRecordClient(c.config)
	c.LottoUserCount = NewLottoUserCountClient(c.config)
	c.Mission = NewMissionClient(c.config)
	c.MissionBatch = NewMissionBatchClient(c.config)
	c.MissionCategory = NewMissionCategoryClient(c.config)
	c.MissionConsumeOrder = NewMissionConsumeOrderClient(c.config)
	c.MissionExtraService = NewMissionExtraServiceClient(c.config)
	c.MissionKeyPair = NewMissionKeyPairClient(c.config)
	c.MissionKind = NewMissionKindClient(c.config)
	c.MissionOrder = NewMissionOrderClient(c.config)
	c.MissionProduceOrder = NewMissionProduceOrderClient(c.config)
	c.MissionProduction = NewMissionProductionClient(c.config)
	c.OutputLog = NewOutputLogClient(c.config)
	c.PlatformAccount = NewPlatformAccountClient(c.config)
	c.Price = NewPriceClient(c.config)
	c.ProfitAccount = NewProfitAccountClient(c.config)
	c.ProfitSetting = NewProfitSettingClient(c.config)
	c.RechargeCampaignRule = NewRechargeCampaignRuleClient(c.config)
	c.RechargeOrder = NewRechargeOrderClient(c.config)
	c.RenewalAgreement = NewRenewalAgreementClient(c.config)
	c.Symbol = NewSymbolClient(c.config)
	c.TransferOrder = NewTransferOrderClient(c.config)
	c.TroubleDeduct = NewTroubleDeductClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserDevice = NewUserDeviceClient(c.config)
	c.VXAccount = NewVXAccountClient(c.config)
	c.VXSocial = NewVXSocialClient(c.config)
	c.Wallet = NewWalletClient(c.config)
	c.WithdrawAccount = NewWithdrawAccountClient(c.config)
	c.WithdrawRecord = NewWithdrawRecordClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("cep_ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("cep_ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Artwork:              NewArtworkClient(cfg),
		ArtworkLike:          NewArtworkLikeClient(cfg),
		Bill:                 NewBillClient(cfg),
		CDKInfo:              NewCDKInfoClient(cfg),
		Campaign:             NewCampaignClient(cfg),
		CampaignOrder:        NewCampaignOrderClient(cfg),
		CloudFile:            NewCloudFileClient(cfg),
		Collect:              NewCollectClient(cfg),
		CostAccount:          NewCostAccountClient(cfg),
		CostBill:             NewCostBillClient(cfg),
		Device:               NewDeviceClient(cfg),
		DeviceGpuMission:     NewDeviceGpuMissionClient(cfg),
		DeviceRebootTime:     NewDeviceRebootTimeClient(cfg),
		EarnBill:             NewEarnBillClient(cfg),
		EnumCondition:        NewEnumConditionClient(cfg),
		EnumMissionStatus:    NewEnumMissionStatusClient(cfg),
		ExtraService:         NewExtraServiceClient(cfg),
		ExtraServiceOrder:    NewExtraServiceOrderClient(cfg),
		ExtraServicePrice:    NewExtraServicePriceClient(cfg),
		FrpcInfo:             NewFrpcInfoClient(cfg),
		FrpsInfo:             NewFrpsInfoClient(cfg),
		Gpu:                  NewGpuClient(cfg),
		HmacKeyPair:          NewHmacKeyPairClient(cfg),
		IncomeManage:         NewIncomeManageClient(cfg),
		InputLog:             NewInputLogClient(cfg),
		Invite:               NewInviteClient(cfg),
		LoginRecord:          NewLoginRecordClient(cfg),
		Lotto:                NewLottoClient(cfg),
		LottoChanceRule:      NewLottoChanceRuleClient(cfg),
		LottoGetCountRecord:  NewLottoGetCountRecordClient(cfg),
		LottoPrize:           NewLottoPrizeClient(cfg),
		LottoRecord:          NewLottoRecordClient(cfg),
		LottoUserCount:       NewLottoUserCountClient(cfg),
		Mission:              NewMissionClient(cfg),
		MissionBatch:         NewMissionBatchClient(cfg),
		MissionCategory:      NewMissionCategoryClient(cfg),
		MissionConsumeOrder:  NewMissionConsumeOrderClient(cfg),
		MissionExtraService:  NewMissionExtraServiceClient(cfg),
		MissionKeyPair:       NewMissionKeyPairClient(cfg),
		MissionKind:          NewMissionKindClient(cfg),
		MissionOrder:         NewMissionOrderClient(cfg),
		MissionProduceOrder:  NewMissionProduceOrderClient(cfg),
		MissionProduction:    NewMissionProductionClient(cfg),
		OutputLog:            NewOutputLogClient(cfg),
		PlatformAccount:      NewPlatformAccountClient(cfg),
		Price:                NewPriceClient(cfg),
		ProfitAccount:        NewProfitAccountClient(cfg),
		ProfitSetting:        NewProfitSettingClient(cfg),
		RechargeCampaignRule: NewRechargeCampaignRuleClient(cfg),
		RechargeOrder:        NewRechargeOrderClient(cfg),
		RenewalAgreement:     NewRenewalAgreementClient(cfg),
		Symbol:               NewSymbolClient(cfg),
		TransferOrder:        NewTransferOrderClient(cfg),
		TroubleDeduct:        NewTroubleDeductClient(cfg),
		User:                 NewUserClient(cfg),
		UserDevice:           NewUserDeviceClient(cfg),
		VXAccount:            NewVXAccountClient(cfg),
		VXSocial:             NewVXSocialClient(cfg),
		Wallet:               NewWalletClient(cfg),
		WithdrawAccount:      NewWithdrawAccountClient(cfg),
		WithdrawRecord:       NewWithdrawRecordClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Artwork:              NewArtworkClient(cfg),
		ArtworkLike:          NewArtworkLikeClient(cfg),
		Bill:                 NewBillClient(cfg),
		CDKInfo:              NewCDKInfoClient(cfg),
		Campaign:             NewCampaignClient(cfg),
		CampaignOrder:        NewCampaignOrderClient(cfg),
		CloudFile:            NewCloudFileClient(cfg),
		Collect:              NewCollectClient(cfg),
		CostAccount:          NewCostAccountClient(cfg),
		CostBill:             NewCostBillClient(cfg),
		Device:               NewDeviceClient(cfg),
		DeviceGpuMission:     NewDeviceGpuMissionClient(cfg),
		DeviceRebootTime:     NewDeviceRebootTimeClient(cfg),
		EarnBill:             NewEarnBillClient(cfg),
		EnumCondition:        NewEnumConditionClient(cfg),
		EnumMissionStatus:    NewEnumMissionStatusClient(cfg),
		ExtraService:         NewExtraServiceClient(cfg),
		ExtraServiceOrder:    NewExtraServiceOrderClient(cfg),
		ExtraServicePrice:    NewExtraServicePriceClient(cfg),
		FrpcInfo:             NewFrpcInfoClient(cfg),
		FrpsInfo:             NewFrpsInfoClient(cfg),
		Gpu:                  NewGpuClient(cfg),
		HmacKeyPair:          NewHmacKeyPairClient(cfg),
		IncomeManage:         NewIncomeManageClient(cfg),
		InputLog:             NewInputLogClient(cfg),
		Invite:               NewInviteClient(cfg),
		LoginRecord:          NewLoginRecordClient(cfg),
		Lotto:                NewLottoClient(cfg),
		LottoChanceRule:      NewLottoChanceRuleClient(cfg),
		LottoGetCountRecord:  NewLottoGetCountRecordClient(cfg),
		LottoPrize:           NewLottoPrizeClient(cfg),
		LottoRecord:          NewLottoRecordClient(cfg),
		LottoUserCount:       NewLottoUserCountClient(cfg),
		Mission:              NewMissionClient(cfg),
		MissionBatch:         NewMissionBatchClient(cfg),
		MissionCategory:      NewMissionCategoryClient(cfg),
		MissionConsumeOrder:  NewMissionConsumeOrderClient(cfg),
		MissionExtraService:  NewMissionExtraServiceClient(cfg),
		MissionKeyPair:       NewMissionKeyPairClient(cfg),
		MissionKind:          NewMissionKindClient(cfg),
		MissionOrder:         NewMissionOrderClient(cfg),
		MissionProduceOrder:  NewMissionProduceOrderClient(cfg),
		MissionProduction:    NewMissionProductionClient(cfg),
		OutputLog:            NewOutputLogClient(cfg),
		PlatformAccount:      NewPlatformAccountClient(cfg),
		Price:                NewPriceClient(cfg),
		ProfitAccount:        NewProfitAccountClient(cfg),
		ProfitSetting:        NewProfitSettingClient(cfg),
		RechargeCampaignRule: NewRechargeCampaignRuleClient(cfg),
		RechargeOrder:        NewRechargeOrderClient(cfg),
		RenewalAgreement:     NewRenewalAgreementClient(cfg),
		Symbol:               NewSymbolClient(cfg),
		TransferOrder:        NewTransferOrderClient(cfg),
		TroubleDeduct:        NewTroubleDeductClient(cfg),
		User:                 NewUserClient(cfg),
		UserDevice:           NewUserDeviceClient(cfg),
		VXAccount:            NewVXAccountClient(cfg),
		VXSocial:             NewVXSocialClient(cfg),
		Wallet:               NewWalletClient(cfg),
		WithdrawAccount:      NewWithdrawAccountClient(cfg),
		WithdrawRecord:       NewWithdrawRecordClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Artwork.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Artwork, c.ArtworkLike, c.Bill, c.CDKInfo, c.Campaign, c.CampaignOrder,
		c.CloudFile, c.Collect, c.CostAccount, c.CostBill, c.Device,
		c.DeviceGpuMission, c.DeviceRebootTime, c.EarnBill, c.EnumCondition,
		c.EnumMissionStatus, c.ExtraService, c.ExtraServiceOrder, c.ExtraServicePrice,
		c.FrpcInfo, c.FrpsInfo, c.Gpu, c.HmacKeyPair, c.IncomeManage, c.InputLog,
		c.Invite, c.LoginRecord, c.Lotto, c.LottoChanceRule, c.LottoGetCountRecord,
		c.LottoPrize, c.LottoRecord, c.LottoUserCount, c.Mission, c.MissionBatch,
		c.MissionCategory, c.MissionConsumeOrder, c.MissionExtraService,
		c.MissionKeyPair, c.MissionKind, c.MissionOrder, c.MissionProduceOrder,
		c.MissionProduction, c.OutputLog, c.PlatformAccount, c.Price, c.ProfitAccount,
		c.ProfitSetting, c.RechargeCampaignRule, c.RechargeOrder, c.RenewalAgreement,
		c.Symbol, c.TransferOrder, c.TroubleDeduct, c.User, c.UserDevice, c.VXAccount,
		c.VXSocial, c.Wallet, c.WithdrawAccount, c.WithdrawRecord,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Artwork, c.ArtworkLike, c.Bill, c.CDKInfo, c.Campaign, c.CampaignOrder,
		c.CloudFile, c.Collect, c.CostAccount, c.CostBill, c.Device,
		c.DeviceGpuMission, c.DeviceRebootTime, c.EarnBill, c.EnumCondition,
		c.EnumMissionStatus, c.ExtraService, c.ExtraServiceOrder, c.ExtraServicePrice,
		c.FrpcInfo, c.FrpsInfo, c.Gpu, c.HmacKeyPair, c.IncomeManage, c.InputLog,
		c.Invite, c.LoginRecord, c.Lotto, c.LottoChanceRule, c.LottoGetCountRecord,
		c.LottoPrize, c.LottoRecord, c.LottoUserCount, c.Mission, c.MissionBatch,
		c.MissionCategory, c.MissionConsumeOrder, c.MissionExtraService,
		c.MissionKeyPair, c.MissionKind, c.MissionOrder, c.MissionProduceOrder,
		c.MissionProduction, c.OutputLog, c.PlatformAccount, c.Price, c.ProfitAccount,
		c.ProfitSetting, c.RechargeCampaignRule, c.RechargeOrder, c.RenewalAgreement,
		c.Symbol, c.TransferOrder, c.TroubleDeduct, c.User, c.UserDevice, c.VXAccount,
		c.VXSocial, c.Wallet, c.WithdrawAccount, c.WithdrawRecord,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ArtworkMutation:
		return c.Artwork.mutate(ctx, m)
	case *ArtworkLikeMutation:
		return c.ArtworkLike.mutate(ctx, m)
	case *BillMutation:
		return c.Bill.mutate(ctx, m)
	case *CDKInfoMutation:
		return c.CDKInfo.mutate(ctx, m)
	case *CampaignMutation:
		return c.Campaign.mutate(ctx, m)
	case *CampaignOrderMutation:
		return c.CampaignOrder.mutate(ctx, m)
	case *CloudFileMutation:
		return c.CloudFile.mutate(ctx, m)
	case *CollectMutation:
		return c.Collect.mutate(ctx, m)
	case *CostAccountMutation:
		return c.CostAccount.mutate(ctx, m)
	case *CostBillMutation:
		return c.CostBill.mutate(ctx, m)
	case *DeviceMutation:
		return c.Device.mutate(ctx, m)
	case *DeviceGpuMissionMutation:
		return c.DeviceGpuMission.mutate(ctx, m)
	case *DeviceRebootTimeMutation:
		return c.DeviceRebootTime.mutate(ctx, m)
	case *EarnBillMutation:
		return c.EarnBill.mutate(ctx, m)
	case *EnumConditionMutation:
		return c.EnumCondition.mutate(ctx, m)
	case *EnumMissionStatusMutation:
		return c.EnumMissionStatus.mutate(ctx, m)
	case *ExtraServiceMutation:
		return c.ExtraService.mutate(ctx, m)
	case *ExtraServiceOrderMutation:
		return c.ExtraServiceOrder.mutate(ctx, m)
	case *ExtraServicePriceMutation:
		return c.ExtraServicePrice.mutate(ctx, m)
	case *FrpcInfoMutation:
		return c.FrpcInfo.mutate(ctx, m)
	case *FrpsInfoMutation:
		return c.FrpsInfo.mutate(ctx, m)
	case *GpuMutation:
		return c.Gpu.mutate(ctx, m)
	case *HmacKeyPairMutation:
		return c.HmacKeyPair.mutate(ctx, m)
	case *IncomeManageMutation:
		return c.IncomeManage.mutate(ctx, m)
	case *InputLogMutation:
		return c.InputLog.mutate(ctx, m)
	case *InviteMutation:
		return c.Invite.mutate(ctx, m)
	case *LoginRecordMutation:
		return c.LoginRecord.mutate(ctx, m)
	case *LottoMutation:
		return c.Lotto.mutate(ctx, m)
	case *LottoChanceRuleMutation:
		return c.LottoChanceRule.mutate(ctx, m)
	case *LottoGetCountRecordMutation:
		return c.LottoGetCountRecord.mutate(ctx, m)
	case *LottoPrizeMutation:
		return c.LottoPrize.mutate(ctx, m)
	case *LottoRecordMutation:
		return c.LottoRecord.mutate(ctx, m)
	case *LottoUserCountMutation:
		return c.LottoUserCount.mutate(ctx, m)
	case *MissionMutation:
		return c.Mission.mutate(ctx, m)
	case *MissionBatchMutation:
		return c.MissionBatch.mutate(ctx, m)
	case *MissionCategoryMutation:
		return c.MissionCategory.mutate(ctx, m)
	case *MissionConsumeOrderMutation:
		return c.MissionConsumeOrder.mutate(ctx, m)
	case *MissionExtraServiceMutation:
		return c.MissionExtraService.mutate(ctx, m)
	case *MissionKeyPairMutation:
		return c.MissionKeyPair.mutate(ctx, m)
	case *MissionKindMutation:
		return c.MissionKind.mutate(ctx, m)
	case *MissionOrderMutation:
		return c.MissionOrder.mutate(ctx, m)
	case *MissionProduceOrderMutation:
		return c.MissionProduceOrder.mutate(ctx, m)
	case *MissionProductionMutation:
		return c.MissionProduction.mutate(ctx, m)
	case *OutputLogMutation:
		return c.OutputLog.mutate(ctx, m)
	case *PlatformAccountMutation:
		return c.PlatformAccount.mutate(ctx, m)
	case *PriceMutation:
		return c.Price.mutate(ctx, m)
	case *ProfitAccountMutation:
		return c.ProfitAccount.mutate(ctx, m)
	case *ProfitSettingMutation:
		return c.ProfitSetting.mutate(ctx, m)
	case *RechargeCampaignRuleMutation:
		return c.RechargeCampaignRule.mutate(ctx, m)
	case *RechargeOrderMutation:
		return c.RechargeOrder.mutate(ctx, m)
	case *RenewalAgreementMutation:
		return c.RenewalAgreement.mutate(ctx, m)
	case *SymbolMutation:
		return c.Symbol.mutate(ctx, m)
	case *TransferOrderMutation:
		return c.TransferOrder.mutate(ctx, m)
	case *TroubleDeductMutation:
		return c.TroubleDeduct.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserDeviceMutation:
		return c.UserDevice.mutate(ctx, m)
	case *VXAccountMutation:
		return c.VXAccount.mutate(ctx, m)
	case *VXSocialMutation:
		return c.VXSocial.mutate(ctx, m)
	case *WalletMutation:
		return c.Wallet.mutate(ctx, m)
	case *WithdrawAccountMutation:
		return c.WithdrawAccount.mutate(ctx, m)
	case *WithdrawRecordMutation:
		return c.WithdrawRecord.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("cep_ent: unknown mutation type %T", m)
	}
}

// ArtworkClient is a client for the Artwork schema.
type ArtworkClient struct {
	config
}

// NewArtworkClient returns a client for the Artwork from the given config.
func NewArtworkClient(c config) *ArtworkClient {
	return &ArtworkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artwork.Hooks(f(g(h())))`.
func (c *ArtworkClient) Use(hooks ...Hook) {
	c.hooks.Artwork = append(c.hooks.Artwork, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artwork.Intercept(f(g(h())))`.
func (c *ArtworkClient) Intercept(interceptors ...Interceptor) {
	c.inters.Artwork = append(c.inters.Artwork, interceptors...)
}

// Create returns a builder for creating a Artwork entity.
func (c *ArtworkClient) Create() *ArtworkCreate {
	mutation := newArtworkMutation(c.config, OpCreate)
	return &ArtworkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artwork entities.
func (c *ArtworkClient) CreateBulk(builders ...*ArtworkCreate) *ArtworkCreateBulk {
	return &ArtworkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtworkClient) MapCreateBulk(slice any, setFunc func(*ArtworkCreate, int)) *ArtworkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtworkCreateBulk{err: fmt.Errorf("calling to ArtworkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtworkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtworkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artwork.
func (c *ArtworkClient) Update() *ArtworkUpdate {
	mutation := newArtworkMutation(c.config, OpUpdate)
	return &ArtworkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtworkClient) UpdateOne(a *Artwork) *ArtworkUpdateOne {
	mutation := newArtworkMutation(c.config, OpUpdateOne, withArtwork(a))
	return &ArtworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtworkClient) UpdateOneID(id int64) *ArtworkUpdateOne {
	mutation := newArtworkMutation(c.config, OpUpdateOne, withArtworkID(id))
	return &ArtworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artwork.
func (c *ArtworkClient) Delete() *ArtworkDelete {
	mutation := newArtworkMutation(c.config, OpDelete)
	return &ArtworkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtworkClient) DeleteOne(a *Artwork) *ArtworkDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtworkClient) DeleteOneID(id int64) *ArtworkDeleteOne {
	builder := c.Delete().Where(artwork.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtworkDeleteOne{builder}
}

// Query returns a query builder for Artwork.
func (c *ArtworkClient) Query() *ArtworkQuery {
	return &ArtworkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtwork},
		inters: c.Interceptors(),
	}
}

// Get returns a Artwork entity by its id.
func (c *ArtworkClient) Get(ctx context.Context, id int64) (*Artwork, error) {
	return c.Query().Where(artwork.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtworkClient) GetX(ctx context.Context, id int64) *Artwork {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a Artwork.
func (c *ArtworkClient) QueryAuthor(a *Artwork) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artwork.Table, artwork.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artwork.AuthorTable, artwork.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtworkLikes queries the artwork_likes edge of a Artwork.
func (c *ArtworkClient) QueryArtworkLikes(a *Artwork) *ArtworkLikeQuery {
	query := (&ArtworkLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artwork.Table, artwork.FieldID, id),
			sqlgraph.To(artworklike.Table, artworklike.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, artwork.ArtworkLikesTable, artwork.ArtworkLikesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtworkClient) Hooks() []Hook {
	return c.hooks.Artwork
}

// Interceptors returns the client interceptors.
func (c *ArtworkClient) Interceptors() []Interceptor {
	return c.inters.Artwork
}

func (c *ArtworkClient) mutate(ctx context.Context, m *ArtworkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtworkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtworkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtworkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Artwork mutation op: %q", m.Op())
	}
}

// ArtworkLikeClient is a client for the ArtworkLike schema.
type ArtworkLikeClient struct {
	config
}

// NewArtworkLikeClient returns a client for the ArtworkLike from the given config.
func NewArtworkLikeClient(c config) *ArtworkLikeClient {
	return &ArtworkLikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artworklike.Hooks(f(g(h())))`.
func (c *ArtworkLikeClient) Use(hooks ...Hook) {
	c.hooks.ArtworkLike = append(c.hooks.ArtworkLike, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artworklike.Intercept(f(g(h())))`.
func (c *ArtworkLikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.ArtworkLike = append(c.inters.ArtworkLike, interceptors...)
}

// Create returns a builder for creating a ArtworkLike entity.
func (c *ArtworkLikeClient) Create() *ArtworkLikeCreate {
	mutation := newArtworkLikeMutation(c.config, OpCreate)
	return &ArtworkLikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ArtworkLike entities.
func (c *ArtworkLikeClient) CreateBulk(builders ...*ArtworkLikeCreate) *ArtworkLikeCreateBulk {
	return &ArtworkLikeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtworkLikeClient) MapCreateBulk(slice any, setFunc func(*ArtworkLikeCreate, int)) *ArtworkLikeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtworkLikeCreateBulk{err: fmt.Errorf("calling to ArtworkLikeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtworkLikeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtworkLikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ArtworkLike.
func (c *ArtworkLikeClient) Update() *ArtworkLikeUpdate {
	mutation := newArtworkLikeMutation(c.config, OpUpdate)
	return &ArtworkLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtworkLikeClient) UpdateOne(al *ArtworkLike) *ArtworkLikeUpdateOne {
	mutation := newArtworkLikeMutation(c.config, OpUpdateOne, withArtworkLike(al))
	return &ArtworkLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtworkLikeClient) UpdateOneID(id int64) *ArtworkLikeUpdateOne {
	mutation := newArtworkLikeMutation(c.config, OpUpdateOne, withArtworkLikeID(id))
	return &ArtworkLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ArtworkLike.
func (c *ArtworkLikeClient) Delete() *ArtworkLikeDelete {
	mutation := newArtworkLikeMutation(c.config, OpDelete)
	return &ArtworkLikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtworkLikeClient) DeleteOne(al *ArtworkLike) *ArtworkLikeDeleteOne {
	return c.DeleteOneID(al.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtworkLikeClient) DeleteOneID(id int64) *ArtworkLikeDeleteOne {
	builder := c.Delete().Where(artworklike.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtworkLikeDeleteOne{builder}
}

// Query returns a query builder for ArtworkLike.
func (c *ArtworkLikeClient) Query() *ArtworkLikeQuery {
	return &ArtworkLikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtworkLike},
		inters: c.Interceptors(),
	}
}

// Get returns a ArtworkLike entity by its id.
func (c *ArtworkLikeClient) Get(ctx context.Context, id int64) (*ArtworkLike, error) {
	return c.Query().Where(artworklike.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtworkLikeClient) GetX(ctx context.Context, id int64) *ArtworkLike {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ArtworkLike.
func (c *ArtworkLikeClient) QueryUser(al *ArtworkLike) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := al.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artworklike.Table, artworklike.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artworklike.UserTable, artworklike.UserColumn),
		)
		fromV = sqlgraph.Neighbors(al.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtwork queries the artwork edge of a ArtworkLike.
func (c *ArtworkLikeClient) QueryArtwork(al *ArtworkLike) *ArtworkQuery {
	query := (&ArtworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := al.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artworklike.Table, artworklike.FieldID, id),
			sqlgraph.To(artwork.Table, artwork.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artworklike.ArtworkTable, artworklike.ArtworkColumn),
		)
		fromV = sqlgraph.Neighbors(al.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtworkLikeClient) Hooks() []Hook {
	return c.hooks.ArtworkLike
}

// Interceptors returns the client interceptors.
func (c *ArtworkLikeClient) Interceptors() []Interceptor {
	return c.inters.ArtworkLike
}

func (c *ArtworkLikeClient) mutate(ctx context.Context, m *ArtworkLikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtworkLikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtworkLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtworkLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtworkLikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown ArtworkLike mutation op: %q", m.Op())
	}
}

// BillClient is a client for the Bill schema.
type BillClient struct {
	config
}

// NewBillClient returns a client for the Bill from the given config.
func NewBillClient(c config) *BillClient {
	return &BillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bill.Hooks(f(g(h())))`.
func (c *BillClient) Use(hooks ...Hook) {
	c.hooks.Bill = append(c.hooks.Bill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bill.Intercept(f(g(h())))`.
func (c *BillClient) Intercept(interceptors ...Interceptor) {
	c.inters.Bill = append(c.inters.Bill, interceptors...)
}

// Create returns a builder for creating a Bill entity.
func (c *BillClient) Create() *BillCreate {
	mutation := newBillMutation(c.config, OpCreate)
	return &BillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Bill entities.
func (c *BillClient) CreateBulk(builders ...*BillCreate) *BillCreateBulk {
	return &BillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BillClient) MapCreateBulk(slice any, setFunc func(*BillCreate, int)) *BillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BillCreateBulk{err: fmt.Errorf("calling to BillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Bill.
func (c *BillClient) Update() *BillUpdate {
	mutation := newBillMutation(c.config, OpUpdate)
	return &BillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BillClient) UpdateOne(b *Bill) *BillUpdateOne {
	mutation := newBillMutation(c.config, OpUpdateOne, withBill(b))
	return &BillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BillClient) UpdateOneID(id int64) *BillUpdateOne {
	mutation := newBillMutation(c.config, OpUpdateOne, withBillID(id))
	return &BillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Bill.
func (c *BillClient) Delete() *BillDelete {
	mutation := newBillMutation(c.config, OpDelete)
	return &BillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BillClient) DeleteOne(b *Bill) *BillDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BillClient) DeleteOneID(id int64) *BillDeleteOne {
	builder := c.Delete().Where(bill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BillDeleteOne{builder}
}

// Query returns a query builder for Bill.
func (c *BillClient) Query() *BillQuery {
	return &BillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBill},
		inters: c.Interceptors(),
	}
}

// Get returns a Bill entity by its id.
func (c *BillClient) Get(ctx context.Context, id int64) (*Bill, error) {
	return c.Query().Where(bill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BillClient) GetX(ctx context.Context, id int64) *Bill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySourceUser queries the source_user edge of a Bill.
func (c *BillClient) QuerySourceUser(b *Bill) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.SourceUserTable, bill.SourceUserColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetUser queries the target_user edge of a Bill.
func (c *BillClient) QueryTargetUser(b *Bill) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.TargetUserTable, bill.TargetUserColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransferOrder queries the transfer_order edge of a Bill.
func (c *BillClient) QueryTransferOrder(b *Bill) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.TransferOrderTable, bill.TransferOrderColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrder queries the mission_order edge of a Bill.
func (c *BillClient) QueryMissionOrder(b *Bill) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.MissionOrderTable, bill.MissionOrderColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvite queries the invite edge of a Bill.
func (c *BillClient) QueryInvite(b *Bill) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.InviteTable, bill.InviteColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a Bill.
func (c *BillClient) QuerySymbol(b *Bill) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.SymbolTable, bill.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetSymbol queries the target_symbol edge of a Bill.
func (c *BillClient) QueryTargetSymbol(b *Bill) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.TargetSymbolTable, bill.TargetSymbolColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BillClient) Hooks() []Hook {
	return c.hooks.Bill
}

// Interceptors returns the client interceptors.
func (c *BillClient) Interceptors() []Interceptor {
	return c.inters.Bill
}

func (c *BillClient) mutate(ctx context.Context, m *BillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Bill mutation op: %q", m.Op())
	}
}

// CDKInfoClient is a client for the CDKInfo schema.
type CDKInfoClient struct {
	config
}

// NewCDKInfoClient returns a client for the CDKInfo from the given config.
func NewCDKInfoClient(c config) *CDKInfoClient {
	return &CDKInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cdkinfo.Hooks(f(g(h())))`.
func (c *CDKInfoClient) Use(hooks ...Hook) {
	c.hooks.CDKInfo = append(c.hooks.CDKInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cdkinfo.Intercept(f(g(h())))`.
func (c *CDKInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.CDKInfo = append(c.inters.CDKInfo, interceptors...)
}

// Create returns a builder for creating a CDKInfo entity.
func (c *CDKInfoClient) Create() *CDKInfoCreate {
	mutation := newCDKInfoMutation(c.config, OpCreate)
	return &CDKInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CDKInfo entities.
func (c *CDKInfoClient) CreateBulk(builders ...*CDKInfoCreate) *CDKInfoCreateBulk {
	return &CDKInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CDKInfoClient) MapCreateBulk(slice any, setFunc func(*CDKInfoCreate, int)) *CDKInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CDKInfoCreateBulk{err: fmt.Errorf("calling to CDKInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CDKInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CDKInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CDKInfo.
func (c *CDKInfoClient) Update() *CDKInfoUpdate {
	mutation := newCDKInfoMutation(c.config, OpUpdate)
	return &CDKInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CDKInfoClient) UpdateOne(ci *CDKInfo) *CDKInfoUpdateOne {
	mutation := newCDKInfoMutation(c.config, OpUpdateOne, withCDKInfo(ci))
	return &CDKInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CDKInfoClient) UpdateOneID(id int64) *CDKInfoUpdateOne {
	mutation := newCDKInfoMutation(c.config, OpUpdateOne, withCDKInfoID(id))
	return &CDKInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CDKInfo.
func (c *CDKInfoClient) Delete() *CDKInfoDelete {
	mutation := newCDKInfoMutation(c.config, OpDelete)
	return &CDKInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CDKInfoClient) DeleteOne(ci *CDKInfo) *CDKInfoDeleteOne {
	return c.DeleteOneID(ci.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CDKInfoClient) DeleteOneID(id int64) *CDKInfoDeleteOne {
	builder := c.Delete().Where(cdkinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CDKInfoDeleteOne{builder}
}

// Query returns a query builder for CDKInfo.
func (c *CDKInfoClient) Query() *CDKInfoQuery {
	return &CDKInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCDKInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a CDKInfo entity by its id.
func (c *CDKInfoClient) Get(ctx context.Context, id int64) (*CDKInfo, error) {
	return c.Query().Where(cdkinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CDKInfoClient) GetX(ctx context.Context, id int64) *CDKInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssueUser queries the issue_user edge of a CDKInfo.
func (c *CDKInfoClient) QueryIssueUser(ci *CDKInfo) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cdkinfo.Table, cdkinfo.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, cdkinfo.IssueUserTable, cdkinfo.IssueUserColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUseUser queries the use_user edge of a CDKInfo.
func (c *CDKInfoClient) QueryUseUser(ci *CDKInfo) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cdkinfo.Table, cdkinfo.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, cdkinfo.UseUserTable, cdkinfo.UseUserColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CDKInfoClient) Hooks() []Hook {
	return c.hooks.CDKInfo
}

// Interceptors returns the client interceptors.
func (c *CDKInfoClient) Interceptors() []Interceptor {
	return c.inters.CDKInfo
}

func (c *CDKInfoClient) mutate(ctx context.Context, m *CDKInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CDKInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CDKInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CDKInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CDKInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown CDKInfo mutation op: %q", m.Op())
	}
}

// CampaignClient is a client for the Campaign schema.
type CampaignClient struct {
	config
}

// NewCampaignClient returns a client for the Campaign from the given config.
func NewCampaignClient(c config) *CampaignClient {
	return &CampaignClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `campaign.Hooks(f(g(h())))`.
func (c *CampaignClient) Use(hooks ...Hook) {
	c.hooks.Campaign = append(c.hooks.Campaign, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `campaign.Intercept(f(g(h())))`.
func (c *CampaignClient) Intercept(interceptors ...Interceptor) {
	c.inters.Campaign = append(c.inters.Campaign, interceptors...)
}

// Create returns a builder for creating a Campaign entity.
func (c *CampaignClient) Create() *CampaignCreate {
	mutation := newCampaignMutation(c.config, OpCreate)
	return &CampaignCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Campaign entities.
func (c *CampaignClient) CreateBulk(builders ...*CampaignCreate) *CampaignCreateBulk {
	return &CampaignCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CampaignClient) MapCreateBulk(slice any, setFunc func(*CampaignCreate, int)) *CampaignCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CampaignCreateBulk{err: fmt.Errorf("calling to CampaignClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CampaignCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CampaignCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Campaign.
func (c *CampaignClient) Update() *CampaignUpdate {
	mutation := newCampaignMutation(c.config, OpUpdate)
	return &CampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CampaignClient) UpdateOne(ca *Campaign) *CampaignUpdateOne {
	mutation := newCampaignMutation(c.config, OpUpdateOne, withCampaign(ca))
	return &CampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CampaignClient) UpdateOneID(id int64) *CampaignUpdateOne {
	mutation := newCampaignMutation(c.config, OpUpdateOne, withCampaignID(id))
	return &CampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Campaign.
func (c *CampaignClient) Delete() *CampaignDelete {
	mutation := newCampaignMutation(c.config, OpDelete)
	return &CampaignDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CampaignClient) DeleteOne(ca *Campaign) *CampaignDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CampaignClient) DeleteOneID(id int64) *CampaignDeleteOne {
	builder := c.Delete().Where(campaign.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CampaignDeleteOne{builder}
}

// Query returns a query builder for Campaign.
func (c *CampaignClient) Query() *CampaignQuery {
	return &CampaignQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCampaign},
		inters: c.Interceptors(),
	}
}

// Get returns a Campaign entity by its id.
func (c *CampaignClient) Get(ctx context.Context, id int64) (*Campaign, error) {
	return c.Query().Where(campaign.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CampaignClient) GetX(ctx context.Context, id int64) *Campaign {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInvites queries the invites edge of a Campaign.
func (c *CampaignClient) QueryInvites(ca *Campaign) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaign.Table, campaign.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, campaign.InvitesTable, campaign.InvitesColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaignOrders queries the campaign_orders edge of a Campaign.
func (c *CampaignClient) QueryCampaignOrders(ca *Campaign) *CampaignOrderQuery {
	query := (&CampaignOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaign.Table, campaign.FieldID, id),
			sqlgraph.To(campaignorder.Table, campaignorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, campaign.CampaignOrdersTable, campaign.CampaignOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CampaignClient) Hooks() []Hook {
	return c.hooks.Campaign
}

// Interceptors returns the client interceptors.
func (c *CampaignClient) Interceptors() []Interceptor {
	return c.inters.Campaign
}

func (c *CampaignClient) mutate(ctx context.Context, m *CampaignMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CampaignCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CampaignDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Campaign mutation op: %q", m.Op())
	}
}

// CampaignOrderClient is a client for the CampaignOrder schema.
type CampaignOrderClient struct {
	config
}

// NewCampaignOrderClient returns a client for the CampaignOrder from the given config.
func NewCampaignOrderClient(c config) *CampaignOrderClient {
	return &CampaignOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `campaignorder.Hooks(f(g(h())))`.
func (c *CampaignOrderClient) Use(hooks ...Hook) {
	c.hooks.CampaignOrder = append(c.hooks.CampaignOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `campaignorder.Intercept(f(g(h())))`.
func (c *CampaignOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.CampaignOrder = append(c.inters.CampaignOrder, interceptors...)
}

// Create returns a builder for creating a CampaignOrder entity.
func (c *CampaignOrderClient) Create() *CampaignOrderCreate {
	mutation := newCampaignOrderMutation(c.config, OpCreate)
	return &CampaignOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CampaignOrder entities.
func (c *CampaignOrderClient) CreateBulk(builders ...*CampaignOrderCreate) *CampaignOrderCreateBulk {
	return &CampaignOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CampaignOrderClient) MapCreateBulk(slice any, setFunc func(*CampaignOrderCreate, int)) *CampaignOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CampaignOrderCreateBulk{err: fmt.Errorf("calling to CampaignOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CampaignOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CampaignOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CampaignOrder.
func (c *CampaignOrderClient) Update() *CampaignOrderUpdate {
	mutation := newCampaignOrderMutation(c.config, OpUpdate)
	return &CampaignOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CampaignOrderClient) UpdateOne(co *CampaignOrder) *CampaignOrderUpdateOne {
	mutation := newCampaignOrderMutation(c.config, OpUpdateOne, withCampaignOrder(co))
	return &CampaignOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CampaignOrderClient) UpdateOneID(id int64) *CampaignOrderUpdateOne {
	mutation := newCampaignOrderMutation(c.config, OpUpdateOne, withCampaignOrderID(id))
	return &CampaignOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CampaignOrder.
func (c *CampaignOrderClient) Delete() *CampaignOrderDelete {
	mutation := newCampaignOrderMutation(c.config, OpDelete)
	return &CampaignOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CampaignOrderClient) DeleteOne(co *CampaignOrder) *CampaignOrderDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CampaignOrderClient) DeleteOneID(id int64) *CampaignOrderDeleteOne {
	builder := c.Delete().Where(campaignorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CampaignOrderDeleteOne{builder}
}

// Query returns a query builder for CampaignOrder.
func (c *CampaignOrderClient) Query() *CampaignOrderQuery {
	return &CampaignOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCampaignOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a CampaignOrder entity by its id.
func (c *CampaignOrderClient) Get(ctx context.Context, id int64) (*CampaignOrder, error) {
	return c.Query().Where(campaignorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CampaignOrderClient) GetX(ctx context.Context, id int64) *CampaignOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CampaignOrder.
func (c *CampaignOrderClient) QueryUser(co *CampaignOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaignorder.Table, campaignorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, campaignorder.UserTable, campaignorder.UserColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaign queries the campaign edge of a CampaignOrder.
func (c *CampaignOrderClient) QueryCampaign(co *CampaignOrder) *CampaignQuery {
	query := (&CampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaignorder.Table, campaignorder.FieldID, id),
			sqlgraph.To(campaign.Table, campaign.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, campaignorder.CampaignTable, campaignorder.CampaignColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a CampaignOrder.
func (c *CampaignOrderClient) QueryCostBills(co *CampaignOrder) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaignorder.Table, campaignorder.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, campaignorder.CostBillsTable, campaignorder.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRechargeOrder queries the recharge_order edge of a CampaignOrder.
func (c *CampaignOrderClient) QueryRechargeOrder(co *CampaignOrder) *RechargeOrderQuery {
	query := (&RechargeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaignorder.Table, campaignorder.FieldID, id),
			sqlgraph.To(rechargeorder.Table, rechargeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, campaignorder.RechargeOrderTable, campaignorder.RechargeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CampaignOrderClient) Hooks() []Hook {
	return c.hooks.CampaignOrder
}

// Interceptors returns the client interceptors.
func (c *CampaignOrderClient) Interceptors() []Interceptor {
	return c.inters.CampaignOrder
}

func (c *CampaignOrderClient) mutate(ctx context.Context, m *CampaignOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CampaignOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CampaignOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CampaignOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CampaignOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown CampaignOrder mutation op: %q", m.Op())
	}
}

// CloudFileClient is a client for the CloudFile schema.
type CloudFileClient struct {
	config
}

// NewCloudFileClient returns a client for the CloudFile from the given config.
func NewCloudFileClient(c config) *CloudFileClient {
	return &CloudFileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cloudfile.Hooks(f(g(h())))`.
func (c *CloudFileClient) Use(hooks ...Hook) {
	c.hooks.CloudFile = append(c.hooks.CloudFile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cloudfile.Intercept(f(g(h())))`.
func (c *CloudFileClient) Intercept(interceptors ...Interceptor) {
	c.inters.CloudFile = append(c.inters.CloudFile, interceptors...)
}

// Create returns a builder for creating a CloudFile entity.
func (c *CloudFileClient) Create() *CloudFileCreate {
	mutation := newCloudFileMutation(c.config, OpCreate)
	return &CloudFileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CloudFile entities.
func (c *CloudFileClient) CreateBulk(builders ...*CloudFileCreate) *CloudFileCreateBulk {
	return &CloudFileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CloudFileClient) MapCreateBulk(slice any, setFunc func(*CloudFileCreate, int)) *CloudFileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CloudFileCreateBulk{err: fmt.Errorf("calling to CloudFileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CloudFileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CloudFileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CloudFile.
func (c *CloudFileClient) Update() *CloudFileUpdate {
	mutation := newCloudFileMutation(c.config, OpUpdate)
	return &CloudFileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CloudFileClient) UpdateOne(cf *CloudFile) *CloudFileUpdateOne {
	mutation := newCloudFileMutation(c.config, OpUpdateOne, withCloudFile(cf))
	return &CloudFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CloudFileClient) UpdateOneID(id int64) *CloudFileUpdateOne {
	mutation := newCloudFileMutation(c.config, OpUpdateOne, withCloudFileID(id))
	return &CloudFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CloudFile.
func (c *CloudFileClient) Delete() *CloudFileDelete {
	mutation := newCloudFileMutation(c.config, OpDelete)
	return &CloudFileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CloudFileClient) DeleteOne(cf *CloudFile) *CloudFileDeleteOne {
	return c.DeleteOneID(cf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CloudFileClient) DeleteOneID(id int64) *CloudFileDeleteOne {
	builder := c.Delete().Where(cloudfile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CloudFileDeleteOne{builder}
}

// Query returns a query builder for CloudFile.
func (c *CloudFileClient) Query() *CloudFileQuery {
	return &CloudFileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCloudFile},
		inters: c.Interceptors(),
	}
}

// Get returns a CloudFile entity by its id.
func (c *CloudFileClient) Get(ctx context.Context, id int64) (*CloudFile, error) {
	return c.Query().Where(cloudfile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CloudFileClient) GetX(ctx context.Context, id int64) *CloudFile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CloudFile.
func (c *CloudFileClient) QueryUser(cf *CloudFile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cloudfile.Table, cloudfile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, cloudfile.UserTable, cloudfile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(cf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CloudFileClient) Hooks() []Hook {
	return c.hooks.CloudFile
}

// Interceptors returns the client interceptors.
func (c *CloudFileClient) Interceptors() []Interceptor {
	return c.inters.CloudFile
}

func (c *CloudFileClient) mutate(ctx context.Context, m *CloudFileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CloudFileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CloudFileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CloudFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CloudFileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown CloudFile mutation op: %q", m.Op())
	}
}

// CollectClient is a client for the Collect schema.
type CollectClient struct {
	config
}

// NewCollectClient returns a client for the Collect from the given config.
func NewCollectClient(c config) *CollectClient {
	return &CollectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `collect.Hooks(f(g(h())))`.
func (c *CollectClient) Use(hooks ...Hook) {
	c.hooks.Collect = append(c.hooks.Collect, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `collect.Intercept(f(g(h())))`.
func (c *CollectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Collect = append(c.inters.Collect, interceptors...)
}

// Create returns a builder for creating a Collect entity.
func (c *CollectClient) Create() *CollectCreate {
	mutation := newCollectMutation(c.config, OpCreate)
	return &CollectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Collect entities.
func (c *CollectClient) CreateBulk(builders ...*CollectCreate) *CollectCreateBulk {
	return &CollectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CollectClient) MapCreateBulk(slice any, setFunc func(*CollectCreate, int)) *CollectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CollectCreateBulk{err: fmt.Errorf("calling to CollectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CollectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CollectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Collect.
func (c *CollectClient) Update() *CollectUpdate {
	mutation := newCollectMutation(c.config, OpUpdate)
	return &CollectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CollectClient) UpdateOne(co *Collect) *CollectUpdateOne {
	mutation := newCollectMutation(c.config, OpUpdateOne, withCollect(co))
	return &CollectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CollectClient) UpdateOneID(id int64) *CollectUpdateOne {
	mutation := newCollectMutation(c.config, OpUpdateOne, withCollectID(id))
	return &CollectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Collect.
func (c *CollectClient) Delete() *CollectDelete {
	mutation := newCollectMutation(c.config, OpDelete)
	return &CollectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CollectClient) DeleteOne(co *Collect) *CollectDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CollectClient) DeleteOneID(id int64) *CollectDeleteOne {
	builder := c.Delete().Where(collect.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CollectDeleteOne{builder}
}

// Query returns a query builder for Collect.
func (c *CollectClient) Query() *CollectQuery {
	return &CollectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCollect},
		inters: c.Interceptors(),
	}
}

// Get returns a Collect entity by its id.
func (c *CollectClient) Get(ctx context.Context, id int64) (*Collect, error) {
	return c.Query().Where(collect.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CollectClient) GetX(ctx context.Context, id int64) *Collect {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Collect.
func (c *CollectClient) QueryUser(co *Collect) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collect.Table, collect.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, collect.UserTable, collect.UserColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CollectClient) Hooks() []Hook {
	return c.hooks.Collect
}

// Interceptors returns the client interceptors.
func (c *CollectClient) Interceptors() []Interceptor {
	return c.inters.Collect
}

func (c *CollectClient) mutate(ctx context.Context, m *CollectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CollectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CollectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CollectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CollectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Collect mutation op: %q", m.Op())
	}
}

// CostAccountClient is a client for the CostAccount schema.
type CostAccountClient struct {
	config
}

// NewCostAccountClient returns a client for the CostAccount from the given config.
func NewCostAccountClient(c config) *CostAccountClient {
	return &CostAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `costaccount.Hooks(f(g(h())))`.
func (c *CostAccountClient) Use(hooks ...Hook) {
	c.hooks.CostAccount = append(c.hooks.CostAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `costaccount.Intercept(f(g(h())))`.
func (c *CostAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.CostAccount = append(c.inters.CostAccount, interceptors...)
}

// Create returns a builder for creating a CostAccount entity.
func (c *CostAccountClient) Create() *CostAccountCreate {
	mutation := newCostAccountMutation(c.config, OpCreate)
	return &CostAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CostAccount entities.
func (c *CostAccountClient) CreateBulk(builders ...*CostAccountCreate) *CostAccountCreateBulk {
	return &CostAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CostAccountClient) MapCreateBulk(slice any, setFunc func(*CostAccountCreate, int)) *CostAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CostAccountCreateBulk{err: fmt.Errorf("calling to CostAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CostAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CostAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CostAccount.
func (c *CostAccountClient) Update() *CostAccountUpdate {
	mutation := newCostAccountMutation(c.config, OpUpdate)
	return &CostAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CostAccountClient) UpdateOne(ca *CostAccount) *CostAccountUpdateOne {
	mutation := newCostAccountMutation(c.config, OpUpdateOne, withCostAccount(ca))
	return &CostAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CostAccountClient) UpdateOneID(id int64) *CostAccountUpdateOne {
	mutation := newCostAccountMutation(c.config, OpUpdateOne, withCostAccountID(id))
	return &CostAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CostAccount.
func (c *CostAccountClient) Delete() *CostAccountDelete {
	mutation := newCostAccountMutation(c.config, OpDelete)
	return &CostAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CostAccountClient) DeleteOne(ca *CostAccount) *CostAccountDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CostAccountClient) DeleteOneID(id int64) *CostAccountDeleteOne {
	builder := c.Delete().Where(costaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CostAccountDeleteOne{builder}
}

// Query returns a query builder for CostAccount.
func (c *CostAccountClient) Query() *CostAccountQuery {
	return &CostAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCostAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a CostAccount entity by its id.
func (c *CostAccountClient) Get(ctx context.Context, id int64) (*CostAccount, error) {
	return c.Query().Where(costaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CostAccountClient) GetX(ctx context.Context, id int64) *CostAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CostAccount.
func (c *CostAccountClient) QueryUser(ca *CostAccount) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costaccount.Table, costaccount.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, costaccount.UserTable, costaccount.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a CostAccount.
func (c *CostAccountClient) QueryCostBills(ca *CostAccount) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costaccount.Table, costaccount.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, costaccount.CostBillsTable, costaccount.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CostAccountClient) Hooks() []Hook {
	return c.hooks.CostAccount
}

// Interceptors returns the client interceptors.
func (c *CostAccountClient) Interceptors() []Interceptor {
	return c.inters.CostAccount
}

func (c *CostAccountClient) mutate(ctx context.Context, m *CostAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CostAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CostAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CostAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CostAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown CostAccount mutation op: %q", m.Op())
	}
}

// CostBillClient is a client for the CostBill schema.
type CostBillClient struct {
	config
}

// NewCostBillClient returns a client for the CostBill from the given config.
func NewCostBillClient(c config) *CostBillClient {
	return &CostBillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `costbill.Hooks(f(g(h())))`.
func (c *CostBillClient) Use(hooks ...Hook) {
	c.hooks.CostBill = append(c.hooks.CostBill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `costbill.Intercept(f(g(h())))`.
func (c *CostBillClient) Intercept(interceptors ...Interceptor) {
	c.inters.CostBill = append(c.inters.CostBill, interceptors...)
}

// Create returns a builder for creating a CostBill entity.
func (c *CostBillClient) Create() *CostBillCreate {
	mutation := newCostBillMutation(c.config, OpCreate)
	return &CostBillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CostBill entities.
func (c *CostBillClient) CreateBulk(builders ...*CostBillCreate) *CostBillCreateBulk {
	return &CostBillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CostBillClient) MapCreateBulk(slice any, setFunc func(*CostBillCreate, int)) *CostBillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CostBillCreateBulk{err: fmt.Errorf("calling to CostBillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CostBillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CostBillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CostBill.
func (c *CostBillClient) Update() *CostBillUpdate {
	mutation := newCostBillMutation(c.config, OpUpdate)
	return &CostBillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CostBillClient) UpdateOne(cb *CostBill) *CostBillUpdateOne {
	mutation := newCostBillMutation(c.config, OpUpdateOne, withCostBill(cb))
	return &CostBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CostBillClient) UpdateOneID(id int64) *CostBillUpdateOne {
	mutation := newCostBillMutation(c.config, OpUpdateOne, withCostBillID(id))
	return &CostBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CostBill.
func (c *CostBillClient) Delete() *CostBillDelete {
	mutation := newCostBillMutation(c.config, OpDelete)
	return &CostBillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CostBillClient) DeleteOne(cb *CostBill) *CostBillDeleteOne {
	return c.DeleteOneID(cb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CostBillClient) DeleteOneID(id int64) *CostBillDeleteOne {
	builder := c.Delete().Where(costbill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CostBillDeleteOne{builder}
}

// Query returns a query builder for CostBill.
func (c *CostBillClient) Query() *CostBillQuery {
	return &CostBillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCostBill},
		inters: c.Interceptors(),
	}
}

// Get returns a CostBill entity by its id.
func (c *CostBillClient) Get(ctx context.Context, id int64) (*CostBill, error) {
	return c.Query().Where(costbill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CostBillClient) GetX(ctx context.Context, id int64) *CostBill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CostBill.
func (c *CostBillClient) QueryUser(cb *CostBill) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.UserTable, costbill.UserColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostAccount queries the cost_account edge of a CostBill.
func (c *CostBillClient) QueryCostAccount(cb *CostBill) *CostAccountQuery {
	query := (&CostAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(costaccount.Table, costaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.CostAccountTable, costbill.CostAccountColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRechargeOrder queries the recharge_order edge of a CostBill.
func (c *CostBillClient) QueryRechargeOrder(cb *CostBill) *RechargeOrderQuery {
	query := (&RechargeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(rechargeorder.Table, rechargeorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.RechargeOrderTable, costbill.RechargeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrder queries the mission_consume_order edge of a CostBill.
func (c *CostBillClient) QueryMissionConsumeOrder(cb *CostBill) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.MissionConsumeOrderTable, costbill.MissionConsumeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlatformAccount queries the platform_account edge of a CostBill.
func (c *CostBillClient) QueryPlatformAccount(cb *CostBill) *PlatformAccountQuery {
	query := (&PlatformAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(platformaccount.Table, platformaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.PlatformAccountTable, costbill.PlatformAccountColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaignOrder queries the campaign_order edge of a CostBill.
func (c *CostBillClient) QueryCampaignOrder(cb *CostBill) *CampaignOrderQuery {
	query := (&CampaignOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(campaignorder.Table, campaignorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.CampaignOrderTable, costbill.CampaignOrderColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CostBillClient) Hooks() []Hook {
	return c.hooks.CostBill
}

// Interceptors returns the client interceptors.
func (c *CostBillClient) Interceptors() []Interceptor {
	return c.inters.CostBill
}

func (c *CostBillClient) mutate(ctx context.Context, m *CostBillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CostBillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CostBillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CostBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CostBillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown CostBill mutation op: %q", m.Op())
	}
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `device.Hooks(f(g(h())))`.
func (c *DeviceClient) Use(hooks ...Hook) {
	c.hooks.Device = append(c.hooks.Device, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `device.Intercept(f(g(h())))`.
func (c *DeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Device = append(c.inters.Device, interceptors...)
}

// Create returns a builder for creating a Device entity.
func (c *DeviceClient) Create() *DeviceCreate {
	mutation := newDeviceMutation(c.config, OpCreate)
	return &DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Device entities.
func (c *DeviceClient) CreateBulk(builders ...*DeviceCreate) *DeviceCreateBulk {
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceClient) MapCreateBulk(slice any, setFunc func(*DeviceCreate, int)) *DeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceCreateBulk{err: fmt.Errorf("calling to DeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	mutation := newDeviceMutation(c.config, OpUpdate)
	return &DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(d *Device) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDevice(d))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id int64) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDeviceID(id))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	mutation := newDeviceMutation(c.config, OpDelete)
	return &DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceClient) DeleteOne(d *Device) *DeviceDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceClient) DeleteOneID(id int64) *DeviceDeleteOne {
	builder := c.Delete().Where(device.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceDeleteOne{builder}
}

// Query returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id int64) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id int64) *Device {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Device.
func (c *DeviceClient) QueryUser(d *Device) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, device.UserTable, device.UserColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a Device.
func (c *DeviceClient) QueryMissionProduceOrders(d *Device) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.MissionProduceOrdersTable, device.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserDevices queries the user_devices edge of a Device.
func (c *DeviceClient) QueryUserDevices(d *Device) *UserDeviceQuery {
	query := (&UserDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(userdevice.Table, userdevice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.UserDevicesTable, device.UserDevicesColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeviceGpuMissions queries the device_gpu_missions edge of a Device.
func (c *DeviceClient) QueryDeviceGpuMissions(d *Device) *DeviceGpuMissionQuery {
	query := (&DeviceGpuMissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(devicegpumission.Table, devicegpumission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.DeviceGpuMissionsTable, device.DeviceGpuMissionsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFrpcInfos queries the frpc_infos edge of a Device.
func (c *DeviceClient) QueryFrpcInfos(d *Device) *FrpcInfoQuery {
	query := (&FrpcInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(frpcinfo.Table, frpcinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.FrpcInfosTable, device.FrpcInfosColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrders queries the mission_orders edge of a Device.
func (c *DeviceClient) QueryMissionOrders(d *Device) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.MissionOrdersTable, device.MissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProductions queries the mission_productions edge of a Device.
func (c *DeviceClient) QueryMissionProductions(d *Device) *MissionProductionQuery {
	query := (&MissionProductionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(missionproduction.Table, missionproduction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.MissionProductionsTable, device.MissionProductionsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeviceRebootTimes queries the device_reboot_times edge of a Device.
func (c *DeviceClient) QueryDeviceRebootTimes(d *Device) *DeviceRebootTimeQuery {
	query := (&DeviceRebootTimeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(devicereboottime.Table, devicereboottime.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.DeviceRebootTimesTable, device.DeviceRebootTimesColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTroubleDeducts queries the trouble_deducts edge of a Device.
func (c *DeviceClient) QueryTroubleDeducts(d *Device) *TroubleDeductQuery {
	query := (&TroubleDeductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(troublededuct.Table, troublededuct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.TroubleDeductsTable, device.TroubleDeductsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceClient) Hooks() []Hook {
	return c.hooks.Device
}

// Interceptors returns the client interceptors.
func (c *DeviceClient) Interceptors() []Interceptor {
	return c.inters.Device
}

func (c *DeviceClient) mutate(ctx context.Context, m *DeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Device mutation op: %q", m.Op())
	}
}

// DeviceGpuMissionClient is a client for the DeviceGpuMission schema.
type DeviceGpuMissionClient struct {
	config
}

// NewDeviceGpuMissionClient returns a client for the DeviceGpuMission from the given config.
func NewDeviceGpuMissionClient(c config) *DeviceGpuMissionClient {
	return &DeviceGpuMissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devicegpumission.Hooks(f(g(h())))`.
func (c *DeviceGpuMissionClient) Use(hooks ...Hook) {
	c.hooks.DeviceGpuMission = append(c.hooks.DeviceGpuMission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devicegpumission.Intercept(f(g(h())))`.
func (c *DeviceGpuMissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceGpuMission = append(c.inters.DeviceGpuMission, interceptors...)
}

// Create returns a builder for creating a DeviceGpuMission entity.
func (c *DeviceGpuMissionClient) Create() *DeviceGpuMissionCreate {
	mutation := newDeviceGpuMissionMutation(c.config, OpCreate)
	return &DeviceGpuMissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceGpuMission entities.
func (c *DeviceGpuMissionClient) CreateBulk(builders ...*DeviceGpuMissionCreate) *DeviceGpuMissionCreateBulk {
	return &DeviceGpuMissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceGpuMissionClient) MapCreateBulk(slice any, setFunc func(*DeviceGpuMissionCreate, int)) *DeviceGpuMissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceGpuMissionCreateBulk{err: fmt.Errorf("calling to DeviceGpuMissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceGpuMissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceGpuMissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceGpuMission.
func (c *DeviceGpuMissionClient) Update() *DeviceGpuMissionUpdate {
	mutation := newDeviceGpuMissionMutation(c.config, OpUpdate)
	return &DeviceGpuMissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceGpuMissionClient) UpdateOne(dgm *DeviceGpuMission) *DeviceGpuMissionUpdateOne {
	mutation := newDeviceGpuMissionMutation(c.config, OpUpdateOne, withDeviceGpuMission(dgm))
	return &DeviceGpuMissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceGpuMissionClient) UpdateOneID(id int64) *DeviceGpuMissionUpdateOne {
	mutation := newDeviceGpuMissionMutation(c.config, OpUpdateOne, withDeviceGpuMissionID(id))
	return &DeviceGpuMissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceGpuMission.
func (c *DeviceGpuMissionClient) Delete() *DeviceGpuMissionDelete {
	mutation := newDeviceGpuMissionMutation(c.config, OpDelete)
	return &DeviceGpuMissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceGpuMissionClient) DeleteOne(dgm *DeviceGpuMission) *DeviceGpuMissionDeleteOne {
	return c.DeleteOneID(dgm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceGpuMissionClient) DeleteOneID(id int64) *DeviceGpuMissionDeleteOne {
	builder := c.Delete().Where(devicegpumission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceGpuMissionDeleteOne{builder}
}

// Query returns a query builder for DeviceGpuMission.
func (c *DeviceGpuMissionClient) Query() *DeviceGpuMissionQuery {
	return &DeviceGpuMissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceGpuMission},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceGpuMission entity by its id.
func (c *DeviceGpuMissionClient) Get(ctx context.Context, id int64) (*DeviceGpuMission, error) {
	return c.Query().Where(devicegpumission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceGpuMissionClient) GetX(ctx context.Context, id int64) *DeviceGpuMission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDevice queries the device edge of a DeviceGpuMission.
func (c *DeviceGpuMissionClient) QueryDevice(dgm *DeviceGpuMission) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicegpumission.Table, devicegpumission.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devicegpumission.DeviceTable, devicegpumission.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(dgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGpu queries the gpu edge of a DeviceGpuMission.
func (c *DeviceGpuMissionClient) QueryGpu(dgm *DeviceGpuMission) *GpuQuery {
	query := (&GpuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicegpumission.Table, devicegpumission.FieldID, id),
			sqlgraph.To(gpu.Table, gpu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devicegpumission.GpuTable, devicegpumission.GpuColumn),
		)
		fromV = sqlgraph.Neighbors(dgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceGpuMissionClient) Hooks() []Hook {
	return c.hooks.DeviceGpuMission
}

// Interceptors returns the client interceptors.
func (c *DeviceGpuMissionClient) Interceptors() []Interceptor {
	return c.inters.DeviceGpuMission
}

func (c *DeviceGpuMissionClient) mutate(ctx context.Context, m *DeviceGpuMissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceGpuMissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceGpuMissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceGpuMissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceGpuMissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown DeviceGpuMission mutation op: %q", m.Op())
	}
}

// DeviceRebootTimeClient is a client for the DeviceRebootTime schema.
type DeviceRebootTimeClient struct {
	config
}

// NewDeviceRebootTimeClient returns a client for the DeviceRebootTime from the given config.
func NewDeviceRebootTimeClient(c config) *DeviceRebootTimeClient {
	return &DeviceRebootTimeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devicereboottime.Hooks(f(g(h())))`.
func (c *DeviceRebootTimeClient) Use(hooks ...Hook) {
	c.hooks.DeviceRebootTime = append(c.hooks.DeviceRebootTime, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devicereboottime.Intercept(f(g(h())))`.
func (c *DeviceRebootTimeClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceRebootTime = append(c.inters.DeviceRebootTime, interceptors...)
}

// Create returns a builder for creating a DeviceRebootTime entity.
func (c *DeviceRebootTimeClient) Create() *DeviceRebootTimeCreate {
	mutation := newDeviceRebootTimeMutation(c.config, OpCreate)
	return &DeviceRebootTimeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceRebootTime entities.
func (c *DeviceRebootTimeClient) CreateBulk(builders ...*DeviceRebootTimeCreate) *DeviceRebootTimeCreateBulk {
	return &DeviceRebootTimeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceRebootTimeClient) MapCreateBulk(slice any, setFunc func(*DeviceRebootTimeCreate, int)) *DeviceRebootTimeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceRebootTimeCreateBulk{err: fmt.Errorf("calling to DeviceRebootTimeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceRebootTimeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceRebootTimeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceRebootTime.
func (c *DeviceRebootTimeClient) Update() *DeviceRebootTimeUpdate {
	mutation := newDeviceRebootTimeMutation(c.config, OpUpdate)
	return &DeviceRebootTimeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceRebootTimeClient) UpdateOne(drt *DeviceRebootTime) *DeviceRebootTimeUpdateOne {
	mutation := newDeviceRebootTimeMutation(c.config, OpUpdateOne, withDeviceRebootTime(drt))
	return &DeviceRebootTimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceRebootTimeClient) UpdateOneID(id int64) *DeviceRebootTimeUpdateOne {
	mutation := newDeviceRebootTimeMutation(c.config, OpUpdateOne, withDeviceRebootTimeID(id))
	return &DeviceRebootTimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceRebootTime.
func (c *DeviceRebootTimeClient) Delete() *DeviceRebootTimeDelete {
	mutation := newDeviceRebootTimeMutation(c.config, OpDelete)
	return &DeviceRebootTimeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceRebootTimeClient) DeleteOne(drt *DeviceRebootTime) *DeviceRebootTimeDeleteOne {
	return c.DeleteOneID(drt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceRebootTimeClient) DeleteOneID(id int64) *DeviceRebootTimeDeleteOne {
	builder := c.Delete().Where(devicereboottime.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceRebootTimeDeleteOne{builder}
}

// Query returns a query builder for DeviceRebootTime.
func (c *DeviceRebootTimeClient) Query() *DeviceRebootTimeQuery {
	return &DeviceRebootTimeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceRebootTime},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceRebootTime entity by its id.
func (c *DeviceRebootTimeClient) Get(ctx context.Context, id int64) (*DeviceRebootTime, error) {
	return c.Query().Where(devicereboottime.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceRebootTimeClient) GetX(ctx context.Context, id int64) *DeviceRebootTime {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDevice queries the device edge of a DeviceRebootTime.
func (c *DeviceRebootTimeClient) QueryDevice(drt *DeviceRebootTime) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := drt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicereboottime.Table, devicereboottime.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devicereboottime.DeviceTable, devicereboottime.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(drt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceRebootTimeClient) Hooks() []Hook {
	return c.hooks.DeviceRebootTime
}

// Interceptors returns the client interceptors.
func (c *DeviceRebootTimeClient) Interceptors() []Interceptor {
	return c.inters.DeviceRebootTime
}

func (c *DeviceRebootTimeClient) mutate(ctx context.Context, m *DeviceRebootTimeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceRebootTimeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceRebootTimeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceRebootTimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceRebootTimeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown DeviceRebootTime mutation op: %q", m.Op())
	}
}

// EarnBillClient is a client for the EarnBill schema.
type EarnBillClient struct {
	config
}

// NewEarnBillClient returns a client for the EarnBill from the given config.
func NewEarnBillClient(c config) *EarnBillClient {
	return &EarnBillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `earnbill.Hooks(f(g(h())))`.
func (c *EarnBillClient) Use(hooks ...Hook) {
	c.hooks.EarnBill = append(c.hooks.EarnBill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `earnbill.Intercept(f(g(h())))`.
func (c *EarnBillClient) Intercept(interceptors ...Interceptor) {
	c.inters.EarnBill = append(c.inters.EarnBill, interceptors...)
}

// Create returns a builder for creating a EarnBill entity.
func (c *EarnBillClient) Create() *EarnBillCreate {
	mutation := newEarnBillMutation(c.config, OpCreate)
	return &EarnBillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EarnBill entities.
func (c *EarnBillClient) CreateBulk(builders ...*EarnBillCreate) *EarnBillCreateBulk {
	return &EarnBillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EarnBillClient) MapCreateBulk(slice any, setFunc func(*EarnBillCreate, int)) *EarnBillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EarnBillCreateBulk{err: fmt.Errorf("calling to EarnBillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EarnBillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EarnBillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EarnBill.
func (c *EarnBillClient) Update() *EarnBillUpdate {
	mutation := newEarnBillMutation(c.config, OpUpdate)
	return &EarnBillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EarnBillClient) UpdateOne(eb *EarnBill) *EarnBillUpdateOne {
	mutation := newEarnBillMutation(c.config, OpUpdateOne, withEarnBill(eb))
	return &EarnBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EarnBillClient) UpdateOneID(id int64) *EarnBillUpdateOne {
	mutation := newEarnBillMutation(c.config, OpUpdateOne, withEarnBillID(id))
	return &EarnBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EarnBill.
func (c *EarnBillClient) Delete() *EarnBillDelete {
	mutation := newEarnBillMutation(c.config, OpDelete)
	return &EarnBillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EarnBillClient) DeleteOne(eb *EarnBill) *EarnBillDeleteOne {
	return c.DeleteOneID(eb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EarnBillClient) DeleteOneID(id int64) *EarnBillDeleteOne {
	builder := c.Delete().Where(earnbill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EarnBillDeleteOne{builder}
}

// Query returns a query builder for EarnBill.
func (c *EarnBillClient) Query() *EarnBillQuery {
	return &EarnBillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEarnBill},
		inters: c.Interceptors(),
	}
}

// Get returns a EarnBill entity by its id.
func (c *EarnBillClient) Get(ctx context.Context, id int64) (*EarnBill, error) {
	return c.Query().Where(earnbill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EarnBillClient) GetX(ctx context.Context, id int64) *EarnBill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a EarnBill.
func (c *EarnBillClient) QueryUser(eb *EarnBill) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(earnbill.Table, earnbill.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, earnbill.UserTable, earnbill.UserColumn),
		)
		fromV = sqlgraph.Neighbors(eb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfitAccount queries the profit_account edge of a EarnBill.
func (c *EarnBillClient) QueryProfitAccount(eb *EarnBill) *ProfitAccountQuery {
	query := (&ProfitAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(earnbill.Table, earnbill.FieldID, id),
			sqlgraph.To(profitaccount.Table, profitaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, earnbill.ProfitAccountTable, earnbill.ProfitAccountColumn),
		)
		fromV = sqlgraph.Neighbors(eb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlatformAccount queries the platform_account edge of a EarnBill.
func (c *EarnBillClient) QueryPlatformAccount(eb *EarnBill) *PlatformAccountQuery {
	query := (&PlatformAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(earnbill.Table, earnbill.FieldID, id),
			sqlgraph.To(platformaccount.Table, platformaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, earnbill.PlatformAccountTable, earnbill.PlatformAccountColumn),
		)
		fromV = sqlgraph.Neighbors(eb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a EarnBill.
func (c *EarnBillClient) QueryMissionProduceOrders(eb *EarnBill) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(earnbill.Table, earnbill.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, earnbill.MissionProduceOrdersTable, earnbill.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(eb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EarnBillClient) Hooks() []Hook {
	return c.hooks.EarnBill
}

// Interceptors returns the client interceptors.
func (c *EarnBillClient) Interceptors() []Interceptor {
	return c.inters.EarnBill
}

func (c *EarnBillClient) mutate(ctx context.Context, m *EarnBillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EarnBillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EarnBillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EarnBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EarnBillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown EarnBill mutation op: %q", m.Op())
	}
}

// EnumConditionClient is a client for the EnumCondition schema.
type EnumConditionClient struct {
	config
}

// NewEnumConditionClient returns a client for the EnumCondition from the given config.
func NewEnumConditionClient(c config) *EnumConditionClient {
	return &EnumConditionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `enumcondition.Hooks(f(g(h())))`.
func (c *EnumConditionClient) Use(hooks ...Hook) {
	c.hooks.EnumCondition = append(c.hooks.EnumCondition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `enumcondition.Intercept(f(g(h())))`.
func (c *EnumConditionClient) Intercept(interceptors ...Interceptor) {
	c.inters.EnumCondition = append(c.inters.EnumCondition, interceptors...)
}

// Create returns a builder for creating a EnumCondition entity.
func (c *EnumConditionClient) Create() *EnumConditionCreate {
	mutation := newEnumConditionMutation(c.config, OpCreate)
	return &EnumConditionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EnumCondition entities.
func (c *EnumConditionClient) CreateBulk(builders ...*EnumConditionCreate) *EnumConditionCreateBulk {
	return &EnumConditionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnumConditionClient) MapCreateBulk(slice any, setFunc func(*EnumConditionCreate, int)) *EnumConditionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnumConditionCreateBulk{err: fmt.Errorf("calling to EnumConditionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnumConditionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnumConditionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EnumCondition.
func (c *EnumConditionClient) Update() *EnumConditionUpdate {
	mutation := newEnumConditionMutation(c.config, OpUpdate)
	return &EnumConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnumConditionClient) UpdateOne(ec *EnumCondition) *EnumConditionUpdateOne {
	mutation := newEnumConditionMutation(c.config, OpUpdateOne, withEnumCondition(ec))
	return &EnumConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnumConditionClient) UpdateOneID(id int64) *EnumConditionUpdateOne {
	mutation := newEnumConditionMutation(c.config, OpUpdateOne, withEnumConditionID(id))
	return &EnumConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EnumCondition.
func (c *EnumConditionClient) Delete() *EnumConditionDelete {
	mutation := newEnumConditionMutation(c.config, OpDelete)
	return &EnumConditionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnumConditionClient) DeleteOne(ec *EnumCondition) *EnumConditionDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnumConditionClient) DeleteOneID(id int64) *EnumConditionDeleteOne {
	builder := c.Delete().Where(enumcondition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnumConditionDeleteOne{builder}
}

// Query returns a query builder for EnumCondition.
func (c *EnumConditionClient) Query() *EnumConditionQuery {
	return &EnumConditionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnumCondition},
		inters: c.Interceptors(),
	}
}

// Get returns a EnumCondition entity by its id.
func (c *EnumConditionClient) Get(ctx context.Context, id int64) (*EnumCondition, error) {
	return c.Query().Where(enumcondition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnumConditionClient) GetX(ctx context.Context, id int64) *EnumCondition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EnumConditionClient) Hooks() []Hook {
	return c.hooks.EnumCondition
}

// Interceptors returns the client interceptors.
func (c *EnumConditionClient) Interceptors() []Interceptor {
	return c.inters.EnumCondition
}

func (c *EnumConditionClient) mutate(ctx context.Context, m *EnumConditionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnumConditionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnumConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnumConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnumConditionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown EnumCondition mutation op: %q", m.Op())
	}
}

// EnumMissionStatusClient is a client for the EnumMissionStatus schema.
type EnumMissionStatusClient struct {
	config
}

// NewEnumMissionStatusClient returns a client for the EnumMissionStatus from the given config.
func NewEnumMissionStatusClient(c config) *EnumMissionStatusClient {
	return &EnumMissionStatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `enummissionstatus.Hooks(f(g(h())))`.
func (c *EnumMissionStatusClient) Use(hooks ...Hook) {
	c.hooks.EnumMissionStatus = append(c.hooks.EnumMissionStatus, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `enummissionstatus.Intercept(f(g(h())))`.
func (c *EnumMissionStatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.EnumMissionStatus = append(c.inters.EnumMissionStatus, interceptors...)
}

// Create returns a builder for creating a EnumMissionStatus entity.
func (c *EnumMissionStatusClient) Create() *EnumMissionStatusCreate {
	mutation := newEnumMissionStatusMutation(c.config, OpCreate)
	return &EnumMissionStatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EnumMissionStatus entities.
func (c *EnumMissionStatusClient) CreateBulk(builders ...*EnumMissionStatusCreate) *EnumMissionStatusCreateBulk {
	return &EnumMissionStatusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnumMissionStatusClient) MapCreateBulk(slice any, setFunc func(*EnumMissionStatusCreate, int)) *EnumMissionStatusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnumMissionStatusCreateBulk{err: fmt.Errorf("calling to EnumMissionStatusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnumMissionStatusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnumMissionStatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EnumMissionStatus.
func (c *EnumMissionStatusClient) Update() *EnumMissionStatusUpdate {
	mutation := newEnumMissionStatusMutation(c.config, OpUpdate)
	return &EnumMissionStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnumMissionStatusClient) UpdateOne(ems *EnumMissionStatus) *EnumMissionStatusUpdateOne {
	mutation := newEnumMissionStatusMutation(c.config, OpUpdateOne, withEnumMissionStatus(ems))
	return &EnumMissionStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnumMissionStatusClient) UpdateOneID(id int64) *EnumMissionStatusUpdateOne {
	mutation := newEnumMissionStatusMutation(c.config, OpUpdateOne, withEnumMissionStatusID(id))
	return &EnumMissionStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EnumMissionStatus.
func (c *EnumMissionStatusClient) Delete() *EnumMissionStatusDelete {
	mutation := newEnumMissionStatusMutation(c.config, OpDelete)
	return &EnumMissionStatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnumMissionStatusClient) DeleteOne(ems *EnumMissionStatus) *EnumMissionStatusDeleteOne {
	return c.DeleteOneID(ems.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnumMissionStatusClient) DeleteOneID(id int64) *EnumMissionStatusDeleteOne {
	builder := c.Delete().Where(enummissionstatus.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnumMissionStatusDeleteOne{builder}
}

// Query returns a query builder for EnumMissionStatus.
func (c *EnumMissionStatusClient) Query() *EnumMissionStatusQuery {
	return &EnumMissionStatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnumMissionStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a EnumMissionStatus entity by its id.
func (c *EnumMissionStatusClient) Get(ctx context.Context, id int64) (*EnumMissionStatus, error) {
	return c.Query().Where(enummissionstatus.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnumMissionStatusClient) GetX(ctx context.Context, id int64) *EnumMissionStatus {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EnumMissionStatusClient) Hooks() []Hook {
	return c.hooks.EnumMissionStatus
}

// Interceptors returns the client interceptors.
func (c *EnumMissionStatusClient) Interceptors() []Interceptor {
	return c.inters.EnumMissionStatus
}

func (c *EnumMissionStatusClient) mutate(ctx context.Context, m *EnumMissionStatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnumMissionStatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnumMissionStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnumMissionStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnumMissionStatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown EnumMissionStatus mutation op: %q", m.Op())
	}
}

// ExtraServiceClient is a client for the ExtraService schema.
type ExtraServiceClient struct {
	config
}

// NewExtraServiceClient returns a client for the ExtraService from the given config.
func NewExtraServiceClient(c config) *ExtraServiceClient {
	return &ExtraServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `extraservice.Hooks(f(g(h())))`.
func (c *ExtraServiceClient) Use(hooks ...Hook) {
	c.hooks.ExtraService = append(c.hooks.ExtraService, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `extraservice.Intercept(f(g(h())))`.
func (c *ExtraServiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExtraService = append(c.inters.ExtraService, interceptors...)
}

// Create returns a builder for creating a ExtraService entity.
func (c *ExtraServiceClient) Create() *ExtraServiceCreate {
	mutation := newExtraServiceMutation(c.config, OpCreate)
	return &ExtraServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExtraService entities.
func (c *ExtraServiceClient) CreateBulk(builders ...*ExtraServiceCreate) *ExtraServiceCreateBulk {
	return &ExtraServiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExtraServiceClient) MapCreateBulk(slice any, setFunc func(*ExtraServiceCreate, int)) *ExtraServiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExtraServiceCreateBulk{err: fmt.Errorf("calling to ExtraServiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExtraServiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExtraServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExtraService.
func (c *ExtraServiceClient) Update() *ExtraServiceUpdate {
	mutation := newExtraServiceMutation(c.config, OpUpdate)
	return &ExtraServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExtraServiceClient) UpdateOne(es *ExtraService) *ExtraServiceUpdateOne {
	mutation := newExtraServiceMutation(c.config, OpUpdateOne, withExtraService(es))
	return &ExtraServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExtraServiceClient) UpdateOneID(id int64) *ExtraServiceUpdateOne {
	mutation := newExtraServiceMutation(c.config, OpUpdateOne, withExtraServiceID(id))
	return &ExtraServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExtraService.
func (c *ExtraServiceClient) Delete() *ExtraServiceDelete {
	mutation := newExtraServiceMutation(c.config, OpDelete)
	return &ExtraServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExtraServiceClient) DeleteOne(es *ExtraService) *ExtraServiceDeleteOne {
	return c.DeleteOneID(es.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExtraServiceClient) DeleteOneID(id int64) *ExtraServiceDeleteOne {
	builder := c.Delete().Where(extraservice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExtraServiceDeleteOne{builder}
}

// Query returns a query builder for ExtraService.
func (c *ExtraServiceClient) Query() *ExtraServiceQuery {
	return &ExtraServiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExtraService},
		inters: c.Interceptors(),
	}
}

// Get returns a ExtraService entity by its id.
func (c *ExtraServiceClient) Get(ctx context.Context, id int64) (*ExtraService, error) {
	return c.Query().Where(extraservice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExtraServiceClient) GetX(ctx context.Context, id int64) *ExtraService {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMissions queries the missions edge of a ExtraService.
func (c *ExtraServiceClient) QueryMissions(es *ExtraService) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := es.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(extraservice.Table, extraservice.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, extraservice.MissionsTable, extraservice.MissionsColumn),
		)
		fromV = sqlgraph.Neighbors(es.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionExtraServices queries the mission_extra_services edge of a ExtraService.
func (c *ExtraServiceClient) QueryMissionExtraServices(es *ExtraService) *MissionExtraServiceQuery {
	query := (&MissionExtraServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := es.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(extraservice.Table, extraservice.FieldID, id),
			sqlgraph.To(missionextraservice.Table, missionextraservice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, extraservice.MissionExtraServicesTable, extraservice.MissionExtraServicesColumn),
		)
		fromV = sqlgraph.Neighbors(es.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtraServicePrices queries the extra_service_prices edge of a ExtraService.
func (c *ExtraServiceClient) QueryExtraServicePrices(es *ExtraService) *ExtraServicePriceQuery {
	query := (&ExtraServicePriceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := es.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(extraservice.Table, extraservice.FieldID, id),
			sqlgraph.To(extraserviceprice.Table, extraserviceprice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, extraservice.ExtraServicePricesTable, extraservice.ExtraServicePricesColumn),
		)
		fromV = sqlgraph.Neighbors(es.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExtraServiceClient) Hooks() []Hook {
	return c.hooks.ExtraService
}

// Interceptors returns the client interceptors.
func (c *ExtraServiceClient) Interceptors() []Interceptor {
	return c.inters.ExtraService
}

func (c *ExtraServiceClient) mutate(ctx context.Context, m *ExtraServiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExtraServiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExtraServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExtraServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExtraServiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown ExtraService mutation op: %q", m.Op())
	}
}

// ExtraServiceOrderClient is a client for the ExtraServiceOrder schema.
type ExtraServiceOrderClient struct {
	config
}

// NewExtraServiceOrderClient returns a client for the ExtraServiceOrder from the given config.
func NewExtraServiceOrderClient(c config) *ExtraServiceOrderClient {
	return &ExtraServiceOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `extraserviceorder.Hooks(f(g(h())))`.
func (c *ExtraServiceOrderClient) Use(hooks ...Hook) {
	c.hooks.ExtraServiceOrder = append(c.hooks.ExtraServiceOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `extraserviceorder.Intercept(f(g(h())))`.
func (c *ExtraServiceOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExtraServiceOrder = append(c.inters.ExtraServiceOrder, interceptors...)
}

// Create returns a builder for creating a ExtraServiceOrder entity.
func (c *ExtraServiceOrderClient) Create() *ExtraServiceOrderCreate {
	mutation := newExtraServiceOrderMutation(c.config, OpCreate)
	return &ExtraServiceOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExtraServiceOrder entities.
func (c *ExtraServiceOrderClient) CreateBulk(builders ...*ExtraServiceOrderCreate) *ExtraServiceOrderCreateBulk {
	return &ExtraServiceOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExtraServiceOrderClient) MapCreateBulk(slice any, setFunc func(*ExtraServiceOrderCreate, int)) *ExtraServiceOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExtraServiceOrderCreateBulk{err: fmt.Errorf("calling to ExtraServiceOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExtraServiceOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExtraServiceOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExtraServiceOrder.
func (c *ExtraServiceOrderClient) Update() *ExtraServiceOrderUpdate {
	mutation := newExtraServiceOrderMutation(c.config, OpUpdate)
	return &ExtraServiceOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExtraServiceOrderClient) UpdateOne(eso *ExtraServiceOrder) *ExtraServiceOrderUpdateOne {
	mutation := newExtraServiceOrderMutation(c.config, OpUpdateOne, withExtraServiceOrder(eso))
	return &ExtraServiceOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExtraServiceOrderClient) UpdateOneID(id int64) *ExtraServiceOrderUpdateOne {
	mutation := newExtraServiceOrderMutation(c.config, OpUpdateOne, withExtraServiceOrderID(id))
	return &ExtraServiceOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExtraServiceOrder.
func (c *ExtraServiceOrderClient) Delete() *ExtraServiceOrderDelete {
	mutation := newExtraServiceOrderMutation(c.config, OpDelete)
	return &ExtraServiceOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExtraServiceOrderClient) DeleteOne(eso *ExtraServiceOrder) *ExtraServiceOrderDeleteOne {
	return c.DeleteOneID(eso.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExtraServiceOrderClient) DeleteOneID(id int64) *ExtraServiceOrderDeleteOne {
	builder := c.Delete().Where(extraserviceorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExtraServiceOrderDeleteOne{builder}
}

// Query returns a query builder for ExtraServiceOrder.
func (c *ExtraServiceOrderClient) Query() *ExtraServiceOrderQuery {
	return &ExtraServiceOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExtraServiceOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a ExtraServiceOrder entity by its id.
func (c *ExtraServiceOrderClient) Get(ctx context.Context, id int64) (*ExtraServiceOrder, error) {
	return c.Query().Where(extraserviceorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExtraServiceOrderClient) GetX(ctx context.Context, id int64) *ExtraServiceOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMission queries the mission edge of a ExtraServiceOrder.
func (c *ExtraServiceOrderClient) QueryMission(eso *ExtraServiceOrder) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eso.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(extraserviceorder.Table, extraserviceorder.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, extraserviceorder.MissionTable, extraserviceorder.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(eso.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrder queries the mission_order edge of a ExtraServiceOrder.
func (c *ExtraServiceOrderClient) QueryMissionOrder(eso *ExtraServiceOrder) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eso.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(extraserviceorder.Table, extraserviceorder.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, extraserviceorder.MissionOrderTable, extraserviceorder.MissionOrderColumn),
		)
		fromV = sqlgraph.Neighbors(eso.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a ExtraServiceOrder.
func (c *ExtraServiceOrderClient) QuerySymbol(eso *ExtraServiceOrder) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eso.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(extraserviceorder.Table, extraserviceorder.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, extraserviceorder.SymbolTable, extraserviceorder.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(eso.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionBatch queries the mission_batch edge of a ExtraServiceOrder.
func (c *ExtraServiceOrderClient) QueryMissionBatch(eso *ExtraServiceOrder) *MissionBatchQuery {
	query := (&MissionBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eso.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(extraserviceorder.Table, extraserviceorder.FieldID, id),
			sqlgraph.To(missionbatch.Table, missionbatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, extraserviceorder.MissionBatchTable, extraserviceorder.MissionBatchColumn),
		)
		fromV = sqlgraph.Neighbors(eso.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExtraServiceOrderClient) Hooks() []Hook {
	return c.hooks.ExtraServiceOrder
}

// Interceptors returns the client interceptors.
func (c *ExtraServiceOrderClient) Interceptors() []Interceptor {
	return c.inters.ExtraServiceOrder
}

func (c *ExtraServiceOrderClient) mutate(ctx context.Context, m *ExtraServiceOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExtraServiceOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExtraServiceOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExtraServiceOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExtraServiceOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown ExtraServiceOrder mutation op: %q", m.Op())
	}
}

// ExtraServicePriceClient is a client for the ExtraServicePrice schema.
type ExtraServicePriceClient struct {
	config
}

// NewExtraServicePriceClient returns a client for the ExtraServicePrice from the given config.
func NewExtraServicePriceClient(c config) *ExtraServicePriceClient {
	return &ExtraServicePriceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `extraserviceprice.Hooks(f(g(h())))`.
func (c *ExtraServicePriceClient) Use(hooks ...Hook) {
	c.hooks.ExtraServicePrice = append(c.hooks.ExtraServicePrice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `extraserviceprice.Intercept(f(g(h())))`.
func (c *ExtraServicePriceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExtraServicePrice = append(c.inters.ExtraServicePrice, interceptors...)
}

// Create returns a builder for creating a ExtraServicePrice entity.
func (c *ExtraServicePriceClient) Create() *ExtraServicePriceCreate {
	mutation := newExtraServicePriceMutation(c.config, OpCreate)
	return &ExtraServicePriceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExtraServicePrice entities.
func (c *ExtraServicePriceClient) CreateBulk(builders ...*ExtraServicePriceCreate) *ExtraServicePriceCreateBulk {
	return &ExtraServicePriceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExtraServicePriceClient) MapCreateBulk(slice any, setFunc func(*ExtraServicePriceCreate, int)) *ExtraServicePriceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExtraServicePriceCreateBulk{err: fmt.Errorf("calling to ExtraServicePriceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExtraServicePriceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExtraServicePriceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExtraServicePrice.
func (c *ExtraServicePriceClient) Update() *ExtraServicePriceUpdate {
	mutation := newExtraServicePriceMutation(c.config, OpUpdate)
	return &ExtraServicePriceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExtraServicePriceClient) UpdateOne(esp *ExtraServicePrice) *ExtraServicePriceUpdateOne {
	mutation := newExtraServicePriceMutation(c.config, OpUpdateOne, withExtraServicePrice(esp))
	return &ExtraServicePriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExtraServicePriceClient) UpdateOneID(id int64) *ExtraServicePriceUpdateOne {
	mutation := newExtraServicePriceMutation(c.config, OpUpdateOne, withExtraServicePriceID(id))
	return &ExtraServicePriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExtraServicePrice.
func (c *ExtraServicePriceClient) Delete() *ExtraServicePriceDelete {
	mutation := newExtraServicePriceMutation(c.config, OpDelete)
	return &ExtraServicePriceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExtraServicePriceClient) DeleteOne(esp *ExtraServicePrice) *ExtraServicePriceDeleteOne {
	return c.DeleteOneID(esp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExtraServicePriceClient) DeleteOneID(id int64) *ExtraServicePriceDeleteOne {
	builder := c.Delete().Where(extraserviceprice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExtraServicePriceDeleteOne{builder}
}

// Query returns a query builder for ExtraServicePrice.
func (c *ExtraServicePriceClient) Query() *ExtraServicePriceQuery {
	return &ExtraServicePriceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExtraServicePrice},
		inters: c.Interceptors(),
	}
}

// Get returns a ExtraServicePrice entity by its id.
func (c *ExtraServicePriceClient) Get(ctx context.Context, id int64) (*ExtraServicePrice, error) {
	return c.Query().Where(extraserviceprice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExtraServicePriceClient) GetX(ctx context.Context, id int64) *ExtraServicePrice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExtraService queries the extra_service edge of a ExtraServicePrice.
func (c *ExtraServicePriceClient) QueryExtraService(esp *ExtraServicePrice) *ExtraServiceQuery {
	query := (&ExtraServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := esp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(extraserviceprice.Table, extraserviceprice.FieldID, id),
			sqlgraph.To(extraservice.Table, extraservice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, extraserviceprice.ExtraServiceTable, extraserviceprice.ExtraServiceColumn),
		)
		fromV = sqlgraph.Neighbors(esp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExtraServicePriceClient) Hooks() []Hook {
	return c.hooks.ExtraServicePrice
}

// Interceptors returns the client interceptors.
func (c *ExtraServicePriceClient) Interceptors() []Interceptor {
	return c.inters.ExtraServicePrice
}

func (c *ExtraServicePriceClient) mutate(ctx context.Context, m *ExtraServicePriceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExtraServicePriceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExtraServicePriceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExtraServicePriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExtraServicePriceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown ExtraServicePrice mutation op: %q", m.Op())
	}
}

// FrpcInfoClient is a client for the FrpcInfo schema.
type FrpcInfoClient struct {
	config
}

// NewFrpcInfoClient returns a client for the FrpcInfo from the given config.
func NewFrpcInfoClient(c config) *FrpcInfoClient {
	return &FrpcInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `frpcinfo.Hooks(f(g(h())))`.
func (c *FrpcInfoClient) Use(hooks ...Hook) {
	c.hooks.FrpcInfo = append(c.hooks.FrpcInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `frpcinfo.Intercept(f(g(h())))`.
func (c *FrpcInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.FrpcInfo = append(c.inters.FrpcInfo, interceptors...)
}

// Create returns a builder for creating a FrpcInfo entity.
func (c *FrpcInfoClient) Create() *FrpcInfoCreate {
	mutation := newFrpcInfoMutation(c.config, OpCreate)
	return &FrpcInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FrpcInfo entities.
func (c *FrpcInfoClient) CreateBulk(builders ...*FrpcInfoCreate) *FrpcInfoCreateBulk {
	return &FrpcInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FrpcInfoClient) MapCreateBulk(slice any, setFunc func(*FrpcInfoCreate, int)) *FrpcInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FrpcInfoCreateBulk{err: fmt.Errorf("calling to FrpcInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FrpcInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FrpcInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FrpcInfo.
func (c *FrpcInfoClient) Update() *FrpcInfoUpdate {
	mutation := newFrpcInfoMutation(c.config, OpUpdate)
	return &FrpcInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FrpcInfoClient) UpdateOne(fi *FrpcInfo) *FrpcInfoUpdateOne {
	mutation := newFrpcInfoMutation(c.config, OpUpdateOne, withFrpcInfo(fi))
	return &FrpcInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FrpcInfoClient) UpdateOneID(id int64) *FrpcInfoUpdateOne {
	mutation := newFrpcInfoMutation(c.config, OpUpdateOne, withFrpcInfoID(id))
	return &FrpcInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FrpcInfo.
func (c *FrpcInfoClient) Delete() *FrpcInfoDelete {
	mutation := newFrpcInfoMutation(c.config, OpDelete)
	return &FrpcInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FrpcInfoClient) DeleteOne(fi *FrpcInfo) *FrpcInfoDeleteOne {
	return c.DeleteOneID(fi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FrpcInfoClient) DeleteOneID(id int64) *FrpcInfoDeleteOne {
	builder := c.Delete().Where(frpcinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FrpcInfoDeleteOne{builder}
}

// Query returns a query builder for FrpcInfo.
func (c *FrpcInfoClient) Query() *FrpcInfoQuery {
	return &FrpcInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFrpcInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a FrpcInfo entity by its id.
func (c *FrpcInfoClient) Get(ctx context.Context, id int64) (*FrpcInfo, error) {
	return c.Query().Where(frpcinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FrpcInfoClient) GetX(ctx context.Context, id int64) *FrpcInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFrpsInfo queries the frps_info edge of a FrpcInfo.
func (c *FrpcInfoClient) QueryFrpsInfo(fi *FrpcInfo) *FrpsInfoQuery {
	query := (&FrpsInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(frpcinfo.Table, frpcinfo.FieldID, id),
			sqlgraph.To(frpsinfo.Table, frpsinfo.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, frpcinfo.FrpsInfoTable, frpcinfo.FrpsInfoColumn),
		)
		fromV = sqlgraph.Neighbors(fi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a FrpcInfo.
func (c *FrpcInfoClient) QueryDevice(fi *FrpcInfo) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(frpcinfo.Table, frpcinfo.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, frpcinfo.DeviceTable, frpcinfo.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(fi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FrpcInfoClient) Hooks() []Hook {
	return c.hooks.FrpcInfo
}

// Interceptors returns the client interceptors.
func (c *FrpcInfoClient) Interceptors() []Interceptor {
	return c.inters.FrpcInfo
}

func (c *FrpcInfoClient) mutate(ctx context.Context, m *FrpcInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FrpcInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FrpcInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FrpcInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FrpcInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown FrpcInfo mutation op: %q", m.Op())
	}
}

// FrpsInfoClient is a client for the FrpsInfo schema.
type FrpsInfoClient struct {
	config
}

// NewFrpsInfoClient returns a client for the FrpsInfo from the given config.
func NewFrpsInfoClient(c config) *FrpsInfoClient {
	return &FrpsInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `frpsinfo.Hooks(f(g(h())))`.
func (c *FrpsInfoClient) Use(hooks ...Hook) {
	c.hooks.FrpsInfo = append(c.hooks.FrpsInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `frpsinfo.Intercept(f(g(h())))`.
func (c *FrpsInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.FrpsInfo = append(c.inters.FrpsInfo, interceptors...)
}

// Create returns a builder for creating a FrpsInfo entity.
func (c *FrpsInfoClient) Create() *FrpsInfoCreate {
	mutation := newFrpsInfoMutation(c.config, OpCreate)
	return &FrpsInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FrpsInfo entities.
func (c *FrpsInfoClient) CreateBulk(builders ...*FrpsInfoCreate) *FrpsInfoCreateBulk {
	return &FrpsInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FrpsInfoClient) MapCreateBulk(slice any, setFunc func(*FrpsInfoCreate, int)) *FrpsInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FrpsInfoCreateBulk{err: fmt.Errorf("calling to FrpsInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FrpsInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FrpsInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FrpsInfo.
func (c *FrpsInfoClient) Update() *FrpsInfoUpdate {
	mutation := newFrpsInfoMutation(c.config, OpUpdate)
	return &FrpsInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FrpsInfoClient) UpdateOne(fi *FrpsInfo) *FrpsInfoUpdateOne {
	mutation := newFrpsInfoMutation(c.config, OpUpdateOne, withFrpsInfo(fi))
	return &FrpsInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FrpsInfoClient) UpdateOneID(id int64) *FrpsInfoUpdateOne {
	mutation := newFrpsInfoMutation(c.config, OpUpdateOne, withFrpsInfoID(id))
	return &FrpsInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FrpsInfo.
func (c *FrpsInfoClient) Delete() *FrpsInfoDelete {
	mutation := newFrpsInfoMutation(c.config, OpDelete)
	return &FrpsInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FrpsInfoClient) DeleteOne(fi *FrpsInfo) *FrpsInfoDeleteOne {
	return c.DeleteOneID(fi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FrpsInfoClient) DeleteOneID(id int64) *FrpsInfoDeleteOne {
	builder := c.Delete().Where(frpsinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FrpsInfoDeleteOne{builder}
}

// Query returns a query builder for FrpsInfo.
func (c *FrpsInfoClient) Query() *FrpsInfoQuery {
	return &FrpsInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFrpsInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a FrpsInfo entity by its id.
func (c *FrpsInfoClient) Get(ctx context.Context, id int64) (*FrpsInfo, error) {
	return c.Query().Where(frpsinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FrpsInfoClient) GetX(ctx context.Context, id int64) *FrpsInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFrpcInfos queries the frpc_infos edge of a FrpsInfo.
func (c *FrpsInfoClient) QueryFrpcInfos(fi *FrpsInfo) *FrpcInfoQuery {
	query := (&FrpcInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(frpsinfo.Table, frpsinfo.FieldID, id),
			sqlgraph.To(frpcinfo.Table, frpcinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, frpsinfo.FrpcInfosTable, frpsinfo.FrpcInfosColumn),
		)
		fromV = sqlgraph.Neighbors(fi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FrpsInfoClient) Hooks() []Hook {
	return c.hooks.FrpsInfo
}

// Interceptors returns the client interceptors.
func (c *FrpsInfoClient) Interceptors() []Interceptor {
	return c.inters.FrpsInfo
}

func (c *FrpsInfoClient) mutate(ctx context.Context, m *FrpsInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FrpsInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FrpsInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FrpsInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FrpsInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown FrpsInfo mutation op: %q", m.Op())
	}
}

// GpuClient is a client for the Gpu schema.
type GpuClient struct {
	config
}

// NewGpuClient returns a client for the Gpu from the given config.
func NewGpuClient(c config) *GpuClient {
	return &GpuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gpu.Hooks(f(g(h())))`.
func (c *GpuClient) Use(hooks ...Hook) {
	c.hooks.Gpu = append(c.hooks.Gpu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gpu.Intercept(f(g(h())))`.
func (c *GpuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Gpu = append(c.inters.Gpu, interceptors...)
}

// Create returns a builder for creating a Gpu entity.
func (c *GpuClient) Create() *GpuCreate {
	mutation := newGpuMutation(c.config, OpCreate)
	return &GpuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Gpu entities.
func (c *GpuClient) CreateBulk(builders ...*GpuCreate) *GpuCreateBulk {
	return &GpuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GpuClient) MapCreateBulk(slice any, setFunc func(*GpuCreate, int)) *GpuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GpuCreateBulk{err: fmt.Errorf("calling to GpuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GpuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GpuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Gpu.
func (c *GpuClient) Update() *GpuUpdate {
	mutation := newGpuMutation(c.config, OpUpdate)
	return &GpuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GpuClient) UpdateOne(gp *Gpu) *GpuUpdateOne {
	mutation := newGpuMutation(c.config, OpUpdateOne, withGpu(gp))
	return &GpuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GpuClient) UpdateOneID(id int64) *GpuUpdateOne {
	mutation := newGpuMutation(c.config, OpUpdateOne, withGpuID(id))
	return &GpuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Gpu.
func (c *GpuClient) Delete() *GpuDelete {
	mutation := newGpuMutation(c.config, OpDelete)
	return &GpuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GpuClient) DeleteOne(gp *Gpu) *GpuDeleteOne {
	return c.DeleteOneID(gp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GpuClient) DeleteOneID(id int64) *GpuDeleteOne {
	builder := c.Delete().Where(gpu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GpuDeleteOne{builder}
}

// Query returns a query builder for Gpu.
func (c *GpuClient) Query() *GpuQuery {
	return &GpuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGpu},
		inters: c.Interceptors(),
	}
}

// Get returns a Gpu entity by its id.
func (c *GpuClient) Get(ctx context.Context, id int64) (*Gpu, error) {
	return c.Query().Where(gpu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GpuClient) GetX(ctx context.Context, id int64) *Gpu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeviceGpuMissions queries the device_gpu_missions edge of a Gpu.
func (c *GpuClient) QueryDeviceGpuMissions(gp *Gpu) *DeviceGpuMissionQuery {
	query := (&DeviceGpuMissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gpu.Table, gpu.FieldID, id),
			sqlgraph.To(devicegpumission.Table, devicegpumission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gpu.DeviceGpuMissionsTable, gpu.DeviceGpuMissionsColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrices queries the prices edge of a Gpu.
func (c *GpuClient) QueryPrices(gp *Gpu) *PriceQuery {
	query := (&PriceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gpu.Table, gpu.FieldID, id),
			sqlgraph.To(price.Table, price.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gpu.PricesTable, gpu.PricesColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GpuClient) Hooks() []Hook {
	return c.hooks.Gpu
}

// Interceptors returns the client interceptors.
func (c *GpuClient) Interceptors() []Interceptor {
	return c.inters.Gpu
}

func (c *GpuClient) mutate(ctx context.Context, m *GpuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GpuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GpuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GpuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GpuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Gpu mutation op: %q", m.Op())
	}
}

// HmacKeyPairClient is a client for the HmacKeyPair schema.
type HmacKeyPairClient struct {
	config
}

// NewHmacKeyPairClient returns a client for the HmacKeyPair from the given config.
func NewHmacKeyPairClient(c config) *HmacKeyPairClient {
	return &HmacKeyPairClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hmackeypair.Hooks(f(g(h())))`.
func (c *HmacKeyPairClient) Use(hooks ...Hook) {
	c.hooks.HmacKeyPair = append(c.hooks.HmacKeyPair, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hmackeypair.Intercept(f(g(h())))`.
func (c *HmacKeyPairClient) Intercept(interceptors ...Interceptor) {
	c.inters.HmacKeyPair = append(c.inters.HmacKeyPair, interceptors...)
}

// Create returns a builder for creating a HmacKeyPair entity.
func (c *HmacKeyPairClient) Create() *HmacKeyPairCreate {
	mutation := newHmacKeyPairMutation(c.config, OpCreate)
	return &HmacKeyPairCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HmacKeyPair entities.
func (c *HmacKeyPairClient) CreateBulk(builders ...*HmacKeyPairCreate) *HmacKeyPairCreateBulk {
	return &HmacKeyPairCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HmacKeyPairClient) MapCreateBulk(slice any, setFunc func(*HmacKeyPairCreate, int)) *HmacKeyPairCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HmacKeyPairCreateBulk{err: fmt.Errorf("calling to HmacKeyPairClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HmacKeyPairCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HmacKeyPairCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HmacKeyPair.
func (c *HmacKeyPairClient) Update() *HmacKeyPairUpdate {
	mutation := newHmacKeyPairMutation(c.config, OpUpdate)
	return &HmacKeyPairUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HmacKeyPairClient) UpdateOne(hkp *HmacKeyPair) *HmacKeyPairUpdateOne {
	mutation := newHmacKeyPairMutation(c.config, OpUpdateOne, withHmacKeyPair(hkp))
	return &HmacKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HmacKeyPairClient) UpdateOneID(id int64) *HmacKeyPairUpdateOne {
	mutation := newHmacKeyPairMutation(c.config, OpUpdateOne, withHmacKeyPairID(id))
	return &HmacKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HmacKeyPair.
func (c *HmacKeyPairClient) Delete() *HmacKeyPairDelete {
	mutation := newHmacKeyPairMutation(c.config, OpDelete)
	return &HmacKeyPairDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HmacKeyPairClient) DeleteOne(hkp *HmacKeyPair) *HmacKeyPairDeleteOne {
	return c.DeleteOneID(hkp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HmacKeyPairClient) DeleteOneID(id int64) *HmacKeyPairDeleteOne {
	builder := c.Delete().Where(hmackeypair.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HmacKeyPairDeleteOne{builder}
}

// Query returns a query builder for HmacKeyPair.
func (c *HmacKeyPairClient) Query() *HmacKeyPairQuery {
	return &HmacKeyPairQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHmacKeyPair},
		inters: c.Interceptors(),
	}
}

// Get returns a HmacKeyPair entity by its id.
func (c *HmacKeyPairClient) Get(ctx context.Context, id int64) (*HmacKeyPair, error) {
	return c.Query().Where(hmackeypair.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HmacKeyPairClient) GetX(ctx context.Context, id int64) *HmacKeyPair {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMissionKeyPairs queries the mission_key_pairs edge of a HmacKeyPair.
func (c *HmacKeyPairClient) QueryMissionKeyPairs(hkp *HmacKeyPair) *MissionKeyPairQuery {
	query := (&MissionKeyPairClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hkp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hmackeypair.Table, hmackeypair.FieldID, id),
			sqlgraph.To(missionkeypair.Table, missionkeypair.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, hmackeypair.MissionKeyPairsTable, hmackeypair.MissionKeyPairsColumn),
		)
		fromV = sqlgraph.Neighbors(hkp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedMissions queries the created_missions edge of a HmacKeyPair.
func (c *HmacKeyPairClient) QueryCreatedMissions(hkp *HmacKeyPair) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hkp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hmackeypair.Table, hmackeypair.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, hmackeypair.CreatedMissionsTable, hmackeypair.CreatedMissionsColumn),
		)
		fromV = sqlgraph.Neighbors(hkp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HmacKeyPairClient) Hooks() []Hook {
	return c.hooks.HmacKeyPair
}

// Interceptors returns the client interceptors.
func (c *HmacKeyPairClient) Interceptors() []Interceptor {
	return c.inters.HmacKeyPair
}

func (c *HmacKeyPairClient) mutate(ctx context.Context, m *HmacKeyPairMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HmacKeyPairCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HmacKeyPairUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HmacKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HmacKeyPairDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown HmacKeyPair mutation op: %q", m.Op())
	}
}

// IncomeManageClient is a client for the IncomeManage schema.
type IncomeManageClient struct {
	config
}

// NewIncomeManageClient returns a client for the IncomeManage from the given config.
func NewIncomeManageClient(c config) *IncomeManageClient {
	return &IncomeManageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incomemanage.Hooks(f(g(h())))`.
func (c *IncomeManageClient) Use(hooks ...Hook) {
	c.hooks.IncomeManage = append(c.hooks.IncomeManage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incomemanage.Intercept(f(g(h())))`.
func (c *IncomeManageClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncomeManage = append(c.inters.IncomeManage, interceptors...)
}

// Create returns a builder for creating a IncomeManage entity.
func (c *IncomeManageClient) Create() *IncomeManageCreate {
	mutation := newIncomeManageMutation(c.config, OpCreate)
	return &IncomeManageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncomeManage entities.
func (c *IncomeManageClient) CreateBulk(builders ...*IncomeManageCreate) *IncomeManageCreateBulk {
	return &IncomeManageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncomeManageClient) MapCreateBulk(slice any, setFunc func(*IncomeManageCreate, int)) *IncomeManageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncomeManageCreateBulk{err: fmt.Errorf("calling to IncomeManageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncomeManageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncomeManageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncomeManage.
func (c *IncomeManageClient) Update() *IncomeManageUpdate {
	mutation := newIncomeManageMutation(c.config, OpUpdate)
	return &IncomeManageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncomeManageClient) UpdateOne(im *IncomeManage) *IncomeManageUpdateOne {
	mutation := newIncomeManageMutation(c.config, OpUpdateOne, withIncomeManage(im))
	return &IncomeManageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncomeManageClient) UpdateOneID(id int64) *IncomeManageUpdateOne {
	mutation := newIncomeManageMutation(c.config, OpUpdateOne, withIncomeManageID(id))
	return &IncomeManageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncomeManage.
func (c *IncomeManageClient) Delete() *IncomeManageDelete {
	mutation := newIncomeManageMutation(c.config, OpDelete)
	return &IncomeManageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncomeManageClient) DeleteOne(im *IncomeManage) *IncomeManageDeleteOne {
	return c.DeleteOneID(im.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncomeManageClient) DeleteOneID(id int64) *IncomeManageDeleteOne {
	builder := c.Delete().Where(incomemanage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncomeManageDeleteOne{builder}
}

// Query returns a query builder for IncomeManage.
func (c *IncomeManageClient) Query() *IncomeManageQuery {
	return &IncomeManageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncomeManage},
		inters: c.Interceptors(),
	}
}

// Get returns a IncomeManage entity by its id.
func (c *IncomeManageClient) Get(ctx context.Context, id int64) (*IncomeManage, error) {
	return c.Query().Where(incomemanage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncomeManageClient) GetX(ctx context.Context, id int64) *IncomeManage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a IncomeManage.
func (c *IncomeManageClient) QueryUser(im *IncomeManage) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := im.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incomemanage.Table, incomemanage.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incomemanage.UserTable, incomemanage.UserColumn),
		)
		fromV = sqlgraph.Neighbors(im.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApproveUser queries the approve_user edge of a IncomeManage.
func (c *IncomeManageClient) QueryApproveUser(im *IncomeManage) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := im.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incomemanage.Table, incomemanage.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incomemanage.ApproveUserTable, incomemanage.ApproveUserColumn),
		)
		fromV = sqlgraph.Neighbors(im.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncomeManageClient) Hooks() []Hook {
	return c.hooks.IncomeManage
}

// Interceptors returns the client interceptors.
func (c *IncomeManageClient) Interceptors() []Interceptor {
	return c.inters.IncomeManage
}

func (c *IncomeManageClient) mutate(ctx context.Context, m *IncomeManageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncomeManageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncomeManageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncomeManageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncomeManageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown IncomeManage mutation op: %q", m.Op())
	}
}

// InputLogClient is a client for the InputLog schema.
type InputLogClient struct {
	config
}

// NewInputLogClient returns a client for the InputLog from the given config.
func NewInputLogClient(c config) *InputLogClient {
	return &InputLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inputlog.Hooks(f(g(h())))`.
func (c *InputLogClient) Use(hooks ...Hook) {
	c.hooks.InputLog = append(c.hooks.InputLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inputlog.Intercept(f(g(h())))`.
func (c *InputLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.InputLog = append(c.inters.InputLog, interceptors...)
}

// Create returns a builder for creating a InputLog entity.
func (c *InputLogClient) Create() *InputLogCreate {
	mutation := newInputLogMutation(c.config, OpCreate)
	return &InputLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InputLog entities.
func (c *InputLogClient) CreateBulk(builders ...*InputLogCreate) *InputLogCreateBulk {
	return &InputLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InputLogClient) MapCreateBulk(slice any, setFunc func(*InputLogCreate, int)) *InputLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InputLogCreateBulk{err: fmt.Errorf("calling to InputLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InputLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InputLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InputLog.
func (c *InputLogClient) Update() *InputLogUpdate {
	mutation := newInputLogMutation(c.config, OpUpdate)
	return &InputLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InputLogClient) UpdateOne(il *InputLog) *InputLogUpdateOne {
	mutation := newInputLogMutation(c.config, OpUpdateOne, withInputLog(il))
	return &InputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InputLogClient) UpdateOneID(id int64) *InputLogUpdateOne {
	mutation := newInputLogMutation(c.config, OpUpdateOne, withInputLogID(id))
	return &InputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InputLog.
func (c *InputLogClient) Delete() *InputLogDelete {
	mutation := newInputLogMutation(c.config, OpDelete)
	return &InputLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InputLogClient) DeleteOne(il *InputLog) *InputLogDeleteOne {
	return c.DeleteOneID(il.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InputLogClient) DeleteOneID(id int64) *InputLogDeleteOne {
	builder := c.Delete().Where(inputlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InputLogDeleteOne{builder}
}

// Query returns a query builder for InputLog.
func (c *InputLogClient) Query() *InputLogQuery {
	return &InputLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInputLog},
		inters: c.Interceptors(),
	}
}

// Get returns a InputLog entity by its id.
func (c *InputLogClient) Get(ctx context.Context, id int64) (*InputLog, error) {
	return c.Query().Where(inputlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InputLogClient) GetX(ctx context.Context, id int64) *InputLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InputLogClient) Hooks() []Hook {
	return c.hooks.InputLog
}

// Interceptors returns the client interceptors.
func (c *InputLogClient) Interceptors() []Interceptor {
	return c.inters.InputLog
}

func (c *InputLogClient) mutate(ctx context.Context, m *InputLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InputLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InputLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InputLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown InputLog mutation op: %q", m.Op())
	}
}

// InviteClient is a client for the Invite schema.
type InviteClient struct {
	config
}

// NewInviteClient returns a client for the Invite from the given config.
func NewInviteClient(c config) *InviteClient {
	return &InviteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invite.Hooks(f(g(h())))`.
func (c *InviteClient) Use(hooks ...Hook) {
	c.hooks.Invite = append(c.hooks.Invite, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invite.Intercept(f(g(h())))`.
func (c *InviteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invite = append(c.inters.Invite, interceptors...)
}

// Create returns a builder for creating a Invite entity.
func (c *InviteClient) Create() *InviteCreate {
	mutation := newInviteMutation(c.config, OpCreate)
	return &InviteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invite entities.
func (c *InviteClient) CreateBulk(builders ...*InviteCreate) *InviteCreateBulk {
	return &InviteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InviteClient) MapCreateBulk(slice any, setFunc func(*InviteCreate, int)) *InviteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InviteCreateBulk{err: fmt.Errorf("calling to InviteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InviteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InviteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invite.
func (c *InviteClient) Update() *InviteUpdate {
	mutation := newInviteMutation(c.config, OpUpdate)
	return &InviteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InviteClient) UpdateOne(i *Invite) *InviteUpdateOne {
	mutation := newInviteMutation(c.config, OpUpdateOne, withInvite(i))
	return &InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InviteClient) UpdateOneID(id int64) *InviteUpdateOne {
	mutation := newInviteMutation(c.config, OpUpdateOne, withInviteID(id))
	return &InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invite.
func (c *InviteClient) Delete() *InviteDelete {
	mutation := newInviteMutation(c.config, OpDelete)
	return &InviteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InviteClient) DeleteOne(i *Invite) *InviteDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InviteClient) DeleteOneID(id int64) *InviteDeleteOne {
	builder := c.Delete().Where(invite.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InviteDeleteOne{builder}
}

// Query returns a query builder for Invite.
func (c *InviteClient) Query() *InviteQuery {
	return &InviteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvite},
		inters: c.Interceptors(),
	}
}

// Get returns a Invite entity by its id.
func (c *InviteClient) Get(ctx context.Context, id int64) (*Invite, error) {
	return c.Query().Where(invite.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InviteClient) GetX(ctx context.Context, id int64) *Invite {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Invite.
func (c *InviteClient) QueryUser(i *Invite) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invite.UserTable, invite.UserColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaign queries the campaign edge of a Invite.
func (c *InviteClient) QueryCampaign(i *Invite) *CampaignQuery {
	query := (&CampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(campaign.Table, campaign.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invite.CampaignTable, invite.CampaignColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBills queries the bills edge of a Invite.
func (c *InviteClient) QueryBills(i *Invite) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, invite.BillsTable, invite.BillsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InviteClient) Hooks() []Hook {
	return c.hooks.Invite
}

// Interceptors returns the client interceptors.
func (c *InviteClient) Interceptors() []Interceptor {
	return c.inters.Invite
}

func (c *InviteClient) mutate(ctx context.Context, m *InviteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InviteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InviteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InviteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Invite mutation op: %q", m.Op())
	}
}

// LoginRecordClient is a client for the LoginRecord schema.
type LoginRecordClient struct {
	config
}

// NewLoginRecordClient returns a client for the LoginRecord from the given config.
func NewLoginRecordClient(c config) *LoginRecordClient {
	return &LoginRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `loginrecord.Hooks(f(g(h())))`.
func (c *LoginRecordClient) Use(hooks ...Hook) {
	c.hooks.LoginRecord = append(c.hooks.LoginRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `loginrecord.Intercept(f(g(h())))`.
func (c *LoginRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.LoginRecord = append(c.inters.LoginRecord, interceptors...)
}

// Create returns a builder for creating a LoginRecord entity.
func (c *LoginRecordClient) Create() *LoginRecordCreate {
	mutation := newLoginRecordMutation(c.config, OpCreate)
	return &LoginRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LoginRecord entities.
func (c *LoginRecordClient) CreateBulk(builders ...*LoginRecordCreate) *LoginRecordCreateBulk {
	return &LoginRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoginRecordClient) MapCreateBulk(slice any, setFunc func(*LoginRecordCreate, int)) *LoginRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoginRecordCreateBulk{err: fmt.Errorf("calling to LoginRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoginRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoginRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LoginRecord.
func (c *LoginRecordClient) Update() *LoginRecordUpdate {
	mutation := newLoginRecordMutation(c.config, OpUpdate)
	return &LoginRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoginRecordClient) UpdateOne(lr *LoginRecord) *LoginRecordUpdateOne {
	mutation := newLoginRecordMutation(c.config, OpUpdateOne, withLoginRecord(lr))
	return &LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoginRecordClient) UpdateOneID(id int64) *LoginRecordUpdateOne {
	mutation := newLoginRecordMutation(c.config, OpUpdateOne, withLoginRecordID(id))
	return &LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LoginRecord.
func (c *LoginRecordClient) Delete() *LoginRecordDelete {
	mutation := newLoginRecordMutation(c.config, OpDelete)
	return &LoginRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoginRecordClient) DeleteOne(lr *LoginRecord) *LoginRecordDeleteOne {
	return c.DeleteOneID(lr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoginRecordClient) DeleteOneID(id int64) *LoginRecordDeleteOne {
	builder := c.Delete().Where(loginrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoginRecordDeleteOne{builder}
}

// Query returns a query builder for LoginRecord.
func (c *LoginRecordClient) Query() *LoginRecordQuery {
	return &LoginRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLoginRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a LoginRecord entity by its id.
func (c *LoginRecordClient) Get(ctx context.Context, id int64) (*LoginRecord, error) {
	return c.Query().Where(loginrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoginRecordClient) GetX(ctx context.Context, id int64) *LoginRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LoginRecord.
func (c *LoginRecordClient) QueryUser(lr *LoginRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(loginrecord.Table, loginrecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, loginrecord.UserTable, loginrecord.UserColumn),
		)
		fromV = sqlgraph.Neighbors(lr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LoginRecordClient) Hooks() []Hook {
	return c.hooks.LoginRecord
}

// Interceptors returns the client interceptors.
func (c *LoginRecordClient) Interceptors() []Interceptor {
	return c.inters.LoginRecord
}

func (c *LoginRecordClient) mutate(ctx context.Context, m *LoginRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoginRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoginRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoginRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown LoginRecord mutation op: %q", m.Op())
	}
}

// LottoClient is a client for the Lotto schema.
type LottoClient struct {
	config
}

// NewLottoClient returns a client for the Lotto from the given config.
func NewLottoClient(c config) *LottoClient {
	return &LottoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lotto.Hooks(f(g(h())))`.
func (c *LottoClient) Use(hooks ...Hook) {
	c.hooks.Lotto = append(c.hooks.Lotto, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lotto.Intercept(f(g(h())))`.
func (c *LottoClient) Intercept(interceptors ...Interceptor) {
	c.inters.Lotto = append(c.inters.Lotto, interceptors...)
}

// Create returns a builder for creating a Lotto entity.
func (c *LottoClient) Create() *LottoCreate {
	mutation := newLottoMutation(c.config, OpCreate)
	return &LottoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Lotto entities.
func (c *LottoClient) CreateBulk(builders ...*LottoCreate) *LottoCreateBulk {
	return &LottoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LottoClient) MapCreateBulk(slice any, setFunc func(*LottoCreate, int)) *LottoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LottoCreateBulk{err: fmt.Errorf("calling to LottoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LottoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LottoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Lotto.
func (c *LottoClient) Update() *LottoUpdate {
	mutation := newLottoMutation(c.config, OpUpdate)
	return &LottoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LottoClient) UpdateOne(l *Lotto) *LottoUpdateOne {
	mutation := newLottoMutation(c.config, OpUpdateOne, withLotto(l))
	return &LottoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LottoClient) UpdateOneID(id int64) *LottoUpdateOne {
	mutation := newLottoMutation(c.config, OpUpdateOne, withLottoID(id))
	return &LottoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Lotto.
func (c *LottoClient) Delete() *LottoDelete {
	mutation := newLottoMutation(c.config, OpDelete)
	return &LottoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LottoClient) DeleteOne(l *Lotto) *LottoDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LottoClient) DeleteOneID(id int64) *LottoDeleteOne {
	builder := c.Delete().Where(lotto.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LottoDeleteOne{builder}
}

// Query returns a query builder for Lotto.
func (c *LottoClient) Query() *LottoQuery {
	return &LottoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLotto},
		inters: c.Interceptors(),
	}
}

// Get returns a Lotto entity by its id.
func (c *LottoClient) Get(ctx context.Context, id int64) (*Lotto, error) {
	return c.Query().Where(lotto.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LottoClient) GetX(ctx context.Context, id int64) *Lotto {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLottoPrizes queries the lotto_prizes edge of a Lotto.
func (c *LottoClient) QueryLottoPrizes(l *Lotto) *LottoPrizeQuery {
	query := (&LottoPrizeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lotto.Table, lotto.FieldID, id),
			sqlgraph.To(lottoprize.Table, lottoprize.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lotto.LottoPrizesTable, lotto.LottoPrizesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLottoRecords queries the lotto_records edge of a Lotto.
func (c *LottoClient) QueryLottoRecords(l *Lotto) *LottoRecordQuery {
	query := (&LottoRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lotto.Table, lotto.FieldID, id),
			sqlgraph.To(lottorecord.Table, lottorecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lotto.LottoRecordsTable, lotto.LottoRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLottoUserCounts queries the lotto_user_counts edge of a Lotto.
func (c *LottoClient) QueryLottoUserCounts(l *Lotto) *LottoUserCountQuery {
	query := (&LottoUserCountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lotto.Table, lotto.FieldID, id),
			sqlgraph.To(lottousercount.Table, lottousercount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lotto.LottoUserCountsTable, lotto.LottoUserCountsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLottoGetCountRecords queries the lotto_get_count_records edge of a Lotto.
func (c *LottoClient) QueryLottoGetCountRecords(l *Lotto) *LottoGetCountRecordQuery {
	query := (&LottoGetCountRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lotto.Table, lotto.FieldID, id),
			sqlgraph.To(lottogetcountrecord.Table, lottogetcountrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lotto.LottoGetCountRecordsTable, lotto.LottoGetCountRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLottoChangeRules queries the lotto_Change_rules edge of a Lotto.
func (c *LottoClient) QueryLottoChangeRules(l *Lotto) *LottoChanceRuleQuery {
	query := (&LottoChanceRuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lotto.Table, lotto.FieldID, id),
			sqlgraph.To(lottochancerule.Table, lottochancerule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lotto.LottoChangeRulesTable, lotto.LottoChangeRulesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LottoClient) Hooks() []Hook {
	return c.hooks.Lotto
}

// Interceptors returns the client interceptors.
func (c *LottoClient) Interceptors() []Interceptor {
	return c.inters.Lotto
}

func (c *LottoClient) mutate(ctx context.Context, m *LottoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LottoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LottoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LottoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LottoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Lotto mutation op: %q", m.Op())
	}
}

// LottoChanceRuleClient is a client for the LottoChanceRule schema.
type LottoChanceRuleClient struct {
	config
}

// NewLottoChanceRuleClient returns a client for the LottoChanceRule from the given config.
func NewLottoChanceRuleClient(c config) *LottoChanceRuleClient {
	return &LottoChanceRuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lottochancerule.Hooks(f(g(h())))`.
func (c *LottoChanceRuleClient) Use(hooks ...Hook) {
	c.hooks.LottoChanceRule = append(c.hooks.LottoChanceRule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lottochancerule.Intercept(f(g(h())))`.
func (c *LottoChanceRuleClient) Intercept(interceptors ...Interceptor) {
	c.inters.LottoChanceRule = append(c.inters.LottoChanceRule, interceptors...)
}

// Create returns a builder for creating a LottoChanceRule entity.
func (c *LottoChanceRuleClient) Create() *LottoChanceRuleCreate {
	mutation := newLottoChanceRuleMutation(c.config, OpCreate)
	return &LottoChanceRuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LottoChanceRule entities.
func (c *LottoChanceRuleClient) CreateBulk(builders ...*LottoChanceRuleCreate) *LottoChanceRuleCreateBulk {
	return &LottoChanceRuleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LottoChanceRuleClient) MapCreateBulk(slice any, setFunc func(*LottoChanceRuleCreate, int)) *LottoChanceRuleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LottoChanceRuleCreateBulk{err: fmt.Errorf("calling to LottoChanceRuleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LottoChanceRuleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LottoChanceRuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LottoChanceRule.
func (c *LottoChanceRuleClient) Update() *LottoChanceRuleUpdate {
	mutation := newLottoChanceRuleMutation(c.config, OpUpdate)
	return &LottoChanceRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LottoChanceRuleClient) UpdateOne(lcr *LottoChanceRule) *LottoChanceRuleUpdateOne {
	mutation := newLottoChanceRuleMutation(c.config, OpUpdateOne, withLottoChanceRule(lcr))
	return &LottoChanceRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LottoChanceRuleClient) UpdateOneID(id int64) *LottoChanceRuleUpdateOne {
	mutation := newLottoChanceRuleMutation(c.config, OpUpdateOne, withLottoChanceRuleID(id))
	return &LottoChanceRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LottoChanceRule.
func (c *LottoChanceRuleClient) Delete() *LottoChanceRuleDelete {
	mutation := newLottoChanceRuleMutation(c.config, OpDelete)
	return &LottoChanceRuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LottoChanceRuleClient) DeleteOne(lcr *LottoChanceRule) *LottoChanceRuleDeleteOne {
	return c.DeleteOneID(lcr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LottoChanceRuleClient) DeleteOneID(id int64) *LottoChanceRuleDeleteOne {
	builder := c.Delete().Where(lottochancerule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LottoChanceRuleDeleteOne{builder}
}

// Query returns a query builder for LottoChanceRule.
func (c *LottoChanceRuleClient) Query() *LottoChanceRuleQuery {
	return &LottoChanceRuleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLottoChanceRule},
		inters: c.Interceptors(),
	}
}

// Get returns a LottoChanceRule entity by its id.
func (c *LottoChanceRuleClient) Get(ctx context.Context, id int64) (*LottoChanceRule, error) {
	return c.Query().Where(lottochancerule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LottoChanceRuleClient) GetX(ctx context.Context, id int64) *LottoChanceRule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLotto queries the lotto edge of a LottoChanceRule.
func (c *LottoChanceRuleClient) QueryLotto(lcr *LottoChanceRule) *LottoQuery {
	query := (&LottoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lcr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottochancerule.Table, lottochancerule.FieldID, id),
			sqlgraph.To(lotto.Table, lotto.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lottochancerule.LottoTable, lottochancerule.LottoColumn),
		)
		fromV = sqlgraph.Neighbors(lcr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LottoChanceRuleClient) Hooks() []Hook {
	return c.hooks.LottoChanceRule
}

// Interceptors returns the client interceptors.
func (c *LottoChanceRuleClient) Interceptors() []Interceptor {
	return c.inters.LottoChanceRule
}

func (c *LottoChanceRuleClient) mutate(ctx context.Context, m *LottoChanceRuleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LottoChanceRuleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LottoChanceRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LottoChanceRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LottoChanceRuleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown LottoChanceRule mutation op: %q", m.Op())
	}
}

// LottoGetCountRecordClient is a client for the LottoGetCountRecord schema.
type LottoGetCountRecordClient struct {
	config
}

// NewLottoGetCountRecordClient returns a client for the LottoGetCountRecord from the given config.
func NewLottoGetCountRecordClient(c config) *LottoGetCountRecordClient {
	return &LottoGetCountRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lottogetcountrecord.Hooks(f(g(h())))`.
func (c *LottoGetCountRecordClient) Use(hooks ...Hook) {
	c.hooks.LottoGetCountRecord = append(c.hooks.LottoGetCountRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lottogetcountrecord.Intercept(f(g(h())))`.
func (c *LottoGetCountRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.LottoGetCountRecord = append(c.inters.LottoGetCountRecord, interceptors...)
}

// Create returns a builder for creating a LottoGetCountRecord entity.
func (c *LottoGetCountRecordClient) Create() *LottoGetCountRecordCreate {
	mutation := newLottoGetCountRecordMutation(c.config, OpCreate)
	return &LottoGetCountRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LottoGetCountRecord entities.
func (c *LottoGetCountRecordClient) CreateBulk(builders ...*LottoGetCountRecordCreate) *LottoGetCountRecordCreateBulk {
	return &LottoGetCountRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LottoGetCountRecordClient) MapCreateBulk(slice any, setFunc func(*LottoGetCountRecordCreate, int)) *LottoGetCountRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LottoGetCountRecordCreateBulk{err: fmt.Errorf("calling to LottoGetCountRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LottoGetCountRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LottoGetCountRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LottoGetCountRecord.
func (c *LottoGetCountRecordClient) Update() *LottoGetCountRecordUpdate {
	mutation := newLottoGetCountRecordMutation(c.config, OpUpdate)
	return &LottoGetCountRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LottoGetCountRecordClient) UpdateOne(lgcr *LottoGetCountRecord) *LottoGetCountRecordUpdateOne {
	mutation := newLottoGetCountRecordMutation(c.config, OpUpdateOne, withLottoGetCountRecord(lgcr))
	return &LottoGetCountRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LottoGetCountRecordClient) UpdateOneID(id int64) *LottoGetCountRecordUpdateOne {
	mutation := newLottoGetCountRecordMutation(c.config, OpUpdateOne, withLottoGetCountRecordID(id))
	return &LottoGetCountRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LottoGetCountRecord.
func (c *LottoGetCountRecordClient) Delete() *LottoGetCountRecordDelete {
	mutation := newLottoGetCountRecordMutation(c.config, OpDelete)
	return &LottoGetCountRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LottoGetCountRecordClient) DeleteOne(lgcr *LottoGetCountRecord) *LottoGetCountRecordDeleteOne {
	return c.DeleteOneID(lgcr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LottoGetCountRecordClient) DeleteOneID(id int64) *LottoGetCountRecordDeleteOne {
	builder := c.Delete().Where(lottogetcountrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LottoGetCountRecordDeleteOne{builder}
}

// Query returns a query builder for LottoGetCountRecord.
func (c *LottoGetCountRecordClient) Query() *LottoGetCountRecordQuery {
	return &LottoGetCountRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLottoGetCountRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a LottoGetCountRecord entity by its id.
func (c *LottoGetCountRecordClient) Get(ctx context.Context, id int64) (*LottoGetCountRecord, error) {
	return c.Query().Where(lottogetcountrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LottoGetCountRecordClient) GetX(ctx context.Context, id int64) *LottoGetCountRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LottoGetCountRecord.
func (c *LottoGetCountRecordClient) QueryUser(lgcr *LottoGetCountRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lgcr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottogetcountrecord.Table, lottogetcountrecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lottogetcountrecord.UserTable, lottogetcountrecord.UserColumn),
		)
		fromV = sqlgraph.Neighbors(lgcr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLotto queries the lotto edge of a LottoGetCountRecord.
func (c *LottoGetCountRecordClient) QueryLotto(lgcr *LottoGetCountRecord) *LottoQuery {
	query := (&LottoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lgcr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottogetcountrecord.Table, lottogetcountrecord.FieldID, id),
			sqlgraph.To(lotto.Table, lotto.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lottogetcountrecord.LottoTable, lottogetcountrecord.LottoColumn),
		)
		fromV = sqlgraph.Neighbors(lgcr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LottoGetCountRecordClient) Hooks() []Hook {
	return c.hooks.LottoGetCountRecord
}

// Interceptors returns the client interceptors.
func (c *LottoGetCountRecordClient) Interceptors() []Interceptor {
	return c.inters.LottoGetCountRecord
}

func (c *LottoGetCountRecordClient) mutate(ctx context.Context, m *LottoGetCountRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LottoGetCountRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LottoGetCountRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LottoGetCountRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LottoGetCountRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown LottoGetCountRecord mutation op: %q", m.Op())
	}
}

// LottoPrizeClient is a client for the LottoPrize schema.
type LottoPrizeClient struct {
	config
}

// NewLottoPrizeClient returns a client for the LottoPrize from the given config.
func NewLottoPrizeClient(c config) *LottoPrizeClient {
	return &LottoPrizeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lottoprize.Hooks(f(g(h())))`.
func (c *LottoPrizeClient) Use(hooks ...Hook) {
	c.hooks.LottoPrize = append(c.hooks.LottoPrize, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lottoprize.Intercept(f(g(h())))`.
func (c *LottoPrizeClient) Intercept(interceptors ...Interceptor) {
	c.inters.LottoPrize = append(c.inters.LottoPrize, interceptors...)
}

// Create returns a builder for creating a LottoPrize entity.
func (c *LottoPrizeClient) Create() *LottoPrizeCreate {
	mutation := newLottoPrizeMutation(c.config, OpCreate)
	return &LottoPrizeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LottoPrize entities.
func (c *LottoPrizeClient) CreateBulk(builders ...*LottoPrizeCreate) *LottoPrizeCreateBulk {
	return &LottoPrizeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LottoPrizeClient) MapCreateBulk(slice any, setFunc func(*LottoPrizeCreate, int)) *LottoPrizeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LottoPrizeCreateBulk{err: fmt.Errorf("calling to LottoPrizeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LottoPrizeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LottoPrizeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LottoPrize.
func (c *LottoPrizeClient) Update() *LottoPrizeUpdate {
	mutation := newLottoPrizeMutation(c.config, OpUpdate)
	return &LottoPrizeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LottoPrizeClient) UpdateOne(lp *LottoPrize) *LottoPrizeUpdateOne {
	mutation := newLottoPrizeMutation(c.config, OpUpdateOne, withLottoPrize(lp))
	return &LottoPrizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LottoPrizeClient) UpdateOneID(id int64) *LottoPrizeUpdateOne {
	mutation := newLottoPrizeMutation(c.config, OpUpdateOne, withLottoPrizeID(id))
	return &LottoPrizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LottoPrize.
func (c *LottoPrizeClient) Delete() *LottoPrizeDelete {
	mutation := newLottoPrizeMutation(c.config, OpDelete)
	return &LottoPrizeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LottoPrizeClient) DeleteOne(lp *LottoPrize) *LottoPrizeDeleteOne {
	return c.DeleteOneID(lp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LottoPrizeClient) DeleteOneID(id int64) *LottoPrizeDeleteOne {
	builder := c.Delete().Where(lottoprize.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LottoPrizeDeleteOne{builder}
}

// Query returns a query builder for LottoPrize.
func (c *LottoPrizeClient) Query() *LottoPrizeQuery {
	return &LottoPrizeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLottoPrize},
		inters: c.Interceptors(),
	}
}

// Get returns a LottoPrize entity by its id.
func (c *LottoPrizeClient) Get(ctx context.Context, id int64) (*LottoPrize, error) {
	return c.Query().Where(lottoprize.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LottoPrizeClient) GetX(ctx context.Context, id int64) *LottoPrize {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLotto queries the lotto edge of a LottoPrize.
func (c *LottoPrizeClient) QueryLotto(lp *LottoPrize) *LottoQuery {
	query := (&LottoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottoprize.Table, lottoprize.FieldID, id),
			sqlgraph.To(lotto.Table, lotto.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lottoprize.LottoTable, lottoprize.LottoColumn),
		)
		fromV = sqlgraph.Neighbors(lp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLottoRecords queries the lotto_records edge of a LottoPrize.
func (c *LottoPrizeClient) QueryLottoRecords(lp *LottoPrize) *LottoRecordQuery {
	query := (&LottoRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottoprize.Table, lottoprize.FieldID, id),
			sqlgraph.To(lottorecord.Table, lottorecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lottoprize.LottoRecordsTable, lottoprize.LottoRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(lp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LottoPrizeClient) Hooks() []Hook {
	return c.hooks.LottoPrize
}

// Interceptors returns the client interceptors.
func (c *LottoPrizeClient) Interceptors() []Interceptor {
	return c.inters.LottoPrize
}

func (c *LottoPrizeClient) mutate(ctx context.Context, m *LottoPrizeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LottoPrizeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LottoPrizeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LottoPrizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LottoPrizeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown LottoPrize mutation op: %q", m.Op())
	}
}

// LottoRecordClient is a client for the LottoRecord schema.
type LottoRecordClient struct {
	config
}

// NewLottoRecordClient returns a client for the LottoRecord from the given config.
func NewLottoRecordClient(c config) *LottoRecordClient {
	return &LottoRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lottorecord.Hooks(f(g(h())))`.
func (c *LottoRecordClient) Use(hooks ...Hook) {
	c.hooks.LottoRecord = append(c.hooks.LottoRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lottorecord.Intercept(f(g(h())))`.
func (c *LottoRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.LottoRecord = append(c.inters.LottoRecord, interceptors...)
}

// Create returns a builder for creating a LottoRecord entity.
func (c *LottoRecordClient) Create() *LottoRecordCreate {
	mutation := newLottoRecordMutation(c.config, OpCreate)
	return &LottoRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LottoRecord entities.
func (c *LottoRecordClient) CreateBulk(builders ...*LottoRecordCreate) *LottoRecordCreateBulk {
	return &LottoRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LottoRecordClient) MapCreateBulk(slice any, setFunc func(*LottoRecordCreate, int)) *LottoRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LottoRecordCreateBulk{err: fmt.Errorf("calling to LottoRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LottoRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LottoRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LottoRecord.
func (c *LottoRecordClient) Update() *LottoRecordUpdate {
	mutation := newLottoRecordMutation(c.config, OpUpdate)
	return &LottoRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LottoRecordClient) UpdateOne(lr *LottoRecord) *LottoRecordUpdateOne {
	mutation := newLottoRecordMutation(c.config, OpUpdateOne, withLottoRecord(lr))
	return &LottoRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LottoRecordClient) UpdateOneID(id int64) *LottoRecordUpdateOne {
	mutation := newLottoRecordMutation(c.config, OpUpdateOne, withLottoRecordID(id))
	return &LottoRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LottoRecord.
func (c *LottoRecordClient) Delete() *LottoRecordDelete {
	mutation := newLottoRecordMutation(c.config, OpDelete)
	return &LottoRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LottoRecordClient) DeleteOne(lr *LottoRecord) *LottoRecordDeleteOne {
	return c.DeleteOneID(lr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LottoRecordClient) DeleteOneID(id int64) *LottoRecordDeleteOne {
	builder := c.Delete().Where(lottorecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LottoRecordDeleteOne{builder}
}

// Query returns a query builder for LottoRecord.
func (c *LottoRecordClient) Query() *LottoRecordQuery {
	return &LottoRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLottoRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a LottoRecord entity by its id.
func (c *LottoRecordClient) Get(ctx context.Context, id int64) (*LottoRecord, error) {
	return c.Query().Where(lottorecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LottoRecordClient) GetX(ctx context.Context, id int64) *LottoRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LottoRecord.
func (c *LottoRecordClient) QueryUser(lr *LottoRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottorecord.Table, lottorecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lottorecord.UserTable, lottorecord.UserColumn),
		)
		fromV = sqlgraph.Neighbors(lr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLotto queries the lotto edge of a LottoRecord.
func (c *LottoRecordClient) QueryLotto(lr *LottoRecord) *LottoQuery {
	query := (&LottoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottorecord.Table, lottorecord.FieldID, id),
			sqlgraph.To(lotto.Table, lotto.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lottorecord.LottoTable, lottorecord.LottoColumn),
		)
		fromV = sqlgraph.Neighbors(lr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLottoPrize queries the lotto_prize edge of a LottoRecord.
func (c *LottoRecordClient) QueryLottoPrize(lr *LottoRecord) *LottoPrizeQuery {
	query := (&LottoPrizeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottorecord.Table, lottorecord.FieldID, id),
			sqlgraph.To(lottoprize.Table, lottoprize.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lottorecord.LottoPrizeTable, lottorecord.LottoPrizeColumn),
		)
		fromV = sqlgraph.Neighbors(lr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LottoRecordClient) Hooks() []Hook {
	return c.hooks.LottoRecord
}

// Interceptors returns the client interceptors.
func (c *LottoRecordClient) Interceptors() []Interceptor {
	return c.inters.LottoRecord
}

func (c *LottoRecordClient) mutate(ctx context.Context, m *LottoRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LottoRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LottoRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LottoRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LottoRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown LottoRecord mutation op: %q", m.Op())
	}
}

// LottoUserCountClient is a client for the LottoUserCount schema.
type LottoUserCountClient struct {
	config
}

// NewLottoUserCountClient returns a client for the LottoUserCount from the given config.
func NewLottoUserCountClient(c config) *LottoUserCountClient {
	return &LottoUserCountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lottousercount.Hooks(f(g(h())))`.
func (c *LottoUserCountClient) Use(hooks ...Hook) {
	c.hooks.LottoUserCount = append(c.hooks.LottoUserCount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lottousercount.Intercept(f(g(h())))`.
func (c *LottoUserCountClient) Intercept(interceptors ...Interceptor) {
	c.inters.LottoUserCount = append(c.inters.LottoUserCount, interceptors...)
}

// Create returns a builder for creating a LottoUserCount entity.
func (c *LottoUserCountClient) Create() *LottoUserCountCreate {
	mutation := newLottoUserCountMutation(c.config, OpCreate)
	return &LottoUserCountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LottoUserCount entities.
func (c *LottoUserCountClient) CreateBulk(builders ...*LottoUserCountCreate) *LottoUserCountCreateBulk {
	return &LottoUserCountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LottoUserCountClient) MapCreateBulk(slice any, setFunc func(*LottoUserCountCreate, int)) *LottoUserCountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LottoUserCountCreateBulk{err: fmt.Errorf("calling to LottoUserCountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LottoUserCountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LottoUserCountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LottoUserCount.
func (c *LottoUserCountClient) Update() *LottoUserCountUpdate {
	mutation := newLottoUserCountMutation(c.config, OpUpdate)
	return &LottoUserCountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LottoUserCountClient) UpdateOne(luc *LottoUserCount) *LottoUserCountUpdateOne {
	mutation := newLottoUserCountMutation(c.config, OpUpdateOne, withLottoUserCount(luc))
	return &LottoUserCountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LottoUserCountClient) UpdateOneID(id int64) *LottoUserCountUpdateOne {
	mutation := newLottoUserCountMutation(c.config, OpUpdateOne, withLottoUserCountID(id))
	return &LottoUserCountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LottoUserCount.
func (c *LottoUserCountClient) Delete() *LottoUserCountDelete {
	mutation := newLottoUserCountMutation(c.config, OpDelete)
	return &LottoUserCountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LottoUserCountClient) DeleteOne(luc *LottoUserCount) *LottoUserCountDeleteOne {
	return c.DeleteOneID(luc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LottoUserCountClient) DeleteOneID(id int64) *LottoUserCountDeleteOne {
	builder := c.Delete().Where(lottousercount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LottoUserCountDeleteOne{builder}
}

// Query returns a query builder for LottoUserCount.
func (c *LottoUserCountClient) Query() *LottoUserCountQuery {
	return &LottoUserCountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLottoUserCount},
		inters: c.Interceptors(),
	}
}

// Get returns a LottoUserCount entity by its id.
func (c *LottoUserCountClient) Get(ctx context.Context, id int64) (*LottoUserCount, error) {
	return c.Query().Where(lottousercount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LottoUserCountClient) GetX(ctx context.Context, id int64) *LottoUserCount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LottoUserCount.
func (c *LottoUserCountClient) QueryUser(luc *LottoUserCount) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := luc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottousercount.Table, lottousercount.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lottousercount.UserTable, lottousercount.UserColumn),
		)
		fromV = sqlgraph.Neighbors(luc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLotto queries the lotto edge of a LottoUserCount.
func (c *LottoUserCountClient) QueryLotto(luc *LottoUserCount) *LottoQuery {
	query := (&LottoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := luc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lottousercount.Table, lottousercount.FieldID, id),
			sqlgraph.To(lotto.Table, lotto.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lottousercount.LottoTable, lottousercount.LottoColumn),
		)
		fromV = sqlgraph.Neighbors(luc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LottoUserCountClient) Hooks() []Hook {
	return c.hooks.LottoUserCount
}

// Interceptors returns the client interceptors.
func (c *LottoUserCountClient) Interceptors() []Interceptor {
	return c.inters.LottoUserCount
}

func (c *LottoUserCountClient) mutate(ctx context.Context, m *LottoUserCountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LottoUserCountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LottoUserCountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LottoUserCountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LottoUserCountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown LottoUserCount mutation op: %q", m.Op())
	}
}

// MissionClient is a client for the Mission schema.
type MissionClient struct {
	config
}

// NewMissionClient returns a client for the Mission from the given config.
func NewMissionClient(c config) *MissionClient {
	return &MissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mission.Hooks(f(g(h())))`.
func (c *MissionClient) Use(hooks ...Hook) {
	c.hooks.Mission = append(c.hooks.Mission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mission.Intercept(f(g(h())))`.
func (c *MissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Mission = append(c.inters.Mission, interceptors...)
}

// Create returns a builder for creating a Mission entity.
func (c *MissionClient) Create() *MissionCreate {
	mutation := newMissionMutation(c.config, OpCreate)
	return &MissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Mission entities.
func (c *MissionClient) CreateBulk(builders ...*MissionCreate) *MissionCreateBulk {
	return &MissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionClient) MapCreateBulk(slice any, setFunc func(*MissionCreate, int)) *MissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionCreateBulk{err: fmt.Errorf("calling to MissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Mission.
func (c *MissionClient) Update() *MissionUpdate {
	mutation := newMissionMutation(c.config, OpUpdate)
	return &MissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionClient) UpdateOne(m *Mission) *MissionUpdateOne {
	mutation := newMissionMutation(c.config, OpUpdateOne, withMission(m))
	return &MissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionClient) UpdateOneID(id int64) *MissionUpdateOne {
	mutation := newMissionMutation(c.config, OpUpdateOne, withMissionID(id))
	return &MissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Mission.
func (c *MissionClient) Delete() *MissionDelete {
	mutation := newMissionMutation(c.config, OpDelete)
	return &MissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionClient) DeleteOne(m *Mission) *MissionDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionClient) DeleteOneID(id int64) *MissionDeleteOne {
	builder := c.Delete().Where(mission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionDeleteOne{builder}
}

// Query returns a query builder for Mission.
func (c *MissionClient) Query() *MissionQuery {
	return &MissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMission},
		inters: c.Interceptors(),
	}
}

// Get returns a Mission entity by its id.
func (c *MissionClient) Get(ctx context.Context, id int64) (*Mission, error) {
	return c.Query().Where(mission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionClient) GetX(ctx context.Context, id int64) *Mission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMissionKind queries the mission_kind edge of a Mission.
func (c *MissionClient) QueryMissionKind(m *Mission) *MissionKindQuery {
	query := (&MissionKindClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionkind.Table, missionkind.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mission.MissionKindTable, mission.MissionKindColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Mission.
func (c *MissionClient) QueryUser(m *Mission) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mission.UserTable, mission.UserColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionKeyPairs queries the mission_key_pairs edge of a Mission.
func (c *MissionClient) QueryMissionKeyPairs(m *Mission) *MissionKeyPairQuery {
	query := (&MissionKeyPairClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionkeypair.Table, missionkeypair.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.MissionKeyPairsTable, mission.MissionKeyPairsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryKeyPair queries the key_pair edge of a Mission.
func (c *MissionClient) QueryKeyPair(m *Mission) *HmacKeyPairQuery {
	query := (&HmacKeyPairClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(hmackeypair.Table, hmackeypair.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mission.KeyPairTable, mission.KeyPairColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrder queries the mission_consume_order edge of a Mission.
func (c *MissionClient) QueryMissionConsumeOrder(m *Mission) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, mission.MissionConsumeOrderTable, mission.MissionConsumeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a Mission.
func (c *MissionClient) QueryMissionProduceOrders(m *Mission) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.MissionProduceOrdersTable, mission.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionBatch queries the mission_batch edge of a Mission.
func (c *MissionClient) QueryMissionBatch(m *Mission) *MissionBatchQuery {
	query := (&MissionBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionbatch.Table, missionbatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mission.MissionBatchTable, mission.MissionBatchColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProductions queries the mission_productions edge of a Mission.
func (c *MissionClient) QueryMissionProductions(m *Mission) *MissionProductionQuery {
	query := (&MissionProductionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionproduction.Table, missionproduction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.MissionProductionsTable, mission.MissionProductionsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrders queries the mission_orders edge of a Mission.
func (c *MissionClient) QueryMissionOrders(m *Mission) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.MissionOrdersTable, mission.MissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRenewalAgreements queries the renewal_agreements edge of a Mission.
func (c *MissionClient) QueryRenewalAgreements(m *Mission) *RenewalAgreementQuery {
	query := (&RenewalAgreementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(renewalagreement.Table, renewalagreement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.RenewalAgreementsTable, mission.RenewalAgreementsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionExtraServices queries the mission_extra_services edge of a Mission.
func (c *MissionClient) QueryMissionExtraServices(m *Mission) *MissionExtraServiceQuery {
	query := (&MissionExtraServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionextraservice.Table, missionextraservice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.MissionExtraServicesTable, mission.MissionExtraServicesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtraServices queries the extra_services edge of a Mission.
func (c *MissionClient) QueryExtraServices(m *Mission) *ExtraServiceQuery {
	query := (&ExtraServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(extraservice.Table, extraservice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.ExtraServicesTable, mission.ExtraServicesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtraServiceOrders queries the extra_service_orders edge of a Mission.
func (c *MissionClient) QueryExtraServiceOrders(m *Mission) *ExtraServiceOrderQuery {
	query := (&ExtraServiceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(extraserviceorder.Table, extraserviceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.ExtraServiceOrdersTable, mission.ExtraServiceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionClient) Hooks() []Hook {
	return c.hooks.Mission
}

// Interceptors returns the client interceptors.
func (c *MissionClient) Interceptors() []Interceptor {
	return c.inters.Mission
}

func (c *MissionClient) mutate(ctx context.Context, m *MissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Mission mutation op: %q", m.Op())
	}
}

// MissionBatchClient is a client for the MissionBatch schema.
type MissionBatchClient struct {
	config
}

// NewMissionBatchClient returns a client for the MissionBatch from the given config.
func NewMissionBatchClient(c config) *MissionBatchClient {
	return &MissionBatchClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionbatch.Hooks(f(g(h())))`.
func (c *MissionBatchClient) Use(hooks ...Hook) {
	c.hooks.MissionBatch = append(c.hooks.MissionBatch, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionbatch.Intercept(f(g(h())))`.
func (c *MissionBatchClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionBatch = append(c.inters.MissionBatch, interceptors...)
}

// Create returns a builder for creating a MissionBatch entity.
func (c *MissionBatchClient) Create() *MissionBatchCreate {
	mutation := newMissionBatchMutation(c.config, OpCreate)
	return &MissionBatchCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionBatch entities.
func (c *MissionBatchClient) CreateBulk(builders ...*MissionBatchCreate) *MissionBatchCreateBulk {
	return &MissionBatchCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionBatchClient) MapCreateBulk(slice any, setFunc func(*MissionBatchCreate, int)) *MissionBatchCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionBatchCreateBulk{err: fmt.Errorf("calling to MissionBatchClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionBatchCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionBatchCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionBatch.
func (c *MissionBatchClient) Update() *MissionBatchUpdate {
	mutation := newMissionBatchMutation(c.config, OpUpdate)
	return &MissionBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionBatchClient) UpdateOne(mb *MissionBatch) *MissionBatchUpdateOne {
	mutation := newMissionBatchMutation(c.config, OpUpdateOne, withMissionBatch(mb))
	return &MissionBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionBatchClient) UpdateOneID(id int64) *MissionBatchUpdateOne {
	mutation := newMissionBatchMutation(c.config, OpUpdateOne, withMissionBatchID(id))
	return &MissionBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionBatch.
func (c *MissionBatchClient) Delete() *MissionBatchDelete {
	mutation := newMissionBatchMutation(c.config, OpDelete)
	return &MissionBatchDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionBatchClient) DeleteOne(mb *MissionBatch) *MissionBatchDeleteOne {
	return c.DeleteOneID(mb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionBatchClient) DeleteOneID(id int64) *MissionBatchDeleteOne {
	builder := c.Delete().Where(missionbatch.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionBatchDeleteOne{builder}
}

// Query returns a query builder for MissionBatch.
func (c *MissionBatchClient) Query() *MissionBatchQuery {
	return &MissionBatchQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionBatch},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionBatch entity by its id.
func (c *MissionBatchClient) Get(ctx context.Context, id int64) (*MissionBatch, error) {
	return c.Query().Where(missionbatch.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionBatchClient) GetX(ctx context.Context, id int64) *MissionBatch {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MissionBatch.
func (c *MissionBatchClient) QueryUser(mb *MissionBatch) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionbatch.Table, missionbatch.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionbatch.UserTable, missionbatch.UserColumn),
		)
		fromV = sqlgraph.Neighbors(mb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrders queries the mission_consume_orders edge of a MissionBatch.
func (c *MissionBatchClient) QueryMissionConsumeOrders(mb *MissionBatch) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionbatch.Table, missionbatch.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionbatch.MissionConsumeOrdersTable, missionbatch.MissionConsumeOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(mb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissions queries the missions edge of a MissionBatch.
func (c *MissionBatchClient) QueryMissions(mb *MissionBatch) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionbatch.Table, missionbatch.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionbatch.MissionsTable, missionbatch.MissionsColumn),
		)
		fromV = sqlgraph.Neighbors(mb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrders queries the mission_orders edge of a MissionBatch.
func (c *MissionBatchClient) QueryMissionOrders(mb *MissionBatch) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionbatch.Table, missionbatch.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionbatch.MissionOrdersTable, missionbatch.MissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(mb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtraServiceOrder queries the extra_service_order edge of a MissionBatch.
func (c *MissionBatchClient) QueryExtraServiceOrder(mb *MissionBatch) *ExtraServiceOrderQuery {
	query := (&ExtraServiceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionbatch.Table, missionbatch.FieldID, id),
			sqlgraph.To(extraserviceorder.Table, extraserviceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionbatch.ExtraServiceOrderTable, missionbatch.ExtraServiceOrderColumn),
		)
		fromV = sqlgraph.Neighbors(mb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionBatchClient) Hooks() []Hook {
	return c.hooks.MissionBatch
}

// Interceptors returns the client interceptors.
func (c *MissionBatchClient) Interceptors() []Interceptor {
	return c.inters.MissionBatch
}

func (c *MissionBatchClient) mutate(ctx context.Context, m *MissionBatchMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionBatchCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionBatchDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionBatch mutation op: %q", m.Op())
	}
}

// MissionCategoryClient is a client for the MissionCategory schema.
type MissionCategoryClient struct {
	config
}

// NewMissionCategoryClient returns a client for the MissionCategory from the given config.
func NewMissionCategoryClient(c config) *MissionCategoryClient {
	return &MissionCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missioncategory.Hooks(f(g(h())))`.
func (c *MissionCategoryClient) Use(hooks ...Hook) {
	c.hooks.MissionCategory = append(c.hooks.MissionCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missioncategory.Intercept(f(g(h())))`.
func (c *MissionCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionCategory = append(c.inters.MissionCategory, interceptors...)
}

// Create returns a builder for creating a MissionCategory entity.
func (c *MissionCategoryClient) Create() *MissionCategoryCreate {
	mutation := newMissionCategoryMutation(c.config, OpCreate)
	return &MissionCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionCategory entities.
func (c *MissionCategoryClient) CreateBulk(builders ...*MissionCategoryCreate) *MissionCategoryCreateBulk {
	return &MissionCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionCategoryClient) MapCreateBulk(slice any, setFunc func(*MissionCategoryCreate, int)) *MissionCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionCategoryCreateBulk{err: fmt.Errorf("calling to MissionCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionCategory.
func (c *MissionCategoryClient) Update() *MissionCategoryUpdate {
	mutation := newMissionCategoryMutation(c.config, OpUpdate)
	return &MissionCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionCategoryClient) UpdateOne(mc *MissionCategory) *MissionCategoryUpdateOne {
	mutation := newMissionCategoryMutation(c.config, OpUpdateOne, withMissionCategory(mc))
	return &MissionCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionCategoryClient) UpdateOneID(id int64) *MissionCategoryUpdateOne {
	mutation := newMissionCategoryMutation(c.config, OpUpdateOne, withMissionCategoryID(id))
	return &MissionCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionCategory.
func (c *MissionCategoryClient) Delete() *MissionCategoryDelete {
	mutation := newMissionCategoryMutation(c.config, OpDelete)
	return &MissionCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionCategoryClient) DeleteOne(mc *MissionCategory) *MissionCategoryDeleteOne {
	return c.DeleteOneID(mc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionCategoryClient) DeleteOneID(id int64) *MissionCategoryDeleteOne {
	builder := c.Delete().Where(missioncategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionCategoryDeleteOne{builder}
}

// Query returns a query builder for MissionCategory.
func (c *MissionCategoryClient) Query() *MissionCategoryQuery {
	return &MissionCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionCategory entity by its id.
func (c *MissionCategoryClient) Get(ctx context.Context, id int64) (*MissionCategory, error) {
	return c.Query().Where(missioncategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionCategoryClient) GetX(ctx context.Context, id int64) *MissionCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MissionCategoryClient) Hooks() []Hook {
	return c.hooks.MissionCategory
}

// Interceptors returns the client interceptors.
func (c *MissionCategoryClient) Interceptors() []Interceptor {
	return c.inters.MissionCategory
}

func (c *MissionCategoryClient) mutate(ctx context.Context, m *MissionCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionCategory mutation op: %q", m.Op())
	}
}

// MissionConsumeOrderClient is a client for the MissionConsumeOrder schema.
type MissionConsumeOrderClient struct {
	config
}

// NewMissionConsumeOrderClient returns a client for the MissionConsumeOrder from the given config.
func NewMissionConsumeOrderClient(c config) *MissionConsumeOrderClient {
	return &MissionConsumeOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionconsumeorder.Hooks(f(g(h())))`.
func (c *MissionConsumeOrderClient) Use(hooks ...Hook) {
	c.hooks.MissionConsumeOrder = append(c.hooks.MissionConsumeOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionconsumeorder.Intercept(f(g(h())))`.
func (c *MissionConsumeOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionConsumeOrder = append(c.inters.MissionConsumeOrder, interceptors...)
}

// Create returns a builder for creating a MissionConsumeOrder entity.
func (c *MissionConsumeOrderClient) Create() *MissionConsumeOrderCreate {
	mutation := newMissionConsumeOrderMutation(c.config, OpCreate)
	return &MissionConsumeOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionConsumeOrder entities.
func (c *MissionConsumeOrderClient) CreateBulk(builders ...*MissionConsumeOrderCreate) *MissionConsumeOrderCreateBulk {
	return &MissionConsumeOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionConsumeOrderClient) MapCreateBulk(slice any, setFunc func(*MissionConsumeOrderCreate, int)) *MissionConsumeOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionConsumeOrderCreateBulk{err: fmt.Errorf("calling to MissionConsumeOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionConsumeOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionConsumeOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionConsumeOrder.
func (c *MissionConsumeOrderClient) Update() *MissionConsumeOrderUpdate {
	mutation := newMissionConsumeOrderMutation(c.config, OpUpdate)
	return &MissionConsumeOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionConsumeOrderClient) UpdateOne(mco *MissionConsumeOrder) *MissionConsumeOrderUpdateOne {
	mutation := newMissionConsumeOrderMutation(c.config, OpUpdateOne, withMissionConsumeOrder(mco))
	return &MissionConsumeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionConsumeOrderClient) UpdateOneID(id int64) *MissionConsumeOrderUpdateOne {
	mutation := newMissionConsumeOrderMutation(c.config, OpUpdateOne, withMissionConsumeOrderID(id))
	return &MissionConsumeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionConsumeOrder.
func (c *MissionConsumeOrderClient) Delete() *MissionConsumeOrderDelete {
	mutation := newMissionConsumeOrderMutation(c.config, OpDelete)
	return &MissionConsumeOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionConsumeOrderClient) DeleteOne(mco *MissionConsumeOrder) *MissionConsumeOrderDeleteOne {
	return c.DeleteOneID(mco.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionConsumeOrderClient) DeleteOneID(id int64) *MissionConsumeOrderDeleteOne {
	builder := c.Delete().Where(missionconsumeorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionConsumeOrderDeleteOne{builder}
}

// Query returns a query builder for MissionConsumeOrder.
func (c *MissionConsumeOrderClient) Query() *MissionConsumeOrderQuery {
	return &MissionConsumeOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionConsumeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionConsumeOrder entity by its id.
func (c *MissionConsumeOrderClient) Get(ctx context.Context, id int64) (*MissionConsumeOrder, error) {
	return c.Query().Where(missionconsumeorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionConsumeOrderClient) GetX(ctx context.Context, id int64) *MissionConsumeOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryUser(mco *MissionConsumeOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionconsumeorder.UserTable, missionconsumeorder.UserColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryCostBills(mco *MissionConsumeOrder) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionconsumeorder.CostBillsTable, missionconsumeorder.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryMissionProduceOrders(mco *MissionConsumeOrder) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionconsumeorder.MissionProduceOrdersTable, missionconsumeorder.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionBatch queries the mission_batch edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryMissionBatch(mco *MissionConsumeOrder) *MissionBatchQuery {
	query := (&MissionBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(missionbatch.Table, missionbatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionconsumeorder.MissionBatchTable, missionconsumeorder.MissionBatchColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMission queries the mission edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryMission(mco *MissionConsumeOrder) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, missionconsumeorder.MissionTable, missionconsumeorder.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionConsumeOrderClient) Hooks() []Hook {
	return c.hooks.MissionConsumeOrder
}

// Interceptors returns the client interceptors.
func (c *MissionConsumeOrderClient) Interceptors() []Interceptor {
	return c.inters.MissionConsumeOrder
}

func (c *MissionConsumeOrderClient) mutate(ctx context.Context, m *MissionConsumeOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionConsumeOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionConsumeOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionConsumeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionConsumeOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionConsumeOrder mutation op: %q", m.Op())
	}
}

// MissionExtraServiceClient is a client for the MissionExtraService schema.
type MissionExtraServiceClient struct {
	config
}

// NewMissionExtraServiceClient returns a client for the MissionExtraService from the given config.
func NewMissionExtraServiceClient(c config) *MissionExtraServiceClient {
	return &MissionExtraServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionextraservice.Hooks(f(g(h())))`.
func (c *MissionExtraServiceClient) Use(hooks ...Hook) {
	c.hooks.MissionExtraService = append(c.hooks.MissionExtraService, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionextraservice.Intercept(f(g(h())))`.
func (c *MissionExtraServiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionExtraService = append(c.inters.MissionExtraService, interceptors...)
}

// Create returns a builder for creating a MissionExtraService entity.
func (c *MissionExtraServiceClient) Create() *MissionExtraServiceCreate {
	mutation := newMissionExtraServiceMutation(c.config, OpCreate)
	return &MissionExtraServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionExtraService entities.
func (c *MissionExtraServiceClient) CreateBulk(builders ...*MissionExtraServiceCreate) *MissionExtraServiceCreateBulk {
	return &MissionExtraServiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionExtraServiceClient) MapCreateBulk(slice any, setFunc func(*MissionExtraServiceCreate, int)) *MissionExtraServiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionExtraServiceCreateBulk{err: fmt.Errorf("calling to MissionExtraServiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionExtraServiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionExtraServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionExtraService.
func (c *MissionExtraServiceClient) Update() *MissionExtraServiceUpdate {
	mutation := newMissionExtraServiceMutation(c.config, OpUpdate)
	return &MissionExtraServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionExtraServiceClient) UpdateOne(mes *MissionExtraService) *MissionExtraServiceUpdateOne {
	mutation := newMissionExtraServiceMutation(c.config, OpUpdateOne, withMissionExtraService(mes))
	return &MissionExtraServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionExtraServiceClient) UpdateOneID(id int64) *MissionExtraServiceUpdateOne {
	mutation := newMissionExtraServiceMutation(c.config, OpUpdateOne, withMissionExtraServiceID(id))
	return &MissionExtraServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionExtraService.
func (c *MissionExtraServiceClient) Delete() *MissionExtraServiceDelete {
	mutation := newMissionExtraServiceMutation(c.config, OpDelete)
	return &MissionExtraServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionExtraServiceClient) DeleteOne(mes *MissionExtraService) *MissionExtraServiceDeleteOne {
	return c.DeleteOneID(mes.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionExtraServiceClient) DeleteOneID(id int64) *MissionExtraServiceDeleteOne {
	builder := c.Delete().Where(missionextraservice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionExtraServiceDeleteOne{builder}
}

// Query returns a query builder for MissionExtraService.
func (c *MissionExtraServiceClient) Query() *MissionExtraServiceQuery {
	return &MissionExtraServiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionExtraService},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionExtraService entity by its id.
func (c *MissionExtraServiceClient) Get(ctx context.Context, id int64) (*MissionExtraService, error) {
	return c.Query().Where(missionextraservice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionExtraServiceClient) GetX(ctx context.Context, id int64) *MissionExtraService {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMission queries the mission edge of a MissionExtraService.
func (c *MissionExtraServiceClient) QueryMission(mes *MissionExtraService) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mes.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionextraservice.Table, missionextraservice.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionextraservice.MissionTable, missionextraservice.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(mes.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtraService queries the extra_service edge of a MissionExtraService.
func (c *MissionExtraServiceClient) QueryExtraService(mes *MissionExtraService) *ExtraServiceQuery {
	query := (&ExtraServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mes.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionextraservice.Table, missionextraservice.FieldID, id),
			sqlgraph.To(extraservice.Table, extraservice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionextraservice.ExtraServiceTable, missionextraservice.ExtraServiceColumn),
		)
		fromV = sqlgraph.Neighbors(mes.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionExtraServiceClient) Hooks() []Hook {
	return c.hooks.MissionExtraService
}

// Interceptors returns the client interceptors.
func (c *MissionExtraServiceClient) Interceptors() []Interceptor {
	return c.inters.MissionExtraService
}

func (c *MissionExtraServiceClient) mutate(ctx context.Context, m *MissionExtraServiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionExtraServiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionExtraServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionExtraServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionExtraServiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionExtraService mutation op: %q", m.Op())
	}
}

// MissionKeyPairClient is a client for the MissionKeyPair schema.
type MissionKeyPairClient struct {
	config
}

// NewMissionKeyPairClient returns a client for the MissionKeyPair from the given config.
func NewMissionKeyPairClient(c config) *MissionKeyPairClient {
	return &MissionKeyPairClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionkeypair.Hooks(f(g(h())))`.
func (c *MissionKeyPairClient) Use(hooks ...Hook) {
	c.hooks.MissionKeyPair = append(c.hooks.MissionKeyPair, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionkeypair.Intercept(f(g(h())))`.
func (c *MissionKeyPairClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionKeyPair = append(c.inters.MissionKeyPair, interceptors...)
}

// Create returns a builder for creating a MissionKeyPair entity.
func (c *MissionKeyPairClient) Create() *MissionKeyPairCreate {
	mutation := newMissionKeyPairMutation(c.config, OpCreate)
	return &MissionKeyPairCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionKeyPair entities.
func (c *MissionKeyPairClient) CreateBulk(builders ...*MissionKeyPairCreate) *MissionKeyPairCreateBulk {
	return &MissionKeyPairCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionKeyPairClient) MapCreateBulk(slice any, setFunc func(*MissionKeyPairCreate, int)) *MissionKeyPairCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionKeyPairCreateBulk{err: fmt.Errorf("calling to MissionKeyPairClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionKeyPairCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionKeyPairCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionKeyPair.
func (c *MissionKeyPairClient) Update() *MissionKeyPairUpdate {
	mutation := newMissionKeyPairMutation(c.config, OpUpdate)
	return &MissionKeyPairUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionKeyPairClient) UpdateOne(mkp *MissionKeyPair) *MissionKeyPairUpdateOne {
	mutation := newMissionKeyPairMutation(c.config, OpUpdateOne, withMissionKeyPair(mkp))
	return &MissionKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionKeyPairClient) UpdateOneID(id int64) *MissionKeyPairUpdateOne {
	mutation := newMissionKeyPairMutation(c.config, OpUpdateOne, withMissionKeyPairID(id))
	return &MissionKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionKeyPair.
func (c *MissionKeyPairClient) Delete() *MissionKeyPairDelete {
	mutation := newMissionKeyPairMutation(c.config, OpDelete)
	return &MissionKeyPairDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionKeyPairClient) DeleteOne(mkp *MissionKeyPair) *MissionKeyPairDeleteOne {
	return c.DeleteOneID(mkp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionKeyPairClient) DeleteOneID(id int64) *MissionKeyPairDeleteOne {
	builder := c.Delete().Where(missionkeypair.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionKeyPairDeleteOne{builder}
}

// Query returns a query builder for MissionKeyPair.
func (c *MissionKeyPairClient) Query() *MissionKeyPairQuery {
	return &MissionKeyPairQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionKeyPair},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionKeyPair entity by its id.
func (c *MissionKeyPairClient) Get(ctx context.Context, id int64) (*MissionKeyPair, error) {
	return c.Query().Where(missionkeypair.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionKeyPairClient) GetX(ctx context.Context, id int64) *MissionKeyPair {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMission queries the mission edge of a MissionKeyPair.
func (c *MissionKeyPairClient) QueryMission(mkp *MissionKeyPair) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mkp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionkeypair.Table, missionkeypair.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionkeypair.MissionTable, missionkeypair.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(mkp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryKeyPair queries the key_pair edge of a MissionKeyPair.
func (c *MissionKeyPairClient) QueryKeyPair(mkp *MissionKeyPair) *HmacKeyPairQuery {
	query := (&HmacKeyPairClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mkp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionkeypair.Table, missionkeypair.FieldID, id),
			sqlgraph.To(hmackeypair.Table, hmackeypair.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionkeypair.KeyPairTable, missionkeypair.KeyPairColumn),
		)
		fromV = sqlgraph.Neighbors(mkp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionKeyPairClient) Hooks() []Hook {
	return c.hooks.MissionKeyPair
}

// Interceptors returns the client interceptors.
func (c *MissionKeyPairClient) Interceptors() []Interceptor {
	return c.inters.MissionKeyPair
}

func (c *MissionKeyPairClient) mutate(ctx context.Context, m *MissionKeyPairMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionKeyPairCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionKeyPairUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionKeyPairDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionKeyPair mutation op: %q", m.Op())
	}
}

// MissionKindClient is a client for the MissionKind schema.
type MissionKindClient struct {
	config
}

// NewMissionKindClient returns a client for the MissionKind from the given config.
func NewMissionKindClient(c config) *MissionKindClient {
	return &MissionKindClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionkind.Hooks(f(g(h())))`.
func (c *MissionKindClient) Use(hooks ...Hook) {
	c.hooks.MissionKind = append(c.hooks.MissionKind, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionkind.Intercept(f(g(h())))`.
func (c *MissionKindClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionKind = append(c.inters.MissionKind, interceptors...)
}

// Create returns a builder for creating a MissionKind entity.
func (c *MissionKindClient) Create() *MissionKindCreate {
	mutation := newMissionKindMutation(c.config, OpCreate)
	return &MissionKindCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionKind entities.
func (c *MissionKindClient) CreateBulk(builders ...*MissionKindCreate) *MissionKindCreateBulk {
	return &MissionKindCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionKindClient) MapCreateBulk(slice any, setFunc func(*MissionKindCreate, int)) *MissionKindCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionKindCreateBulk{err: fmt.Errorf("calling to MissionKindClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionKindCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionKindCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionKind.
func (c *MissionKindClient) Update() *MissionKindUpdate {
	mutation := newMissionKindMutation(c.config, OpUpdate)
	return &MissionKindUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionKindClient) UpdateOne(mk *MissionKind) *MissionKindUpdateOne {
	mutation := newMissionKindMutation(c.config, OpUpdateOne, withMissionKind(mk))
	return &MissionKindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionKindClient) UpdateOneID(id int64) *MissionKindUpdateOne {
	mutation := newMissionKindMutation(c.config, OpUpdateOne, withMissionKindID(id))
	return &MissionKindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionKind.
func (c *MissionKindClient) Delete() *MissionKindDelete {
	mutation := newMissionKindMutation(c.config, OpDelete)
	return &MissionKindDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionKindClient) DeleteOne(mk *MissionKind) *MissionKindDeleteOne {
	return c.DeleteOneID(mk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionKindClient) DeleteOneID(id int64) *MissionKindDeleteOne {
	builder := c.Delete().Where(missionkind.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionKindDeleteOne{builder}
}

// Query returns a query builder for MissionKind.
func (c *MissionKindClient) Query() *MissionKindQuery {
	return &MissionKindQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionKind},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionKind entity by its id.
func (c *MissionKindClient) Get(ctx context.Context, id int64) (*MissionKind, error) {
	return c.Query().Where(missionkind.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionKindClient) GetX(ctx context.Context, id int64) *MissionKind {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMissions queries the missions edge of a MissionKind.
func (c *MissionKindClient) QueryMissions(mk *MissionKind) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionkind.Table, missionkind.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionkind.MissionsTable, missionkind.MissionsColumn),
		)
		fromV = sqlgraph.Neighbors(mk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionKindClient) Hooks() []Hook {
	return c.hooks.MissionKind
}

// Interceptors returns the client interceptors.
func (c *MissionKindClient) Interceptors() []Interceptor {
	return c.inters.MissionKind
}

func (c *MissionKindClient) mutate(ctx context.Context, m *MissionKindMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionKindCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionKindUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionKindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionKindDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionKind mutation op: %q", m.Op())
	}
}

// MissionOrderClient is a client for the MissionOrder schema.
type MissionOrderClient struct {
	config
}

// NewMissionOrderClient returns a client for the MissionOrder from the given config.
func NewMissionOrderClient(c config) *MissionOrderClient {
	return &MissionOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionorder.Hooks(f(g(h())))`.
func (c *MissionOrderClient) Use(hooks ...Hook) {
	c.hooks.MissionOrder = append(c.hooks.MissionOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionorder.Intercept(f(g(h())))`.
func (c *MissionOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionOrder = append(c.inters.MissionOrder, interceptors...)
}

// Create returns a builder for creating a MissionOrder entity.
func (c *MissionOrderClient) Create() *MissionOrderCreate {
	mutation := newMissionOrderMutation(c.config, OpCreate)
	return &MissionOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionOrder entities.
func (c *MissionOrderClient) CreateBulk(builders ...*MissionOrderCreate) *MissionOrderCreateBulk {
	return &MissionOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionOrderClient) MapCreateBulk(slice any, setFunc func(*MissionOrderCreate, int)) *MissionOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionOrderCreateBulk{err: fmt.Errorf("calling to MissionOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionOrder.
func (c *MissionOrderClient) Update() *MissionOrderUpdate {
	mutation := newMissionOrderMutation(c.config, OpUpdate)
	return &MissionOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionOrderClient) UpdateOne(mo *MissionOrder) *MissionOrderUpdateOne {
	mutation := newMissionOrderMutation(c.config, OpUpdateOne, withMissionOrder(mo))
	return &MissionOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionOrderClient) UpdateOneID(id int64) *MissionOrderUpdateOne {
	mutation := newMissionOrderMutation(c.config, OpUpdateOne, withMissionOrderID(id))
	return &MissionOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionOrder.
func (c *MissionOrderClient) Delete() *MissionOrderDelete {
	mutation := newMissionOrderMutation(c.config, OpDelete)
	return &MissionOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionOrderClient) DeleteOne(mo *MissionOrder) *MissionOrderDeleteOne {
	return c.DeleteOneID(mo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionOrderClient) DeleteOneID(id int64) *MissionOrderDeleteOne {
	builder := c.Delete().Where(missionorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionOrderDeleteOne{builder}
}

// Query returns a query builder for MissionOrder.
func (c *MissionOrderClient) Query() *MissionOrderQuery {
	return &MissionOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionOrder entity by its id.
func (c *MissionOrderClient) Get(ctx context.Context, id int64) (*MissionOrder, error) {
	return c.Query().Where(missionorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionOrderClient) GetX(ctx context.Context, id int64) *MissionOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConsumeUser queries the consume_user edge of a MissionOrder.
func (c *MissionOrderClient) QueryConsumeUser(mo *MissionOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.ConsumeUserTable, missionorder.ConsumeUserColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduceUser queries the produce_user edge of a MissionOrder.
func (c *MissionOrderClient) QueryProduceUser(mo *MissionOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.ProduceUserTable, missionorder.ProduceUserColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a MissionOrder.
func (c *MissionOrderClient) QuerySymbol(mo *MissionOrder) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.SymbolTable, missionorder.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBills queries the bills edge of a MissionOrder.
func (c *MissionOrderClient) QueryBills(mo *MissionOrder) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionorder.BillsTable, missionorder.BillsColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionBatch queries the mission_batch edge of a MissionOrder.
func (c *MissionOrderClient) QueryMissionBatch(mo *MissionOrder) *MissionBatchQuery {
	query := (&MissionBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(missionbatch.Table, missionbatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.MissionBatchTable, missionorder.MissionBatchColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMission queries the mission edge of a MissionOrder.
func (c *MissionOrderClient) QueryMission(mo *MissionOrder) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.MissionTable, missionorder.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a MissionOrder.
func (c *MissionOrderClient) QueryDevice(mo *MissionOrder) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.DeviceTable, missionorder.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtraServiceOrders queries the extra_service_orders edge of a MissionOrder.
func (c *MissionOrderClient) QueryExtraServiceOrders(mo *MissionOrder) *ExtraServiceOrderQuery {
	query := (&ExtraServiceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(extraserviceorder.Table, extraserviceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionorder.ExtraServiceOrdersTable, missionorder.ExtraServiceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionOrderClient) Hooks() []Hook {
	return c.hooks.MissionOrder
}

// Interceptors returns the client interceptors.
func (c *MissionOrderClient) Interceptors() []Interceptor {
	return c.inters.MissionOrder
}

func (c *MissionOrderClient) mutate(ctx context.Context, m *MissionOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionOrder mutation op: %q", m.Op())
	}
}

// MissionProduceOrderClient is a client for the MissionProduceOrder schema.
type MissionProduceOrderClient struct {
	config
}

// NewMissionProduceOrderClient returns a client for the MissionProduceOrder from the given config.
func NewMissionProduceOrderClient(c config) *MissionProduceOrderClient {
	return &MissionProduceOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionproduceorder.Hooks(f(g(h())))`.
func (c *MissionProduceOrderClient) Use(hooks ...Hook) {
	c.hooks.MissionProduceOrder = append(c.hooks.MissionProduceOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionproduceorder.Intercept(f(g(h())))`.
func (c *MissionProduceOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionProduceOrder = append(c.inters.MissionProduceOrder, interceptors...)
}

// Create returns a builder for creating a MissionProduceOrder entity.
func (c *MissionProduceOrderClient) Create() *MissionProduceOrderCreate {
	mutation := newMissionProduceOrderMutation(c.config, OpCreate)
	return &MissionProduceOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionProduceOrder entities.
func (c *MissionProduceOrderClient) CreateBulk(builders ...*MissionProduceOrderCreate) *MissionProduceOrderCreateBulk {
	return &MissionProduceOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionProduceOrderClient) MapCreateBulk(slice any, setFunc func(*MissionProduceOrderCreate, int)) *MissionProduceOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionProduceOrderCreateBulk{err: fmt.Errorf("calling to MissionProduceOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionProduceOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionProduceOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionProduceOrder.
func (c *MissionProduceOrderClient) Update() *MissionProduceOrderUpdate {
	mutation := newMissionProduceOrderMutation(c.config, OpUpdate)
	return &MissionProduceOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionProduceOrderClient) UpdateOne(mpo *MissionProduceOrder) *MissionProduceOrderUpdateOne {
	mutation := newMissionProduceOrderMutation(c.config, OpUpdateOne, withMissionProduceOrder(mpo))
	return &MissionProduceOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionProduceOrderClient) UpdateOneID(id int64) *MissionProduceOrderUpdateOne {
	mutation := newMissionProduceOrderMutation(c.config, OpUpdateOne, withMissionProduceOrderID(id))
	return &MissionProduceOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionProduceOrder.
func (c *MissionProduceOrderClient) Delete() *MissionProduceOrderDelete {
	mutation := newMissionProduceOrderMutation(c.config, OpDelete)
	return &MissionProduceOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionProduceOrderClient) DeleteOne(mpo *MissionProduceOrder) *MissionProduceOrderDeleteOne {
	return c.DeleteOneID(mpo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionProduceOrderClient) DeleteOneID(id int64) *MissionProduceOrderDeleteOne {
	builder := c.Delete().Where(missionproduceorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionProduceOrderDeleteOne{builder}
}

// Query returns a query builder for MissionProduceOrder.
func (c *MissionProduceOrderClient) Query() *MissionProduceOrderQuery {
	return &MissionProduceOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionProduceOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionProduceOrder entity by its id.
func (c *MissionProduceOrderClient) Get(ctx context.Context, id int64) (*MissionProduceOrder, error) {
	return c.Query().Where(missionproduceorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionProduceOrderClient) GetX(ctx context.Context, id int64) *MissionProduceOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryUser(mpo *MissionProduceOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduceorder.UserTable, missionproduceorder.UserColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEarnBills queries the earn_bills edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryEarnBills(mpo *MissionProduceOrder) *EarnBillQuery {
	query := (&EarnBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(earnbill.Table, earnbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionproduceorder.EarnBillsTable, missionproduceorder.EarnBillsColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryDevice(mpo *MissionProduceOrder) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduceorder.DeviceTable, missionproduceorder.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrder queries the mission_consume_order edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryMissionConsumeOrder(mpo *MissionProduceOrder) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduceorder.MissionConsumeOrderTable, missionproduceorder.MissionConsumeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduction queries the mission_production edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryMissionProduction(mpo *MissionProduceOrder) *MissionProductionQuery {
	query := (&MissionProductionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(missionproduction.Table, missionproduction.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, missionproduceorder.MissionProductionTable, missionproduceorder.MissionProductionColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionProduceOrderClient) Hooks() []Hook {
	return c.hooks.MissionProduceOrder
}

// Interceptors returns the client interceptors.
func (c *MissionProduceOrderClient) Interceptors() []Interceptor {
	return c.inters.MissionProduceOrder
}

func (c *MissionProduceOrderClient) mutate(ctx context.Context, m *MissionProduceOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionProduceOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionProduceOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionProduceOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionProduceOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionProduceOrder mutation op: %q", m.Op())
	}
}

// MissionProductionClient is a client for the MissionProduction schema.
type MissionProductionClient struct {
	config
}

// NewMissionProductionClient returns a client for the MissionProduction from the given config.
func NewMissionProductionClient(c config) *MissionProductionClient {
	return &MissionProductionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionproduction.Hooks(f(g(h())))`.
func (c *MissionProductionClient) Use(hooks ...Hook) {
	c.hooks.MissionProduction = append(c.hooks.MissionProduction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionproduction.Intercept(f(g(h())))`.
func (c *MissionProductionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionProduction = append(c.inters.MissionProduction, interceptors...)
}

// Create returns a builder for creating a MissionProduction entity.
func (c *MissionProductionClient) Create() *MissionProductionCreate {
	mutation := newMissionProductionMutation(c.config, OpCreate)
	return &MissionProductionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionProduction entities.
func (c *MissionProductionClient) CreateBulk(builders ...*MissionProductionCreate) *MissionProductionCreateBulk {
	return &MissionProductionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionProductionClient) MapCreateBulk(slice any, setFunc func(*MissionProductionCreate, int)) *MissionProductionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionProductionCreateBulk{err: fmt.Errorf("calling to MissionProductionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionProductionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionProductionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionProduction.
func (c *MissionProductionClient) Update() *MissionProductionUpdate {
	mutation := newMissionProductionMutation(c.config, OpUpdate)
	return &MissionProductionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionProductionClient) UpdateOne(mp *MissionProduction) *MissionProductionUpdateOne {
	mutation := newMissionProductionMutation(c.config, OpUpdateOne, withMissionProduction(mp))
	return &MissionProductionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionProductionClient) UpdateOneID(id int64) *MissionProductionUpdateOne {
	mutation := newMissionProductionMutation(c.config, OpUpdateOne, withMissionProductionID(id))
	return &MissionProductionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionProduction.
func (c *MissionProductionClient) Delete() *MissionProductionDelete {
	mutation := newMissionProductionMutation(c.config, OpDelete)
	return &MissionProductionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionProductionClient) DeleteOne(mp *MissionProduction) *MissionProductionDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionProductionClient) DeleteOneID(id int64) *MissionProductionDeleteOne {
	builder := c.Delete().Where(missionproduction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionProductionDeleteOne{builder}
}

// Query returns a query builder for MissionProduction.
func (c *MissionProductionClient) Query() *MissionProductionQuery {
	return &MissionProductionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionProduction},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionProduction entity by its id.
func (c *MissionProductionClient) Get(ctx context.Context, id int64) (*MissionProduction, error) {
	return c.Query().Where(missionproduction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionProductionClient) GetX(ctx context.Context, id int64) *MissionProduction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMission queries the mission edge of a MissionProduction.
func (c *MissionProductionClient) QueryMission(mp *MissionProduction) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduction.Table, missionproduction.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduction.MissionTable, missionproduction.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a MissionProduction.
func (c *MissionProductionClient) QueryUser(mp *MissionProduction) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduction.Table, missionproduction.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduction.UserTable, missionproduction.UserColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a MissionProduction.
func (c *MissionProductionClient) QueryDevice(mp *MissionProduction) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduction.Table, missionproduction.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduction.DeviceTable, missionproduction.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrder queries the mission_produce_order edge of a MissionProduction.
func (c *MissionProductionClient) QueryMissionProduceOrder(mp *MissionProduction) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduction.Table, missionproduction.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, missionproduction.MissionProduceOrderTable, missionproduction.MissionProduceOrderColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionProductionClient) Hooks() []Hook {
	return c.hooks.MissionProduction
}

// Interceptors returns the client interceptors.
func (c *MissionProductionClient) Interceptors() []Interceptor {
	return c.inters.MissionProduction
}

func (c *MissionProductionClient) mutate(ctx context.Context, m *MissionProductionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionProductionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionProductionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionProductionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionProductionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionProduction mutation op: %q", m.Op())
	}
}

// OutputLogClient is a client for the OutputLog schema.
type OutputLogClient struct {
	config
}

// NewOutputLogClient returns a client for the OutputLog from the given config.
func NewOutputLogClient(c config) *OutputLogClient {
	return &OutputLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `outputlog.Hooks(f(g(h())))`.
func (c *OutputLogClient) Use(hooks ...Hook) {
	c.hooks.OutputLog = append(c.hooks.OutputLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `outputlog.Intercept(f(g(h())))`.
func (c *OutputLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.OutputLog = append(c.inters.OutputLog, interceptors...)
}

// Create returns a builder for creating a OutputLog entity.
func (c *OutputLogClient) Create() *OutputLogCreate {
	mutation := newOutputLogMutation(c.config, OpCreate)
	return &OutputLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OutputLog entities.
func (c *OutputLogClient) CreateBulk(builders ...*OutputLogCreate) *OutputLogCreateBulk {
	return &OutputLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OutputLogClient) MapCreateBulk(slice any, setFunc func(*OutputLogCreate, int)) *OutputLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OutputLogCreateBulk{err: fmt.Errorf("calling to OutputLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OutputLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OutputLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OutputLog.
func (c *OutputLogClient) Update() *OutputLogUpdate {
	mutation := newOutputLogMutation(c.config, OpUpdate)
	return &OutputLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OutputLogClient) UpdateOne(ol *OutputLog) *OutputLogUpdateOne {
	mutation := newOutputLogMutation(c.config, OpUpdateOne, withOutputLog(ol))
	return &OutputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OutputLogClient) UpdateOneID(id int64) *OutputLogUpdateOne {
	mutation := newOutputLogMutation(c.config, OpUpdateOne, withOutputLogID(id))
	return &OutputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OutputLog.
func (c *OutputLogClient) Delete() *OutputLogDelete {
	mutation := newOutputLogMutation(c.config, OpDelete)
	return &OutputLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OutputLogClient) DeleteOne(ol *OutputLog) *OutputLogDeleteOne {
	return c.DeleteOneID(ol.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OutputLogClient) DeleteOneID(id int64) *OutputLogDeleteOne {
	builder := c.Delete().Where(outputlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OutputLogDeleteOne{builder}
}

// Query returns a query builder for OutputLog.
func (c *OutputLogClient) Query() *OutputLogQuery {
	return &OutputLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOutputLog},
		inters: c.Interceptors(),
	}
}

// Get returns a OutputLog entity by its id.
func (c *OutputLogClient) Get(ctx context.Context, id int64) (*OutputLog, error) {
	return c.Query().Where(outputlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OutputLogClient) GetX(ctx context.Context, id int64) *OutputLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OutputLogClient) Hooks() []Hook {
	return c.hooks.OutputLog
}

// Interceptors returns the client interceptors.
func (c *OutputLogClient) Interceptors() []Interceptor {
	return c.inters.OutputLog
}

func (c *OutputLogClient) mutate(ctx context.Context, m *OutputLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OutputLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OutputLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OutputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OutputLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown OutputLog mutation op: %q", m.Op())
	}
}

// PlatformAccountClient is a client for the PlatformAccount schema.
type PlatformAccountClient struct {
	config
}

// NewPlatformAccountClient returns a client for the PlatformAccount from the given config.
func NewPlatformAccountClient(c config) *PlatformAccountClient {
	return &PlatformAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `platformaccount.Hooks(f(g(h())))`.
func (c *PlatformAccountClient) Use(hooks ...Hook) {
	c.hooks.PlatformAccount = append(c.hooks.PlatformAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `platformaccount.Intercept(f(g(h())))`.
func (c *PlatformAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.PlatformAccount = append(c.inters.PlatformAccount, interceptors...)
}

// Create returns a builder for creating a PlatformAccount entity.
func (c *PlatformAccountClient) Create() *PlatformAccountCreate {
	mutation := newPlatformAccountMutation(c.config, OpCreate)
	return &PlatformAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlatformAccount entities.
func (c *PlatformAccountClient) CreateBulk(builders ...*PlatformAccountCreate) *PlatformAccountCreateBulk {
	return &PlatformAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlatformAccountClient) MapCreateBulk(slice any, setFunc func(*PlatformAccountCreate, int)) *PlatformAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlatformAccountCreateBulk{err: fmt.Errorf("calling to PlatformAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlatformAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlatformAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlatformAccount.
func (c *PlatformAccountClient) Update() *PlatformAccountUpdate {
	mutation := newPlatformAccountMutation(c.config, OpUpdate)
	return &PlatformAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlatformAccountClient) UpdateOne(pa *PlatformAccount) *PlatformAccountUpdateOne {
	mutation := newPlatformAccountMutation(c.config, OpUpdateOne, withPlatformAccount(pa))
	return &PlatformAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlatformAccountClient) UpdateOneID(id int64) *PlatformAccountUpdateOne {
	mutation := newPlatformAccountMutation(c.config, OpUpdateOne, withPlatformAccountID(id))
	return &PlatformAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlatformAccount.
func (c *PlatformAccountClient) Delete() *PlatformAccountDelete {
	mutation := newPlatformAccountMutation(c.config, OpDelete)
	return &PlatformAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlatformAccountClient) DeleteOne(pa *PlatformAccount) *PlatformAccountDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlatformAccountClient) DeleteOneID(id int64) *PlatformAccountDeleteOne {
	builder := c.Delete().Where(platformaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlatformAccountDeleteOne{builder}
}

// Query returns a query builder for PlatformAccount.
func (c *PlatformAccountClient) Query() *PlatformAccountQuery {
	return &PlatformAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlatformAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a PlatformAccount entity by its id.
func (c *PlatformAccountClient) Get(ctx context.Context, id int64) (*PlatformAccount, error) {
	return c.Query().Where(platformaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlatformAccountClient) GetX(ctx context.Context, id int64) *PlatformAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEarnBills queries the earn_bills edge of a PlatformAccount.
func (c *PlatformAccountClient) QueryEarnBills(pa *PlatformAccount) *EarnBillQuery {
	query := (&EarnBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(platformaccount.Table, platformaccount.FieldID, id),
			sqlgraph.To(earnbill.Table, earnbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, platformaccount.EarnBillsTable, platformaccount.EarnBillsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a PlatformAccount.
func (c *PlatformAccountClient) QueryCostBills(pa *PlatformAccount) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(platformaccount.Table, platformaccount.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, platformaccount.CostBillsTable, platformaccount.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlatformAccountClient) Hooks() []Hook {
	return c.hooks.PlatformAccount
}

// Interceptors returns the client interceptors.
func (c *PlatformAccountClient) Interceptors() []Interceptor {
	return c.inters.PlatformAccount
}

func (c *PlatformAccountClient) mutate(ctx context.Context, m *PlatformAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlatformAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlatformAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlatformAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlatformAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown PlatformAccount mutation op: %q", m.Op())
	}
}

// PriceClient is a client for the Price schema.
type PriceClient struct {
	config
}

// NewPriceClient returns a client for the Price from the given config.
func NewPriceClient(c config) *PriceClient {
	return &PriceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `price.Hooks(f(g(h())))`.
func (c *PriceClient) Use(hooks ...Hook) {
	c.hooks.Price = append(c.hooks.Price, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `price.Intercept(f(g(h())))`.
func (c *PriceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Price = append(c.inters.Price, interceptors...)
}

// Create returns a builder for creating a Price entity.
func (c *PriceClient) Create() *PriceCreate {
	mutation := newPriceMutation(c.config, OpCreate)
	return &PriceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Price entities.
func (c *PriceClient) CreateBulk(builders ...*PriceCreate) *PriceCreateBulk {
	return &PriceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PriceClient) MapCreateBulk(slice any, setFunc func(*PriceCreate, int)) *PriceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PriceCreateBulk{err: fmt.Errorf("calling to PriceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PriceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PriceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Price.
func (c *PriceClient) Update() *PriceUpdate {
	mutation := newPriceMutation(c.config, OpUpdate)
	return &PriceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PriceClient) UpdateOne(pr *Price) *PriceUpdateOne {
	mutation := newPriceMutation(c.config, OpUpdateOne, withPrice(pr))
	return &PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PriceClient) UpdateOneID(id int64) *PriceUpdateOne {
	mutation := newPriceMutation(c.config, OpUpdateOne, withPriceID(id))
	return &PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Price.
func (c *PriceClient) Delete() *PriceDelete {
	mutation := newPriceMutation(c.config, OpDelete)
	return &PriceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PriceClient) DeleteOne(pr *Price) *PriceDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PriceClient) DeleteOneID(id int64) *PriceDeleteOne {
	builder := c.Delete().Where(price.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PriceDeleteOne{builder}
}

// Query returns a query builder for Price.
func (c *PriceClient) Query() *PriceQuery {
	return &PriceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrice},
		inters: c.Interceptors(),
	}
}

// Get returns a Price entity by its id.
func (c *PriceClient) Get(ctx context.Context, id int64) (*Price, error) {
	return c.Query().Where(price.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PriceClient) GetX(ctx context.Context, id int64) *Price {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGpu queries the gpu edge of a Price.
func (c *PriceClient) QueryGpu(pr *Price) *GpuQuery {
	query := (&GpuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(price.Table, price.FieldID, id),
			sqlgraph.To(gpu.Table, gpu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, price.GpuTable, price.GpuColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PriceClient) Hooks() []Hook {
	return c.hooks.Price
}

// Interceptors returns the client interceptors.
func (c *PriceClient) Interceptors() []Interceptor {
	return c.inters.Price
}

func (c *PriceClient) mutate(ctx context.Context, m *PriceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PriceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PriceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PriceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Price mutation op: %q", m.Op())
	}
}

// ProfitAccountClient is a client for the ProfitAccount schema.
type ProfitAccountClient struct {
	config
}

// NewProfitAccountClient returns a client for the ProfitAccount from the given config.
func NewProfitAccountClient(c config) *ProfitAccountClient {
	return &ProfitAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profitaccount.Hooks(f(g(h())))`.
func (c *ProfitAccountClient) Use(hooks ...Hook) {
	c.hooks.ProfitAccount = append(c.hooks.ProfitAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profitaccount.Intercept(f(g(h())))`.
func (c *ProfitAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProfitAccount = append(c.inters.ProfitAccount, interceptors...)
}

// Create returns a builder for creating a ProfitAccount entity.
func (c *ProfitAccountClient) Create() *ProfitAccountCreate {
	mutation := newProfitAccountMutation(c.config, OpCreate)
	return &ProfitAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProfitAccount entities.
func (c *ProfitAccountClient) CreateBulk(builders ...*ProfitAccountCreate) *ProfitAccountCreateBulk {
	return &ProfitAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfitAccountClient) MapCreateBulk(slice any, setFunc func(*ProfitAccountCreate, int)) *ProfitAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfitAccountCreateBulk{err: fmt.Errorf("calling to ProfitAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfitAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfitAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProfitAccount.
func (c *ProfitAccountClient) Update() *ProfitAccountUpdate {
	mutation := newProfitAccountMutation(c.config, OpUpdate)
	return &ProfitAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfitAccountClient) UpdateOne(pa *ProfitAccount) *ProfitAccountUpdateOne {
	mutation := newProfitAccountMutation(c.config, OpUpdateOne, withProfitAccount(pa))
	return &ProfitAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfitAccountClient) UpdateOneID(id int64) *ProfitAccountUpdateOne {
	mutation := newProfitAccountMutation(c.config, OpUpdateOne, withProfitAccountID(id))
	return &ProfitAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProfitAccount.
func (c *ProfitAccountClient) Delete() *ProfitAccountDelete {
	mutation := newProfitAccountMutation(c.config, OpDelete)
	return &ProfitAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfitAccountClient) DeleteOne(pa *ProfitAccount) *ProfitAccountDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfitAccountClient) DeleteOneID(id int64) *ProfitAccountDeleteOne {
	builder := c.Delete().Where(profitaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfitAccountDeleteOne{builder}
}

// Query returns a query builder for ProfitAccount.
func (c *ProfitAccountClient) Query() *ProfitAccountQuery {
	return &ProfitAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfitAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a ProfitAccount entity by its id.
func (c *ProfitAccountClient) Get(ctx context.Context, id int64) (*ProfitAccount, error) {
	return c.Query().Where(profitaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfitAccountClient) GetX(ctx context.Context, id int64) *ProfitAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ProfitAccount.
func (c *ProfitAccountClient) QueryUser(pa *ProfitAccount) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profitaccount.Table, profitaccount.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, profitaccount.UserTable, profitaccount.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEarnBills queries the earn_bills edge of a ProfitAccount.
func (c *ProfitAccountClient) QueryEarnBills(pa *ProfitAccount) *EarnBillQuery {
	query := (&EarnBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profitaccount.Table, profitaccount.FieldID, id),
			sqlgraph.To(earnbill.Table, earnbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profitaccount.EarnBillsTable, profitaccount.EarnBillsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfitAccountClient) Hooks() []Hook {
	return c.hooks.ProfitAccount
}

// Interceptors returns the client interceptors.
func (c *ProfitAccountClient) Interceptors() []Interceptor {
	return c.inters.ProfitAccount
}

func (c *ProfitAccountClient) mutate(ctx context.Context, m *ProfitAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfitAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfitAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfitAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfitAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown ProfitAccount mutation op: %q", m.Op())
	}
}

// ProfitSettingClient is a client for the ProfitSetting schema.
type ProfitSettingClient struct {
	config
}

// NewProfitSettingClient returns a client for the ProfitSetting from the given config.
func NewProfitSettingClient(c config) *ProfitSettingClient {
	return &ProfitSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profitsetting.Hooks(f(g(h())))`.
func (c *ProfitSettingClient) Use(hooks ...Hook) {
	c.hooks.ProfitSetting = append(c.hooks.ProfitSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profitsetting.Intercept(f(g(h())))`.
func (c *ProfitSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProfitSetting = append(c.inters.ProfitSetting, interceptors...)
}

// Create returns a builder for creating a ProfitSetting entity.
func (c *ProfitSettingClient) Create() *ProfitSettingCreate {
	mutation := newProfitSettingMutation(c.config, OpCreate)
	return &ProfitSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProfitSetting entities.
func (c *ProfitSettingClient) CreateBulk(builders ...*ProfitSettingCreate) *ProfitSettingCreateBulk {
	return &ProfitSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfitSettingClient) MapCreateBulk(slice any, setFunc func(*ProfitSettingCreate, int)) *ProfitSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfitSettingCreateBulk{err: fmt.Errorf("calling to ProfitSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfitSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfitSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProfitSetting.
func (c *ProfitSettingClient) Update() *ProfitSettingUpdate {
	mutation := newProfitSettingMutation(c.config, OpUpdate)
	return &ProfitSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfitSettingClient) UpdateOne(ps *ProfitSetting) *ProfitSettingUpdateOne {
	mutation := newProfitSettingMutation(c.config, OpUpdateOne, withProfitSetting(ps))
	return &ProfitSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfitSettingClient) UpdateOneID(id int64) *ProfitSettingUpdateOne {
	mutation := newProfitSettingMutation(c.config, OpUpdateOne, withProfitSettingID(id))
	return &ProfitSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProfitSetting.
func (c *ProfitSettingClient) Delete() *ProfitSettingDelete {
	mutation := newProfitSettingMutation(c.config, OpDelete)
	return &ProfitSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfitSettingClient) DeleteOne(ps *ProfitSetting) *ProfitSettingDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfitSettingClient) DeleteOneID(id int64) *ProfitSettingDeleteOne {
	builder := c.Delete().Where(profitsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfitSettingDeleteOne{builder}
}

// Query returns a query builder for ProfitSetting.
func (c *ProfitSettingClient) Query() *ProfitSettingQuery {
	return &ProfitSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfitSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a ProfitSetting entity by its id.
func (c *ProfitSettingClient) Get(ctx context.Context, id int64) (*ProfitSetting, error) {
	return c.Query().Where(profitsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfitSettingClient) GetX(ctx context.Context, id int64) *ProfitSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ProfitSetting.
func (c *ProfitSettingClient) QueryUser(ps *ProfitSetting) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profitsetting.Table, profitsetting.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, profitsetting.UserTable, profitsetting.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfitSettingClient) Hooks() []Hook {
	return c.hooks.ProfitSetting
}

// Interceptors returns the client interceptors.
func (c *ProfitSettingClient) Interceptors() []Interceptor {
	return c.inters.ProfitSetting
}

func (c *ProfitSettingClient) mutate(ctx context.Context, m *ProfitSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfitSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfitSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfitSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfitSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown ProfitSetting mutation op: %q", m.Op())
	}
}

// RechargeCampaignRuleClient is a client for the RechargeCampaignRule schema.
type RechargeCampaignRuleClient struct {
	config
}

// NewRechargeCampaignRuleClient returns a client for the RechargeCampaignRule from the given config.
func NewRechargeCampaignRuleClient(c config) *RechargeCampaignRuleClient {
	return &RechargeCampaignRuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rechargecampaignrule.Hooks(f(g(h())))`.
func (c *RechargeCampaignRuleClient) Use(hooks ...Hook) {
	c.hooks.RechargeCampaignRule = append(c.hooks.RechargeCampaignRule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rechargecampaignrule.Intercept(f(g(h())))`.
func (c *RechargeCampaignRuleClient) Intercept(interceptors ...Interceptor) {
	c.inters.RechargeCampaignRule = append(c.inters.RechargeCampaignRule, interceptors...)
}

// Create returns a builder for creating a RechargeCampaignRule entity.
func (c *RechargeCampaignRuleClient) Create() *RechargeCampaignRuleCreate {
	mutation := newRechargeCampaignRuleMutation(c.config, OpCreate)
	return &RechargeCampaignRuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RechargeCampaignRule entities.
func (c *RechargeCampaignRuleClient) CreateBulk(builders ...*RechargeCampaignRuleCreate) *RechargeCampaignRuleCreateBulk {
	return &RechargeCampaignRuleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RechargeCampaignRuleClient) MapCreateBulk(slice any, setFunc func(*RechargeCampaignRuleCreate, int)) *RechargeCampaignRuleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RechargeCampaignRuleCreateBulk{err: fmt.Errorf("calling to RechargeCampaignRuleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RechargeCampaignRuleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RechargeCampaignRuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RechargeCampaignRule.
func (c *RechargeCampaignRuleClient) Update() *RechargeCampaignRuleUpdate {
	mutation := newRechargeCampaignRuleMutation(c.config, OpUpdate)
	return &RechargeCampaignRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RechargeCampaignRuleClient) UpdateOne(rcr *RechargeCampaignRule) *RechargeCampaignRuleUpdateOne {
	mutation := newRechargeCampaignRuleMutation(c.config, OpUpdateOne, withRechargeCampaignRule(rcr))
	return &RechargeCampaignRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RechargeCampaignRuleClient) UpdateOneID(id int64) *RechargeCampaignRuleUpdateOne {
	mutation := newRechargeCampaignRuleMutation(c.config, OpUpdateOne, withRechargeCampaignRuleID(id))
	return &RechargeCampaignRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RechargeCampaignRule.
func (c *RechargeCampaignRuleClient) Delete() *RechargeCampaignRuleDelete {
	mutation := newRechargeCampaignRuleMutation(c.config, OpDelete)
	return &RechargeCampaignRuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RechargeCampaignRuleClient) DeleteOne(rcr *RechargeCampaignRule) *RechargeCampaignRuleDeleteOne {
	return c.DeleteOneID(rcr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RechargeCampaignRuleClient) DeleteOneID(id int64) *RechargeCampaignRuleDeleteOne {
	builder := c.Delete().Where(rechargecampaignrule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RechargeCampaignRuleDeleteOne{builder}
}

// Query returns a query builder for RechargeCampaignRule.
func (c *RechargeCampaignRuleClient) Query() *RechargeCampaignRuleQuery {
	return &RechargeCampaignRuleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRechargeCampaignRule},
		inters: c.Interceptors(),
	}
}

// Get returns a RechargeCampaignRule entity by its id.
func (c *RechargeCampaignRuleClient) Get(ctx context.Context, id int64) (*RechargeCampaignRule, error) {
	return c.Query().Where(rechargecampaignrule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RechargeCampaignRuleClient) GetX(ctx context.Context, id int64) *RechargeCampaignRule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RechargeCampaignRuleClient) Hooks() []Hook {
	return c.hooks.RechargeCampaignRule
}

// Interceptors returns the client interceptors.
func (c *RechargeCampaignRuleClient) Interceptors() []Interceptor {
	return c.inters.RechargeCampaignRule
}

func (c *RechargeCampaignRuleClient) mutate(ctx context.Context, m *RechargeCampaignRuleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RechargeCampaignRuleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RechargeCampaignRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RechargeCampaignRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RechargeCampaignRuleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown RechargeCampaignRule mutation op: %q", m.Op())
	}
}

// RechargeOrderClient is a client for the RechargeOrder schema.
type RechargeOrderClient struct {
	config
}

// NewRechargeOrderClient returns a client for the RechargeOrder from the given config.
func NewRechargeOrderClient(c config) *RechargeOrderClient {
	return &RechargeOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rechargeorder.Hooks(f(g(h())))`.
func (c *RechargeOrderClient) Use(hooks ...Hook) {
	c.hooks.RechargeOrder = append(c.hooks.RechargeOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rechargeorder.Intercept(f(g(h())))`.
func (c *RechargeOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.RechargeOrder = append(c.inters.RechargeOrder, interceptors...)
}

// Create returns a builder for creating a RechargeOrder entity.
func (c *RechargeOrderClient) Create() *RechargeOrderCreate {
	mutation := newRechargeOrderMutation(c.config, OpCreate)
	return &RechargeOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RechargeOrder entities.
func (c *RechargeOrderClient) CreateBulk(builders ...*RechargeOrderCreate) *RechargeOrderCreateBulk {
	return &RechargeOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RechargeOrderClient) MapCreateBulk(slice any, setFunc func(*RechargeOrderCreate, int)) *RechargeOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RechargeOrderCreateBulk{err: fmt.Errorf("calling to RechargeOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RechargeOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RechargeOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RechargeOrder.
func (c *RechargeOrderClient) Update() *RechargeOrderUpdate {
	mutation := newRechargeOrderMutation(c.config, OpUpdate)
	return &RechargeOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RechargeOrderClient) UpdateOne(ro *RechargeOrder) *RechargeOrderUpdateOne {
	mutation := newRechargeOrderMutation(c.config, OpUpdateOne, withRechargeOrder(ro))
	return &RechargeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RechargeOrderClient) UpdateOneID(id int64) *RechargeOrderUpdateOne {
	mutation := newRechargeOrderMutation(c.config, OpUpdateOne, withRechargeOrderID(id))
	return &RechargeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RechargeOrder.
func (c *RechargeOrderClient) Delete() *RechargeOrderDelete {
	mutation := newRechargeOrderMutation(c.config, OpDelete)
	return &RechargeOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RechargeOrderClient) DeleteOne(ro *RechargeOrder) *RechargeOrderDeleteOne {
	return c.DeleteOneID(ro.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RechargeOrderClient) DeleteOneID(id int64) *RechargeOrderDeleteOne {
	builder := c.Delete().Where(rechargeorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RechargeOrderDeleteOne{builder}
}

// Query returns a query builder for RechargeOrder.
func (c *RechargeOrderClient) Query() *RechargeOrderQuery {
	return &RechargeOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRechargeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a RechargeOrder entity by its id.
func (c *RechargeOrderClient) Get(ctx context.Context, id int64) (*RechargeOrder, error) {
	return c.Query().Where(rechargeorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RechargeOrderClient) GetX(ctx context.Context, id int64) *RechargeOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a RechargeOrder.
func (c *RechargeOrderClient) QueryUser(ro *RechargeOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rechargeorder.Table, rechargeorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rechargeorder.UserTable, rechargeorder.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a RechargeOrder.
func (c *RechargeOrderClient) QueryCostBills(ro *RechargeOrder) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rechargeorder.Table, rechargeorder.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, rechargeorder.CostBillsTable, rechargeorder.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVxSocial queries the vx_social edge of a RechargeOrder.
func (c *RechargeOrderClient) QueryVxSocial(ro *RechargeOrder) *VXSocialQuery {
	query := (&VXSocialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rechargeorder.Table, rechargeorder.FieldID, id),
			sqlgraph.To(vxsocial.Table, vxsocial.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rechargeorder.VxSocialTable, rechargeorder.VxSocialColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaignOrder queries the campaign_order edge of a RechargeOrder.
func (c *RechargeOrderClient) QueryCampaignOrder(ro *RechargeOrder) *CampaignOrderQuery {
	query := (&CampaignOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rechargeorder.Table, rechargeorder.FieldID, id),
			sqlgraph.To(campaignorder.Table, campaignorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, rechargeorder.CampaignOrderTable, rechargeorder.CampaignOrderColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RechargeOrderClient) Hooks() []Hook {
	return c.hooks.RechargeOrder
}

// Interceptors returns the client interceptors.
func (c *RechargeOrderClient) Interceptors() []Interceptor {
	return c.inters.RechargeOrder
}

func (c *RechargeOrderClient) mutate(ctx context.Context, m *RechargeOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RechargeOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RechargeOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RechargeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RechargeOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown RechargeOrder mutation op: %q", m.Op())
	}
}

// RenewalAgreementClient is a client for the RenewalAgreement schema.
type RenewalAgreementClient struct {
	config
}

// NewRenewalAgreementClient returns a client for the RenewalAgreement from the given config.
func NewRenewalAgreementClient(c config) *RenewalAgreementClient {
	return &RenewalAgreementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `renewalagreement.Hooks(f(g(h())))`.
func (c *RenewalAgreementClient) Use(hooks ...Hook) {
	c.hooks.RenewalAgreement = append(c.hooks.RenewalAgreement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `renewalagreement.Intercept(f(g(h())))`.
func (c *RenewalAgreementClient) Intercept(interceptors ...Interceptor) {
	c.inters.RenewalAgreement = append(c.inters.RenewalAgreement, interceptors...)
}

// Create returns a builder for creating a RenewalAgreement entity.
func (c *RenewalAgreementClient) Create() *RenewalAgreementCreate {
	mutation := newRenewalAgreementMutation(c.config, OpCreate)
	return &RenewalAgreementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RenewalAgreement entities.
func (c *RenewalAgreementClient) CreateBulk(builders ...*RenewalAgreementCreate) *RenewalAgreementCreateBulk {
	return &RenewalAgreementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RenewalAgreementClient) MapCreateBulk(slice any, setFunc func(*RenewalAgreementCreate, int)) *RenewalAgreementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RenewalAgreementCreateBulk{err: fmt.Errorf("calling to RenewalAgreementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RenewalAgreementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RenewalAgreementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RenewalAgreement.
func (c *RenewalAgreementClient) Update() *RenewalAgreementUpdate {
	mutation := newRenewalAgreementMutation(c.config, OpUpdate)
	return &RenewalAgreementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RenewalAgreementClient) UpdateOne(ra *RenewalAgreement) *RenewalAgreementUpdateOne {
	mutation := newRenewalAgreementMutation(c.config, OpUpdateOne, withRenewalAgreement(ra))
	return &RenewalAgreementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RenewalAgreementClient) UpdateOneID(id int64) *RenewalAgreementUpdateOne {
	mutation := newRenewalAgreementMutation(c.config, OpUpdateOne, withRenewalAgreementID(id))
	return &RenewalAgreementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RenewalAgreement.
func (c *RenewalAgreementClient) Delete() *RenewalAgreementDelete {
	mutation := newRenewalAgreementMutation(c.config, OpDelete)
	return &RenewalAgreementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RenewalAgreementClient) DeleteOne(ra *RenewalAgreement) *RenewalAgreementDeleteOne {
	return c.DeleteOneID(ra.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RenewalAgreementClient) DeleteOneID(id int64) *RenewalAgreementDeleteOne {
	builder := c.Delete().Where(renewalagreement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RenewalAgreementDeleteOne{builder}
}

// Query returns a query builder for RenewalAgreement.
func (c *RenewalAgreementClient) Query() *RenewalAgreementQuery {
	return &RenewalAgreementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRenewalAgreement},
		inters: c.Interceptors(),
	}
}

// Get returns a RenewalAgreement entity by its id.
func (c *RenewalAgreementClient) Get(ctx context.Context, id int64) (*RenewalAgreement, error) {
	return c.Query().Where(renewalagreement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RenewalAgreementClient) GetX(ctx context.Context, id int64) *RenewalAgreement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a RenewalAgreement.
func (c *RenewalAgreementClient) QueryUser(ra *RenewalAgreement) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ra.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(renewalagreement.Table, renewalagreement.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, renewalagreement.UserTable, renewalagreement.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ra.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMission queries the mission edge of a RenewalAgreement.
func (c *RenewalAgreementClient) QueryMission(ra *RenewalAgreement) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ra.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(renewalagreement.Table, renewalagreement.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, renewalagreement.MissionTable, renewalagreement.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(ra.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RenewalAgreementClient) Hooks() []Hook {
	return c.hooks.RenewalAgreement
}

// Interceptors returns the client interceptors.
func (c *RenewalAgreementClient) Interceptors() []Interceptor {
	return c.inters.RenewalAgreement
}

func (c *RenewalAgreementClient) mutate(ctx context.Context, m *RenewalAgreementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RenewalAgreementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RenewalAgreementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RenewalAgreementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RenewalAgreementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown RenewalAgreement mutation op: %q", m.Op())
	}
}

// SymbolClient is a client for the Symbol schema.
type SymbolClient struct {
	config
}

// NewSymbolClient returns a client for the Symbol from the given config.
func NewSymbolClient(c config) *SymbolClient {
	return &SymbolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `symbol.Hooks(f(g(h())))`.
func (c *SymbolClient) Use(hooks ...Hook) {
	c.hooks.Symbol = append(c.hooks.Symbol, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `symbol.Intercept(f(g(h())))`.
func (c *SymbolClient) Intercept(interceptors ...Interceptor) {
	c.inters.Symbol = append(c.inters.Symbol, interceptors...)
}

// Create returns a builder for creating a Symbol entity.
func (c *SymbolClient) Create() *SymbolCreate {
	mutation := newSymbolMutation(c.config, OpCreate)
	return &SymbolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Symbol entities.
func (c *SymbolClient) CreateBulk(builders ...*SymbolCreate) *SymbolCreateBulk {
	return &SymbolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SymbolClient) MapCreateBulk(slice any, setFunc func(*SymbolCreate, int)) *SymbolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SymbolCreateBulk{err: fmt.Errorf("calling to SymbolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SymbolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SymbolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Symbol.
func (c *SymbolClient) Update() *SymbolUpdate {
	mutation := newSymbolMutation(c.config, OpUpdate)
	return &SymbolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SymbolClient) UpdateOne(s *Symbol) *SymbolUpdateOne {
	mutation := newSymbolMutation(c.config, OpUpdateOne, withSymbol(s))
	return &SymbolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SymbolClient) UpdateOneID(id int64) *SymbolUpdateOne {
	mutation := newSymbolMutation(c.config, OpUpdateOne, withSymbolID(id))
	return &SymbolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Symbol.
func (c *SymbolClient) Delete() *SymbolDelete {
	mutation := newSymbolMutation(c.config, OpDelete)
	return &SymbolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SymbolClient) DeleteOne(s *Symbol) *SymbolDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SymbolClient) DeleteOneID(id int64) *SymbolDeleteOne {
	builder := c.Delete().Where(symbol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SymbolDeleteOne{builder}
}

// Query returns a query builder for Symbol.
func (c *SymbolClient) Query() *SymbolQuery {
	return &SymbolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSymbol},
		inters: c.Interceptors(),
	}
}

// Get returns a Symbol entity by its id.
func (c *SymbolClient) Get(ctx context.Context, id int64) (*Symbol, error) {
	return c.Query().Where(symbol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SymbolClient) GetX(ctx context.Context, id int64) *Symbol {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWallets queries the wallets edge of a Symbol.
func (c *SymbolClient) QueryWallets(s *Symbol) *WalletQuery {
	query := (&WalletClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(wallet.Table, wallet.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.WalletsTable, symbol.WalletsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBills queries the bills edge of a Symbol.
func (c *SymbolClient) QueryBills(s *Symbol) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.BillsTable, symbol.BillsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncomeBills queries the income_bills edge of a Symbol.
func (c *SymbolClient) QueryIncomeBills(s *Symbol) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.IncomeBillsTable, symbol.IncomeBillsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrders queries the mission_orders edge of a Symbol.
func (c *SymbolClient) QueryMissionOrders(s *Symbol) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.MissionOrdersTable, symbol.MissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransferOrders queries the transfer_orders edge of a Symbol.
func (c *SymbolClient) QueryTransferOrders(s *Symbol) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.TransferOrdersTable, symbol.TransferOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtraServiceOrder queries the extra_service_order edge of a Symbol.
func (c *SymbolClient) QueryExtraServiceOrder(s *Symbol) *ExtraServiceOrderQuery {
	query := (&ExtraServiceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(extraserviceorder.Table, extraserviceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.ExtraServiceOrderTable, symbol.ExtraServiceOrderColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SymbolClient) Hooks() []Hook {
	return c.hooks.Symbol
}

// Interceptors returns the client interceptors.
func (c *SymbolClient) Interceptors() []Interceptor {
	return c.inters.Symbol
}

func (c *SymbolClient) mutate(ctx context.Context, m *SymbolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SymbolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SymbolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SymbolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SymbolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Symbol mutation op: %q", m.Op())
	}
}

// TransferOrderClient is a client for the TransferOrder schema.
type TransferOrderClient struct {
	config
}

// NewTransferOrderClient returns a client for the TransferOrder from the given config.
func NewTransferOrderClient(c config) *TransferOrderClient {
	return &TransferOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transferorder.Hooks(f(g(h())))`.
func (c *TransferOrderClient) Use(hooks ...Hook) {
	c.hooks.TransferOrder = append(c.hooks.TransferOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `transferorder.Intercept(f(g(h())))`.
func (c *TransferOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.TransferOrder = append(c.inters.TransferOrder, interceptors...)
}

// Create returns a builder for creating a TransferOrder entity.
func (c *TransferOrderClient) Create() *TransferOrderCreate {
	mutation := newTransferOrderMutation(c.config, OpCreate)
	return &TransferOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TransferOrder entities.
func (c *TransferOrderClient) CreateBulk(builders ...*TransferOrderCreate) *TransferOrderCreateBulk {
	return &TransferOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TransferOrderClient) MapCreateBulk(slice any, setFunc func(*TransferOrderCreate, int)) *TransferOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TransferOrderCreateBulk{err: fmt.Errorf("calling to TransferOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TransferOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TransferOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TransferOrder.
func (c *TransferOrderClient) Update() *TransferOrderUpdate {
	mutation := newTransferOrderMutation(c.config, OpUpdate)
	return &TransferOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransferOrderClient) UpdateOne(to *TransferOrder) *TransferOrderUpdateOne {
	mutation := newTransferOrderMutation(c.config, OpUpdateOne, withTransferOrder(to))
	return &TransferOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransferOrderClient) UpdateOneID(id int64) *TransferOrderUpdateOne {
	mutation := newTransferOrderMutation(c.config, OpUpdateOne, withTransferOrderID(id))
	return &TransferOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TransferOrder.
func (c *TransferOrderClient) Delete() *TransferOrderDelete {
	mutation := newTransferOrderMutation(c.config, OpDelete)
	return &TransferOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransferOrderClient) DeleteOne(to *TransferOrder) *TransferOrderDeleteOne {
	return c.DeleteOneID(to.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TransferOrderClient) DeleteOneID(id int64) *TransferOrderDeleteOne {
	builder := c.Delete().Where(transferorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransferOrderDeleteOne{builder}
}

// Query returns a query builder for TransferOrder.
func (c *TransferOrderClient) Query() *TransferOrderQuery {
	return &TransferOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTransferOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a TransferOrder entity by its id.
func (c *TransferOrderClient) Get(ctx context.Context, id int64) (*TransferOrder, error) {
	return c.Query().Where(transferorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransferOrderClient) GetX(ctx context.Context, id int64) *TransferOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySourceUser queries the source_user edge of a TransferOrder.
func (c *TransferOrderClient) QuerySourceUser(to *TransferOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transferorder.SourceUserTable, transferorder.SourceUserColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetUser queries the target_user edge of a TransferOrder.
func (c *TransferOrderClient) QueryTargetUser(to *TransferOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transferorder.TargetUserTable, transferorder.TargetUserColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBills queries the bills edge of a TransferOrder.
func (c *TransferOrderClient) QueryBills(to *TransferOrder) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, transferorder.BillsTable, transferorder.BillsColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVxSocial queries the vx_social edge of a TransferOrder.
func (c *TransferOrderClient) QueryVxSocial(to *TransferOrder) *VXSocialQuery {
	query := (&VXSocialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(vxsocial.Table, vxsocial.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transferorder.VxSocialTable, transferorder.VxSocialColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a TransferOrder.
func (c *TransferOrderClient) QuerySymbol(to *TransferOrder) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transferorder.SymbolTable, transferorder.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWithdrawRecord queries the withdraw_record edge of a TransferOrder.
func (c *TransferOrderClient) QueryWithdrawRecord(to *TransferOrder) *WithdrawRecordQuery {
	query := (&WithdrawRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(withdrawrecord.Table, withdrawrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, transferorder.WithdrawRecordTable, transferorder.WithdrawRecordColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TransferOrderClient) Hooks() []Hook {
	return c.hooks.TransferOrder
}

// Interceptors returns the client interceptors.
func (c *TransferOrderClient) Interceptors() []Interceptor {
	return c.inters.TransferOrder
}

func (c *TransferOrderClient) mutate(ctx context.Context, m *TransferOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TransferOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TransferOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TransferOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TransferOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown TransferOrder mutation op: %q", m.Op())
	}
}

// TroubleDeductClient is a client for the TroubleDeduct schema.
type TroubleDeductClient struct {
	config
}

// NewTroubleDeductClient returns a client for the TroubleDeduct from the given config.
func NewTroubleDeductClient(c config) *TroubleDeductClient {
	return &TroubleDeductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `troublededuct.Hooks(f(g(h())))`.
func (c *TroubleDeductClient) Use(hooks ...Hook) {
	c.hooks.TroubleDeduct = append(c.hooks.TroubleDeduct, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `troublededuct.Intercept(f(g(h())))`.
func (c *TroubleDeductClient) Intercept(interceptors ...Interceptor) {
	c.inters.TroubleDeduct = append(c.inters.TroubleDeduct, interceptors...)
}

// Create returns a builder for creating a TroubleDeduct entity.
func (c *TroubleDeductClient) Create() *TroubleDeductCreate {
	mutation := newTroubleDeductMutation(c.config, OpCreate)
	return &TroubleDeductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TroubleDeduct entities.
func (c *TroubleDeductClient) CreateBulk(builders ...*TroubleDeductCreate) *TroubleDeductCreateBulk {
	return &TroubleDeductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TroubleDeductClient) MapCreateBulk(slice any, setFunc func(*TroubleDeductCreate, int)) *TroubleDeductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TroubleDeductCreateBulk{err: fmt.Errorf("calling to TroubleDeductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TroubleDeductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TroubleDeductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TroubleDeduct.
func (c *TroubleDeductClient) Update() *TroubleDeductUpdate {
	mutation := newTroubleDeductMutation(c.config, OpUpdate)
	return &TroubleDeductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TroubleDeductClient) UpdateOne(td *TroubleDeduct) *TroubleDeductUpdateOne {
	mutation := newTroubleDeductMutation(c.config, OpUpdateOne, withTroubleDeduct(td))
	return &TroubleDeductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TroubleDeductClient) UpdateOneID(id int64) *TroubleDeductUpdateOne {
	mutation := newTroubleDeductMutation(c.config, OpUpdateOne, withTroubleDeductID(id))
	return &TroubleDeductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TroubleDeduct.
func (c *TroubleDeductClient) Delete() *TroubleDeductDelete {
	mutation := newTroubleDeductMutation(c.config, OpDelete)
	return &TroubleDeductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TroubleDeductClient) DeleteOne(td *TroubleDeduct) *TroubleDeductDeleteOne {
	return c.DeleteOneID(td.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TroubleDeductClient) DeleteOneID(id int64) *TroubleDeductDeleteOne {
	builder := c.Delete().Where(troublededuct.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TroubleDeductDeleteOne{builder}
}

// Query returns a query builder for TroubleDeduct.
func (c *TroubleDeductClient) Query() *TroubleDeductQuery {
	return &TroubleDeductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTroubleDeduct},
		inters: c.Interceptors(),
	}
}

// Get returns a TroubleDeduct entity by its id.
func (c *TroubleDeductClient) Get(ctx context.Context, id int64) (*TroubleDeduct, error) {
	return c.Query().Where(troublededuct.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TroubleDeductClient) GetX(ctx context.Context, id int64) *TroubleDeduct {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TroubleDeduct.
func (c *TroubleDeductClient) QueryUser(td *TroubleDeduct) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := td.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(troublededuct.Table, troublededuct.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, troublededuct.UserTable, troublededuct.UserColumn),
		)
		fromV = sqlgraph.Neighbors(td.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a TroubleDeduct.
func (c *TroubleDeductClient) QueryDevice(td *TroubleDeduct) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := td.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(troublededuct.Table, troublededuct.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, troublededuct.DeviceTable, troublededuct.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(td.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TroubleDeductClient) Hooks() []Hook {
	return c.hooks.TroubleDeduct
}

// Interceptors returns the client interceptors.
func (c *TroubleDeductClient) Interceptors() []Interceptor {
	return c.inters.TroubleDeduct
}

func (c *TroubleDeductClient) mutate(ctx context.Context, m *TroubleDeductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TroubleDeductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TroubleDeductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TroubleDeductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TroubleDeductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown TroubleDeduct mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVxAccounts queries the vx_accounts edge of a User.
func (c *UserClient) QueryVxAccounts(u *User) *VXAccountQuery {
	query := (&VXAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(vxaccount.Table, vxaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.VxAccountsTable, user.VxAccountsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollects queries the collects edge of a User.
func (c *UserClient) QueryCollects(u *User) *CollectQuery {
	query := (&CollectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(collect.Table, collect.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CollectsTable, user.CollectsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevices queries the devices edge of a User.
func (c *UserClient) QueryDevices(u *User) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DevicesTable, user.DevicesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfitSettings queries the profit_settings edge of a User.
func (c *UserClient) QueryProfitSettings(u *User) *ProfitSettingQuery {
	query := (&ProfitSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(profitsetting.Table, profitsetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProfitSettingsTable, user.ProfitSettingsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostAccount queries the cost_account edge of a User.
func (c *UserClient) QueryCostAccount(u *User) *CostAccountQuery {
	query := (&CostAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(costaccount.Table, costaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.CostAccountTable, user.CostAccountColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfitAccount queries the profit_account edge of a User.
func (c *UserClient) QueryProfitAccount(u *User) *ProfitAccountQuery {
	query := (&ProfitAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(profitaccount.Table, profitaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.ProfitAccountTable, user.ProfitAccountColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a User.
func (c *UserClient) QueryCostBills(u *User) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CostBillsTable, user.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEarnBills queries the earn_bills edge of a User.
func (c *UserClient) QueryEarnBills(u *User) *EarnBillQuery {
	query := (&EarnBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(earnbill.Table, earnbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EarnBillsTable, user.EarnBillsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrders queries the mission_consume_orders edge of a User.
func (c *UserClient) QueryMissionConsumeOrders(u *User) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionConsumeOrdersTable, user.MissionConsumeOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a User.
func (c *UserClient) QueryMissionProduceOrders(u *User) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionProduceOrdersTable, user.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRechargeOrders queries the recharge_orders edge of a User.
func (c *UserClient) QueryRechargeOrders(u *User) *RechargeOrderQuery {
	query := (&RechargeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(rechargeorder.Table, rechargeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RechargeOrdersTable, user.RechargeOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVxSocials queries the vx_socials edge of a User.
func (c *UserClient) QueryVxSocials(u *User) *VXSocialQuery {
	query := (&VXSocialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(vxsocial.Table, vxsocial.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.VxSocialsTable, user.VxSocialsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionBatches queries the mission_batches edge of a User.
func (c *UserClient) QueryMissionBatches(u *User) *MissionBatchQuery {
	query := (&MissionBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionbatch.Table, missionbatch.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionBatchesTable, user.MissionBatchesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserDevices queries the user_devices edge of a User.
func (c *UserClient) QueryUserDevices(u *User) *UserDeviceQuery {
	query := (&UserDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userdevice.Table, userdevice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserDevicesTable, user.UserDevicesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a User.
func (c *UserClient) QueryParent(u *User) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.ParentTable, user.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a User.
func (c *UserClient) QueryChildren(u *User) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ChildrenTable, user.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvites queries the invites edge of a User.
func (c *UserClient) QueryInvites(u *User) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.InvitesTable, user.InvitesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaignOrders queries the campaign_orders edge of a User.
func (c *UserClient) QueryCampaignOrders(u *User) *CampaignOrderQuery {
	query := (&CampaignOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(campaignorder.Table, campaignorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CampaignOrdersTable, user.CampaignOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWallets queries the wallets edge of a User.
func (c *UserClient) QueryWallets(u *User) *WalletQuery {
	query := (&WalletClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(wallet.Table, wallet.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.WalletsTable, user.WalletsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWithdrawAccount queries the withdraw_account edge of a User.
func (c *UserClient) QueryWithdrawAccount(u *User) *WithdrawAccountQuery {
	query := (&WithdrawAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(withdrawaccount.Table, withdrawaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.WithdrawAccountTable, user.WithdrawAccountColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncomeBills queries the income_bills edge of a User.
func (c *UserClient) QueryIncomeBills(u *User) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.IncomeBillsTable, user.IncomeBillsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOutcomeBills queries the outcome_bills edge of a User.
func (c *UserClient) QueryOutcomeBills(u *User) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OutcomeBillsTable, user.OutcomeBillsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProductions queries the mission_productions edge of a User.
func (c *UserClient) QueryMissionProductions(u *User) *MissionProductionQuery {
	query := (&MissionProductionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionproduction.Table, missionproduction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionProductionsTable, user.MissionProductionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissions queries the missions edge of a User.
func (c *UserClient) QueryMissions(u *User) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionsTable, user.MissionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncomeTransferOrders queries the income_transfer_orders edge of a User.
func (c *UserClient) QueryIncomeTransferOrders(u *User) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.IncomeTransferOrdersTable, user.IncomeTransferOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOutcomeTransferOrders queries the outcome_transfer_orders edge of a User.
func (c *UserClient) QueryOutcomeTransferOrders(u *User) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OutcomeTransferOrdersTable, user.OutcomeTransferOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConsumeMissionOrders queries the consume_mission_orders edge of a User.
func (c *UserClient) QueryConsumeMissionOrders(u *User) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ConsumeMissionOrdersTable, user.ConsumeMissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduceMissionOrders queries the produce_mission_orders edge of a User.
func (c *UserClient) QueryProduceMissionOrders(u *User) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProduceMissionOrdersTable, user.ProduceMissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLoginRecords queries the login_records edge of a User.
func (c *UserClient) QueryLoginRecords(u *User) *LoginRecordQuery {
	query := (&LoginRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(loginrecord.Table, loginrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LoginRecordsTable, user.LoginRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRenewalAgreements queries the renewal_agreements edge of a User.
func (c *UserClient) QueryRenewalAgreements(u *User) *RenewalAgreementQuery {
	query := (&RenewalAgreementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(renewalagreement.Table, renewalagreement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RenewalAgreementsTable, user.RenewalAgreementsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtworks queries the artworks edge of a User.
func (c *UserClient) QueryArtworks(u *User) *ArtworkQuery {
	query := (&ArtworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(artwork.Table, artwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ArtworksTable, user.ArtworksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtworkLikes queries the artwork_likes edge of a User.
func (c *UserClient) QueryArtworkLikes(u *User) *ArtworkLikeQuery {
	query := (&ArtworkLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(artworklike.Table, artworklike.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ArtworkLikesTable, user.ArtworkLikesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCdkInfos queries the cdk_infos edge of a User.
func (c *UserClient) QueryCdkInfos(u *User) *CDKInfoQuery {
	query := (&CDKInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(cdkinfo.Table, cdkinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CdkInfosTable, user.CdkInfosColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUseCdkInfos queries the use_cdk_infos edge of a User.
func (c *UserClient) QueryUseCdkInfos(u *User) *CDKInfoQuery {
	query := (&CDKInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(cdkinfo.Table, cdkinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UseCdkInfosTable, user.UseCdkInfosColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLottoRecords queries the lotto_records edge of a User.
func (c *UserClient) QueryLottoRecords(u *User) *LottoRecordQuery {
	query := (&LottoRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(lottorecord.Table, lottorecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LottoRecordsTable, user.LottoRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLottoUserCounts queries the lotto_user_counts edge of a User.
func (c *UserClient) QueryLottoUserCounts(u *User) *LottoUserCountQuery {
	query := (&LottoUserCountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(lottousercount.Table, lottousercount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LottoUserCountsTable, user.LottoUserCountsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLottoGetCountRecords queries the lotto_get_count_records edge of a User.
func (c *UserClient) QueryLottoGetCountRecords(u *User) *LottoGetCountRecordQuery {
	query := (&LottoGetCountRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(lottogetcountrecord.Table, lottogetcountrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LottoGetCountRecordsTable, user.LottoGetCountRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCloudFiles queries the cloud_files edge of a User.
func (c *UserClient) QueryCloudFiles(u *User) *CloudFileQuery {
	query := (&CloudFileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(cloudfile.Table, cloudfile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CloudFilesTable, user.CloudFilesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWithdrawRecords queries the withdraw_records edge of a User.
func (c *UserClient) QueryWithdrawRecords(u *User) *WithdrawRecordQuery {
	query := (&WithdrawRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(withdrawrecord.Table, withdrawrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.WithdrawRecordsTable, user.WithdrawRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOperateWithdrawRecords queries the operate_withdraw_records edge of a User.
func (c *UserClient) QueryOperateWithdrawRecords(u *User) *WithdrawRecordQuery {
	query := (&WithdrawRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(withdrawrecord.Table, withdrawrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OperateWithdrawRecordsTable, user.OperateWithdrawRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTroubleDeducts queries the trouble_deducts edge of a User.
func (c *UserClient) QueryTroubleDeducts(u *User) *TroubleDeductQuery {
	query := (&TroubleDeductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(troublededuct.Table, troublededuct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TroubleDeductsTable, user.TroubleDeductsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncomeManages queries the income_manages edge of a User.
func (c *UserClient) QueryIncomeManages(u *User) *IncomeManageQuery {
	query := (&IncomeManageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(incomemanage.Table, incomemanage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.IncomeManagesTable, user.IncomeManagesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApproveIncomeManages queries the approve_income_manages edge of a User.
func (c *UserClient) QueryApproveIncomeManages(u *User) *IncomeManageQuery {
	query := (&IncomeManageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(incomemanage.Table, incomemanage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ApproveIncomeManagesTable, user.ApproveIncomeManagesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown User mutation op: %q", m.Op())
	}
}

// UserDeviceClient is a client for the UserDevice schema.
type UserDeviceClient struct {
	config
}

// NewUserDeviceClient returns a client for the UserDevice from the given config.
func NewUserDeviceClient(c config) *UserDeviceClient {
	return &UserDeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userdevice.Hooks(f(g(h())))`.
func (c *UserDeviceClient) Use(hooks ...Hook) {
	c.hooks.UserDevice = append(c.hooks.UserDevice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userdevice.Intercept(f(g(h())))`.
func (c *UserDeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserDevice = append(c.inters.UserDevice, interceptors...)
}

// Create returns a builder for creating a UserDevice entity.
func (c *UserDeviceClient) Create() *UserDeviceCreate {
	mutation := newUserDeviceMutation(c.config, OpCreate)
	return &UserDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserDevice entities.
func (c *UserDeviceClient) CreateBulk(builders ...*UserDeviceCreate) *UserDeviceCreateBulk {
	return &UserDeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserDeviceClient) MapCreateBulk(slice any, setFunc func(*UserDeviceCreate, int)) *UserDeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserDeviceCreateBulk{err: fmt.Errorf("calling to UserDeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserDeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserDeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserDevice.
func (c *UserDeviceClient) Update() *UserDeviceUpdate {
	mutation := newUserDeviceMutation(c.config, OpUpdate)
	return &UserDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserDeviceClient) UpdateOne(ud *UserDevice) *UserDeviceUpdateOne {
	mutation := newUserDeviceMutation(c.config, OpUpdateOne, withUserDevice(ud))
	return &UserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserDeviceClient) UpdateOneID(id int64) *UserDeviceUpdateOne {
	mutation := newUserDeviceMutation(c.config, OpUpdateOne, withUserDeviceID(id))
	return &UserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserDevice.
func (c *UserDeviceClient) Delete() *UserDeviceDelete {
	mutation := newUserDeviceMutation(c.config, OpDelete)
	return &UserDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserDeviceClient) DeleteOne(ud *UserDevice) *UserDeviceDeleteOne {
	return c.DeleteOneID(ud.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserDeviceClient) DeleteOneID(id int64) *UserDeviceDeleteOne {
	builder := c.Delete().Where(userdevice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeviceDeleteOne{builder}
}

// Query returns a query builder for UserDevice.
func (c *UserDeviceClient) Query() *UserDeviceQuery {
	return &UserDeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a UserDevice entity by its id.
func (c *UserDeviceClient) Get(ctx context.Context, id int64) (*UserDevice, error) {
	return c.Query().Where(userdevice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserDeviceClient) GetX(ctx context.Context, id int64) *UserDevice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserDevice.
func (c *UserDeviceClient) QueryUser(ud *UserDevice) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ud.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userdevice.Table, userdevice.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userdevice.UserTable, userdevice.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ud.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a UserDevice.
func (c *UserDeviceClient) QueryDevice(ud *UserDevice) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ud.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userdevice.Table, userdevice.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userdevice.DeviceTable, userdevice.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(ud.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserDeviceClient) Hooks() []Hook {
	return c.hooks.UserDevice
}

// Interceptors returns the client interceptors.
func (c *UserDeviceClient) Interceptors() []Interceptor {
	return c.inters.UserDevice
}

func (c *UserDeviceClient) mutate(ctx context.Context, m *UserDeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown UserDevice mutation op: %q", m.Op())
	}
}

// VXAccountClient is a client for the VXAccount schema.
type VXAccountClient struct {
	config
}

// NewVXAccountClient returns a client for the VXAccount from the given config.
func NewVXAccountClient(c config) *VXAccountClient {
	return &VXAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vxaccount.Hooks(f(g(h())))`.
func (c *VXAccountClient) Use(hooks ...Hook) {
	c.hooks.VXAccount = append(c.hooks.VXAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vxaccount.Intercept(f(g(h())))`.
func (c *VXAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.VXAccount = append(c.inters.VXAccount, interceptors...)
}

// Create returns a builder for creating a VXAccount entity.
func (c *VXAccountClient) Create() *VXAccountCreate {
	mutation := newVXAccountMutation(c.config, OpCreate)
	return &VXAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VXAccount entities.
func (c *VXAccountClient) CreateBulk(builders ...*VXAccountCreate) *VXAccountCreateBulk {
	return &VXAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VXAccountClient) MapCreateBulk(slice any, setFunc func(*VXAccountCreate, int)) *VXAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VXAccountCreateBulk{err: fmt.Errorf("calling to VXAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VXAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VXAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VXAccount.
func (c *VXAccountClient) Update() *VXAccountUpdate {
	mutation := newVXAccountMutation(c.config, OpUpdate)
	return &VXAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VXAccountClient) UpdateOne(va *VXAccount) *VXAccountUpdateOne {
	mutation := newVXAccountMutation(c.config, OpUpdateOne, withVXAccount(va))
	return &VXAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VXAccountClient) UpdateOneID(id int64) *VXAccountUpdateOne {
	mutation := newVXAccountMutation(c.config, OpUpdateOne, withVXAccountID(id))
	return &VXAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VXAccount.
func (c *VXAccountClient) Delete() *VXAccountDelete {
	mutation := newVXAccountMutation(c.config, OpDelete)
	return &VXAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VXAccountClient) DeleteOne(va *VXAccount) *VXAccountDeleteOne {
	return c.DeleteOneID(va.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VXAccountClient) DeleteOneID(id int64) *VXAccountDeleteOne {
	builder := c.Delete().Where(vxaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VXAccountDeleteOne{builder}
}

// Query returns a query builder for VXAccount.
func (c *VXAccountClient) Query() *VXAccountQuery {
	return &VXAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVXAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a VXAccount entity by its id.
func (c *VXAccountClient) Get(ctx context.Context, id int64) (*VXAccount, error) {
	return c.Query().Where(vxaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VXAccountClient) GetX(ctx context.Context, id int64) *VXAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a VXAccount.
func (c *VXAccountClient) QueryUser(va *VXAccount) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := va.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vxaccount.Table, vxaccount.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vxaccount.UserTable, vxaccount.UserColumn),
		)
		fromV = sqlgraph.Neighbors(va.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VXAccountClient) Hooks() []Hook {
	return c.hooks.VXAccount
}

// Interceptors returns the client interceptors.
func (c *VXAccountClient) Interceptors() []Interceptor {
	return c.inters.VXAccount
}

func (c *VXAccountClient) mutate(ctx context.Context, m *VXAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VXAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VXAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VXAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VXAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown VXAccount mutation op: %q", m.Op())
	}
}

// VXSocialClient is a client for the VXSocial schema.
type VXSocialClient struct {
	config
}

// NewVXSocialClient returns a client for the VXSocial from the given config.
func NewVXSocialClient(c config) *VXSocialClient {
	return &VXSocialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vxsocial.Hooks(f(g(h())))`.
func (c *VXSocialClient) Use(hooks ...Hook) {
	c.hooks.VXSocial = append(c.hooks.VXSocial, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vxsocial.Intercept(f(g(h())))`.
func (c *VXSocialClient) Intercept(interceptors ...Interceptor) {
	c.inters.VXSocial = append(c.inters.VXSocial, interceptors...)
}

// Create returns a builder for creating a VXSocial entity.
func (c *VXSocialClient) Create() *VXSocialCreate {
	mutation := newVXSocialMutation(c.config, OpCreate)
	return &VXSocialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VXSocial entities.
func (c *VXSocialClient) CreateBulk(builders ...*VXSocialCreate) *VXSocialCreateBulk {
	return &VXSocialCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VXSocialClient) MapCreateBulk(slice any, setFunc func(*VXSocialCreate, int)) *VXSocialCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VXSocialCreateBulk{err: fmt.Errorf("calling to VXSocialClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VXSocialCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VXSocialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VXSocial.
func (c *VXSocialClient) Update() *VXSocialUpdate {
	mutation := newVXSocialMutation(c.config, OpUpdate)
	return &VXSocialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VXSocialClient) UpdateOne(vs *VXSocial) *VXSocialUpdateOne {
	mutation := newVXSocialMutation(c.config, OpUpdateOne, withVXSocial(vs))
	return &VXSocialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VXSocialClient) UpdateOneID(id int64) *VXSocialUpdateOne {
	mutation := newVXSocialMutation(c.config, OpUpdateOne, withVXSocialID(id))
	return &VXSocialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VXSocial.
func (c *VXSocialClient) Delete() *VXSocialDelete {
	mutation := newVXSocialMutation(c.config, OpDelete)
	return &VXSocialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VXSocialClient) DeleteOne(vs *VXSocial) *VXSocialDeleteOne {
	return c.DeleteOneID(vs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VXSocialClient) DeleteOneID(id int64) *VXSocialDeleteOne {
	builder := c.Delete().Where(vxsocial.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VXSocialDeleteOne{builder}
}

// Query returns a query builder for VXSocial.
func (c *VXSocialClient) Query() *VXSocialQuery {
	return &VXSocialQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVXSocial},
		inters: c.Interceptors(),
	}
}

// Get returns a VXSocial entity by its id.
func (c *VXSocialClient) Get(ctx context.Context, id int64) (*VXSocial, error) {
	return c.Query().Where(vxsocial.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VXSocialClient) GetX(ctx context.Context, id int64) *VXSocial {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a VXSocial.
func (c *VXSocialClient) QueryUser(vs *VXSocial) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vxsocial.Table, vxsocial.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vxsocial.UserTable, vxsocial.UserColumn),
		)
		fromV = sqlgraph.Neighbors(vs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRechargeOrders queries the recharge_orders edge of a VXSocial.
func (c *VXSocialClient) QueryRechargeOrders(vs *VXSocial) *RechargeOrderQuery {
	query := (&RechargeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vxsocial.Table, vxsocial.FieldID, id),
			sqlgraph.To(rechargeorder.Table, rechargeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vxsocial.RechargeOrdersTable, vxsocial.RechargeOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(vs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransferOrders queries the transfer_orders edge of a VXSocial.
func (c *VXSocialClient) QueryTransferOrders(vs *VXSocial) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vxsocial.Table, vxsocial.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vxsocial.TransferOrdersTable, vxsocial.TransferOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(vs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VXSocialClient) Hooks() []Hook {
	return c.hooks.VXSocial
}

// Interceptors returns the client interceptors.
func (c *VXSocialClient) Interceptors() []Interceptor {
	return c.inters.VXSocial
}

func (c *VXSocialClient) mutate(ctx context.Context, m *VXSocialMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VXSocialCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VXSocialUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VXSocialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VXSocialDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown VXSocial mutation op: %q", m.Op())
	}
}

// WalletClient is a client for the Wallet schema.
type WalletClient struct {
	config
}

// NewWalletClient returns a client for the Wallet from the given config.
func NewWalletClient(c config) *WalletClient {
	return &WalletClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wallet.Hooks(f(g(h())))`.
func (c *WalletClient) Use(hooks ...Hook) {
	c.hooks.Wallet = append(c.hooks.Wallet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wallet.Intercept(f(g(h())))`.
func (c *WalletClient) Intercept(interceptors ...Interceptor) {
	c.inters.Wallet = append(c.inters.Wallet, interceptors...)
}

// Create returns a builder for creating a Wallet entity.
func (c *WalletClient) Create() *WalletCreate {
	mutation := newWalletMutation(c.config, OpCreate)
	return &WalletCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Wallet entities.
func (c *WalletClient) CreateBulk(builders ...*WalletCreate) *WalletCreateBulk {
	return &WalletCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WalletClient) MapCreateBulk(slice any, setFunc func(*WalletCreate, int)) *WalletCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WalletCreateBulk{err: fmt.Errorf("calling to WalletClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WalletCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WalletCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Wallet.
func (c *WalletClient) Update() *WalletUpdate {
	mutation := newWalletMutation(c.config, OpUpdate)
	return &WalletUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WalletClient) UpdateOne(w *Wallet) *WalletUpdateOne {
	mutation := newWalletMutation(c.config, OpUpdateOne, withWallet(w))
	return &WalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WalletClient) UpdateOneID(id int64) *WalletUpdateOne {
	mutation := newWalletMutation(c.config, OpUpdateOne, withWalletID(id))
	return &WalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Wallet.
func (c *WalletClient) Delete() *WalletDelete {
	mutation := newWalletMutation(c.config, OpDelete)
	return &WalletDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WalletClient) DeleteOne(w *Wallet) *WalletDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WalletClient) DeleteOneID(id int64) *WalletDeleteOne {
	builder := c.Delete().Where(wallet.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WalletDeleteOne{builder}
}

// Query returns a query builder for Wallet.
func (c *WalletClient) Query() *WalletQuery {
	return &WalletQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWallet},
		inters: c.Interceptors(),
	}
}

// Get returns a Wallet entity by its id.
func (c *WalletClient) Get(ctx context.Context, id int64) (*Wallet, error) {
	return c.Query().Where(wallet.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WalletClient) GetX(ctx context.Context, id int64) *Wallet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Wallet.
func (c *WalletClient) QueryUser(w *Wallet) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(wallet.Table, wallet.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, wallet.UserTable, wallet.UserColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a Wallet.
func (c *WalletClient) QuerySymbol(w *Wallet) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(wallet.Table, wallet.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, wallet.SymbolTable, wallet.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WalletClient) Hooks() []Hook {
	return c.hooks.Wallet
}

// Interceptors returns the client interceptors.
func (c *WalletClient) Interceptors() []Interceptor {
	return c.inters.Wallet
}

func (c *WalletClient) mutate(ctx context.Context, m *WalletMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WalletCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WalletUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WalletDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Wallet mutation op: %q", m.Op())
	}
}

// WithdrawAccountClient is a client for the WithdrawAccount schema.
type WithdrawAccountClient struct {
	config
}

// NewWithdrawAccountClient returns a client for the WithdrawAccount from the given config.
func NewWithdrawAccountClient(c config) *WithdrawAccountClient {
	return &WithdrawAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `withdrawaccount.Hooks(f(g(h())))`.
func (c *WithdrawAccountClient) Use(hooks ...Hook) {
	c.hooks.WithdrawAccount = append(c.hooks.WithdrawAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `withdrawaccount.Intercept(f(g(h())))`.
func (c *WithdrawAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.WithdrawAccount = append(c.inters.WithdrawAccount, interceptors...)
}

// Create returns a builder for creating a WithdrawAccount entity.
func (c *WithdrawAccountClient) Create() *WithdrawAccountCreate {
	mutation := newWithdrawAccountMutation(c.config, OpCreate)
	return &WithdrawAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WithdrawAccount entities.
func (c *WithdrawAccountClient) CreateBulk(builders ...*WithdrawAccountCreate) *WithdrawAccountCreateBulk {
	return &WithdrawAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WithdrawAccountClient) MapCreateBulk(slice any, setFunc func(*WithdrawAccountCreate, int)) *WithdrawAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WithdrawAccountCreateBulk{err: fmt.Errorf("calling to WithdrawAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WithdrawAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WithdrawAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WithdrawAccount.
func (c *WithdrawAccountClient) Update() *WithdrawAccountUpdate {
	mutation := newWithdrawAccountMutation(c.config, OpUpdate)
	return &WithdrawAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WithdrawAccountClient) UpdateOne(wa *WithdrawAccount) *WithdrawAccountUpdateOne {
	mutation := newWithdrawAccountMutation(c.config, OpUpdateOne, withWithdrawAccount(wa))
	return &WithdrawAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WithdrawAccountClient) UpdateOneID(id int64) *WithdrawAccountUpdateOne {
	mutation := newWithdrawAccountMutation(c.config, OpUpdateOne, withWithdrawAccountID(id))
	return &WithdrawAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WithdrawAccount.
func (c *WithdrawAccountClient) Delete() *WithdrawAccountDelete {
	mutation := newWithdrawAccountMutation(c.config, OpDelete)
	return &WithdrawAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WithdrawAccountClient) DeleteOne(wa *WithdrawAccount) *WithdrawAccountDeleteOne {
	return c.DeleteOneID(wa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WithdrawAccountClient) DeleteOneID(id int64) *WithdrawAccountDeleteOne {
	builder := c.Delete().Where(withdrawaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WithdrawAccountDeleteOne{builder}
}

// Query returns a query builder for WithdrawAccount.
func (c *WithdrawAccountClient) Query() *WithdrawAccountQuery {
	return &WithdrawAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWithdrawAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a WithdrawAccount entity by its id.
func (c *WithdrawAccountClient) Get(ctx context.Context, id int64) (*WithdrawAccount, error) {
	return c.Query().Where(withdrawaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WithdrawAccountClient) GetX(ctx context.Context, id int64) *WithdrawAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a WithdrawAccount.
func (c *WithdrawAccountClient) QueryUser(wa *WithdrawAccount) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(withdrawaccount.Table, withdrawaccount.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, withdrawaccount.UserTable, withdrawaccount.UserColumn),
		)
		fromV = sqlgraph.Neighbors(wa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WithdrawAccountClient) Hooks() []Hook {
	return c.hooks.WithdrawAccount
}

// Interceptors returns the client interceptors.
func (c *WithdrawAccountClient) Interceptors() []Interceptor {
	return c.inters.WithdrawAccount
}

func (c *WithdrawAccountClient) mutate(ctx context.Context, m *WithdrawAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WithdrawAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WithdrawAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WithdrawAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WithdrawAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown WithdrawAccount mutation op: %q", m.Op())
	}
}

// WithdrawRecordClient is a client for the WithdrawRecord schema.
type WithdrawRecordClient struct {
	config
}

// NewWithdrawRecordClient returns a client for the WithdrawRecord from the given config.
func NewWithdrawRecordClient(c config) *WithdrawRecordClient {
	return &WithdrawRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `withdrawrecord.Hooks(f(g(h())))`.
func (c *WithdrawRecordClient) Use(hooks ...Hook) {
	c.hooks.WithdrawRecord = append(c.hooks.WithdrawRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `withdrawrecord.Intercept(f(g(h())))`.
func (c *WithdrawRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.WithdrawRecord = append(c.inters.WithdrawRecord, interceptors...)
}

// Create returns a builder for creating a WithdrawRecord entity.
func (c *WithdrawRecordClient) Create() *WithdrawRecordCreate {
	mutation := newWithdrawRecordMutation(c.config, OpCreate)
	return &WithdrawRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WithdrawRecord entities.
func (c *WithdrawRecordClient) CreateBulk(builders ...*WithdrawRecordCreate) *WithdrawRecordCreateBulk {
	return &WithdrawRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WithdrawRecordClient) MapCreateBulk(slice any, setFunc func(*WithdrawRecordCreate, int)) *WithdrawRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WithdrawRecordCreateBulk{err: fmt.Errorf("calling to WithdrawRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WithdrawRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WithdrawRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WithdrawRecord.
func (c *WithdrawRecordClient) Update() *WithdrawRecordUpdate {
	mutation := newWithdrawRecordMutation(c.config, OpUpdate)
	return &WithdrawRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WithdrawRecordClient) UpdateOne(wr *WithdrawRecord) *WithdrawRecordUpdateOne {
	mutation := newWithdrawRecordMutation(c.config, OpUpdateOne, withWithdrawRecord(wr))
	return &WithdrawRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WithdrawRecordClient) UpdateOneID(id int64) *WithdrawRecordUpdateOne {
	mutation := newWithdrawRecordMutation(c.config, OpUpdateOne, withWithdrawRecordID(id))
	return &WithdrawRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WithdrawRecord.
func (c *WithdrawRecordClient) Delete() *WithdrawRecordDelete {
	mutation := newWithdrawRecordMutation(c.config, OpDelete)
	return &WithdrawRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WithdrawRecordClient) DeleteOne(wr *WithdrawRecord) *WithdrawRecordDeleteOne {
	return c.DeleteOneID(wr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WithdrawRecordClient) DeleteOneID(id int64) *WithdrawRecordDeleteOne {
	builder := c.Delete().Where(withdrawrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WithdrawRecordDeleteOne{builder}
}

// Query returns a query builder for WithdrawRecord.
func (c *WithdrawRecordClient) Query() *WithdrawRecordQuery {
	return &WithdrawRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWithdrawRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a WithdrawRecord entity by its id.
func (c *WithdrawRecordClient) Get(ctx context.Context, id int64) (*WithdrawRecord, error) {
	return c.Query().Where(withdrawrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WithdrawRecordClient) GetX(ctx context.Context, id int64) *WithdrawRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a WithdrawRecord.
func (c *WithdrawRecordClient) QueryUser(wr *WithdrawRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(withdrawrecord.Table, withdrawrecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, withdrawrecord.UserTable, withdrawrecord.UserColumn),
		)
		fromV = sqlgraph.Neighbors(wr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOperateUser queries the operate_user edge of a WithdrawRecord.
func (c *WithdrawRecordClient) QueryOperateUser(wr *WithdrawRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(withdrawrecord.Table, withdrawrecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, withdrawrecord.OperateUserTable, withdrawrecord.OperateUserColumn),
		)
		fromV = sqlgraph.Neighbors(wr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransferOrder queries the transfer_order edge of a WithdrawRecord.
func (c *WithdrawRecordClient) QueryTransferOrder(wr *WithdrawRecord) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(withdrawrecord.Table, withdrawrecord.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, withdrawrecord.TransferOrderTable, withdrawrecord.TransferOrderColumn),
		)
		fromV = sqlgraph.Neighbors(wr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WithdrawRecordClient) Hooks() []Hook {
	return c.hooks.WithdrawRecord
}

// Interceptors returns the client interceptors.
func (c *WithdrawRecordClient) Interceptors() []Interceptor {
	return c.inters.WithdrawRecord
}

func (c *WithdrawRecordClient) mutate(ctx context.Context, m *WithdrawRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WithdrawRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WithdrawRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WithdrawRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WithdrawRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown WithdrawRecord mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Artwork, ArtworkLike, Bill, CDKInfo, Campaign, CampaignOrder, CloudFile,
		Collect, CostAccount, CostBill, Device, DeviceGpuMission, DeviceRebootTime,
		EarnBill, EnumCondition, EnumMissionStatus, ExtraService, ExtraServiceOrder,
		ExtraServicePrice, FrpcInfo, FrpsInfo, Gpu, HmacKeyPair, IncomeManage,
		InputLog, Invite, LoginRecord, Lotto, LottoChanceRule, LottoGetCountRecord,
		LottoPrize, LottoRecord, LottoUserCount, Mission, MissionBatch,
		MissionCategory, MissionConsumeOrder, MissionExtraService, MissionKeyPair,
		MissionKind, MissionOrder, MissionProduceOrder, MissionProduction, OutputLog,
		PlatformAccount, Price, ProfitAccount, ProfitSetting, RechargeCampaignRule,
		RechargeOrder, RenewalAgreement, Symbol, TransferOrder, TroubleDeduct, User,
		UserDevice, VXAccount, VXSocial, Wallet, WithdrawAccount,
		WithdrawRecord []ent.Hook
	}
	inters struct {
		Artwork, ArtworkLike, Bill, CDKInfo, Campaign, CampaignOrder, CloudFile,
		Collect, CostAccount, CostBill, Device, DeviceGpuMission, DeviceRebootTime,
		EarnBill, EnumCondition, EnumMissionStatus, ExtraService, ExtraServiceOrder,
		ExtraServicePrice, FrpcInfo, FrpsInfo, Gpu, HmacKeyPair, IncomeManage,
		InputLog, Invite, LoginRecord, Lotto, LottoChanceRule, LottoGetCountRecord,
		LottoPrize, LottoRecord, LottoUserCount, Mission, MissionBatch,
		MissionCategory, MissionConsumeOrder, MissionExtraService, MissionKeyPair,
		MissionKind, MissionOrder, MissionProduceOrder, MissionProduction, OutputLog,
		PlatformAccount, Price, ProfitAccount, ProfitSetting, RechargeCampaignRule,
		RechargeOrder, RenewalAgreement, Symbol, TransferOrder, TroubleDeduct, User,
		UserDevice, VXAccount, VXSocial, Wallet, WithdrawAccount,
		WithdrawRecord []ent.Interceptor
	}
)
