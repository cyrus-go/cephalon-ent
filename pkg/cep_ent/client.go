// Code generated by ent, DO NOT EDIT.

package cep_ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/bill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/campaign"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/campaignorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/collect"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/device"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/devicegpumission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/earnbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enumcondition"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enummissionstatus"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/frpcinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/frpsinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/gpu"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/hmackeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/inputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/invite"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/loginrecord"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/mission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionbatch"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionconsumeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkind"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionproduceorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionproduction"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/outputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/platformaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/price"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitsetting"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/rechargecampaignrule"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/rechargeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/symbol"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/transferorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/user"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/userdevice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxsocial"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/wallet"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Bill is the client for interacting with the Bill builders.
	Bill *BillClient
	// Campaign is the client for interacting with the Campaign builders.
	Campaign *CampaignClient
	// CampaignOrder is the client for interacting with the CampaignOrder builders.
	CampaignOrder *CampaignOrderClient
	// Collect is the client for interacting with the Collect builders.
	Collect *CollectClient
	// CostAccount is the client for interacting with the CostAccount builders.
	CostAccount *CostAccountClient
	// CostBill is the client for interacting with the CostBill builders.
	CostBill *CostBillClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// DeviceGpuMission is the client for interacting with the DeviceGpuMission builders.
	DeviceGpuMission *DeviceGpuMissionClient
	// EarnBill is the client for interacting with the EarnBill builders.
	EarnBill *EarnBillClient
	// EnumCondition is the client for interacting with the EnumCondition builders.
	EnumCondition *EnumConditionClient
	// EnumMissionStatus is the client for interacting with the EnumMissionStatus builders.
	EnumMissionStatus *EnumMissionStatusClient
	// FrpcInfo is the client for interacting with the FrpcInfo builders.
	FrpcInfo *FrpcInfoClient
	// FrpsInfo is the client for interacting with the FrpsInfo builders.
	FrpsInfo *FrpsInfoClient
	// Gpu is the client for interacting with the Gpu builders.
	Gpu *GpuClient
	// HmacKeyPair is the client for interacting with the HmacKeyPair builders.
	HmacKeyPair *HmacKeyPairClient
	// InputLog is the client for interacting with the InputLog builders.
	InputLog *InputLogClient
	// Invite is the client for interacting with the Invite builders.
	Invite *InviteClient
	// LoginRecord is the client for interacting with the LoginRecord builders.
	LoginRecord *LoginRecordClient
	// Mission is the client for interacting with the Mission builders.
	Mission *MissionClient
	// MissionBatch is the client for interacting with the MissionBatch builders.
	MissionBatch *MissionBatchClient
	// MissionConsumeOrder is the client for interacting with the MissionConsumeOrder builders.
	MissionConsumeOrder *MissionConsumeOrderClient
	// MissionKeyPair is the client for interacting with the MissionKeyPair builders.
	MissionKeyPair *MissionKeyPairClient
	// MissionKind is the client for interacting with the MissionKind builders.
	MissionKind *MissionKindClient
	// MissionOrder is the client for interacting with the MissionOrder builders.
	MissionOrder *MissionOrderClient
	// MissionProduceOrder is the client for interacting with the MissionProduceOrder builders.
	MissionProduceOrder *MissionProduceOrderClient
	// MissionProduction is the client for interacting with the MissionProduction builders.
	MissionProduction *MissionProductionClient
	// OutputLog is the client for interacting with the OutputLog builders.
	OutputLog *OutputLogClient
	// PlatformAccount is the client for interacting with the PlatformAccount builders.
	PlatformAccount *PlatformAccountClient
	// Price is the client for interacting with the Price builders.
	Price *PriceClient
	// ProfitAccount is the client for interacting with the ProfitAccount builders.
	ProfitAccount *ProfitAccountClient
	// ProfitSetting is the client for interacting with the ProfitSetting builders.
	ProfitSetting *ProfitSettingClient
	// RechargeCampaignRule is the client for interacting with the RechargeCampaignRule builders.
	RechargeCampaignRule *RechargeCampaignRuleClient
	// RechargeOrder is the client for interacting with the RechargeOrder builders.
	RechargeOrder *RechargeOrderClient
	// Symbol is the client for interacting with the Symbol builders.
	Symbol *SymbolClient
	// TransferOrder is the client for interacting with the TransferOrder builders.
	TransferOrder *TransferOrderClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserDevice is the client for interacting with the UserDevice builders.
	UserDevice *UserDeviceClient
	// VXAccount is the client for interacting with the VXAccount builders.
	VXAccount *VXAccountClient
	// VXSocial is the client for interacting with the VXSocial builders.
	VXSocial *VXSocialClient
	// Wallet is the client for interacting with the Wallet builders.
	Wallet *WalletClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Bill = NewBillClient(c.config)
	c.Campaign = NewCampaignClient(c.config)
	c.CampaignOrder = NewCampaignOrderClient(c.config)
	c.Collect = NewCollectClient(c.config)
	c.CostAccount = NewCostAccountClient(c.config)
	c.CostBill = NewCostBillClient(c.config)
	c.Device = NewDeviceClient(c.config)
	c.DeviceGpuMission = NewDeviceGpuMissionClient(c.config)
	c.EarnBill = NewEarnBillClient(c.config)
	c.EnumCondition = NewEnumConditionClient(c.config)
	c.EnumMissionStatus = NewEnumMissionStatusClient(c.config)
	c.FrpcInfo = NewFrpcInfoClient(c.config)
	c.FrpsInfo = NewFrpsInfoClient(c.config)
	c.Gpu = NewGpuClient(c.config)
	c.HmacKeyPair = NewHmacKeyPairClient(c.config)
	c.InputLog = NewInputLogClient(c.config)
	c.Invite = NewInviteClient(c.config)
	c.LoginRecord = NewLoginRecordClient(c.config)
	c.Mission = NewMissionClient(c.config)
	c.MissionBatch = NewMissionBatchClient(c.config)
	c.MissionConsumeOrder = NewMissionConsumeOrderClient(c.config)
	c.MissionKeyPair = NewMissionKeyPairClient(c.config)
	c.MissionKind = NewMissionKindClient(c.config)
	c.MissionOrder = NewMissionOrderClient(c.config)
	c.MissionProduceOrder = NewMissionProduceOrderClient(c.config)
	c.MissionProduction = NewMissionProductionClient(c.config)
	c.OutputLog = NewOutputLogClient(c.config)
	c.PlatformAccount = NewPlatformAccountClient(c.config)
	c.Price = NewPriceClient(c.config)
	c.ProfitAccount = NewProfitAccountClient(c.config)
	c.ProfitSetting = NewProfitSettingClient(c.config)
	c.RechargeCampaignRule = NewRechargeCampaignRuleClient(c.config)
	c.RechargeOrder = NewRechargeOrderClient(c.config)
	c.Symbol = NewSymbolClient(c.config)
	c.TransferOrder = NewTransferOrderClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserDevice = NewUserDeviceClient(c.config)
	c.VXAccount = NewVXAccountClient(c.config)
	c.VXSocial = NewVXSocialClient(c.config)
	c.Wallet = NewWalletClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("cep_ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("cep_ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Bill:                 NewBillClient(cfg),
		Campaign:             NewCampaignClient(cfg),
		CampaignOrder:        NewCampaignOrderClient(cfg),
		Collect:              NewCollectClient(cfg),
		CostAccount:          NewCostAccountClient(cfg),
		CostBill:             NewCostBillClient(cfg),
		Device:               NewDeviceClient(cfg),
		DeviceGpuMission:     NewDeviceGpuMissionClient(cfg),
		EarnBill:             NewEarnBillClient(cfg),
		EnumCondition:        NewEnumConditionClient(cfg),
		EnumMissionStatus:    NewEnumMissionStatusClient(cfg),
		FrpcInfo:             NewFrpcInfoClient(cfg),
		FrpsInfo:             NewFrpsInfoClient(cfg),
		Gpu:                  NewGpuClient(cfg),
		HmacKeyPair:          NewHmacKeyPairClient(cfg),
		InputLog:             NewInputLogClient(cfg),
		Invite:               NewInviteClient(cfg),
		LoginRecord:          NewLoginRecordClient(cfg),
		Mission:              NewMissionClient(cfg),
		MissionBatch:         NewMissionBatchClient(cfg),
		MissionConsumeOrder:  NewMissionConsumeOrderClient(cfg),
		MissionKeyPair:       NewMissionKeyPairClient(cfg),
		MissionKind:          NewMissionKindClient(cfg),
		MissionOrder:         NewMissionOrderClient(cfg),
		MissionProduceOrder:  NewMissionProduceOrderClient(cfg),
		MissionProduction:    NewMissionProductionClient(cfg),
		OutputLog:            NewOutputLogClient(cfg),
		PlatformAccount:      NewPlatformAccountClient(cfg),
		Price:                NewPriceClient(cfg),
		ProfitAccount:        NewProfitAccountClient(cfg),
		ProfitSetting:        NewProfitSettingClient(cfg),
		RechargeCampaignRule: NewRechargeCampaignRuleClient(cfg),
		RechargeOrder:        NewRechargeOrderClient(cfg),
		Symbol:               NewSymbolClient(cfg),
		TransferOrder:        NewTransferOrderClient(cfg),
		User:                 NewUserClient(cfg),
		UserDevice:           NewUserDeviceClient(cfg),
		VXAccount:            NewVXAccountClient(cfg),
		VXSocial:             NewVXSocialClient(cfg),
		Wallet:               NewWalletClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Bill:                 NewBillClient(cfg),
		Campaign:             NewCampaignClient(cfg),
		CampaignOrder:        NewCampaignOrderClient(cfg),
		Collect:              NewCollectClient(cfg),
		CostAccount:          NewCostAccountClient(cfg),
		CostBill:             NewCostBillClient(cfg),
		Device:               NewDeviceClient(cfg),
		DeviceGpuMission:     NewDeviceGpuMissionClient(cfg),
		EarnBill:             NewEarnBillClient(cfg),
		EnumCondition:        NewEnumConditionClient(cfg),
		EnumMissionStatus:    NewEnumMissionStatusClient(cfg),
		FrpcInfo:             NewFrpcInfoClient(cfg),
		FrpsInfo:             NewFrpsInfoClient(cfg),
		Gpu:                  NewGpuClient(cfg),
		HmacKeyPair:          NewHmacKeyPairClient(cfg),
		InputLog:             NewInputLogClient(cfg),
		Invite:               NewInviteClient(cfg),
		LoginRecord:          NewLoginRecordClient(cfg),
		Mission:              NewMissionClient(cfg),
		MissionBatch:         NewMissionBatchClient(cfg),
		MissionConsumeOrder:  NewMissionConsumeOrderClient(cfg),
		MissionKeyPair:       NewMissionKeyPairClient(cfg),
		MissionKind:          NewMissionKindClient(cfg),
		MissionOrder:         NewMissionOrderClient(cfg),
		MissionProduceOrder:  NewMissionProduceOrderClient(cfg),
		MissionProduction:    NewMissionProductionClient(cfg),
		OutputLog:            NewOutputLogClient(cfg),
		PlatformAccount:      NewPlatformAccountClient(cfg),
		Price:                NewPriceClient(cfg),
		ProfitAccount:        NewProfitAccountClient(cfg),
		ProfitSetting:        NewProfitSettingClient(cfg),
		RechargeCampaignRule: NewRechargeCampaignRuleClient(cfg),
		RechargeOrder:        NewRechargeOrderClient(cfg),
		Symbol:               NewSymbolClient(cfg),
		TransferOrder:        NewTransferOrderClient(cfg),
		User:                 NewUserClient(cfg),
		UserDevice:           NewUserDeviceClient(cfg),
		VXAccount:            NewVXAccountClient(cfg),
		VXSocial:             NewVXSocialClient(cfg),
		Wallet:               NewWalletClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Bill.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Bill, c.Campaign, c.CampaignOrder, c.Collect, c.CostAccount, c.CostBill,
		c.Device, c.DeviceGpuMission, c.EarnBill, c.EnumCondition, c.EnumMissionStatus,
		c.FrpcInfo, c.FrpsInfo, c.Gpu, c.HmacKeyPair, c.InputLog, c.Invite,
		c.LoginRecord, c.Mission, c.MissionBatch, c.MissionConsumeOrder,
		c.MissionKeyPair, c.MissionKind, c.MissionOrder, c.MissionProduceOrder,
		c.MissionProduction, c.OutputLog, c.PlatformAccount, c.Price, c.ProfitAccount,
		c.ProfitSetting, c.RechargeCampaignRule, c.RechargeOrder, c.Symbol,
		c.TransferOrder, c.User, c.UserDevice, c.VXAccount, c.VXSocial, c.Wallet,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Bill, c.Campaign, c.CampaignOrder, c.Collect, c.CostAccount, c.CostBill,
		c.Device, c.DeviceGpuMission, c.EarnBill, c.EnumCondition, c.EnumMissionStatus,
		c.FrpcInfo, c.FrpsInfo, c.Gpu, c.HmacKeyPair, c.InputLog, c.Invite,
		c.LoginRecord, c.Mission, c.MissionBatch, c.MissionConsumeOrder,
		c.MissionKeyPair, c.MissionKind, c.MissionOrder, c.MissionProduceOrder,
		c.MissionProduction, c.OutputLog, c.PlatformAccount, c.Price, c.ProfitAccount,
		c.ProfitSetting, c.RechargeCampaignRule, c.RechargeOrder, c.Symbol,
		c.TransferOrder, c.User, c.UserDevice, c.VXAccount, c.VXSocial, c.Wallet,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BillMutation:
		return c.Bill.mutate(ctx, m)
	case *CampaignMutation:
		return c.Campaign.mutate(ctx, m)
	case *CampaignOrderMutation:
		return c.CampaignOrder.mutate(ctx, m)
	case *CollectMutation:
		return c.Collect.mutate(ctx, m)
	case *CostAccountMutation:
		return c.CostAccount.mutate(ctx, m)
	case *CostBillMutation:
		return c.CostBill.mutate(ctx, m)
	case *DeviceMutation:
		return c.Device.mutate(ctx, m)
	case *DeviceGpuMissionMutation:
		return c.DeviceGpuMission.mutate(ctx, m)
	case *EarnBillMutation:
		return c.EarnBill.mutate(ctx, m)
	case *EnumConditionMutation:
		return c.EnumCondition.mutate(ctx, m)
	case *EnumMissionStatusMutation:
		return c.EnumMissionStatus.mutate(ctx, m)
	case *FrpcInfoMutation:
		return c.FrpcInfo.mutate(ctx, m)
	case *FrpsInfoMutation:
		return c.FrpsInfo.mutate(ctx, m)
	case *GpuMutation:
		return c.Gpu.mutate(ctx, m)
	case *HmacKeyPairMutation:
		return c.HmacKeyPair.mutate(ctx, m)
	case *InputLogMutation:
		return c.InputLog.mutate(ctx, m)
	case *InviteMutation:
		return c.Invite.mutate(ctx, m)
	case *LoginRecordMutation:
		return c.LoginRecord.mutate(ctx, m)
	case *MissionMutation:
		return c.Mission.mutate(ctx, m)
	case *MissionBatchMutation:
		return c.MissionBatch.mutate(ctx, m)
	case *MissionConsumeOrderMutation:
		return c.MissionConsumeOrder.mutate(ctx, m)
	case *MissionKeyPairMutation:
		return c.MissionKeyPair.mutate(ctx, m)
	case *MissionKindMutation:
		return c.MissionKind.mutate(ctx, m)
	case *MissionOrderMutation:
		return c.MissionOrder.mutate(ctx, m)
	case *MissionProduceOrderMutation:
		return c.MissionProduceOrder.mutate(ctx, m)
	case *MissionProductionMutation:
		return c.MissionProduction.mutate(ctx, m)
	case *OutputLogMutation:
		return c.OutputLog.mutate(ctx, m)
	case *PlatformAccountMutation:
		return c.PlatformAccount.mutate(ctx, m)
	case *PriceMutation:
		return c.Price.mutate(ctx, m)
	case *ProfitAccountMutation:
		return c.ProfitAccount.mutate(ctx, m)
	case *ProfitSettingMutation:
		return c.ProfitSetting.mutate(ctx, m)
	case *RechargeCampaignRuleMutation:
		return c.RechargeCampaignRule.mutate(ctx, m)
	case *RechargeOrderMutation:
		return c.RechargeOrder.mutate(ctx, m)
	case *SymbolMutation:
		return c.Symbol.mutate(ctx, m)
	case *TransferOrderMutation:
		return c.TransferOrder.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserDeviceMutation:
		return c.UserDevice.mutate(ctx, m)
	case *VXAccountMutation:
		return c.VXAccount.mutate(ctx, m)
	case *VXSocialMutation:
		return c.VXSocial.mutate(ctx, m)
	case *WalletMutation:
		return c.Wallet.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("cep_ent: unknown mutation type %T", m)
	}
}

// BillClient is a client for the Bill schema.
type BillClient struct {
	config
}

// NewBillClient returns a client for the Bill from the given config.
func NewBillClient(c config) *BillClient {
	return &BillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bill.Hooks(f(g(h())))`.
func (c *BillClient) Use(hooks ...Hook) {
	c.hooks.Bill = append(c.hooks.Bill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bill.Intercept(f(g(h())))`.
func (c *BillClient) Intercept(interceptors ...Interceptor) {
	c.inters.Bill = append(c.inters.Bill, interceptors...)
}

// Create returns a builder for creating a Bill entity.
func (c *BillClient) Create() *BillCreate {
	mutation := newBillMutation(c.config, OpCreate)
	return &BillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Bill entities.
func (c *BillClient) CreateBulk(builders ...*BillCreate) *BillCreateBulk {
	return &BillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BillClient) MapCreateBulk(slice any, setFunc func(*BillCreate, int)) *BillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BillCreateBulk{err: fmt.Errorf("calling to BillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Bill.
func (c *BillClient) Update() *BillUpdate {
	mutation := newBillMutation(c.config, OpUpdate)
	return &BillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BillClient) UpdateOne(b *Bill) *BillUpdateOne {
	mutation := newBillMutation(c.config, OpUpdateOne, withBill(b))
	return &BillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BillClient) UpdateOneID(id int64) *BillUpdateOne {
	mutation := newBillMutation(c.config, OpUpdateOne, withBillID(id))
	return &BillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Bill.
func (c *BillClient) Delete() *BillDelete {
	mutation := newBillMutation(c.config, OpDelete)
	return &BillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BillClient) DeleteOne(b *Bill) *BillDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BillClient) DeleteOneID(id int64) *BillDeleteOne {
	builder := c.Delete().Where(bill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BillDeleteOne{builder}
}

// Query returns a query builder for Bill.
func (c *BillClient) Query() *BillQuery {
	return &BillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBill},
		inters: c.Interceptors(),
	}
}

// Get returns a Bill entity by its id.
func (c *BillClient) Get(ctx context.Context, id int64) (*Bill, error) {
	return c.Query().Where(bill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BillClient) GetX(ctx context.Context, id int64) *Bill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySourceUser queries the source_user edge of a Bill.
func (c *BillClient) QuerySourceUser(b *Bill) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.SourceUserTable, bill.SourceUserColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetUser queries the target_user edge of a Bill.
func (c *BillClient) QueryTargetUser(b *Bill) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.TargetUserTable, bill.TargetUserColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransferOrder queries the transfer_order edge of a Bill.
func (c *BillClient) QueryTransferOrder(b *Bill) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.TransferOrderTable, bill.TransferOrderColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrder queries the mission_order edge of a Bill.
func (c *BillClient) QueryMissionOrder(b *Bill) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.MissionOrderTable, bill.MissionOrderColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvite queries the invite edge of a Bill.
func (c *BillClient) QueryInvite(b *Bill) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.InviteTable, bill.InviteColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a Bill.
func (c *BillClient) QuerySymbol(b *Bill) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bill.Table, bill.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bill.SymbolTable, bill.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BillClient) Hooks() []Hook {
	return c.hooks.Bill
}

// Interceptors returns the client interceptors.
func (c *BillClient) Interceptors() []Interceptor {
	return c.inters.Bill
}

func (c *BillClient) mutate(ctx context.Context, m *BillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Bill mutation op: %q", m.Op())
	}
}

// CampaignClient is a client for the Campaign schema.
type CampaignClient struct {
	config
}

// NewCampaignClient returns a client for the Campaign from the given config.
func NewCampaignClient(c config) *CampaignClient {
	return &CampaignClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `campaign.Hooks(f(g(h())))`.
func (c *CampaignClient) Use(hooks ...Hook) {
	c.hooks.Campaign = append(c.hooks.Campaign, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `campaign.Intercept(f(g(h())))`.
func (c *CampaignClient) Intercept(interceptors ...Interceptor) {
	c.inters.Campaign = append(c.inters.Campaign, interceptors...)
}

// Create returns a builder for creating a Campaign entity.
func (c *CampaignClient) Create() *CampaignCreate {
	mutation := newCampaignMutation(c.config, OpCreate)
	return &CampaignCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Campaign entities.
func (c *CampaignClient) CreateBulk(builders ...*CampaignCreate) *CampaignCreateBulk {
	return &CampaignCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CampaignClient) MapCreateBulk(slice any, setFunc func(*CampaignCreate, int)) *CampaignCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CampaignCreateBulk{err: fmt.Errorf("calling to CampaignClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CampaignCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CampaignCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Campaign.
func (c *CampaignClient) Update() *CampaignUpdate {
	mutation := newCampaignMutation(c.config, OpUpdate)
	return &CampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CampaignClient) UpdateOne(ca *Campaign) *CampaignUpdateOne {
	mutation := newCampaignMutation(c.config, OpUpdateOne, withCampaign(ca))
	return &CampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CampaignClient) UpdateOneID(id int64) *CampaignUpdateOne {
	mutation := newCampaignMutation(c.config, OpUpdateOne, withCampaignID(id))
	return &CampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Campaign.
func (c *CampaignClient) Delete() *CampaignDelete {
	mutation := newCampaignMutation(c.config, OpDelete)
	return &CampaignDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CampaignClient) DeleteOne(ca *Campaign) *CampaignDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CampaignClient) DeleteOneID(id int64) *CampaignDeleteOne {
	builder := c.Delete().Where(campaign.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CampaignDeleteOne{builder}
}

// Query returns a query builder for Campaign.
func (c *CampaignClient) Query() *CampaignQuery {
	return &CampaignQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCampaign},
		inters: c.Interceptors(),
	}
}

// Get returns a Campaign entity by its id.
func (c *CampaignClient) Get(ctx context.Context, id int64) (*Campaign, error) {
	return c.Query().Where(campaign.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CampaignClient) GetX(ctx context.Context, id int64) *Campaign {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInvites queries the invites edge of a Campaign.
func (c *CampaignClient) QueryInvites(ca *Campaign) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaign.Table, campaign.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, campaign.InvitesTable, campaign.InvitesColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaignOrders queries the campaign_orders edge of a Campaign.
func (c *CampaignClient) QueryCampaignOrders(ca *Campaign) *CampaignOrderQuery {
	query := (&CampaignOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaign.Table, campaign.FieldID, id),
			sqlgraph.To(campaignorder.Table, campaignorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, campaign.CampaignOrdersTable, campaign.CampaignOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CampaignClient) Hooks() []Hook {
	return c.hooks.Campaign
}

// Interceptors returns the client interceptors.
func (c *CampaignClient) Interceptors() []Interceptor {
	return c.inters.Campaign
}

func (c *CampaignClient) mutate(ctx context.Context, m *CampaignMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CampaignCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CampaignDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Campaign mutation op: %q", m.Op())
	}
}

// CampaignOrderClient is a client for the CampaignOrder schema.
type CampaignOrderClient struct {
	config
}

// NewCampaignOrderClient returns a client for the CampaignOrder from the given config.
func NewCampaignOrderClient(c config) *CampaignOrderClient {
	return &CampaignOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `campaignorder.Hooks(f(g(h())))`.
func (c *CampaignOrderClient) Use(hooks ...Hook) {
	c.hooks.CampaignOrder = append(c.hooks.CampaignOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `campaignorder.Intercept(f(g(h())))`.
func (c *CampaignOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.CampaignOrder = append(c.inters.CampaignOrder, interceptors...)
}

// Create returns a builder for creating a CampaignOrder entity.
func (c *CampaignOrderClient) Create() *CampaignOrderCreate {
	mutation := newCampaignOrderMutation(c.config, OpCreate)
	return &CampaignOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CampaignOrder entities.
func (c *CampaignOrderClient) CreateBulk(builders ...*CampaignOrderCreate) *CampaignOrderCreateBulk {
	return &CampaignOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CampaignOrderClient) MapCreateBulk(slice any, setFunc func(*CampaignOrderCreate, int)) *CampaignOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CampaignOrderCreateBulk{err: fmt.Errorf("calling to CampaignOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CampaignOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CampaignOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CampaignOrder.
func (c *CampaignOrderClient) Update() *CampaignOrderUpdate {
	mutation := newCampaignOrderMutation(c.config, OpUpdate)
	return &CampaignOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CampaignOrderClient) UpdateOne(co *CampaignOrder) *CampaignOrderUpdateOne {
	mutation := newCampaignOrderMutation(c.config, OpUpdateOne, withCampaignOrder(co))
	return &CampaignOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CampaignOrderClient) UpdateOneID(id int64) *CampaignOrderUpdateOne {
	mutation := newCampaignOrderMutation(c.config, OpUpdateOne, withCampaignOrderID(id))
	return &CampaignOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CampaignOrder.
func (c *CampaignOrderClient) Delete() *CampaignOrderDelete {
	mutation := newCampaignOrderMutation(c.config, OpDelete)
	return &CampaignOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CampaignOrderClient) DeleteOne(co *CampaignOrder) *CampaignOrderDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CampaignOrderClient) DeleteOneID(id int64) *CampaignOrderDeleteOne {
	builder := c.Delete().Where(campaignorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CampaignOrderDeleteOne{builder}
}

// Query returns a query builder for CampaignOrder.
func (c *CampaignOrderClient) Query() *CampaignOrderQuery {
	return &CampaignOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCampaignOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a CampaignOrder entity by its id.
func (c *CampaignOrderClient) Get(ctx context.Context, id int64) (*CampaignOrder, error) {
	return c.Query().Where(campaignorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CampaignOrderClient) GetX(ctx context.Context, id int64) *CampaignOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CampaignOrder.
func (c *CampaignOrderClient) QueryUser(co *CampaignOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaignorder.Table, campaignorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, campaignorder.UserTable, campaignorder.UserColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaign queries the campaign edge of a CampaignOrder.
func (c *CampaignOrderClient) QueryCampaign(co *CampaignOrder) *CampaignQuery {
	query := (&CampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaignorder.Table, campaignorder.FieldID, id),
			sqlgraph.To(campaign.Table, campaign.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, campaignorder.CampaignTable, campaignorder.CampaignColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a CampaignOrder.
func (c *CampaignOrderClient) QueryCostBills(co *CampaignOrder) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaignorder.Table, campaignorder.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, campaignorder.CostBillsTable, campaignorder.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRechargeOrder queries the recharge_order edge of a CampaignOrder.
func (c *CampaignOrderClient) QueryRechargeOrder(co *CampaignOrder) *RechargeOrderQuery {
	query := (&RechargeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaignorder.Table, campaignorder.FieldID, id),
			sqlgraph.To(rechargeorder.Table, rechargeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, campaignorder.RechargeOrderTable, campaignorder.RechargeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CampaignOrderClient) Hooks() []Hook {
	return c.hooks.CampaignOrder
}

// Interceptors returns the client interceptors.
func (c *CampaignOrderClient) Interceptors() []Interceptor {
	return c.inters.CampaignOrder
}

func (c *CampaignOrderClient) mutate(ctx context.Context, m *CampaignOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CampaignOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CampaignOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CampaignOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CampaignOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown CampaignOrder mutation op: %q", m.Op())
	}
}

// CollectClient is a client for the Collect schema.
type CollectClient struct {
	config
}

// NewCollectClient returns a client for the Collect from the given config.
func NewCollectClient(c config) *CollectClient {
	return &CollectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `collect.Hooks(f(g(h())))`.
func (c *CollectClient) Use(hooks ...Hook) {
	c.hooks.Collect = append(c.hooks.Collect, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `collect.Intercept(f(g(h())))`.
func (c *CollectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Collect = append(c.inters.Collect, interceptors...)
}

// Create returns a builder for creating a Collect entity.
func (c *CollectClient) Create() *CollectCreate {
	mutation := newCollectMutation(c.config, OpCreate)
	return &CollectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Collect entities.
func (c *CollectClient) CreateBulk(builders ...*CollectCreate) *CollectCreateBulk {
	return &CollectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CollectClient) MapCreateBulk(slice any, setFunc func(*CollectCreate, int)) *CollectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CollectCreateBulk{err: fmt.Errorf("calling to CollectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CollectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CollectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Collect.
func (c *CollectClient) Update() *CollectUpdate {
	mutation := newCollectMutation(c.config, OpUpdate)
	return &CollectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CollectClient) UpdateOne(co *Collect) *CollectUpdateOne {
	mutation := newCollectMutation(c.config, OpUpdateOne, withCollect(co))
	return &CollectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CollectClient) UpdateOneID(id int64) *CollectUpdateOne {
	mutation := newCollectMutation(c.config, OpUpdateOne, withCollectID(id))
	return &CollectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Collect.
func (c *CollectClient) Delete() *CollectDelete {
	mutation := newCollectMutation(c.config, OpDelete)
	return &CollectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CollectClient) DeleteOne(co *Collect) *CollectDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CollectClient) DeleteOneID(id int64) *CollectDeleteOne {
	builder := c.Delete().Where(collect.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CollectDeleteOne{builder}
}

// Query returns a query builder for Collect.
func (c *CollectClient) Query() *CollectQuery {
	return &CollectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCollect},
		inters: c.Interceptors(),
	}
}

// Get returns a Collect entity by its id.
func (c *CollectClient) Get(ctx context.Context, id int64) (*Collect, error) {
	return c.Query().Where(collect.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CollectClient) GetX(ctx context.Context, id int64) *Collect {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Collect.
func (c *CollectClient) QueryUser(co *Collect) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collect.Table, collect.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, collect.UserTable, collect.UserColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CollectClient) Hooks() []Hook {
	return c.hooks.Collect
}

// Interceptors returns the client interceptors.
func (c *CollectClient) Interceptors() []Interceptor {
	return c.inters.Collect
}

func (c *CollectClient) mutate(ctx context.Context, m *CollectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CollectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CollectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CollectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CollectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Collect mutation op: %q", m.Op())
	}
}

// CostAccountClient is a client for the CostAccount schema.
type CostAccountClient struct {
	config
}

// NewCostAccountClient returns a client for the CostAccount from the given config.
func NewCostAccountClient(c config) *CostAccountClient {
	return &CostAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `costaccount.Hooks(f(g(h())))`.
func (c *CostAccountClient) Use(hooks ...Hook) {
	c.hooks.CostAccount = append(c.hooks.CostAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `costaccount.Intercept(f(g(h())))`.
func (c *CostAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.CostAccount = append(c.inters.CostAccount, interceptors...)
}

// Create returns a builder for creating a CostAccount entity.
func (c *CostAccountClient) Create() *CostAccountCreate {
	mutation := newCostAccountMutation(c.config, OpCreate)
	return &CostAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CostAccount entities.
func (c *CostAccountClient) CreateBulk(builders ...*CostAccountCreate) *CostAccountCreateBulk {
	return &CostAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CostAccountClient) MapCreateBulk(slice any, setFunc func(*CostAccountCreate, int)) *CostAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CostAccountCreateBulk{err: fmt.Errorf("calling to CostAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CostAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CostAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CostAccount.
func (c *CostAccountClient) Update() *CostAccountUpdate {
	mutation := newCostAccountMutation(c.config, OpUpdate)
	return &CostAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CostAccountClient) UpdateOne(ca *CostAccount) *CostAccountUpdateOne {
	mutation := newCostAccountMutation(c.config, OpUpdateOne, withCostAccount(ca))
	return &CostAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CostAccountClient) UpdateOneID(id int64) *CostAccountUpdateOne {
	mutation := newCostAccountMutation(c.config, OpUpdateOne, withCostAccountID(id))
	return &CostAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CostAccount.
func (c *CostAccountClient) Delete() *CostAccountDelete {
	mutation := newCostAccountMutation(c.config, OpDelete)
	return &CostAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CostAccountClient) DeleteOne(ca *CostAccount) *CostAccountDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CostAccountClient) DeleteOneID(id int64) *CostAccountDeleteOne {
	builder := c.Delete().Where(costaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CostAccountDeleteOne{builder}
}

// Query returns a query builder for CostAccount.
func (c *CostAccountClient) Query() *CostAccountQuery {
	return &CostAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCostAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a CostAccount entity by its id.
func (c *CostAccountClient) Get(ctx context.Context, id int64) (*CostAccount, error) {
	return c.Query().Where(costaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CostAccountClient) GetX(ctx context.Context, id int64) *CostAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CostAccount.
func (c *CostAccountClient) QueryUser(ca *CostAccount) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costaccount.Table, costaccount.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, costaccount.UserTable, costaccount.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a CostAccount.
func (c *CostAccountClient) QueryCostBills(ca *CostAccount) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costaccount.Table, costaccount.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, costaccount.CostBillsTable, costaccount.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CostAccountClient) Hooks() []Hook {
	return c.hooks.CostAccount
}

// Interceptors returns the client interceptors.
func (c *CostAccountClient) Interceptors() []Interceptor {
	return c.inters.CostAccount
}

func (c *CostAccountClient) mutate(ctx context.Context, m *CostAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CostAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CostAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CostAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CostAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown CostAccount mutation op: %q", m.Op())
	}
}

// CostBillClient is a client for the CostBill schema.
type CostBillClient struct {
	config
}

// NewCostBillClient returns a client for the CostBill from the given config.
func NewCostBillClient(c config) *CostBillClient {
	return &CostBillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `costbill.Hooks(f(g(h())))`.
func (c *CostBillClient) Use(hooks ...Hook) {
	c.hooks.CostBill = append(c.hooks.CostBill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `costbill.Intercept(f(g(h())))`.
func (c *CostBillClient) Intercept(interceptors ...Interceptor) {
	c.inters.CostBill = append(c.inters.CostBill, interceptors...)
}

// Create returns a builder for creating a CostBill entity.
func (c *CostBillClient) Create() *CostBillCreate {
	mutation := newCostBillMutation(c.config, OpCreate)
	return &CostBillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CostBill entities.
func (c *CostBillClient) CreateBulk(builders ...*CostBillCreate) *CostBillCreateBulk {
	return &CostBillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CostBillClient) MapCreateBulk(slice any, setFunc func(*CostBillCreate, int)) *CostBillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CostBillCreateBulk{err: fmt.Errorf("calling to CostBillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CostBillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CostBillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CostBill.
func (c *CostBillClient) Update() *CostBillUpdate {
	mutation := newCostBillMutation(c.config, OpUpdate)
	return &CostBillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CostBillClient) UpdateOne(cb *CostBill) *CostBillUpdateOne {
	mutation := newCostBillMutation(c.config, OpUpdateOne, withCostBill(cb))
	return &CostBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CostBillClient) UpdateOneID(id int64) *CostBillUpdateOne {
	mutation := newCostBillMutation(c.config, OpUpdateOne, withCostBillID(id))
	return &CostBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CostBill.
func (c *CostBillClient) Delete() *CostBillDelete {
	mutation := newCostBillMutation(c.config, OpDelete)
	return &CostBillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CostBillClient) DeleteOne(cb *CostBill) *CostBillDeleteOne {
	return c.DeleteOneID(cb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CostBillClient) DeleteOneID(id int64) *CostBillDeleteOne {
	builder := c.Delete().Where(costbill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CostBillDeleteOne{builder}
}

// Query returns a query builder for CostBill.
func (c *CostBillClient) Query() *CostBillQuery {
	return &CostBillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCostBill},
		inters: c.Interceptors(),
	}
}

// Get returns a CostBill entity by its id.
func (c *CostBillClient) Get(ctx context.Context, id int64) (*CostBill, error) {
	return c.Query().Where(costbill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CostBillClient) GetX(ctx context.Context, id int64) *CostBill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CostBill.
func (c *CostBillClient) QueryUser(cb *CostBill) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.UserTable, costbill.UserColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostAccount queries the cost_account edge of a CostBill.
func (c *CostBillClient) QueryCostAccount(cb *CostBill) *CostAccountQuery {
	query := (&CostAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(costaccount.Table, costaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.CostAccountTable, costbill.CostAccountColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRechargeOrder queries the recharge_order edge of a CostBill.
func (c *CostBillClient) QueryRechargeOrder(cb *CostBill) *RechargeOrderQuery {
	query := (&RechargeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(rechargeorder.Table, rechargeorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.RechargeOrderTable, costbill.RechargeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrder queries the mission_consume_order edge of a CostBill.
func (c *CostBillClient) QueryMissionConsumeOrder(cb *CostBill) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.MissionConsumeOrderTable, costbill.MissionConsumeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlatformAccount queries the platform_account edge of a CostBill.
func (c *CostBillClient) QueryPlatformAccount(cb *CostBill) *PlatformAccountQuery {
	query := (&PlatformAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(platformaccount.Table, platformaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.PlatformAccountTable, costbill.PlatformAccountColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaignOrder queries the campaign_order edge of a CostBill.
func (c *CostBillClient) QueryCampaignOrder(cb *CostBill) *CampaignOrderQuery {
	query := (&CampaignOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costbill.Table, costbill.FieldID, id),
			sqlgraph.To(campaignorder.Table, campaignorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costbill.CampaignOrderTable, costbill.CampaignOrderColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CostBillClient) Hooks() []Hook {
	return c.hooks.CostBill
}

// Interceptors returns the client interceptors.
func (c *CostBillClient) Interceptors() []Interceptor {
	return c.inters.CostBill
}

func (c *CostBillClient) mutate(ctx context.Context, m *CostBillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CostBillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CostBillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CostBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CostBillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown CostBill mutation op: %q", m.Op())
	}
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `device.Hooks(f(g(h())))`.
func (c *DeviceClient) Use(hooks ...Hook) {
	c.hooks.Device = append(c.hooks.Device, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `device.Intercept(f(g(h())))`.
func (c *DeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Device = append(c.inters.Device, interceptors...)
}

// Create returns a builder for creating a Device entity.
func (c *DeviceClient) Create() *DeviceCreate {
	mutation := newDeviceMutation(c.config, OpCreate)
	return &DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Device entities.
func (c *DeviceClient) CreateBulk(builders ...*DeviceCreate) *DeviceCreateBulk {
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceClient) MapCreateBulk(slice any, setFunc func(*DeviceCreate, int)) *DeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceCreateBulk{err: fmt.Errorf("calling to DeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	mutation := newDeviceMutation(c.config, OpUpdate)
	return &DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(d *Device) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDevice(d))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id int64) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDeviceID(id))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	mutation := newDeviceMutation(c.config, OpDelete)
	return &DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceClient) DeleteOne(d *Device) *DeviceDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceClient) DeleteOneID(id int64) *DeviceDeleteOne {
	builder := c.Delete().Where(device.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceDeleteOne{builder}
}

// Query returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id int64) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id int64) *Device {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Device.
func (c *DeviceClient) QueryUser(d *Device) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, device.UserTable, device.UserColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a Device.
func (c *DeviceClient) QueryMissionProduceOrders(d *Device) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.MissionProduceOrdersTable, device.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserDevices queries the user_devices edge of a Device.
func (c *DeviceClient) QueryUserDevices(d *Device) *UserDeviceQuery {
	query := (&UserDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(userdevice.Table, userdevice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.UserDevicesTable, device.UserDevicesColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeviceGpuMissions queries the device_gpu_missions edge of a Device.
func (c *DeviceClient) QueryDeviceGpuMissions(d *Device) *DeviceGpuMissionQuery {
	query := (&DeviceGpuMissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(devicegpumission.Table, devicegpumission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.DeviceGpuMissionsTable, device.DeviceGpuMissionsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFrpcInfos queries the frpc_infos edge of a Device.
func (c *DeviceClient) QueryFrpcInfos(d *Device) *FrpcInfoQuery {
	query := (&FrpcInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(frpcinfo.Table, frpcinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.FrpcInfosTable, device.FrpcInfosColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceClient) Hooks() []Hook {
	return c.hooks.Device
}

// Interceptors returns the client interceptors.
func (c *DeviceClient) Interceptors() []Interceptor {
	return c.inters.Device
}

func (c *DeviceClient) mutate(ctx context.Context, m *DeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Device mutation op: %q", m.Op())
	}
}

// DeviceGpuMissionClient is a client for the DeviceGpuMission schema.
type DeviceGpuMissionClient struct {
	config
}

// NewDeviceGpuMissionClient returns a client for the DeviceGpuMission from the given config.
func NewDeviceGpuMissionClient(c config) *DeviceGpuMissionClient {
	return &DeviceGpuMissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devicegpumission.Hooks(f(g(h())))`.
func (c *DeviceGpuMissionClient) Use(hooks ...Hook) {
	c.hooks.DeviceGpuMission = append(c.hooks.DeviceGpuMission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devicegpumission.Intercept(f(g(h())))`.
func (c *DeviceGpuMissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceGpuMission = append(c.inters.DeviceGpuMission, interceptors...)
}

// Create returns a builder for creating a DeviceGpuMission entity.
func (c *DeviceGpuMissionClient) Create() *DeviceGpuMissionCreate {
	mutation := newDeviceGpuMissionMutation(c.config, OpCreate)
	return &DeviceGpuMissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceGpuMission entities.
func (c *DeviceGpuMissionClient) CreateBulk(builders ...*DeviceGpuMissionCreate) *DeviceGpuMissionCreateBulk {
	return &DeviceGpuMissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceGpuMissionClient) MapCreateBulk(slice any, setFunc func(*DeviceGpuMissionCreate, int)) *DeviceGpuMissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceGpuMissionCreateBulk{err: fmt.Errorf("calling to DeviceGpuMissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceGpuMissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceGpuMissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceGpuMission.
func (c *DeviceGpuMissionClient) Update() *DeviceGpuMissionUpdate {
	mutation := newDeviceGpuMissionMutation(c.config, OpUpdate)
	return &DeviceGpuMissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceGpuMissionClient) UpdateOne(dgm *DeviceGpuMission) *DeviceGpuMissionUpdateOne {
	mutation := newDeviceGpuMissionMutation(c.config, OpUpdateOne, withDeviceGpuMission(dgm))
	return &DeviceGpuMissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceGpuMissionClient) UpdateOneID(id int64) *DeviceGpuMissionUpdateOne {
	mutation := newDeviceGpuMissionMutation(c.config, OpUpdateOne, withDeviceGpuMissionID(id))
	return &DeviceGpuMissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceGpuMission.
func (c *DeviceGpuMissionClient) Delete() *DeviceGpuMissionDelete {
	mutation := newDeviceGpuMissionMutation(c.config, OpDelete)
	return &DeviceGpuMissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceGpuMissionClient) DeleteOne(dgm *DeviceGpuMission) *DeviceGpuMissionDeleteOne {
	return c.DeleteOneID(dgm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceGpuMissionClient) DeleteOneID(id int64) *DeviceGpuMissionDeleteOne {
	builder := c.Delete().Where(devicegpumission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceGpuMissionDeleteOne{builder}
}

// Query returns a query builder for DeviceGpuMission.
func (c *DeviceGpuMissionClient) Query() *DeviceGpuMissionQuery {
	return &DeviceGpuMissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceGpuMission},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceGpuMission entity by its id.
func (c *DeviceGpuMissionClient) Get(ctx context.Context, id int64) (*DeviceGpuMission, error) {
	return c.Query().Where(devicegpumission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceGpuMissionClient) GetX(ctx context.Context, id int64) *DeviceGpuMission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDevice queries the device edge of a DeviceGpuMission.
func (c *DeviceGpuMissionClient) QueryDevice(dgm *DeviceGpuMission) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicegpumission.Table, devicegpumission.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devicegpumission.DeviceTable, devicegpumission.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(dgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionKind queries the mission_kind edge of a DeviceGpuMission.
func (c *DeviceGpuMissionClient) QueryMissionKind(dgm *DeviceGpuMission) *MissionKindQuery {
	query := (&MissionKindClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicegpumission.Table, devicegpumission.FieldID, id),
			sqlgraph.To(missionkind.Table, missionkind.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devicegpumission.MissionKindTable, devicegpumission.MissionKindColumn),
		)
		fromV = sqlgraph.Neighbors(dgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGpu queries the gpu edge of a DeviceGpuMission.
func (c *DeviceGpuMissionClient) QueryGpu(dgm *DeviceGpuMission) *GpuQuery {
	query := (&GpuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicegpumission.Table, devicegpumission.FieldID, id),
			sqlgraph.To(gpu.Table, gpu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devicegpumission.GpuTable, devicegpumission.GpuColumn),
		)
		fromV = sqlgraph.Neighbors(dgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceGpuMissionClient) Hooks() []Hook {
	return c.hooks.DeviceGpuMission
}

// Interceptors returns the client interceptors.
func (c *DeviceGpuMissionClient) Interceptors() []Interceptor {
	return c.inters.DeviceGpuMission
}

func (c *DeviceGpuMissionClient) mutate(ctx context.Context, m *DeviceGpuMissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceGpuMissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceGpuMissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceGpuMissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceGpuMissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown DeviceGpuMission mutation op: %q", m.Op())
	}
}

// EarnBillClient is a client for the EarnBill schema.
type EarnBillClient struct {
	config
}

// NewEarnBillClient returns a client for the EarnBill from the given config.
func NewEarnBillClient(c config) *EarnBillClient {
	return &EarnBillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `earnbill.Hooks(f(g(h())))`.
func (c *EarnBillClient) Use(hooks ...Hook) {
	c.hooks.EarnBill = append(c.hooks.EarnBill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `earnbill.Intercept(f(g(h())))`.
func (c *EarnBillClient) Intercept(interceptors ...Interceptor) {
	c.inters.EarnBill = append(c.inters.EarnBill, interceptors...)
}

// Create returns a builder for creating a EarnBill entity.
func (c *EarnBillClient) Create() *EarnBillCreate {
	mutation := newEarnBillMutation(c.config, OpCreate)
	return &EarnBillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EarnBill entities.
func (c *EarnBillClient) CreateBulk(builders ...*EarnBillCreate) *EarnBillCreateBulk {
	return &EarnBillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EarnBillClient) MapCreateBulk(slice any, setFunc func(*EarnBillCreate, int)) *EarnBillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EarnBillCreateBulk{err: fmt.Errorf("calling to EarnBillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EarnBillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EarnBillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EarnBill.
func (c *EarnBillClient) Update() *EarnBillUpdate {
	mutation := newEarnBillMutation(c.config, OpUpdate)
	return &EarnBillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EarnBillClient) UpdateOne(eb *EarnBill) *EarnBillUpdateOne {
	mutation := newEarnBillMutation(c.config, OpUpdateOne, withEarnBill(eb))
	return &EarnBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EarnBillClient) UpdateOneID(id int64) *EarnBillUpdateOne {
	mutation := newEarnBillMutation(c.config, OpUpdateOne, withEarnBillID(id))
	return &EarnBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EarnBill.
func (c *EarnBillClient) Delete() *EarnBillDelete {
	mutation := newEarnBillMutation(c.config, OpDelete)
	return &EarnBillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EarnBillClient) DeleteOne(eb *EarnBill) *EarnBillDeleteOne {
	return c.DeleteOneID(eb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EarnBillClient) DeleteOneID(id int64) *EarnBillDeleteOne {
	builder := c.Delete().Where(earnbill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EarnBillDeleteOne{builder}
}

// Query returns a query builder for EarnBill.
func (c *EarnBillClient) Query() *EarnBillQuery {
	return &EarnBillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEarnBill},
		inters: c.Interceptors(),
	}
}

// Get returns a EarnBill entity by its id.
func (c *EarnBillClient) Get(ctx context.Context, id int64) (*EarnBill, error) {
	return c.Query().Where(earnbill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EarnBillClient) GetX(ctx context.Context, id int64) *EarnBill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a EarnBill.
func (c *EarnBillClient) QueryUser(eb *EarnBill) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(earnbill.Table, earnbill.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, earnbill.UserTable, earnbill.UserColumn),
		)
		fromV = sqlgraph.Neighbors(eb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfitAccount queries the profit_account edge of a EarnBill.
func (c *EarnBillClient) QueryProfitAccount(eb *EarnBill) *ProfitAccountQuery {
	query := (&ProfitAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(earnbill.Table, earnbill.FieldID, id),
			sqlgraph.To(profitaccount.Table, profitaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, earnbill.ProfitAccountTable, earnbill.ProfitAccountColumn),
		)
		fromV = sqlgraph.Neighbors(eb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlatformAccount queries the platform_account edge of a EarnBill.
func (c *EarnBillClient) QueryPlatformAccount(eb *EarnBill) *PlatformAccountQuery {
	query := (&PlatformAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(earnbill.Table, earnbill.FieldID, id),
			sqlgraph.To(platformaccount.Table, platformaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, earnbill.PlatformAccountTable, earnbill.PlatformAccountColumn),
		)
		fromV = sqlgraph.Neighbors(eb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a EarnBill.
func (c *EarnBillClient) QueryMissionProduceOrders(eb *EarnBill) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(earnbill.Table, earnbill.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, earnbill.MissionProduceOrdersTable, earnbill.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(eb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EarnBillClient) Hooks() []Hook {
	return c.hooks.EarnBill
}

// Interceptors returns the client interceptors.
func (c *EarnBillClient) Interceptors() []Interceptor {
	return c.inters.EarnBill
}

func (c *EarnBillClient) mutate(ctx context.Context, m *EarnBillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EarnBillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EarnBillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EarnBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EarnBillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown EarnBill mutation op: %q", m.Op())
	}
}

// EnumConditionClient is a client for the EnumCondition schema.
type EnumConditionClient struct {
	config
}

// NewEnumConditionClient returns a client for the EnumCondition from the given config.
func NewEnumConditionClient(c config) *EnumConditionClient {
	return &EnumConditionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `enumcondition.Hooks(f(g(h())))`.
func (c *EnumConditionClient) Use(hooks ...Hook) {
	c.hooks.EnumCondition = append(c.hooks.EnumCondition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `enumcondition.Intercept(f(g(h())))`.
func (c *EnumConditionClient) Intercept(interceptors ...Interceptor) {
	c.inters.EnumCondition = append(c.inters.EnumCondition, interceptors...)
}

// Create returns a builder for creating a EnumCondition entity.
func (c *EnumConditionClient) Create() *EnumConditionCreate {
	mutation := newEnumConditionMutation(c.config, OpCreate)
	return &EnumConditionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EnumCondition entities.
func (c *EnumConditionClient) CreateBulk(builders ...*EnumConditionCreate) *EnumConditionCreateBulk {
	return &EnumConditionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnumConditionClient) MapCreateBulk(slice any, setFunc func(*EnumConditionCreate, int)) *EnumConditionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnumConditionCreateBulk{err: fmt.Errorf("calling to EnumConditionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnumConditionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnumConditionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EnumCondition.
func (c *EnumConditionClient) Update() *EnumConditionUpdate {
	mutation := newEnumConditionMutation(c.config, OpUpdate)
	return &EnumConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnumConditionClient) UpdateOne(ec *EnumCondition) *EnumConditionUpdateOne {
	mutation := newEnumConditionMutation(c.config, OpUpdateOne, withEnumCondition(ec))
	return &EnumConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnumConditionClient) UpdateOneID(id int64) *EnumConditionUpdateOne {
	mutation := newEnumConditionMutation(c.config, OpUpdateOne, withEnumConditionID(id))
	return &EnumConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EnumCondition.
func (c *EnumConditionClient) Delete() *EnumConditionDelete {
	mutation := newEnumConditionMutation(c.config, OpDelete)
	return &EnumConditionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnumConditionClient) DeleteOne(ec *EnumCondition) *EnumConditionDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnumConditionClient) DeleteOneID(id int64) *EnumConditionDeleteOne {
	builder := c.Delete().Where(enumcondition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnumConditionDeleteOne{builder}
}

// Query returns a query builder for EnumCondition.
func (c *EnumConditionClient) Query() *EnumConditionQuery {
	return &EnumConditionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnumCondition},
		inters: c.Interceptors(),
	}
}

// Get returns a EnumCondition entity by its id.
func (c *EnumConditionClient) Get(ctx context.Context, id int64) (*EnumCondition, error) {
	return c.Query().Where(enumcondition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnumConditionClient) GetX(ctx context.Context, id int64) *EnumCondition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EnumConditionClient) Hooks() []Hook {
	return c.hooks.EnumCondition
}

// Interceptors returns the client interceptors.
func (c *EnumConditionClient) Interceptors() []Interceptor {
	return c.inters.EnumCondition
}

func (c *EnumConditionClient) mutate(ctx context.Context, m *EnumConditionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnumConditionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnumConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnumConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnumConditionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown EnumCondition mutation op: %q", m.Op())
	}
}

// EnumMissionStatusClient is a client for the EnumMissionStatus schema.
type EnumMissionStatusClient struct {
	config
}

// NewEnumMissionStatusClient returns a client for the EnumMissionStatus from the given config.
func NewEnumMissionStatusClient(c config) *EnumMissionStatusClient {
	return &EnumMissionStatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `enummissionstatus.Hooks(f(g(h())))`.
func (c *EnumMissionStatusClient) Use(hooks ...Hook) {
	c.hooks.EnumMissionStatus = append(c.hooks.EnumMissionStatus, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `enummissionstatus.Intercept(f(g(h())))`.
func (c *EnumMissionStatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.EnumMissionStatus = append(c.inters.EnumMissionStatus, interceptors...)
}

// Create returns a builder for creating a EnumMissionStatus entity.
func (c *EnumMissionStatusClient) Create() *EnumMissionStatusCreate {
	mutation := newEnumMissionStatusMutation(c.config, OpCreate)
	return &EnumMissionStatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EnumMissionStatus entities.
func (c *EnumMissionStatusClient) CreateBulk(builders ...*EnumMissionStatusCreate) *EnumMissionStatusCreateBulk {
	return &EnumMissionStatusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnumMissionStatusClient) MapCreateBulk(slice any, setFunc func(*EnumMissionStatusCreate, int)) *EnumMissionStatusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnumMissionStatusCreateBulk{err: fmt.Errorf("calling to EnumMissionStatusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnumMissionStatusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnumMissionStatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EnumMissionStatus.
func (c *EnumMissionStatusClient) Update() *EnumMissionStatusUpdate {
	mutation := newEnumMissionStatusMutation(c.config, OpUpdate)
	return &EnumMissionStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnumMissionStatusClient) UpdateOne(ems *EnumMissionStatus) *EnumMissionStatusUpdateOne {
	mutation := newEnumMissionStatusMutation(c.config, OpUpdateOne, withEnumMissionStatus(ems))
	return &EnumMissionStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnumMissionStatusClient) UpdateOneID(id int64) *EnumMissionStatusUpdateOne {
	mutation := newEnumMissionStatusMutation(c.config, OpUpdateOne, withEnumMissionStatusID(id))
	return &EnumMissionStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EnumMissionStatus.
func (c *EnumMissionStatusClient) Delete() *EnumMissionStatusDelete {
	mutation := newEnumMissionStatusMutation(c.config, OpDelete)
	return &EnumMissionStatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnumMissionStatusClient) DeleteOne(ems *EnumMissionStatus) *EnumMissionStatusDeleteOne {
	return c.DeleteOneID(ems.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnumMissionStatusClient) DeleteOneID(id int64) *EnumMissionStatusDeleteOne {
	builder := c.Delete().Where(enummissionstatus.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnumMissionStatusDeleteOne{builder}
}

// Query returns a query builder for EnumMissionStatus.
func (c *EnumMissionStatusClient) Query() *EnumMissionStatusQuery {
	return &EnumMissionStatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnumMissionStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a EnumMissionStatus entity by its id.
func (c *EnumMissionStatusClient) Get(ctx context.Context, id int64) (*EnumMissionStatus, error) {
	return c.Query().Where(enummissionstatus.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnumMissionStatusClient) GetX(ctx context.Context, id int64) *EnumMissionStatus {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EnumMissionStatusClient) Hooks() []Hook {
	return c.hooks.EnumMissionStatus
}

// Interceptors returns the client interceptors.
func (c *EnumMissionStatusClient) Interceptors() []Interceptor {
	return c.inters.EnumMissionStatus
}

func (c *EnumMissionStatusClient) mutate(ctx context.Context, m *EnumMissionStatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnumMissionStatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnumMissionStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnumMissionStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnumMissionStatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown EnumMissionStatus mutation op: %q", m.Op())
	}
}

// FrpcInfoClient is a client for the FrpcInfo schema.
type FrpcInfoClient struct {
	config
}

// NewFrpcInfoClient returns a client for the FrpcInfo from the given config.
func NewFrpcInfoClient(c config) *FrpcInfoClient {
	return &FrpcInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `frpcinfo.Hooks(f(g(h())))`.
func (c *FrpcInfoClient) Use(hooks ...Hook) {
	c.hooks.FrpcInfo = append(c.hooks.FrpcInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `frpcinfo.Intercept(f(g(h())))`.
func (c *FrpcInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.FrpcInfo = append(c.inters.FrpcInfo, interceptors...)
}

// Create returns a builder for creating a FrpcInfo entity.
func (c *FrpcInfoClient) Create() *FrpcInfoCreate {
	mutation := newFrpcInfoMutation(c.config, OpCreate)
	return &FrpcInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FrpcInfo entities.
func (c *FrpcInfoClient) CreateBulk(builders ...*FrpcInfoCreate) *FrpcInfoCreateBulk {
	return &FrpcInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FrpcInfoClient) MapCreateBulk(slice any, setFunc func(*FrpcInfoCreate, int)) *FrpcInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FrpcInfoCreateBulk{err: fmt.Errorf("calling to FrpcInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FrpcInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FrpcInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FrpcInfo.
func (c *FrpcInfoClient) Update() *FrpcInfoUpdate {
	mutation := newFrpcInfoMutation(c.config, OpUpdate)
	return &FrpcInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FrpcInfoClient) UpdateOne(fi *FrpcInfo) *FrpcInfoUpdateOne {
	mutation := newFrpcInfoMutation(c.config, OpUpdateOne, withFrpcInfo(fi))
	return &FrpcInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FrpcInfoClient) UpdateOneID(id int64) *FrpcInfoUpdateOne {
	mutation := newFrpcInfoMutation(c.config, OpUpdateOne, withFrpcInfoID(id))
	return &FrpcInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FrpcInfo.
func (c *FrpcInfoClient) Delete() *FrpcInfoDelete {
	mutation := newFrpcInfoMutation(c.config, OpDelete)
	return &FrpcInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FrpcInfoClient) DeleteOne(fi *FrpcInfo) *FrpcInfoDeleteOne {
	return c.DeleteOneID(fi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FrpcInfoClient) DeleteOneID(id int64) *FrpcInfoDeleteOne {
	builder := c.Delete().Where(frpcinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FrpcInfoDeleteOne{builder}
}

// Query returns a query builder for FrpcInfo.
func (c *FrpcInfoClient) Query() *FrpcInfoQuery {
	return &FrpcInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFrpcInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a FrpcInfo entity by its id.
func (c *FrpcInfoClient) Get(ctx context.Context, id int64) (*FrpcInfo, error) {
	return c.Query().Where(frpcinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FrpcInfoClient) GetX(ctx context.Context, id int64) *FrpcInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFrpsInfo queries the frps_info edge of a FrpcInfo.
func (c *FrpcInfoClient) QueryFrpsInfo(fi *FrpcInfo) *FrpsInfoQuery {
	query := (&FrpsInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(frpcinfo.Table, frpcinfo.FieldID, id),
			sqlgraph.To(frpsinfo.Table, frpsinfo.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, frpcinfo.FrpsInfoTable, frpcinfo.FrpsInfoColumn),
		)
		fromV = sqlgraph.Neighbors(fi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a FrpcInfo.
func (c *FrpcInfoClient) QueryDevice(fi *FrpcInfo) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(frpcinfo.Table, frpcinfo.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, frpcinfo.DeviceTable, frpcinfo.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(fi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FrpcInfoClient) Hooks() []Hook {
	return c.hooks.FrpcInfo
}

// Interceptors returns the client interceptors.
func (c *FrpcInfoClient) Interceptors() []Interceptor {
	return c.inters.FrpcInfo
}

func (c *FrpcInfoClient) mutate(ctx context.Context, m *FrpcInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FrpcInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FrpcInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FrpcInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FrpcInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown FrpcInfo mutation op: %q", m.Op())
	}
}

// FrpsInfoClient is a client for the FrpsInfo schema.
type FrpsInfoClient struct {
	config
}

// NewFrpsInfoClient returns a client for the FrpsInfo from the given config.
func NewFrpsInfoClient(c config) *FrpsInfoClient {
	return &FrpsInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `frpsinfo.Hooks(f(g(h())))`.
func (c *FrpsInfoClient) Use(hooks ...Hook) {
	c.hooks.FrpsInfo = append(c.hooks.FrpsInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `frpsinfo.Intercept(f(g(h())))`.
func (c *FrpsInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.FrpsInfo = append(c.inters.FrpsInfo, interceptors...)
}

// Create returns a builder for creating a FrpsInfo entity.
func (c *FrpsInfoClient) Create() *FrpsInfoCreate {
	mutation := newFrpsInfoMutation(c.config, OpCreate)
	return &FrpsInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FrpsInfo entities.
func (c *FrpsInfoClient) CreateBulk(builders ...*FrpsInfoCreate) *FrpsInfoCreateBulk {
	return &FrpsInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FrpsInfoClient) MapCreateBulk(slice any, setFunc func(*FrpsInfoCreate, int)) *FrpsInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FrpsInfoCreateBulk{err: fmt.Errorf("calling to FrpsInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FrpsInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FrpsInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FrpsInfo.
func (c *FrpsInfoClient) Update() *FrpsInfoUpdate {
	mutation := newFrpsInfoMutation(c.config, OpUpdate)
	return &FrpsInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FrpsInfoClient) UpdateOne(fi *FrpsInfo) *FrpsInfoUpdateOne {
	mutation := newFrpsInfoMutation(c.config, OpUpdateOne, withFrpsInfo(fi))
	return &FrpsInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FrpsInfoClient) UpdateOneID(id int64) *FrpsInfoUpdateOne {
	mutation := newFrpsInfoMutation(c.config, OpUpdateOne, withFrpsInfoID(id))
	return &FrpsInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FrpsInfo.
func (c *FrpsInfoClient) Delete() *FrpsInfoDelete {
	mutation := newFrpsInfoMutation(c.config, OpDelete)
	return &FrpsInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FrpsInfoClient) DeleteOne(fi *FrpsInfo) *FrpsInfoDeleteOne {
	return c.DeleteOneID(fi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FrpsInfoClient) DeleteOneID(id int64) *FrpsInfoDeleteOne {
	builder := c.Delete().Where(frpsinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FrpsInfoDeleteOne{builder}
}

// Query returns a query builder for FrpsInfo.
func (c *FrpsInfoClient) Query() *FrpsInfoQuery {
	return &FrpsInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFrpsInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a FrpsInfo entity by its id.
func (c *FrpsInfoClient) Get(ctx context.Context, id int64) (*FrpsInfo, error) {
	return c.Query().Where(frpsinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FrpsInfoClient) GetX(ctx context.Context, id int64) *FrpsInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFrpcInfos queries the frpc_infos edge of a FrpsInfo.
func (c *FrpsInfoClient) QueryFrpcInfos(fi *FrpsInfo) *FrpcInfoQuery {
	query := (&FrpcInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(frpsinfo.Table, frpsinfo.FieldID, id),
			sqlgraph.To(frpcinfo.Table, frpcinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, frpsinfo.FrpcInfosTable, frpsinfo.FrpcInfosColumn),
		)
		fromV = sqlgraph.Neighbors(fi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FrpsInfoClient) Hooks() []Hook {
	return c.hooks.FrpsInfo
}

// Interceptors returns the client interceptors.
func (c *FrpsInfoClient) Interceptors() []Interceptor {
	return c.inters.FrpsInfo
}

func (c *FrpsInfoClient) mutate(ctx context.Context, m *FrpsInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FrpsInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FrpsInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FrpsInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FrpsInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown FrpsInfo mutation op: %q", m.Op())
	}
}

// GpuClient is a client for the Gpu schema.
type GpuClient struct {
	config
}

// NewGpuClient returns a client for the Gpu from the given config.
func NewGpuClient(c config) *GpuClient {
	return &GpuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gpu.Hooks(f(g(h())))`.
func (c *GpuClient) Use(hooks ...Hook) {
	c.hooks.Gpu = append(c.hooks.Gpu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gpu.Intercept(f(g(h())))`.
func (c *GpuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Gpu = append(c.inters.Gpu, interceptors...)
}

// Create returns a builder for creating a Gpu entity.
func (c *GpuClient) Create() *GpuCreate {
	mutation := newGpuMutation(c.config, OpCreate)
	return &GpuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Gpu entities.
func (c *GpuClient) CreateBulk(builders ...*GpuCreate) *GpuCreateBulk {
	return &GpuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GpuClient) MapCreateBulk(slice any, setFunc func(*GpuCreate, int)) *GpuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GpuCreateBulk{err: fmt.Errorf("calling to GpuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GpuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GpuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Gpu.
func (c *GpuClient) Update() *GpuUpdate {
	mutation := newGpuMutation(c.config, OpUpdate)
	return &GpuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GpuClient) UpdateOne(gp *Gpu) *GpuUpdateOne {
	mutation := newGpuMutation(c.config, OpUpdateOne, withGpu(gp))
	return &GpuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GpuClient) UpdateOneID(id int64) *GpuUpdateOne {
	mutation := newGpuMutation(c.config, OpUpdateOne, withGpuID(id))
	return &GpuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Gpu.
func (c *GpuClient) Delete() *GpuDelete {
	mutation := newGpuMutation(c.config, OpDelete)
	return &GpuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GpuClient) DeleteOne(gp *Gpu) *GpuDeleteOne {
	return c.DeleteOneID(gp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GpuClient) DeleteOneID(id int64) *GpuDeleteOne {
	builder := c.Delete().Where(gpu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GpuDeleteOne{builder}
}

// Query returns a query builder for Gpu.
func (c *GpuClient) Query() *GpuQuery {
	return &GpuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGpu},
		inters: c.Interceptors(),
	}
}

// Get returns a Gpu entity by its id.
func (c *GpuClient) Get(ctx context.Context, id int64) (*Gpu, error) {
	return c.Query().Where(gpu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GpuClient) GetX(ctx context.Context, id int64) *Gpu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeviceGpuMissions queries the device_gpu_missions edge of a Gpu.
func (c *GpuClient) QueryDeviceGpuMissions(gp *Gpu) *DeviceGpuMissionQuery {
	query := (&DeviceGpuMissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gpu.Table, gpu.FieldID, id),
			sqlgraph.To(devicegpumission.Table, devicegpumission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gpu.DeviceGpuMissionsTable, gpu.DeviceGpuMissionsColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GpuClient) Hooks() []Hook {
	return c.hooks.Gpu
}

// Interceptors returns the client interceptors.
func (c *GpuClient) Interceptors() []Interceptor {
	return c.inters.Gpu
}

func (c *GpuClient) mutate(ctx context.Context, m *GpuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GpuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GpuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GpuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GpuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Gpu mutation op: %q", m.Op())
	}
}

// HmacKeyPairClient is a client for the HmacKeyPair schema.
type HmacKeyPairClient struct {
	config
}

// NewHmacKeyPairClient returns a client for the HmacKeyPair from the given config.
func NewHmacKeyPairClient(c config) *HmacKeyPairClient {
	return &HmacKeyPairClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hmackeypair.Hooks(f(g(h())))`.
func (c *HmacKeyPairClient) Use(hooks ...Hook) {
	c.hooks.HmacKeyPair = append(c.hooks.HmacKeyPair, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hmackeypair.Intercept(f(g(h())))`.
func (c *HmacKeyPairClient) Intercept(interceptors ...Interceptor) {
	c.inters.HmacKeyPair = append(c.inters.HmacKeyPair, interceptors...)
}

// Create returns a builder for creating a HmacKeyPair entity.
func (c *HmacKeyPairClient) Create() *HmacKeyPairCreate {
	mutation := newHmacKeyPairMutation(c.config, OpCreate)
	return &HmacKeyPairCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HmacKeyPair entities.
func (c *HmacKeyPairClient) CreateBulk(builders ...*HmacKeyPairCreate) *HmacKeyPairCreateBulk {
	return &HmacKeyPairCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HmacKeyPairClient) MapCreateBulk(slice any, setFunc func(*HmacKeyPairCreate, int)) *HmacKeyPairCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HmacKeyPairCreateBulk{err: fmt.Errorf("calling to HmacKeyPairClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HmacKeyPairCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HmacKeyPairCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HmacKeyPair.
func (c *HmacKeyPairClient) Update() *HmacKeyPairUpdate {
	mutation := newHmacKeyPairMutation(c.config, OpUpdate)
	return &HmacKeyPairUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HmacKeyPairClient) UpdateOne(hkp *HmacKeyPair) *HmacKeyPairUpdateOne {
	mutation := newHmacKeyPairMutation(c.config, OpUpdateOne, withHmacKeyPair(hkp))
	return &HmacKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HmacKeyPairClient) UpdateOneID(id int64) *HmacKeyPairUpdateOne {
	mutation := newHmacKeyPairMutation(c.config, OpUpdateOne, withHmacKeyPairID(id))
	return &HmacKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HmacKeyPair.
func (c *HmacKeyPairClient) Delete() *HmacKeyPairDelete {
	mutation := newHmacKeyPairMutation(c.config, OpDelete)
	return &HmacKeyPairDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HmacKeyPairClient) DeleteOne(hkp *HmacKeyPair) *HmacKeyPairDeleteOne {
	return c.DeleteOneID(hkp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HmacKeyPairClient) DeleteOneID(id int64) *HmacKeyPairDeleteOne {
	builder := c.Delete().Where(hmackeypair.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HmacKeyPairDeleteOne{builder}
}

// Query returns a query builder for HmacKeyPair.
func (c *HmacKeyPairClient) Query() *HmacKeyPairQuery {
	return &HmacKeyPairQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHmacKeyPair},
		inters: c.Interceptors(),
	}
}

// Get returns a HmacKeyPair entity by its id.
func (c *HmacKeyPairClient) Get(ctx context.Context, id int64) (*HmacKeyPair, error) {
	return c.Query().Where(hmackeypair.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HmacKeyPairClient) GetX(ctx context.Context, id int64) *HmacKeyPair {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMissionKeyPairs queries the mission_key_pairs edge of a HmacKeyPair.
func (c *HmacKeyPairClient) QueryMissionKeyPairs(hkp *HmacKeyPair) *MissionKeyPairQuery {
	query := (&MissionKeyPairClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hkp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hmackeypair.Table, hmackeypair.FieldID, id),
			sqlgraph.To(missionkeypair.Table, missionkeypair.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, hmackeypair.MissionKeyPairsTable, hmackeypair.MissionKeyPairsColumn),
		)
		fromV = sqlgraph.Neighbors(hkp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedMissions queries the created_missions edge of a HmacKeyPair.
func (c *HmacKeyPairClient) QueryCreatedMissions(hkp *HmacKeyPair) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hkp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hmackeypair.Table, hmackeypair.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, hmackeypair.CreatedMissionsTable, hmackeypair.CreatedMissionsColumn),
		)
		fromV = sqlgraph.Neighbors(hkp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HmacKeyPairClient) Hooks() []Hook {
	return c.hooks.HmacKeyPair
}

// Interceptors returns the client interceptors.
func (c *HmacKeyPairClient) Interceptors() []Interceptor {
	return c.inters.HmacKeyPair
}

func (c *HmacKeyPairClient) mutate(ctx context.Context, m *HmacKeyPairMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HmacKeyPairCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HmacKeyPairUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HmacKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HmacKeyPairDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown HmacKeyPair mutation op: %q", m.Op())
	}
}

// InputLogClient is a client for the InputLog schema.
type InputLogClient struct {
	config
}

// NewInputLogClient returns a client for the InputLog from the given config.
func NewInputLogClient(c config) *InputLogClient {
	return &InputLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inputlog.Hooks(f(g(h())))`.
func (c *InputLogClient) Use(hooks ...Hook) {
	c.hooks.InputLog = append(c.hooks.InputLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inputlog.Intercept(f(g(h())))`.
func (c *InputLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.InputLog = append(c.inters.InputLog, interceptors...)
}

// Create returns a builder for creating a InputLog entity.
func (c *InputLogClient) Create() *InputLogCreate {
	mutation := newInputLogMutation(c.config, OpCreate)
	return &InputLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InputLog entities.
func (c *InputLogClient) CreateBulk(builders ...*InputLogCreate) *InputLogCreateBulk {
	return &InputLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InputLogClient) MapCreateBulk(slice any, setFunc func(*InputLogCreate, int)) *InputLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InputLogCreateBulk{err: fmt.Errorf("calling to InputLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InputLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InputLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InputLog.
func (c *InputLogClient) Update() *InputLogUpdate {
	mutation := newInputLogMutation(c.config, OpUpdate)
	return &InputLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InputLogClient) UpdateOne(il *InputLog) *InputLogUpdateOne {
	mutation := newInputLogMutation(c.config, OpUpdateOne, withInputLog(il))
	return &InputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InputLogClient) UpdateOneID(id int64) *InputLogUpdateOne {
	mutation := newInputLogMutation(c.config, OpUpdateOne, withInputLogID(id))
	return &InputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InputLog.
func (c *InputLogClient) Delete() *InputLogDelete {
	mutation := newInputLogMutation(c.config, OpDelete)
	return &InputLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InputLogClient) DeleteOne(il *InputLog) *InputLogDeleteOne {
	return c.DeleteOneID(il.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InputLogClient) DeleteOneID(id int64) *InputLogDeleteOne {
	builder := c.Delete().Where(inputlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InputLogDeleteOne{builder}
}

// Query returns a query builder for InputLog.
func (c *InputLogClient) Query() *InputLogQuery {
	return &InputLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInputLog},
		inters: c.Interceptors(),
	}
}

// Get returns a InputLog entity by its id.
func (c *InputLogClient) Get(ctx context.Context, id int64) (*InputLog, error) {
	return c.Query().Where(inputlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InputLogClient) GetX(ctx context.Context, id int64) *InputLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InputLogClient) Hooks() []Hook {
	return c.hooks.InputLog
}

// Interceptors returns the client interceptors.
func (c *InputLogClient) Interceptors() []Interceptor {
	return c.inters.InputLog
}

func (c *InputLogClient) mutate(ctx context.Context, m *InputLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InputLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InputLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InputLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown InputLog mutation op: %q", m.Op())
	}
}

// InviteClient is a client for the Invite schema.
type InviteClient struct {
	config
}

// NewInviteClient returns a client for the Invite from the given config.
func NewInviteClient(c config) *InviteClient {
	return &InviteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invite.Hooks(f(g(h())))`.
func (c *InviteClient) Use(hooks ...Hook) {
	c.hooks.Invite = append(c.hooks.Invite, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invite.Intercept(f(g(h())))`.
func (c *InviteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invite = append(c.inters.Invite, interceptors...)
}

// Create returns a builder for creating a Invite entity.
func (c *InviteClient) Create() *InviteCreate {
	mutation := newInviteMutation(c.config, OpCreate)
	return &InviteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invite entities.
func (c *InviteClient) CreateBulk(builders ...*InviteCreate) *InviteCreateBulk {
	return &InviteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InviteClient) MapCreateBulk(slice any, setFunc func(*InviteCreate, int)) *InviteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InviteCreateBulk{err: fmt.Errorf("calling to InviteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InviteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InviteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invite.
func (c *InviteClient) Update() *InviteUpdate {
	mutation := newInviteMutation(c.config, OpUpdate)
	return &InviteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InviteClient) UpdateOne(i *Invite) *InviteUpdateOne {
	mutation := newInviteMutation(c.config, OpUpdateOne, withInvite(i))
	return &InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InviteClient) UpdateOneID(id int64) *InviteUpdateOne {
	mutation := newInviteMutation(c.config, OpUpdateOne, withInviteID(id))
	return &InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invite.
func (c *InviteClient) Delete() *InviteDelete {
	mutation := newInviteMutation(c.config, OpDelete)
	return &InviteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InviteClient) DeleteOne(i *Invite) *InviteDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InviteClient) DeleteOneID(id int64) *InviteDeleteOne {
	builder := c.Delete().Where(invite.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InviteDeleteOne{builder}
}

// Query returns a query builder for Invite.
func (c *InviteClient) Query() *InviteQuery {
	return &InviteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvite},
		inters: c.Interceptors(),
	}
}

// Get returns a Invite entity by its id.
func (c *InviteClient) Get(ctx context.Context, id int64) (*Invite, error) {
	return c.Query().Where(invite.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InviteClient) GetX(ctx context.Context, id int64) *Invite {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Invite.
func (c *InviteClient) QueryUser(i *Invite) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invite.UserTable, invite.UserColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaign queries the campaign edge of a Invite.
func (c *InviteClient) QueryCampaign(i *Invite) *CampaignQuery {
	query := (&CampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(campaign.Table, campaign.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invite.CampaignTable, invite.CampaignColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBills queries the bills edge of a Invite.
func (c *InviteClient) QueryBills(i *Invite) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, invite.BillsTable, invite.BillsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InviteClient) Hooks() []Hook {
	return c.hooks.Invite
}

// Interceptors returns the client interceptors.
func (c *InviteClient) Interceptors() []Interceptor {
	return c.inters.Invite
}

func (c *InviteClient) mutate(ctx context.Context, m *InviteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InviteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InviteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InviteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Invite mutation op: %q", m.Op())
	}
}

// LoginRecordClient is a client for the LoginRecord schema.
type LoginRecordClient struct {
	config
}

// NewLoginRecordClient returns a client for the LoginRecord from the given config.
func NewLoginRecordClient(c config) *LoginRecordClient {
	return &LoginRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `loginrecord.Hooks(f(g(h())))`.
func (c *LoginRecordClient) Use(hooks ...Hook) {
	c.hooks.LoginRecord = append(c.hooks.LoginRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `loginrecord.Intercept(f(g(h())))`.
func (c *LoginRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.LoginRecord = append(c.inters.LoginRecord, interceptors...)
}

// Create returns a builder for creating a LoginRecord entity.
func (c *LoginRecordClient) Create() *LoginRecordCreate {
	mutation := newLoginRecordMutation(c.config, OpCreate)
	return &LoginRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LoginRecord entities.
func (c *LoginRecordClient) CreateBulk(builders ...*LoginRecordCreate) *LoginRecordCreateBulk {
	return &LoginRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoginRecordClient) MapCreateBulk(slice any, setFunc func(*LoginRecordCreate, int)) *LoginRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoginRecordCreateBulk{err: fmt.Errorf("calling to LoginRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoginRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoginRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LoginRecord.
func (c *LoginRecordClient) Update() *LoginRecordUpdate {
	mutation := newLoginRecordMutation(c.config, OpUpdate)
	return &LoginRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoginRecordClient) UpdateOne(lr *LoginRecord) *LoginRecordUpdateOne {
	mutation := newLoginRecordMutation(c.config, OpUpdateOne, withLoginRecord(lr))
	return &LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoginRecordClient) UpdateOneID(id int64) *LoginRecordUpdateOne {
	mutation := newLoginRecordMutation(c.config, OpUpdateOne, withLoginRecordID(id))
	return &LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LoginRecord.
func (c *LoginRecordClient) Delete() *LoginRecordDelete {
	mutation := newLoginRecordMutation(c.config, OpDelete)
	return &LoginRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoginRecordClient) DeleteOne(lr *LoginRecord) *LoginRecordDeleteOne {
	return c.DeleteOneID(lr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoginRecordClient) DeleteOneID(id int64) *LoginRecordDeleteOne {
	builder := c.Delete().Where(loginrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoginRecordDeleteOne{builder}
}

// Query returns a query builder for LoginRecord.
func (c *LoginRecordClient) Query() *LoginRecordQuery {
	return &LoginRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLoginRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a LoginRecord entity by its id.
func (c *LoginRecordClient) Get(ctx context.Context, id int64) (*LoginRecord, error) {
	return c.Query().Where(loginrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoginRecordClient) GetX(ctx context.Context, id int64) *LoginRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LoginRecord.
func (c *LoginRecordClient) QueryUser(lr *LoginRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(loginrecord.Table, loginrecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, loginrecord.UserTable, loginrecord.UserColumn),
		)
		fromV = sqlgraph.Neighbors(lr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LoginRecordClient) Hooks() []Hook {
	return c.hooks.LoginRecord
}

// Interceptors returns the client interceptors.
func (c *LoginRecordClient) Interceptors() []Interceptor {
	return c.inters.LoginRecord
}

func (c *LoginRecordClient) mutate(ctx context.Context, m *LoginRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoginRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoginRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoginRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown LoginRecord mutation op: %q", m.Op())
	}
}

// MissionClient is a client for the Mission schema.
type MissionClient struct {
	config
}

// NewMissionClient returns a client for the Mission from the given config.
func NewMissionClient(c config) *MissionClient {
	return &MissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mission.Hooks(f(g(h())))`.
func (c *MissionClient) Use(hooks ...Hook) {
	c.hooks.Mission = append(c.hooks.Mission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mission.Intercept(f(g(h())))`.
func (c *MissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Mission = append(c.inters.Mission, interceptors...)
}

// Create returns a builder for creating a Mission entity.
func (c *MissionClient) Create() *MissionCreate {
	mutation := newMissionMutation(c.config, OpCreate)
	return &MissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Mission entities.
func (c *MissionClient) CreateBulk(builders ...*MissionCreate) *MissionCreateBulk {
	return &MissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionClient) MapCreateBulk(slice any, setFunc func(*MissionCreate, int)) *MissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionCreateBulk{err: fmt.Errorf("calling to MissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Mission.
func (c *MissionClient) Update() *MissionUpdate {
	mutation := newMissionMutation(c.config, OpUpdate)
	return &MissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionClient) UpdateOne(m *Mission) *MissionUpdateOne {
	mutation := newMissionMutation(c.config, OpUpdateOne, withMission(m))
	return &MissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionClient) UpdateOneID(id int64) *MissionUpdateOne {
	mutation := newMissionMutation(c.config, OpUpdateOne, withMissionID(id))
	return &MissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Mission.
func (c *MissionClient) Delete() *MissionDelete {
	mutation := newMissionMutation(c.config, OpDelete)
	return &MissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionClient) DeleteOne(m *Mission) *MissionDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionClient) DeleteOneID(id int64) *MissionDeleteOne {
	builder := c.Delete().Where(mission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionDeleteOne{builder}
}

// Query returns a query builder for Mission.
func (c *MissionClient) Query() *MissionQuery {
	return &MissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMission},
		inters: c.Interceptors(),
	}
}

// Get returns a Mission entity by its id.
func (c *MissionClient) Get(ctx context.Context, id int64) (*Mission, error) {
	return c.Query().Where(mission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionClient) GetX(ctx context.Context, id int64) *Mission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMissionKind queries the mission_kind edge of a Mission.
func (c *MissionClient) QueryMissionKind(m *Mission) *MissionKindQuery {
	query := (&MissionKindClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionkind.Table, missionkind.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mission.MissionKindTable, mission.MissionKindColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Mission.
func (c *MissionClient) QueryUser(m *Mission) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mission.UserTable, mission.UserColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionKeyPairs queries the mission_key_pairs edge of a Mission.
func (c *MissionClient) QueryMissionKeyPairs(m *Mission) *MissionKeyPairQuery {
	query := (&MissionKeyPairClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionkeypair.Table, missionkeypair.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.MissionKeyPairsTable, mission.MissionKeyPairsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryKeyPair queries the key_pair edge of a Mission.
func (c *MissionClient) QueryKeyPair(m *Mission) *HmacKeyPairQuery {
	query := (&HmacKeyPairClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(hmackeypair.Table, hmackeypair.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mission.KeyPairTable, mission.KeyPairColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrder queries the mission_consume_order edge of a Mission.
func (c *MissionClient) QueryMissionConsumeOrder(m *Mission) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, mission.MissionConsumeOrderTable, mission.MissionConsumeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a Mission.
func (c *MissionClient) QueryMissionProduceOrders(m *Mission) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.MissionProduceOrdersTable, mission.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionBatch queries the mission_batch edge of a Mission.
func (c *MissionClient) QueryMissionBatch(m *Mission) *MissionBatchQuery {
	query := (&MissionBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionbatch.Table, missionbatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mission.MissionBatchTable, mission.MissionBatchColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProductions queries the mission_productions edge of a Mission.
func (c *MissionClient) QueryMissionProductions(m *Mission) *MissionProductionQuery {
	query := (&MissionProductionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionproduction.Table, missionproduction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.MissionProductionsTable, mission.MissionProductionsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrders queries the mission_orders edge of a Mission.
func (c *MissionClient) QueryMissionOrders(m *Mission) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mission.Table, mission.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mission.MissionOrdersTable, mission.MissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionClient) Hooks() []Hook {
	return c.hooks.Mission
}

// Interceptors returns the client interceptors.
func (c *MissionClient) Interceptors() []Interceptor {
	return c.inters.Mission
}

func (c *MissionClient) mutate(ctx context.Context, m *MissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Mission mutation op: %q", m.Op())
	}
}

// MissionBatchClient is a client for the MissionBatch schema.
type MissionBatchClient struct {
	config
}

// NewMissionBatchClient returns a client for the MissionBatch from the given config.
func NewMissionBatchClient(c config) *MissionBatchClient {
	return &MissionBatchClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionbatch.Hooks(f(g(h())))`.
func (c *MissionBatchClient) Use(hooks ...Hook) {
	c.hooks.MissionBatch = append(c.hooks.MissionBatch, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionbatch.Intercept(f(g(h())))`.
func (c *MissionBatchClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionBatch = append(c.inters.MissionBatch, interceptors...)
}

// Create returns a builder for creating a MissionBatch entity.
func (c *MissionBatchClient) Create() *MissionBatchCreate {
	mutation := newMissionBatchMutation(c.config, OpCreate)
	return &MissionBatchCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionBatch entities.
func (c *MissionBatchClient) CreateBulk(builders ...*MissionBatchCreate) *MissionBatchCreateBulk {
	return &MissionBatchCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionBatchClient) MapCreateBulk(slice any, setFunc func(*MissionBatchCreate, int)) *MissionBatchCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionBatchCreateBulk{err: fmt.Errorf("calling to MissionBatchClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionBatchCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionBatchCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionBatch.
func (c *MissionBatchClient) Update() *MissionBatchUpdate {
	mutation := newMissionBatchMutation(c.config, OpUpdate)
	return &MissionBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionBatchClient) UpdateOne(mb *MissionBatch) *MissionBatchUpdateOne {
	mutation := newMissionBatchMutation(c.config, OpUpdateOne, withMissionBatch(mb))
	return &MissionBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionBatchClient) UpdateOneID(id int64) *MissionBatchUpdateOne {
	mutation := newMissionBatchMutation(c.config, OpUpdateOne, withMissionBatchID(id))
	return &MissionBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionBatch.
func (c *MissionBatchClient) Delete() *MissionBatchDelete {
	mutation := newMissionBatchMutation(c.config, OpDelete)
	return &MissionBatchDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionBatchClient) DeleteOne(mb *MissionBatch) *MissionBatchDeleteOne {
	return c.DeleteOneID(mb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionBatchClient) DeleteOneID(id int64) *MissionBatchDeleteOne {
	builder := c.Delete().Where(missionbatch.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionBatchDeleteOne{builder}
}

// Query returns a query builder for MissionBatch.
func (c *MissionBatchClient) Query() *MissionBatchQuery {
	return &MissionBatchQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionBatch},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionBatch entity by its id.
func (c *MissionBatchClient) Get(ctx context.Context, id int64) (*MissionBatch, error) {
	return c.Query().Where(missionbatch.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionBatchClient) GetX(ctx context.Context, id int64) *MissionBatch {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MissionBatch.
func (c *MissionBatchClient) QueryUser(mb *MissionBatch) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionbatch.Table, missionbatch.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionbatch.UserTable, missionbatch.UserColumn),
		)
		fromV = sqlgraph.Neighbors(mb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrders queries the mission_consume_orders edge of a MissionBatch.
func (c *MissionBatchClient) QueryMissionConsumeOrders(mb *MissionBatch) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionbatch.Table, missionbatch.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionbatch.MissionConsumeOrdersTable, missionbatch.MissionConsumeOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(mb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissions queries the missions edge of a MissionBatch.
func (c *MissionBatchClient) QueryMissions(mb *MissionBatch) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionbatch.Table, missionbatch.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionbatch.MissionsTable, missionbatch.MissionsColumn),
		)
		fromV = sqlgraph.Neighbors(mb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrders queries the mission_orders edge of a MissionBatch.
func (c *MissionBatchClient) QueryMissionOrders(mb *MissionBatch) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionbatch.Table, missionbatch.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionbatch.MissionOrdersTable, missionbatch.MissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(mb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionBatchClient) Hooks() []Hook {
	return c.hooks.MissionBatch
}

// Interceptors returns the client interceptors.
func (c *MissionBatchClient) Interceptors() []Interceptor {
	return c.inters.MissionBatch
}

func (c *MissionBatchClient) mutate(ctx context.Context, m *MissionBatchMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionBatchCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionBatchDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionBatch mutation op: %q", m.Op())
	}
}

// MissionConsumeOrderClient is a client for the MissionConsumeOrder schema.
type MissionConsumeOrderClient struct {
	config
}

// NewMissionConsumeOrderClient returns a client for the MissionConsumeOrder from the given config.
func NewMissionConsumeOrderClient(c config) *MissionConsumeOrderClient {
	return &MissionConsumeOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionconsumeorder.Hooks(f(g(h())))`.
func (c *MissionConsumeOrderClient) Use(hooks ...Hook) {
	c.hooks.MissionConsumeOrder = append(c.hooks.MissionConsumeOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionconsumeorder.Intercept(f(g(h())))`.
func (c *MissionConsumeOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionConsumeOrder = append(c.inters.MissionConsumeOrder, interceptors...)
}

// Create returns a builder for creating a MissionConsumeOrder entity.
func (c *MissionConsumeOrderClient) Create() *MissionConsumeOrderCreate {
	mutation := newMissionConsumeOrderMutation(c.config, OpCreate)
	return &MissionConsumeOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionConsumeOrder entities.
func (c *MissionConsumeOrderClient) CreateBulk(builders ...*MissionConsumeOrderCreate) *MissionConsumeOrderCreateBulk {
	return &MissionConsumeOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionConsumeOrderClient) MapCreateBulk(slice any, setFunc func(*MissionConsumeOrderCreate, int)) *MissionConsumeOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionConsumeOrderCreateBulk{err: fmt.Errorf("calling to MissionConsumeOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionConsumeOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionConsumeOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionConsumeOrder.
func (c *MissionConsumeOrderClient) Update() *MissionConsumeOrderUpdate {
	mutation := newMissionConsumeOrderMutation(c.config, OpUpdate)
	return &MissionConsumeOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionConsumeOrderClient) UpdateOne(mco *MissionConsumeOrder) *MissionConsumeOrderUpdateOne {
	mutation := newMissionConsumeOrderMutation(c.config, OpUpdateOne, withMissionConsumeOrder(mco))
	return &MissionConsumeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionConsumeOrderClient) UpdateOneID(id int64) *MissionConsumeOrderUpdateOne {
	mutation := newMissionConsumeOrderMutation(c.config, OpUpdateOne, withMissionConsumeOrderID(id))
	return &MissionConsumeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionConsumeOrder.
func (c *MissionConsumeOrderClient) Delete() *MissionConsumeOrderDelete {
	mutation := newMissionConsumeOrderMutation(c.config, OpDelete)
	return &MissionConsumeOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionConsumeOrderClient) DeleteOne(mco *MissionConsumeOrder) *MissionConsumeOrderDeleteOne {
	return c.DeleteOneID(mco.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionConsumeOrderClient) DeleteOneID(id int64) *MissionConsumeOrderDeleteOne {
	builder := c.Delete().Where(missionconsumeorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionConsumeOrderDeleteOne{builder}
}

// Query returns a query builder for MissionConsumeOrder.
func (c *MissionConsumeOrderClient) Query() *MissionConsumeOrderQuery {
	return &MissionConsumeOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionConsumeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionConsumeOrder entity by its id.
func (c *MissionConsumeOrderClient) Get(ctx context.Context, id int64) (*MissionConsumeOrder, error) {
	return c.Query().Where(missionconsumeorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionConsumeOrderClient) GetX(ctx context.Context, id int64) *MissionConsumeOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryUser(mco *MissionConsumeOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionconsumeorder.UserTable, missionconsumeorder.UserColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryCostBills(mco *MissionConsumeOrder) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionconsumeorder.CostBillsTable, missionconsumeorder.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryMissionProduceOrders(mco *MissionConsumeOrder) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionconsumeorder.MissionProduceOrdersTable, missionconsumeorder.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionBatch queries the mission_batch edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryMissionBatch(mco *MissionConsumeOrder) *MissionBatchQuery {
	query := (&MissionBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(missionbatch.Table, missionbatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionconsumeorder.MissionBatchTable, missionconsumeorder.MissionBatchColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMission queries the mission edge of a MissionConsumeOrder.
func (c *MissionConsumeOrderClient) QueryMission(mco *MissionConsumeOrder) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mco.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionconsumeorder.Table, missionconsumeorder.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, missionconsumeorder.MissionTable, missionconsumeorder.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(mco.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionConsumeOrderClient) Hooks() []Hook {
	return c.hooks.MissionConsumeOrder
}

// Interceptors returns the client interceptors.
func (c *MissionConsumeOrderClient) Interceptors() []Interceptor {
	return c.inters.MissionConsumeOrder
}

func (c *MissionConsumeOrderClient) mutate(ctx context.Context, m *MissionConsumeOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionConsumeOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionConsumeOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionConsumeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionConsumeOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionConsumeOrder mutation op: %q", m.Op())
	}
}

// MissionKeyPairClient is a client for the MissionKeyPair schema.
type MissionKeyPairClient struct {
	config
}

// NewMissionKeyPairClient returns a client for the MissionKeyPair from the given config.
func NewMissionKeyPairClient(c config) *MissionKeyPairClient {
	return &MissionKeyPairClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionkeypair.Hooks(f(g(h())))`.
func (c *MissionKeyPairClient) Use(hooks ...Hook) {
	c.hooks.MissionKeyPair = append(c.hooks.MissionKeyPair, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionkeypair.Intercept(f(g(h())))`.
func (c *MissionKeyPairClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionKeyPair = append(c.inters.MissionKeyPair, interceptors...)
}

// Create returns a builder for creating a MissionKeyPair entity.
func (c *MissionKeyPairClient) Create() *MissionKeyPairCreate {
	mutation := newMissionKeyPairMutation(c.config, OpCreate)
	return &MissionKeyPairCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionKeyPair entities.
func (c *MissionKeyPairClient) CreateBulk(builders ...*MissionKeyPairCreate) *MissionKeyPairCreateBulk {
	return &MissionKeyPairCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionKeyPairClient) MapCreateBulk(slice any, setFunc func(*MissionKeyPairCreate, int)) *MissionKeyPairCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionKeyPairCreateBulk{err: fmt.Errorf("calling to MissionKeyPairClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionKeyPairCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionKeyPairCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionKeyPair.
func (c *MissionKeyPairClient) Update() *MissionKeyPairUpdate {
	mutation := newMissionKeyPairMutation(c.config, OpUpdate)
	return &MissionKeyPairUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionKeyPairClient) UpdateOne(mkp *MissionKeyPair) *MissionKeyPairUpdateOne {
	mutation := newMissionKeyPairMutation(c.config, OpUpdateOne, withMissionKeyPair(mkp))
	return &MissionKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionKeyPairClient) UpdateOneID(id int64) *MissionKeyPairUpdateOne {
	mutation := newMissionKeyPairMutation(c.config, OpUpdateOne, withMissionKeyPairID(id))
	return &MissionKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionKeyPair.
func (c *MissionKeyPairClient) Delete() *MissionKeyPairDelete {
	mutation := newMissionKeyPairMutation(c.config, OpDelete)
	return &MissionKeyPairDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionKeyPairClient) DeleteOne(mkp *MissionKeyPair) *MissionKeyPairDeleteOne {
	return c.DeleteOneID(mkp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionKeyPairClient) DeleteOneID(id int64) *MissionKeyPairDeleteOne {
	builder := c.Delete().Where(missionkeypair.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionKeyPairDeleteOne{builder}
}

// Query returns a query builder for MissionKeyPair.
func (c *MissionKeyPairClient) Query() *MissionKeyPairQuery {
	return &MissionKeyPairQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionKeyPair},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionKeyPair entity by its id.
func (c *MissionKeyPairClient) Get(ctx context.Context, id int64) (*MissionKeyPair, error) {
	return c.Query().Where(missionkeypair.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionKeyPairClient) GetX(ctx context.Context, id int64) *MissionKeyPair {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMission queries the mission edge of a MissionKeyPair.
func (c *MissionKeyPairClient) QueryMission(mkp *MissionKeyPair) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mkp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionkeypair.Table, missionkeypair.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionkeypair.MissionTable, missionkeypair.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(mkp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryKeyPair queries the key_pair edge of a MissionKeyPair.
func (c *MissionKeyPairClient) QueryKeyPair(mkp *MissionKeyPair) *HmacKeyPairQuery {
	query := (&HmacKeyPairClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mkp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionkeypair.Table, missionkeypair.FieldID, id),
			sqlgraph.To(hmackeypair.Table, hmackeypair.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionkeypair.KeyPairTable, missionkeypair.KeyPairColumn),
		)
		fromV = sqlgraph.Neighbors(mkp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionKeyPairClient) Hooks() []Hook {
	return c.hooks.MissionKeyPair
}

// Interceptors returns the client interceptors.
func (c *MissionKeyPairClient) Interceptors() []Interceptor {
	return c.inters.MissionKeyPair
}

func (c *MissionKeyPairClient) mutate(ctx context.Context, m *MissionKeyPairMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionKeyPairCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionKeyPairUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionKeyPairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionKeyPairDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionKeyPair mutation op: %q", m.Op())
	}
}

// MissionKindClient is a client for the MissionKind schema.
type MissionKindClient struct {
	config
}

// NewMissionKindClient returns a client for the MissionKind from the given config.
func NewMissionKindClient(c config) *MissionKindClient {
	return &MissionKindClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionkind.Hooks(f(g(h())))`.
func (c *MissionKindClient) Use(hooks ...Hook) {
	c.hooks.MissionKind = append(c.hooks.MissionKind, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionkind.Intercept(f(g(h())))`.
func (c *MissionKindClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionKind = append(c.inters.MissionKind, interceptors...)
}

// Create returns a builder for creating a MissionKind entity.
func (c *MissionKindClient) Create() *MissionKindCreate {
	mutation := newMissionKindMutation(c.config, OpCreate)
	return &MissionKindCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionKind entities.
func (c *MissionKindClient) CreateBulk(builders ...*MissionKindCreate) *MissionKindCreateBulk {
	return &MissionKindCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionKindClient) MapCreateBulk(slice any, setFunc func(*MissionKindCreate, int)) *MissionKindCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionKindCreateBulk{err: fmt.Errorf("calling to MissionKindClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionKindCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionKindCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionKind.
func (c *MissionKindClient) Update() *MissionKindUpdate {
	mutation := newMissionKindMutation(c.config, OpUpdate)
	return &MissionKindUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionKindClient) UpdateOne(mk *MissionKind) *MissionKindUpdateOne {
	mutation := newMissionKindMutation(c.config, OpUpdateOne, withMissionKind(mk))
	return &MissionKindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionKindClient) UpdateOneID(id int64) *MissionKindUpdateOne {
	mutation := newMissionKindMutation(c.config, OpUpdateOne, withMissionKindID(id))
	return &MissionKindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionKind.
func (c *MissionKindClient) Delete() *MissionKindDelete {
	mutation := newMissionKindMutation(c.config, OpDelete)
	return &MissionKindDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionKindClient) DeleteOne(mk *MissionKind) *MissionKindDeleteOne {
	return c.DeleteOneID(mk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionKindClient) DeleteOneID(id int64) *MissionKindDeleteOne {
	builder := c.Delete().Where(missionkind.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionKindDeleteOne{builder}
}

// Query returns a query builder for MissionKind.
func (c *MissionKindClient) Query() *MissionKindQuery {
	return &MissionKindQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionKind},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionKind entity by its id.
func (c *MissionKindClient) Get(ctx context.Context, id int64) (*MissionKind, error) {
	return c.Query().Where(missionkind.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionKindClient) GetX(ctx context.Context, id int64) *MissionKind {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeviceGpuMissions queries the device_gpu_missions edge of a MissionKind.
func (c *MissionKindClient) QueryDeviceGpuMissions(mk *MissionKind) *DeviceGpuMissionQuery {
	query := (&DeviceGpuMissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionkind.Table, missionkind.FieldID, id),
			sqlgraph.To(devicegpumission.Table, devicegpumission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionkind.DeviceGpuMissionsTable, missionkind.DeviceGpuMissionsColumn),
		)
		fromV = sqlgraph.Neighbors(mk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissions queries the missions edge of a MissionKind.
func (c *MissionKindClient) QueryMissions(mk *MissionKind) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionkind.Table, missionkind.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionkind.MissionsTable, missionkind.MissionsColumn),
		)
		fromV = sqlgraph.Neighbors(mk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionKindClient) Hooks() []Hook {
	return c.hooks.MissionKind
}

// Interceptors returns the client interceptors.
func (c *MissionKindClient) Interceptors() []Interceptor {
	return c.inters.MissionKind
}

func (c *MissionKindClient) mutate(ctx context.Context, m *MissionKindMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionKindCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionKindUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionKindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionKindDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionKind mutation op: %q", m.Op())
	}
}

// MissionOrderClient is a client for the MissionOrder schema.
type MissionOrderClient struct {
	config
}

// NewMissionOrderClient returns a client for the MissionOrder from the given config.
func NewMissionOrderClient(c config) *MissionOrderClient {
	return &MissionOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionorder.Hooks(f(g(h())))`.
func (c *MissionOrderClient) Use(hooks ...Hook) {
	c.hooks.MissionOrder = append(c.hooks.MissionOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionorder.Intercept(f(g(h())))`.
func (c *MissionOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionOrder = append(c.inters.MissionOrder, interceptors...)
}

// Create returns a builder for creating a MissionOrder entity.
func (c *MissionOrderClient) Create() *MissionOrderCreate {
	mutation := newMissionOrderMutation(c.config, OpCreate)
	return &MissionOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionOrder entities.
func (c *MissionOrderClient) CreateBulk(builders ...*MissionOrderCreate) *MissionOrderCreateBulk {
	return &MissionOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionOrderClient) MapCreateBulk(slice any, setFunc func(*MissionOrderCreate, int)) *MissionOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionOrderCreateBulk{err: fmt.Errorf("calling to MissionOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionOrder.
func (c *MissionOrderClient) Update() *MissionOrderUpdate {
	mutation := newMissionOrderMutation(c.config, OpUpdate)
	return &MissionOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionOrderClient) UpdateOne(mo *MissionOrder) *MissionOrderUpdateOne {
	mutation := newMissionOrderMutation(c.config, OpUpdateOne, withMissionOrder(mo))
	return &MissionOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionOrderClient) UpdateOneID(id int64) *MissionOrderUpdateOne {
	mutation := newMissionOrderMutation(c.config, OpUpdateOne, withMissionOrderID(id))
	return &MissionOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionOrder.
func (c *MissionOrderClient) Delete() *MissionOrderDelete {
	mutation := newMissionOrderMutation(c.config, OpDelete)
	return &MissionOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionOrderClient) DeleteOne(mo *MissionOrder) *MissionOrderDeleteOne {
	return c.DeleteOneID(mo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionOrderClient) DeleteOneID(id int64) *MissionOrderDeleteOne {
	builder := c.Delete().Where(missionorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionOrderDeleteOne{builder}
}

// Query returns a query builder for MissionOrder.
func (c *MissionOrderClient) Query() *MissionOrderQuery {
	return &MissionOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionOrder entity by its id.
func (c *MissionOrderClient) Get(ctx context.Context, id int64) (*MissionOrder, error) {
	return c.Query().Where(missionorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionOrderClient) GetX(ctx context.Context, id int64) *MissionOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConsumeUser queries the consume_user edge of a MissionOrder.
func (c *MissionOrderClient) QueryConsumeUser(mo *MissionOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.ConsumeUserTable, missionorder.ConsumeUserColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduceUser queries the produce_user edge of a MissionOrder.
func (c *MissionOrderClient) QueryProduceUser(mo *MissionOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.ProduceUserTable, missionorder.ProduceUserColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a MissionOrder.
func (c *MissionOrderClient) QuerySymbol(mo *MissionOrder) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.SymbolTable, missionorder.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBills queries the bills edge of a MissionOrder.
func (c *MissionOrderClient) QueryBills(mo *MissionOrder) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionorder.BillsTable, missionorder.BillsColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionBatch queries the mission_batch edge of a MissionOrder.
func (c *MissionOrderClient) QueryMissionBatch(mo *MissionOrder) *MissionBatchQuery {
	query := (&MissionBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(missionbatch.Table, missionbatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.MissionBatchTable, missionorder.MissionBatchColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMission queries the mission edge of a MissionOrder.
func (c *MissionOrderClient) QueryMission(mo *MissionOrder) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionorder.Table, missionorder.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionorder.MissionTable, missionorder.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(mo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionOrderClient) Hooks() []Hook {
	return c.hooks.MissionOrder
}

// Interceptors returns the client interceptors.
func (c *MissionOrderClient) Interceptors() []Interceptor {
	return c.inters.MissionOrder
}

func (c *MissionOrderClient) mutate(ctx context.Context, m *MissionOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionOrder mutation op: %q", m.Op())
	}
}

// MissionProduceOrderClient is a client for the MissionProduceOrder schema.
type MissionProduceOrderClient struct {
	config
}

// NewMissionProduceOrderClient returns a client for the MissionProduceOrder from the given config.
func NewMissionProduceOrderClient(c config) *MissionProduceOrderClient {
	return &MissionProduceOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionproduceorder.Hooks(f(g(h())))`.
func (c *MissionProduceOrderClient) Use(hooks ...Hook) {
	c.hooks.MissionProduceOrder = append(c.hooks.MissionProduceOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionproduceorder.Intercept(f(g(h())))`.
func (c *MissionProduceOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionProduceOrder = append(c.inters.MissionProduceOrder, interceptors...)
}

// Create returns a builder for creating a MissionProduceOrder entity.
func (c *MissionProduceOrderClient) Create() *MissionProduceOrderCreate {
	mutation := newMissionProduceOrderMutation(c.config, OpCreate)
	return &MissionProduceOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionProduceOrder entities.
func (c *MissionProduceOrderClient) CreateBulk(builders ...*MissionProduceOrderCreate) *MissionProduceOrderCreateBulk {
	return &MissionProduceOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionProduceOrderClient) MapCreateBulk(slice any, setFunc func(*MissionProduceOrderCreate, int)) *MissionProduceOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionProduceOrderCreateBulk{err: fmt.Errorf("calling to MissionProduceOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionProduceOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionProduceOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionProduceOrder.
func (c *MissionProduceOrderClient) Update() *MissionProduceOrderUpdate {
	mutation := newMissionProduceOrderMutation(c.config, OpUpdate)
	return &MissionProduceOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionProduceOrderClient) UpdateOne(mpo *MissionProduceOrder) *MissionProduceOrderUpdateOne {
	mutation := newMissionProduceOrderMutation(c.config, OpUpdateOne, withMissionProduceOrder(mpo))
	return &MissionProduceOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionProduceOrderClient) UpdateOneID(id int64) *MissionProduceOrderUpdateOne {
	mutation := newMissionProduceOrderMutation(c.config, OpUpdateOne, withMissionProduceOrderID(id))
	return &MissionProduceOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionProduceOrder.
func (c *MissionProduceOrderClient) Delete() *MissionProduceOrderDelete {
	mutation := newMissionProduceOrderMutation(c.config, OpDelete)
	return &MissionProduceOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionProduceOrderClient) DeleteOne(mpo *MissionProduceOrder) *MissionProduceOrderDeleteOne {
	return c.DeleteOneID(mpo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionProduceOrderClient) DeleteOneID(id int64) *MissionProduceOrderDeleteOne {
	builder := c.Delete().Where(missionproduceorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionProduceOrderDeleteOne{builder}
}

// Query returns a query builder for MissionProduceOrder.
func (c *MissionProduceOrderClient) Query() *MissionProduceOrderQuery {
	return &MissionProduceOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionProduceOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionProduceOrder entity by its id.
func (c *MissionProduceOrderClient) Get(ctx context.Context, id int64) (*MissionProduceOrder, error) {
	return c.Query().Where(missionproduceorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionProduceOrderClient) GetX(ctx context.Context, id int64) *MissionProduceOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryUser(mpo *MissionProduceOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduceorder.UserTable, missionproduceorder.UserColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEarnBills queries the earn_bills edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryEarnBills(mpo *MissionProduceOrder) *EarnBillQuery {
	query := (&EarnBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(earnbill.Table, earnbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, missionproduceorder.EarnBillsTable, missionproduceorder.EarnBillsColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryDevice(mpo *MissionProduceOrder) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduceorder.DeviceTable, missionproduceorder.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrder queries the mission_consume_order edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryMissionConsumeOrder(mpo *MissionProduceOrder) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduceorder.MissionConsumeOrderTable, missionproduceorder.MissionConsumeOrderColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduction queries the mission_production edge of a MissionProduceOrder.
func (c *MissionProduceOrderClient) QueryMissionProduction(mpo *MissionProduceOrder) *MissionProductionQuery {
	query := (&MissionProductionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduceorder.Table, missionproduceorder.FieldID, id),
			sqlgraph.To(missionproduction.Table, missionproduction.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, missionproduceorder.MissionProductionTable, missionproduceorder.MissionProductionColumn),
		)
		fromV = sqlgraph.Neighbors(mpo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionProduceOrderClient) Hooks() []Hook {
	return c.hooks.MissionProduceOrder
}

// Interceptors returns the client interceptors.
func (c *MissionProduceOrderClient) Interceptors() []Interceptor {
	return c.inters.MissionProduceOrder
}

func (c *MissionProduceOrderClient) mutate(ctx context.Context, m *MissionProduceOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionProduceOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionProduceOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionProduceOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionProduceOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionProduceOrder mutation op: %q", m.Op())
	}
}

// MissionProductionClient is a client for the MissionProduction schema.
type MissionProductionClient struct {
	config
}

// NewMissionProductionClient returns a client for the MissionProduction from the given config.
func NewMissionProductionClient(c config) *MissionProductionClient {
	return &MissionProductionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missionproduction.Hooks(f(g(h())))`.
func (c *MissionProductionClient) Use(hooks ...Hook) {
	c.hooks.MissionProduction = append(c.hooks.MissionProduction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missionproduction.Intercept(f(g(h())))`.
func (c *MissionProductionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissionProduction = append(c.inters.MissionProduction, interceptors...)
}

// Create returns a builder for creating a MissionProduction entity.
func (c *MissionProductionClient) Create() *MissionProductionCreate {
	mutation := newMissionProductionMutation(c.config, OpCreate)
	return &MissionProductionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissionProduction entities.
func (c *MissionProductionClient) CreateBulk(builders ...*MissionProductionCreate) *MissionProductionCreateBulk {
	return &MissionProductionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissionProductionClient) MapCreateBulk(slice any, setFunc func(*MissionProductionCreate, int)) *MissionProductionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissionProductionCreateBulk{err: fmt.Errorf("calling to MissionProductionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissionProductionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissionProductionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissionProduction.
func (c *MissionProductionClient) Update() *MissionProductionUpdate {
	mutation := newMissionProductionMutation(c.config, OpUpdate)
	return &MissionProductionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissionProductionClient) UpdateOne(mp *MissionProduction) *MissionProductionUpdateOne {
	mutation := newMissionProductionMutation(c.config, OpUpdateOne, withMissionProduction(mp))
	return &MissionProductionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissionProductionClient) UpdateOneID(id int64) *MissionProductionUpdateOne {
	mutation := newMissionProductionMutation(c.config, OpUpdateOne, withMissionProductionID(id))
	return &MissionProductionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissionProduction.
func (c *MissionProductionClient) Delete() *MissionProductionDelete {
	mutation := newMissionProductionMutation(c.config, OpDelete)
	return &MissionProductionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissionProductionClient) DeleteOne(mp *MissionProduction) *MissionProductionDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissionProductionClient) DeleteOneID(id int64) *MissionProductionDeleteOne {
	builder := c.Delete().Where(missionproduction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissionProductionDeleteOne{builder}
}

// Query returns a query builder for MissionProduction.
func (c *MissionProductionClient) Query() *MissionProductionQuery {
	return &MissionProductionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissionProduction},
		inters: c.Interceptors(),
	}
}

// Get returns a MissionProduction entity by its id.
func (c *MissionProductionClient) Get(ctx context.Context, id int64) (*MissionProduction, error) {
	return c.Query().Where(missionproduction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissionProductionClient) GetX(ctx context.Context, id int64) *MissionProduction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMission queries the mission edge of a MissionProduction.
func (c *MissionProductionClient) QueryMission(mp *MissionProduction) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduction.Table, missionproduction.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduction.MissionTable, missionproduction.MissionColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a MissionProduction.
func (c *MissionProductionClient) QueryUser(mp *MissionProduction) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduction.Table, missionproduction.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missionproduction.UserTable, missionproduction.UserColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrder queries the mission_produce_order edge of a MissionProduction.
func (c *MissionProductionClient) QueryMissionProduceOrder(mp *MissionProduction) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missionproduction.Table, missionproduction.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, missionproduction.MissionProduceOrderTable, missionproduction.MissionProduceOrderColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissionProductionClient) Hooks() []Hook {
	return c.hooks.MissionProduction
}

// Interceptors returns the client interceptors.
func (c *MissionProductionClient) Interceptors() []Interceptor {
	return c.inters.MissionProduction
}

func (c *MissionProductionClient) mutate(ctx context.Context, m *MissionProductionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissionProductionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissionProductionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissionProductionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissionProductionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown MissionProduction mutation op: %q", m.Op())
	}
}

// OutputLogClient is a client for the OutputLog schema.
type OutputLogClient struct {
	config
}

// NewOutputLogClient returns a client for the OutputLog from the given config.
func NewOutputLogClient(c config) *OutputLogClient {
	return &OutputLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `outputlog.Hooks(f(g(h())))`.
func (c *OutputLogClient) Use(hooks ...Hook) {
	c.hooks.OutputLog = append(c.hooks.OutputLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `outputlog.Intercept(f(g(h())))`.
func (c *OutputLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.OutputLog = append(c.inters.OutputLog, interceptors...)
}

// Create returns a builder for creating a OutputLog entity.
func (c *OutputLogClient) Create() *OutputLogCreate {
	mutation := newOutputLogMutation(c.config, OpCreate)
	return &OutputLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OutputLog entities.
func (c *OutputLogClient) CreateBulk(builders ...*OutputLogCreate) *OutputLogCreateBulk {
	return &OutputLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OutputLogClient) MapCreateBulk(slice any, setFunc func(*OutputLogCreate, int)) *OutputLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OutputLogCreateBulk{err: fmt.Errorf("calling to OutputLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OutputLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OutputLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OutputLog.
func (c *OutputLogClient) Update() *OutputLogUpdate {
	mutation := newOutputLogMutation(c.config, OpUpdate)
	return &OutputLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OutputLogClient) UpdateOne(ol *OutputLog) *OutputLogUpdateOne {
	mutation := newOutputLogMutation(c.config, OpUpdateOne, withOutputLog(ol))
	return &OutputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OutputLogClient) UpdateOneID(id int64) *OutputLogUpdateOne {
	mutation := newOutputLogMutation(c.config, OpUpdateOne, withOutputLogID(id))
	return &OutputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OutputLog.
func (c *OutputLogClient) Delete() *OutputLogDelete {
	mutation := newOutputLogMutation(c.config, OpDelete)
	return &OutputLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OutputLogClient) DeleteOne(ol *OutputLog) *OutputLogDeleteOne {
	return c.DeleteOneID(ol.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OutputLogClient) DeleteOneID(id int64) *OutputLogDeleteOne {
	builder := c.Delete().Where(outputlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OutputLogDeleteOne{builder}
}

// Query returns a query builder for OutputLog.
func (c *OutputLogClient) Query() *OutputLogQuery {
	return &OutputLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOutputLog},
		inters: c.Interceptors(),
	}
}

// Get returns a OutputLog entity by its id.
func (c *OutputLogClient) Get(ctx context.Context, id int64) (*OutputLog, error) {
	return c.Query().Where(outputlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OutputLogClient) GetX(ctx context.Context, id int64) *OutputLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OutputLogClient) Hooks() []Hook {
	return c.hooks.OutputLog
}

// Interceptors returns the client interceptors.
func (c *OutputLogClient) Interceptors() []Interceptor {
	return c.inters.OutputLog
}

func (c *OutputLogClient) mutate(ctx context.Context, m *OutputLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OutputLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OutputLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OutputLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OutputLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown OutputLog mutation op: %q", m.Op())
	}
}

// PlatformAccountClient is a client for the PlatformAccount schema.
type PlatformAccountClient struct {
	config
}

// NewPlatformAccountClient returns a client for the PlatformAccount from the given config.
func NewPlatformAccountClient(c config) *PlatformAccountClient {
	return &PlatformAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `platformaccount.Hooks(f(g(h())))`.
func (c *PlatformAccountClient) Use(hooks ...Hook) {
	c.hooks.PlatformAccount = append(c.hooks.PlatformAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `platformaccount.Intercept(f(g(h())))`.
func (c *PlatformAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.PlatformAccount = append(c.inters.PlatformAccount, interceptors...)
}

// Create returns a builder for creating a PlatformAccount entity.
func (c *PlatformAccountClient) Create() *PlatformAccountCreate {
	mutation := newPlatformAccountMutation(c.config, OpCreate)
	return &PlatformAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlatformAccount entities.
func (c *PlatformAccountClient) CreateBulk(builders ...*PlatformAccountCreate) *PlatformAccountCreateBulk {
	return &PlatformAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlatformAccountClient) MapCreateBulk(slice any, setFunc func(*PlatformAccountCreate, int)) *PlatformAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlatformAccountCreateBulk{err: fmt.Errorf("calling to PlatformAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlatformAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlatformAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlatformAccount.
func (c *PlatformAccountClient) Update() *PlatformAccountUpdate {
	mutation := newPlatformAccountMutation(c.config, OpUpdate)
	return &PlatformAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlatformAccountClient) UpdateOne(pa *PlatformAccount) *PlatformAccountUpdateOne {
	mutation := newPlatformAccountMutation(c.config, OpUpdateOne, withPlatformAccount(pa))
	return &PlatformAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlatformAccountClient) UpdateOneID(id int64) *PlatformAccountUpdateOne {
	mutation := newPlatformAccountMutation(c.config, OpUpdateOne, withPlatformAccountID(id))
	return &PlatformAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlatformAccount.
func (c *PlatformAccountClient) Delete() *PlatformAccountDelete {
	mutation := newPlatformAccountMutation(c.config, OpDelete)
	return &PlatformAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlatformAccountClient) DeleteOne(pa *PlatformAccount) *PlatformAccountDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlatformAccountClient) DeleteOneID(id int64) *PlatformAccountDeleteOne {
	builder := c.Delete().Where(platformaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlatformAccountDeleteOne{builder}
}

// Query returns a query builder for PlatformAccount.
func (c *PlatformAccountClient) Query() *PlatformAccountQuery {
	return &PlatformAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlatformAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a PlatformAccount entity by its id.
func (c *PlatformAccountClient) Get(ctx context.Context, id int64) (*PlatformAccount, error) {
	return c.Query().Where(platformaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlatformAccountClient) GetX(ctx context.Context, id int64) *PlatformAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEarnBills queries the earn_bills edge of a PlatformAccount.
func (c *PlatformAccountClient) QueryEarnBills(pa *PlatformAccount) *EarnBillQuery {
	query := (&EarnBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(platformaccount.Table, platformaccount.FieldID, id),
			sqlgraph.To(earnbill.Table, earnbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, platformaccount.EarnBillsTable, platformaccount.EarnBillsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a PlatformAccount.
func (c *PlatformAccountClient) QueryCostBills(pa *PlatformAccount) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(platformaccount.Table, platformaccount.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, platformaccount.CostBillsTable, platformaccount.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlatformAccountClient) Hooks() []Hook {
	return c.hooks.PlatformAccount
}

// Interceptors returns the client interceptors.
func (c *PlatformAccountClient) Interceptors() []Interceptor {
	return c.inters.PlatformAccount
}

func (c *PlatformAccountClient) mutate(ctx context.Context, m *PlatformAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlatformAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlatformAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlatformAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlatformAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown PlatformAccount mutation op: %q", m.Op())
	}
}

// PriceClient is a client for the Price schema.
type PriceClient struct {
	config
}

// NewPriceClient returns a client for the Price from the given config.
func NewPriceClient(c config) *PriceClient {
	return &PriceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `price.Hooks(f(g(h())))`.
func (c *PriceClient) Use(hooks ...Hook) {
	c.hooks.Price = append(c.hooks.Price, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `price.Intercept(f(g(h())))`.
func (c *PriceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Price = append(c.inters.Price, interceptors...)
}

// Create returns a builder for creating a Price entity.
func (c *PriceClient) Create() *PriceCreate {
	mutation := newPriceMutation(c.config, OpCreate)
	return &PriceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Price entities.
func (c *PriceClient) CreateBulk(builders ...*PriceCreate) *PriceCreateBulk {
	return &PriceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PriceClient) MapCreateBulk(slice any, setFunc func(*PriceCreate, int)) *PriceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PriceCreateBulk{err: fmt.Errorf("calling to PriceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PriceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PriceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Price.
func (c *PriceClient) Update() *PriceUpdate {
	mutation := newPriceMutation(c.config, OpUpdate)
	return &PriceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PriceClient) UpdateOne(pr *Price) *PriceUpdateOne {
	mutation := newPriceMutation(c.config, OpUpdateOne, withPrice(pr))
	return &PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PriceClient) UpdateOneID(id int64) *PriceUpdateOne {
	mutation := newPriceMutation(c.config, OpUpdateOne, withPriceID(id))
	return &PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Price.
func (c *PriceClient) Delete() *PriceDelete {
	mutation := newPriceMutation(c.config, OpDelete)
	return &PriceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PriceClient) DeleteOne(pr *Price) *PriceDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PriceClient) DeleteOneID(id int64) *PriceDeleteOne {
	builder := c.Delete().Where(price.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PriceDeleteOne{builder}
}

// Query returns a query builder for Price.
func (c *PriceClient) Query() *PriceQuery {
	return &PriceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrice},
		inters: c.Interceptors(),
	}
}

// Get returns a Price entity by its id.
func (c *PriceClient) Get(ctx context.Context, id int64) (*Price, error) {
	return c.Query().Where(price.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PriceClient) GetX(ctx context.Context, id int64) *Price {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PriceClient) Hooks() []Hook {
	return c.hooks.Price
}

// Interceptors returns the client interceptors.
func (c *PriceClient) Interceptors() []Interceptor {
	return c.inters.Price
}

func (c *PriceClient) mutate(ctx context.Context, m *PriceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PriceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PriceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PriceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Price mutation op: %q", m.Op())
	}
}

// ProfitAccountClient is a client for the ProfitAccount schema.
type ProfitAccountClient struct {
	config
}

// NewProfitAccountClient returns a client for the ProfitAccount from the given config.
func NewProfitAccountClient(c config) *ProfitAccountClient {
	return &ProfitAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profitaccount.Hooks(f(g(h())))`.
func (c *ProfitAccountClient) Use(hooks ...Hook) {
	c.hooks.ProfitAccount = append(c.hooks.ProfitAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profitaccount.Intercept(f(g(h())))`.
func (c *ProfitAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProfitAccount = append(c.inters.ProfitAccount, interceptors...)
}

// Create returns a builder for creating a ProfitAccount entity.
func (c *ProfitAccountClient) Create() *ProfitAccountCreate {
	mutation := newProfitAccountMutation(c.config, OpCreate)
	return &ProfitAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProfitAccount entities.
func (c *ProfitAccountClient) CreateBulk(builders ...*ProfitAccountCreate) *ProfitAccountCreateBulk {
	return &ProfitAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfitAccountClient) MapCreateBulk(slice any, setFunc func(*ProfitAccountCreate, int)) *ProfitAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfitAccountCreateBulk{err: fmt.Errorf("calling to ProfitAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfitAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfitAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProfitAccount.
func (c *ProfitAccountClient) Update() *ProfitAccountUpdate {
	mutation := newProfitAccountMutation(c.config, OpUpdate)
	return &ProfitAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfitAccountClient) UpdateOne(pa *ProfitAccount) *ProfitAccountUpdateOne {
	mutation := newProfitAccountMutation(c.config, OpUpdateOne, withProfitAccount(pa))
	return &ProfitAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfitAccountClient) UpdateOneID(id int64) *ProfitAccountUpdateOne {
	mutation := newProfitAccountMutation(c.config, OpUpdateOne, withProfitAccountID(id))
	return &ProfitAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProfitAccount.
func (c *ProfitAccountClient) Delete() *ProfitAccountDelete {
	mutation := newProfitAccountMutation(c.config, OpDelete)
	return &ProfitAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfitAccountClient) DeleteOne(pa *ProfitAccount) *ProfitAccountDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfitAccountClient) DeleteOneID(id int64) *ProfitAccountDeleteOne {
	builder := c.Delete().Where(profitaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfitAccountDeleteOne{builder}
}

// Query returns a query builder for ProfitAccount.
func (c *ProfitAccountClient) Query() *ProfitAccountQuery {
	return &ProfitAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfitAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a ProfitAccount entity by its id.
func (c *ProfitAccountClient) Get(ctx context.Context, id int64) (*ProfitAccount, error) {
	return c.Query().Where(profitaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfitAccountClient) GetX(ctx context.Context, id int64) *ProfitAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ProfitAccount.
func (c *ProfitAccountClient) QueryUser(pa *ProfitAccount) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profitaccount.Table, profitaccount.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, profitaccount.UserTable, profitaccount.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEarnBills queries the earn_bills edge of a ProfitAccount.
func (c *ProfitAccountClient) QueryEarnBills(pa *ProfitAccount) *EarnBillQuery {
	query := (&EarnBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profitaccount.Table, profitaccount.FieldID, id),
			sqlgraph.To(earnbill.Table, earnbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profitaccount.EarnBillsTable, profitaccount.EarnBillsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfitAccountClient) Hooks() []Hook {
	return c.hooks.ProfitAccount
}

// Interceptors returns the client interceptors.
func (c *ProfitAccountClient) Interceptors() []Interceptor {
	return c.inters.ProfitAccount
}

func (c *ProfitAccountClient) mutate(ctx context.Context, m *ProfitAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfitAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfitAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfitAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfitAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown ProfitAccount mutation op: %q", m.Op())
	}
}

// ProfitSettingClient is a client for the ProfitSetting schema.
type ProfitSettingClient struct {
	config
}

// NewProfitSettingClient returns a client for the ProfitSetting from the given config.
func NewProfitSettingClient(c config) *ProfitSettingClient {
	return &ProfitSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profitsetting.Hooks(f(g(h())))`.
func (c *ProfitSettingClient) Use(hooks ...Hook) {
	c.hooks.ProfitSetting = append(c.hooks.ProfitSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profitsetting.Intercept(f(g(h())))`.
func (c *ProfitSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProfitSetting = append(c.inters.ProfitSetting, interceptors...)
}

// Create returns a builder for creating a ProfitSetting entity.
func (c *ProfitSettingClient) Create() *ProfitSettingCreate {
	mutation := newProfitSettingMutation(c.config, OpCreate)
	return &ProfitSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProfitSetting entities.
func (c *ProfitSettingClient) CreateBulk(builders ...*ProfitSettingCreate) *ProfitSettingCreateBulk {
	return &ProfitSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfitSettingClient) MapCreateBulk(slice any, setFunc func(*ProfitSettingCreate, int)) *ProfitSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfitSettingCreateBulk{err: fmt.Errorf("calling to ProfitSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfitSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfitSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProfitSetting.
func (c *ProfitSettingClient) Update() *ProfitSettingUpdate {
	mutation := newProfitSettingMutation(c.config, OpUpdate)
	return &ProfitSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfitSettingClient) UpdateOne(ps *ProfitSetting) *ProfitSettingUpdateOne {
	mutation := newProfitSettingMutation(c.config, OpUpdateOne, withProfitSetting(ps))
	return &ProfitSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfitSettingClient) UpdateOneID(id int64) *ProfitSettingUpdateOne {
	mutation := newProfitSettingMutation(c.config, OpUpdateOne, withProfitSettingID(id))
	return &ProfitSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProfitSetting.
func (c *ProfitSettingClient) Delete() *ProfitSettingDelete {
	mutation := newProfitSettingMutation(c.config, OpDelete)
	return &ProfitSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfitSettingClient) DeleteOne(ps *ProfitSetting) *ProfitSettingDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfitSettingClient) DeleteOneID(id int64) *ProfitSettingDeleteOne {
	builder := c.Delete().Where(profitsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfitSettingDeleteOne{builder}
}

// Query returns a query builder for ProfitSetting.
func (c *ProfitSettingClient) Query() *ProfitSettingQuery {
	return &ProfitSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfitSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a ProfitSetting entity by its id.
func (c *ProfitSettingClient) Get(ctx context.Context, id int64) (*ProfitSetting, error) {
	return c.Query().Where(profitsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfitSettingClient) GetX(ctx context.Context, id int64) *ProfitSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ProfitSetting.
func (c *ProfitSettingClient) QueryUser(ps *ProfitSetting) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profitsetting.Table, profitsetting.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, profitsetting.UserTable, profitsetting.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfitSettingClient) Hooks() []Hook {
	return c.hooks.ProfitSetting
}

// Interceptors returns the client interceptors.
func (c *ProfitSettingClient) Interceptors() []Interceptor {
	return c.inters.ProfitSetting
}

func (c *ProfitSettingClient) mutate(ctx context.Context, m *ProfitSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfitSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfitSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfitSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfitSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown ProfitSetting mutation op: %q", m.Op())
	}
}

// RechargeCampaignRuleClient is a client for the RechargeCampaignRule schema.
type RechargeCampaignRuleClient struct {
	config
}

// NewRechargeCampaignRuleClient returns a client for the RechargeCampaignRule from the given config.
func NewRechargeCampaignRuleClient(c config) *RechargeCampaignRuleClient {
	return &RechargeCampaignRuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rechargecampaignrule.Hooks(f(g(h())))`.
func (c *RechargeCampaignRuleClient) Use(hooks ...Hook) {
	c.hooks.RechargeCampaignRule = append(c.hooks.RechargeCampaignRule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rechargecampaignrule.Intercept(f(g(h())))`.
func (c *RechargeCampaignRuleClient) Intercept(interceptors ...Interceptor) {
	c.inters.RechargeCampaignRule = append(c.inters.RechargeCampaignRule, interceptors...)
}

// Create returns a builder for creating a RechargeCampaignRule entity.
func (c *RechargeCampaignRuleClient) Create() *RechargeCampaignRuleCreate {
	mutation := newRechargeCampaignRuleMutation(c.config, OpCreate)
	return &RechargeCampaignRuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RechargeCampaignRule entities.
func (c *RechargeCampaignRuleClient) CreateBulk(builders ...*RechargeCampaignRuleCreate) *RechargeCampaignRuleCreateBulk {
	return &RechargeCampaignRuleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RechargeCampaignRuleClient) MapCreateBulk(slice any, setFunc func(*RechargeCampaignRuleCreate, int)) *RechargeCampaignRuleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RechargeCampaignRuleCreateBulk{err: fmt.Errorf("calling to RechargeCampaignRuleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RechargeCampaignRuleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RechargeCampaignRuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RechargeCampaignRule.
func (c *RechargeCampaignRuleClient) Update() *RechargeCampaignRuleUpdate {
	mutation := newRechargeCampaignRuleMutation(c.config, OpUpdate)
	return &RechargeCampaignRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RechargeCampaignRuleClient) UpdateOne(rcr *RechargeCampaignRule) *RechargeCampaignRuleUpdateOne {
	mutation := newRechargeCampaignRuleMutation(c.config, OpUpdateOne, withRechargeCampaignRule(rcr))
	return &RechargeCampaignRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RechargeCampaignRuleClient) UpdateOneID(id int64) *RechargeCampaignRuleUpdateOne {
	mutation := newRechargeCampaignRuleMutation(c.config, OpUpdateOne, withRechargeCampaignRuleID(id))
	return &RechargeCampaignRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RechargeCampaignRule.
func (c *RechargeCampaignRuleClient) Delete() *RechargeCampaignRuleDelete {
	mutation := newRechargeCampaignRuleMutation(c.config, OpDelete)
	return &RechargeCampaignRuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RechargeCampaignRuleClient) DeleteOne(rcr *RechargeCampaignRule) *RechargeCampaignRuleDeleteOne {
	return c.DeleteOneID(rcr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RechargeCampaignRuleClient) DeleteOneID(id int64) *RechargeCampaignRuleDeleteOne {
	builder := c.Delete().Where(rechargecampaignrule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RechargeCampaignRuleDeleteOne{builder}
}

// Query returns a query builder for RechargeCampaignRule.
func (c *RechargeCampaignRuleClient) Query() *RechargeCampaignRuleQuery {
	return &RechargeCampaignRuleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRechargeCampaignRule},
		inters: c.Interceptors(),
	}
}

// Get returns a RechargeCampaignRule entity by its id.
func (c *RechargeCampaignRuleClient) Get(ctx context.Context, id int64) (*RechargeCampaignRule, error) {
	return c.Query().Where(rechargecampaignrule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RechargeCampaignRuleClient) GetX(ctx context.Context, id int64) *RechargeCampaignRule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RechargeCampaignRuleClient) Hooks() []Hook {
	return c.hooks.RechargeCampaignRule
}

// Interceptors returns the client interceptors.
func (c *RechargeCampaignRuleClient) Interceptors() []Interceptor {
	return c.inters.RechargeCampaignRule
}

func (c *RechargeCampaignRuleClient) mutate(ctx context.Context, m *RechargeCampaignRuleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RechargeCampaignRuleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RechargeCampaignRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RechargeCampaignRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RechargeCampaignRuleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown RechargeCampaignRule mutation op: %q", m.Op())
	}
}

// RechargeOrderClient is a client for the RechargeOrder schema.
type RechargeOrderClient struct {
	config
}

// NewRechargeOrderClient returns a client for the RechargeOrder from the given config.
func NewRechargeOrderClient(c config) *RechargeOrderClient {
	return &RechargeOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rechargeorder.Hooks(f(g(h())))`.
func (c *RechargeOrderClient) Use(hooks ...Hook) {
	c.hooks.RechargeOrder = append(c.hooks.RechargeOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rechargeorder.Intercept(f(g(h())))`.
func (c *RechargeOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.RechargeOrder = append(c.inters.RechargeOrder, interceptors...)
}

// Create returns a builder for creating a RechargeOrder entity.
func (c *RechargeOrderClient) Create() *RechargeOrderCreate {
	mutation := newRechargeOrderMutation(c.config, OpCreate)
	return &RechargeOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RechargeOrder entities.
func (c *RechargeOrderClient) CreateBulk(builders ...*RechargeOrderCreate) *RechargeOrderCreateBulk {
	return &RechargeOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RechargeOrderClient) MapCreateBulk(slice any, setFunc func(*RechargeOrderCreate, int)) *RechargeOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RechargeOrderCreateBulk{err: fmt.Errorf("calling to RechargeOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RechargeOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RechargeOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RechargeOrder.
func (c *RechargeOrderClient) Update() *RechargeOrderUpdate {
	mutation := newRechargeOrderMutation(c.config, OpUpdate)
	return &RechargeOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RechargeOrderClient) UpdateOne(ro *RechargeOrder) *RechargeOrderUpdateOne {
	mutation := newRechargeOrderMutation(c.config, OpUpdateOne, withRechargeOrder(ro))
	return &RechargeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RechargeOrderClient) UpdateOneID(id int64) *RechargeOrderUpdateOne {
	mutation := newRechargeOrderMutation(c.config, OpUpdateOne, withRechargeOrderID(id))
	return &RechargeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RechargeOrder.
func (c *RechargeOrderClient) Delete() *RechargeOrderDelete {
	mutation := newRechargeOrderMutation(c.config, OpDelete)
	return &RechargeOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RechargeOrderClient) DeleteOne(ro *RechargeOrder) *RechargeOrderDeleteOne {
	return c.DeleteOneID(ro.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RechargeOrderClient) DeleteOneID(id int64) *RechargeOrderDeleteOne {
	builder := c.Delete().Where(rechargeorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RechargeOrderDeleteOne{builder}
}

// Query returns a query builder for RechargeOrder.
func (c *RechargeOrderClient) Query() *RechargeOrderQuery {
	return &RechargeOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRechargeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a RechargeOrder entity by its id.
func (c *RechargeOrderClient) Get(ctx context.Context, id int64) (*RechargeOrder, error) {
	return c.Query().Where(rechargeorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RechargeOrderClient) GetX(ctx context.Context, id int64) *RechargeOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a RechargeOrder.
func (c *RechargeOrderClient) QueryUser(ro *RechargeOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rechargeorder.Table, rechargeorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rechargeorder.UserTable, rechargeorder.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a RechargeOrder.
func (c *RechargeOrderClient) QueryCostBills(ro *RechargeOrder) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rechargeorder.Table, rechargeorder.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, rechargeorder.CostBillsTable, rechargeorder.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVxSocial queries the vx_social edge of a RechargeOrder.
func (c *RechargeOrderClient) QueryVxSocial(ro *RechargeOrder) *VXSocialQuery {
	query := (&VXSocialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rechargeorder.Table, rechargeorder.FieldID, id),
			sqlgraph.To(vxsocial.Table, vxsocial.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rechargeorder.VxSocialTable, rechargeorder.VxSocialColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaignOrder queries the campaign_order edge of a RechargeOrder.
func (c *RechargeOrderClient) QueryCampaignOrder(ro *RechargeOrder) *CampaignOrderQuery {
	query := (&CampaignOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rechargeorder.Table, rechargeorder.FieldID, id),
			sqlgraph.To(campaignorder.Table, campaignorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, rechargeorder.CampaignOrderTable, rechargeorder.CampaignOrderColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RechargeOrderClient) Hooks() []Hook {
	return c.hooks.RechargeOrder
}

// Interceptors returns the client interceptors.
func (c *RechargeOrderClient) Interceptors() []Interceptor {
	return c.inters.RechargeOrder
}

func (c *RechargeOrderClient) mutate(ctx context.Context, m *RechargeOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RechargeOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RechargeOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RechargeOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RechargeOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown RechargeOrder mutation op: %q", m.Op())
	}
}

// SymbolClient is a client for the Symbol schema.
type SymbolClient struct {
	config
}

// NewSymbolClient returns a client for the Symbol from the given config.
func NewSymbolClient(c config) *SymbolClient {
	return &SymbolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `symbol.Hooks(f(g(h())))`.
func (c *SymbolClient) Use(hooks ...Hook) {
	c.hooks.Symbol = append(c.hooks.Symbol, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `symbol.Intercept(f(g(h())))`.
func (c *SymbolClient) Intercept(interceptors ...Interceptor) {
	c.inters.Symbol = append(c.inters.Symbol, interceptors...)
}

// Create returns a builder for creating a Symbol entity.
func (c *SymbolClient) Create() *SymbolCreate {
	mutation := newSymbolMutation(c.config, OpCreate)
	return &SymbolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Symbol entities.
func (c *SymbolClient) CreateBulk(builders ...*SymbolCreate) *SymbolCreateBulk {
	return &SymbolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SymbolClient) MapCreateBulk(slice any, setFunc func(*SymbolCreate, int)) *SymbolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SymbolCreateBulk{err: fmt.Errorf("calling to SymbolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SymbolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SymbolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Symbol.
func (c *SymbolClient) Update() *SymbolUpdate {
	mutation := newSymbolMutation(c.config, OpUpdate)
	return &SymbolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SymbolClient) UpdateOne(s *Symbol) *SymbolUpdateOne {
	mutation := newSymbolMutation(c.config, OpUpdateOne, withSymbol(s))
	return &SymbolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SymbolClient) UpdateOneID(id int64) *SymbolUpdateOne {
	mutation := newSymbolMutation(c.config, OpUpdateOne, withSymbolID(id))
	return &SymbolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Symbol.
func (c *SymbolClient) Delete() *SymbolDelete {
	mutation := newSymbolMutation(c.config, OpDelete)
	return &SymbolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SymbolClient) DeleteOne(s *Symbol) *SymbolDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SymbolClient) DeleteOneID(id int64) *SymbolDeleteOne {
	builder := c.Delete().Where(symbol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SymbolDeleteOne{builder}
}

// Query returns a query builder for Symbol.
func (c *SymbolClient) Query() *SymbolQuery {
	return &SymbolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSymbol},
		inters: c.Interceptors(),
	}
}

// Get returns a Symbol entity by its id.
func (c *SymbolClient) Get(ctx context.Context, id int64) (*Symbol, error) {
	return c.Query().Where(symbol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SymbolClient) GetX(ctx context.Context, id int64) *Symbol {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWallets queries the wallets edge of a Symbol.
func (c *SymbolClient) QueryWallets(s *Symbol) *WalletQuery {
	query := (&WalletClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(wallet.Table, wallet.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.WalletsTable, symbol.WalletsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBills queries the bills edge of a Symbol.
func (c *SymbolClient) QueryBills(s *Symbol) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.BillsTable, symbol.BillsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionOrders queries the mission_orders edge of a Symbol.
func (c *SymbolClient) QueryMissionOrders(s *Symbol) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.MissionOrdersTable, symbol.MissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransferOrders queries the transfer_orders edge of a Symbol.
func (c *SymbolClient) QueryTransferOrders(s *Symbol) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.TransferOrdersTable, symbol.TransferOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SymbolClient) Hooks() []Hook {
	return c.hooks.Symbol
}

// Interceptors returns the client interceptors.
func (c *SymbolClient) Interceptors() []Interceptor {
	return c.inters.Symbol
}

func (c *SymbolClient) mutate(ctx context.Context, m *SymbolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SymbolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SymbolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SymbolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SymbolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Symbol mutation op: %q", m.Op())
	}
}

// TransferOrderClient is a client for the TransferOrder schema.
type TransferOrderClient struct {
	config
}

// NewTransferOrderClient returns a client for the TransferOrder from the given config.
func NewTransferOrderClient(c config) *TransferOrderClient {
	return &TransferOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transferorder.Hooks(f(g(h())))`.
func (c *TransferOrderClient) Use(hooks ...Hook) {
	c.hooks.TransferOrder = append(c.hooks.TransferOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `transferorder.Intercept(f(g(h())))`.
func (c *TransferOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.TransferOrder = append(c.inters.TransferOrder, interceptors...)
}

// Create returns a builder for creating a TransferOrder entity.
func (c *TransferOrderClient) Create() *TransferOrderCreate {
	mutation := newTransferOrderMutation(c.config, OpCreate)
	return &TransferOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TransferOrder entities.
func (c *TransferOrderClient) CreateBulk(builders ...*TransferOrderCreate) *TransferOrderCreateBulk {
	return &TransferOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TransferOrderClient) MapCreateBulk(slice any, setFunc func(*TransferOrderCreate, int)) *TransferOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TransferOrderCreateBulk{err: fmt.Errorf("calling to TransferOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TransferOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TransferOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TransferOrder.
func (c *TransferOrderClient) Update() *TransferOrderUpdate {
	mutation := newTransferOrderMutation(c.config, OpUpdate)
	return &TransferOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransferOrderClient) UpdateOne(to *TransferOrder) *TransferOrderUpdateOne {
	mutation := newTransferOrderMutation(c.config, OpUpdateOne, withTransferOrder(to))
	return &TransferOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransferOrderClient) UpdateOneID(id int64) *TransferOrderUpdateOne {
	mutation := newTransferOrderMutation(c.config, OpUpdateOne, withTransferOrderID(id))
	return &TransferOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TransferOrder.
func (c *TransferOrderClient) Delete() *TransferOrderDelete {
	mutation := newTransferOrderMutation(c.config, OpDelete)
	return &TransferOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransferOrderClient) DeleteOne(to *TransferOrder) *TransferOrderDeleteOne {
	return c.DeleteOneID(to.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TransferOrderClient) DeleteOneID(id int64) *TransferOrderDeleteOne {
	builder := c.Delete().Where(transferorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransferOrderDeleteOne{builder}
}

// Query returns a query builder for TransferOrder.
func (c *TransferOrderClient) Query() *TransferOrderQuery {
	return &TransferOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTransferOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a TransferOrder entity by its id.
func (c *TransferOrderClient) Get(ctx context.Context, id int64) (*TransferOrder, error) {
	return c.Query().Where(transferorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransferOrderClient) GetX(ctx context.Context, id int64) *TransferOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySourceUser queries the source_user edge of a TransferOrder.
func (c *TransferOrderClient) QuerySourceUser(to *TransferOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transferorder.SourceUserTable, transferorder.SourceUserColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetUser queries the target_user edge of a TransferOrder.
func (c *TransferOrderClient) QueryTargetUser(to *TransferOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transferorder.TargetUserTable, transferorder.TargetUserColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBills queries the bills edge of a TransferOrder.
func (c *TransferOrderClient) QueryBills(to *TransferOrder) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, transferorder.BillsTable, transferorder.BillsColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVxSocial queries the vx_social edge of a TransferOrder.
func (c *TransferOrderClient) QueryVxSocial(to *TransferOrder) *VXSocialQuery {
	query := (&VXSocialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(vxsocial.Table, vxsocial.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transferorder.VxSocialTable, transferorder.VxSocialColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a TransferOrder.
func (c *TransferOrderClient) QuerySymbol(to *TransferOrder) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transferorder.Table, transferorder.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transferorder.SymbolTable, transferorder.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TransferOrderClient) Hooks() []Hook {
	return c.hooks.TransferOrder
}

// Interceptors returns the client interceptors.
func (c *TransferOrderClient) Interceptors() []Interceptor {
	return c.inters.TransferOrder
}

func (c *TransferOrderClient) mutate(ctx context.Context, m *TransferOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TransferOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TransferOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TransferOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TransferOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown TransferOrder mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVxAccounts queries the vx_accounts edge of a User.
func (c *UserClient) QueryVxAccounts(u *User) *VXAccountQuery {
	query := (&VXAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(vxaccount.Table, vxaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.VxAccountsTable, user.VxAccountsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollects queries the collects edge of a User.
func (c *UserClient) QueryCollects(u *User) *CollectQuery {
	query := (&CollectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(collect.Table, collect.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CollectsTable, user.CollectsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevices queries the devices edge of a User.
func (c *UserClient) QueryDevices(u *User) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DevicesTable, user.DevicesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfitSettings queries the profit_settings edge of a User.
func (c *UserClient) QueryProfitSettings(u *User) *ProfitSettingQuery {
	query := (&ProfitSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(profitsetting.Table, profitsetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProfitSettingsTable, user.ProfitSettingsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostAccount queries the cost_account edge of a User.
func (c *UserClient) QueryCostAccount(u *User) *CostAccountQuery {
	query := (&CostAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(costaccount.Table, costaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.CostAccountTable, user.CostAccountColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfitAccount queries the profit_account edge of a User.
func (c *UserClient) QueryProfitAccount(u *User) *ProfitAccountQuery {
	query := (&ProfitAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(profitaccount.Table, profitaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.ProfitAccountTable, user.ProfitAccountColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostBills queries the cost_bills edge of a User.
func (c *UserClient) QueryCostBills(u *User) *CostBillQuery {
	query := (&CostBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(costbill.Table, costbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CostBillsTable, user.CostBillsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEarnBills queries the earn_bills edge of a User.
func (c *UserClient) QueryEarnBills(u *User) *EarnBillQuery {
	query := (&EarnBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(earnbill.Table, earnbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EarnBillsTable, user.EarnBillsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionConsumeOrders queries the mission_consume_orders edge of a User.
func (c *UserClient) QueryMissionConsumeOrders(u *User) *MissionConsumeOrderQuery {
	query := (&MissionConsumeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionconsumeorder.Table, missionconsumeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionConsumeOrdersTable, user.MissionConsumeOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProduceOrders queries the mission_produce_orders edge of a User.
func (c *UserClient) QueryMissionProduceOrders(u *User) *MissionProduceOrderQuery {
	query := (&MissionProduceOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionproduceorder.Table, missionproduceorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionProduceOrdersTable, user.MissionProduceOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRechargeOrders queries the recharge_orders edge of a User.
func (c *UserClient) QueryRechargeOrders(u *User) *RechargeOrderQuery {
	query := (&RechargeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(rechargeorder.Table, rechargeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RechargeOrdersTable, user.RechargeOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVxSocials queries the vx_socials edge of a User.
func (c *UserClient) QueryVxSocials(u *User) *VXSocialQuery {
	query := (&VXSocialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(vxsocial.Table, vxsocial.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.VxSocialsTable, user.VxSocialsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionBatches queries the mission_batches edge of a User.
func (c *UserClient) QueryMissionBatches(u *User) *MissionBatchQuery {
	query := (&MissionBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionbatch.Table, missionbatch.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionBatchesTable, user.MissionBatchesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserDevices queries the user_devices edge of a User.
func (c *UserClient) QueryUserDevices(u *User) *UserDeviceQuery {
	query := (&UserDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userdevice.Table, userdevice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserDevicesTable, user.UserDevicesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a User.
func (c *UserClient) QueryParent(u *User) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.ParentTable, user.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a User.
func (c *UserClient) QueryChildren(u *User) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ChildrenTable, user.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvites queries the invites edge of a User.
func (c *UserClient) QueryInvites(u *User) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.InvitesTable, user.InvitesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaignOrders queries the campaign_orders edge of a User.
func (c *UserClient) QueryCampaignOrders(u *User) *CampaignOrderQuery {
	query := (&CampaignOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(campaignorder.Table, campaignorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CampaignOrdersTable, user.CampaignOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWallets queries the wallets edge of a User.
func (c *UserClient) QueryWallets(u *User) *WalletQuery {
	query := (&WalletClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(wallet.Table, wallet.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.WalletsTable, user.WalletsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncomeBills queries the income_bills edge of a User.
func (c *UserClient) QueryIncomeBills(u *User) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.IncomeBillsTable, user.IncomeBillsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOutcomeBills queries the outcome_bills edge of a User.
func (c *UserClient) QueryOutcomeBills(u *User) *BillQuery {
	query := (&BillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(bill.Table, bill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OutcomeBillsTable, user.OutcomeBillsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissionProductions queries the mission_productions edge of a User.
func (c *UserClient) QueryMissionProductions(u *User) *MissionProductionQuery {
	query := (&MissionProductionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionproduction.Table, missionproduction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionProductionsTable, user.MissionProductionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissions queries the missions edge of a User.
func (c *UserClient) QueryMissions(u *User) *MissionQuery {
	query := (&MissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(mission.Table, mission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MissionsTable, user.MissionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncomeTransferOrders queries the income_transfer_orders edge of a User.
func (c *UserClient) QueryIncomeTransferOrders(u *User) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.IncomeTransferOrdersTable, user.IncomeTransferOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOutcomeTransferOrders queries the outcome_transfer_orders edge of a User.
func (c *UserClient) QueryOutcomeTransferOrders(u *User) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OutcomeTransferOrdersTable, user.OutcomeTransferOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConsumeMissionOrders queries the consume_mission_orders edge of a User.
func (c *UserClient) QueryConsumeMissionOrders(u *User) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ConsumeMissionOrdersTable, user.ConsumeMissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduceMissionOrders queries the produce_mission_orders edge of a User.
func (c *UserClient) QueryProduceMissionOrders(u *User) *MissionOrderQuery {
	query := (&MissionOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(missionorder.Table, missionorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProduceMissionOrdersTable, user.ProduceMissionOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLoginRecords queries the login_records edge of a User.
func (c *UserClient) QueryLoginRecords(u *User) *LoginRecordQuery {
	query := (&LoginRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(loginrecord.Table, loginrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LoginRecordsTable, user.LoginRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown User mutation op: %q", m.Op())
	}
}

// UserDeviceClient is a client for the UserDevice schema.
type UserDeviceClient struct {
	config
}

// NewUserDeviceClient returns a client for the UserDevice from the given config.
func NewUserDeviceClient(c config) *UserDeviceClient {
	return &UserDeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userdevice.Hooks(f(g(h())))`.
func (c *UserDeviceClient) Use(hooks ...Hook) {
	c.hooks.UserDevice = append(c.hooks.UserDevice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userdevice.Intercept(f(g(h())))`.
func (c *UserDeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserDevice = append(c.inters.UserDevice, interceptors...)
}

// Create returns a builder for creating a UserDevice entity.
func (c *UserDeviceClient) Create() *UserDeviceCreate {
	mutation := newUserDeviceMutation(c.config, OpCreate)
	return &UserDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserDevice entities.
func (c *UserDeviceClient) CreateBulk(builders ...*UserDeviceCreate) *UserDeviceCreateBulk {
	return &UserDeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserDeviceClient) MapCreateBulk(slice any, setFunc func(*UserDeviceCreate, int)) *UserDeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserDeviceCreateBulk{err: fmt.Errorf("calling to UserDeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserDeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserDeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserDevice.
func (c *UserDeviceClient) Update() *UserDeviceUpdate {
	mutation := newUserDeviceMutation(c.config, OpUpdate)
	return &UserDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserDeviceClient) UpdateOne(ud *UserDevice) *UserDeviceUpdateOne {
	mutation := newUserDeviceMutation(c.config, OpUpdateOne, withUserDevice(ud))
	return &UserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserDeviceClient) UpdateOneID(id int64) *UserDeviceUpdateOne {
	mutation := newUserDeviceMutation(c.config, OpUpdateOne, withUserDeviceID(id))
	return &UserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserDevice.
func (c *UserDeviceClient) Delete() *UserDeviceDelete {
	mutation := newUserDeviceMutation(c.config, OpDelete)
	return &UserDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserDeviceClient) DeleteOne(ud *UserDevice) *UserDeviceDeleteOne {
	return c.DeleteOneID(ud.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserDeviceClient) DeleteOneID(id int64) *UserDeviceDeleteOne {
	builder := c.Delete().Where(userdevice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeviceDeleteOne{builder}
}

// Query returns a query builder for UserDevice.
func (c *UserDeviceClient) Query() *UserDeviceQuery {
	return &UserDeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a UserDevice entity by its id.
func (c *UserDeviceClient) Get(ctx context.Context, id int64) (*UserDevice, error) {
	return c.Query().Where(userdevice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserDeviceClient) GetX(ctx context.Context, id int64) *UserDevice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserDevice.
func (c *UserDeviceClient) QueryUser(ud *UserDevice) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ud.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userdevice.Table, userdevice.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userdevice.UserTable, userdevice.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ud.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a UserDevice.
func (c *UserDeviceClient) QueryDevice(ud *UserDevice) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ud.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userdevice.Table, userdevice.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userdevice.DeviceTable, userdevice.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(ud.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserDeviceClient) Hooks() []Hook {
	return c.hooks.UserDevice
}

// Interceptors returns the client interceptors.
func (c *UserDeviceClient) Interceptors() []Interceptor {
	return c.inters.UserDevice
}

func (c *UserDeviceClient) mutate(ctx context.Context, m *UserDeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown UserDevice mutation op: %q", m.Op())
	}
}

// VXAccountClient is a client for the VXAccount schema.
type VXAccountClient struct {
	config
}

// NewVXAccountClient returns a client for the VXAccount from the given config.
func NewVXAccountClient(c config) *VXAccountClient {
	return &VXAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vxaccount.Hooks(f(g(h())))`.
func (c *VXAccountClient) Use(hooks ...Hook) {
	c.hooks.VXAccount = append(c.hooks.VXAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vxaccount.Intercept(f(g(h())))`.
func (c *VXAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.VXAccount = append(c.inters.VXAccount, interceptors...)
}

// Create returns a builder for creating a VXAccount entity.
func (c *VXAccountClient) Create() *VXAccountCreate {
	mutation := newVXAccountMutation(c.config, OpCreate)
	return &VXAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VXAccount entities.
func (c *VXAccountClient) CreateBulk(builders ...*VXAccountCreate) *VXAccountCreateBulk {
	return &VXAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VXAccountClient) MapCreateBulk(slice any, setFunc func(*VXAccountCreate, int)) *VXAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VXAccountCreateBulk{err: fmt.Errorf("calling to VXAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VXAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VXAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VXAccount.
func (c *VXAccountClient) Update() *VXAccountUpdate {
	mutation := newVXAccountMutation(c.config, OpUpdate)
	return &VXAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VXAccountClient) UpdateOne(va *VXAccount) *VXAccountUpdateOne {
	mutation := newVXAccountMutation(c.config, OpUpdateOne, withVXAccount(va))
	return &VXAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VXAccountClient) UpdateOneID(id int64) *VXAccountUpdateOne {
	mutation := newVXAccountMutation(c.config, OpUpdateOne, withVXAccountID(id))
	return &VXAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VXAccount.
func (c *VXAccountClient) Delete() *VXAccountDelete {
	mutation := newVXAccountMutation(c.config, OpDelete)
	return &VXAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VXAccountClient) DeleteOne(va *VXAccount) *VXAccountDeleteOne {
	return c.DeleteOneID(va.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VXAccountClient) DeleteOneID(id int64) *VXAccountDeleteOne {
	builder := c.Delete().Where(vxaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VXAccountDeleteOne{builder}
}

// Query returns a query builder for VXAccount.
func (c *VXAccountClient) Query() *VXAccountQuery {
	return &VXAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVXAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a VXAccount entity by its id.
func (c *VXAccountClient) Get(ctx context.Context, id int64) (*VXAccount, error) {
	return c.Query().Where(vxaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VXAccountClient) GetX(ctx context.Context, id int64) *VXAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a VXAccount.
func (c *VXAccountClient) QueryUser(va *VXAccount) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := va.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vxaccount.Table, vxaccount.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vxaccount.UserTable, vxaccount.UserColumn),
		)
		fromV = sqlgraph.Neighbors(va.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VXAccountClient) Hooks() []Hook {
	return c.hooks.VXAccount
}

// Interceptors returns the client interceptors.
func (c *VXAccountClient) Interceptors() []Interceptor {
	return c.inters.VXAccount
}

func (c *VXAccountClient) mutate(ctx context.Context, m *VXAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VXAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VXAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VXAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VXAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown VXAccount mutation op: %q", m.Op())
	}
}

// VXSocialClient is a client for the VXSocial schema.
type VXSocialClient struct {
	config
}

// NewVXSocialClient returns a client for the VXSocial from the given config.
func NewVXSocialClient(c config) *VXSocialClient {
	return &VXSocialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vxsocial.Hooks(f(g(h())))`.
func (c *VXSocialClient) Use(hooks ...Hook) {
	c.hooks.VXSocial = append(c.hooks.VXSocial, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vxsocial.Intercept(f(g(h())))`.
func (c *VXSocialClient) Intercept(interceptors ...Interceptor) {
	c.inters.VXSocial = append(c.inters.VXSocial, interceptors...)
}

// Create returns a builder for creating a VXSocial entity.
func (c *VXSocialClient) Create() *VXSocialCreate {
	mutation := newVXSocialMutation(c.config, OpCreate)
	return &VXSocialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VXSocial entities.
func (c *VXSocialClient) CreateBulk(builders ...*VXSocialCreate) *VXSocialCreateBulk {
	return &VXSocialCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VXSocialClient) MapCreateBulk(slice any, setFunc func(*VXSocialCreate, int)) *VXSocialCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VXSocialCreateBulk{err: fmt.Errorf("calling to VXSocialClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VXSocialCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VXSocialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VXSocial.
func (c *VXSocialClient) Update() *VXSocialUpdate {
	mutation := newVXSocialMutation(c.config, OpUpdate)
	return &VXSocialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VXSocialClient) UpdateOne(vs *VXSocial) *VXSocialUpdateOne {
	mutation := newVXSocialMutation(c.config, OpUpdateOne, withVXSocial(vs))
	return &VXSocialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VXSocialClient) UpdateOneID(id int64) *VXSocialUpdateOne {
	mutation := newVXSocialMutation(c.config, OpUpdateOne, withVXSocialID(id))
	return &VXSocialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VXSocial.
func (c *VXSocialClient) Delete() *VXSocialDelete {
	mutation := newVXSocialMutation(c.config, OpDelete)
	return &VXSocialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VXSocialClient) DeleteOne(vs *VXSocial) *VXSocialDeleteOne {
	return c.DeleteOneID(vs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VXSocialClient) DeleteOneID(id int64) *VXSocialDeleteOne {
	builder := c.Delete().Where(vxsocial.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VXSocialDeleteOne{builder}
}

// Query returns a query builder for VXSocial.
func (c *VXSocialClient) Query() *VXSocialQuery {
	return &VXSocialQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVXSocial},
		inters: c.Interceptors(),
	}
}

// Get returns a VXSocial entity by its id.
func (c *VXSocialClient) Get(ctx context.Context, id int64) (*VXSocial, error) {
	return c.Query().Where(vxsocial.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VXSocialClient) GetX(ctx context.Context, id int64) *VXSocial {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a VXSocial.
func (c *VXSocialClient) QueryUser(vs *VXSocial) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vxsocial.Table, vxsocial.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vxsocial.UserTable, vxsocial.UserColumn),
		)
		fromV = sqlgraph.Neighbors(vs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRechargeOrders queries the recharge_orders edge of a VXSocial.
func (c *VXSocialClient) QueryRechargeOrders(vs *VXSocial) *RechargeOrderQuery {
	query := (&RechargeOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vxsocial.Table, vxsocial.FieldID, id),
			sqlgraph.To(rechargeorder.Table, rechargeorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vxsocial.RechargeOrdersTable, vxsocial.RechargeOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(vs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransferOrders queries the transfer_orders edge of a VXSocial.
func (c *VXSocialClient) QueryTransferOrders(vs *VXSocial) *TransferOrderQuery {
	query := (&TransferOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vxsocial.Table, vxsocial.FieldID, id),
			sqlgraph.To(transferorder.Table, transferorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vxsocial.TransferOrdersTable, vxsocial.TransferOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(vs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VXSocialClient) Hooks() []Hook {
	return c.hooks.VXSocial
}

// Interceptors returns the client interceptors.
func (c *VXSocialClient) Interceptors() []Interceptor {
	return c.inters.VXSocial
}

func (c *VXSocialClient) mutate(ctx context.Context, m *VXSocialMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VXSocialCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VXSocialUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VXSocialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VXSocialDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown VXSocial mutation op: %q", m.Op())
	}
}

// WalletClient is a client for the Wallet schema.
type WalletClient struct {
	config
}

// NewWalletClient returns a client for the Wallet from the given config.
func NewWalletClient(c config) *WalletClient {
	return &WalletClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wallet.Hooks(f(g(h())))`.
func (c *WalletClient) Use(hooks ...Hook) {
	c.hooks.Wallet = append(c.hooks.Wallet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wallet.Intercept(f(g(h())))`.
func (c *WalletClient) Intercept(interceptors ...Interceptor) {
	c.inters.Wallet = append(c.inters.Wallet, interceptors...)
}

// Create returns a builder for creating a Wallet entity.
func (c *WalletClient) Create() *WalletCreate {
	mutation := newWalletMutation(c.config, OpCreate)
	return &WalletCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Wallet entities.
func (c *WalletClient) CreateBulk(builders ...*WalletCreate) *WalletCreateBulk {
	return &WalletCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WalletClient) MapCreateBulk(slice any, setFunc func(*WalletCreate, int)) *WalletCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WalletCreateBulk{err: fmt.Errorf("calling to WalletClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WalletCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WalletCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Wallet.
func (c *WalletClient) Update() *WalletUpdate {
	mutation := newWalletMutation(c.config, OpUpdate)
	return &WalletUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WalletClient) UpdateOne(w *Wallet) *WalletUpdateOne {
	mutation := newWalletMutation(c.config, OpUpdateOne, withWallet(w))
	return &WalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WalletClient) UpdateOneID(id int64) *WalletUpdateOne {
	mutation := newWalletMutation(c.config, OpUpdateOne, withWalletID(id))
	return &WalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Wallet.
func (c *WalletClient) Delete() *WalletDelete {
	mutation := newWalletMutation(c.config, OpDelete)
	return &WalletDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WalletClient) DeleteOne(w *Wallet) *WalletDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WalletClient) DeleteOneID(id int64) *WalletDeleteOne {
	builder := c.Delete().Where(wallet.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WalletDeleteOne{builder}
}

// Query returns a query builder for Wallet.
func (c *WalletClient) Query() *WalletQuery {
	return &WalletQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWallet},
		inters: c.Interceptors(),
	}
}

// Get returns a Wallet entity by its id.
func (c *WalletClient) Get(ctx context.Context, id int64) (*Wallet, error) {
	return c.Query().Where(wallet.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WalletClient) GetX(ctx context.Context, id int64) *Wallet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Wallet.
func (c *WalletClient) QueryUser(w *Wallet) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(wallet.Table, wallet.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, wallet.UserTable, wallet.UserColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a Wallet.
func (c *WalletClient) QuerySymbol(w *Wallet) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(wallet.Table, wallet.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, wallet.SymbolTable, wallet.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WalletClient) Hooks() []Hook {
	return c.hooks.Wallet
}

// Interceptors returns the client interceptors.
func (c *WalletClient) Interceptors() []Interceptor {
	return c.inters.Wallet
}

func (c *WalletClient) mutate(ctx context.Context, m *WalletMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WalletCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WalletUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WalletDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("cep_ent: unknown Wallet mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Bill, Campaign, CampaignOrder, Collect, CostAccount, CostBill, Device,
		DeviceGpuMission, EarnBill, EnumCondition, EnumMissionStatus, FrpcInfo,
		FrpsInfo, Gpu, HmacKeyPair, InputLog, Invite, LoginRecord, Mission,
		MissionBatch, MissionConsumeOrder, MissionKeyPair, MissionKind, MissionOrder,
		MissionProduceOrder, MissionProduction, OutputLog, PlatformAccount, Price,
		ProfitAccount, ProfitSetting, RechargeCampaignRule, RechargeOrder, Symbol,
		TransferOrder, User, UserDevice, VXAccount, VXSocial, Wallet []ent.Hook
	}
	inters struct {
		Bill, Campaign, CampaignOrder, Collect, CostAccount, CostBill, Device,
		DeviceGpuMission, EarnBill, EnumCondition, EnumMissionStatus, FrpcInfo,
		FrpsInfo, Gpu, HmacKeyPair, InputLog, Invite, LoginRecord, Mission,
		MissionBatch, MissionConsumeOrder, MissionKeyPair, MissionKind, MissionOrder,
		MissionProduceOrder, MissionProduction, OutputLog, PlatformAccount, Price,
		ProfitAccount, ProfitSetting, RechargeCampaignRule, RechargeOrder, Symbol,
		TransferOrder, User, UserDevice, VXAccount, VXSocial, Wallet []ent.Interceptor
	}
)
