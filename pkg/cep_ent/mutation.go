// Code generated by ent, DO NOT EDIT.

package cep_ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/apitoken"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/artwork"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/artworklike"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/bill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/campaign"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/campaignorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/cdkinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/cloudfile"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/collect"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/device"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/devicegpumission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/deviceofflinerecord"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/devicereboottime"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/devicestate"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/earnbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enumcondition"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enummissionstatus"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/extraservice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/extraserviceorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/extraserviceprice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/frpcinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/frpsinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/giftmissionconfig"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/gpu"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/hmackeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/incomemanage"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/inputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/invite"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/invokemodelorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/loginrecord"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lotto"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottochancerule"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottogetcountrecord"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottoprize"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottorecord"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/lottousercount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/mission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionbatch"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missioncategory"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionconsumeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionextraservice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionfailedfeedback"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkind"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionproduceorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionproduction"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/model"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/modelprice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/outputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/platformaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/predicate"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/price"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitsetting"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/rechargecampaignrule"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/rechargeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/renewalagreement"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/survey"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/surveyanswer"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/surveyquestion"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/surveyresponse"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/symbol"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/transferorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/troublededuct"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/user"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/userdevice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/usermodel"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxsocial"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/wallet"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/withdrawaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/withdrawrecord"
	"github.com/stark-sim/cephalon-ent/pkg/enums"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApiToken              = "ApiToken"
	TypeArtwork               = "Artwork"
	TypeArtworkLike           = "ArtworkLike"
	TypeBill                  = "Bill"
	TypeCDKInfo               = "CDKInfo"
	TypeCampaign              = "Campaign"
	TypeCampaignOrder         = "CampaignOrder"
	TypeCloudFile             = "CloudFile"
	TypeCollect               = "Collect"
	TypeCostAccount           = "CostAccount"
	TypeCostBill              = "CostBill"
	TypeDevice                = "Device"
	TypeDeviceGpuMission      = "DeviceGpuMission"
	TypeDeviceOfflineRecord   = "DeviceOfflineRecord"
	TypeDeviceRebootTime      = "DeviceRebootTime"
	TypeDeviceState           = "DeviceState"
	TypeEarnBill              = "EarnBill"
	TypeEnumCondition         = "EnumCondition"
	TypeEnumMissionStatus     = "EnumMissionStatus"
	TypeExtraService          = "ExtraService"
	TypeExtraServiceOrder     = "ExtraServiceOrder"
	TypeExtraServicePrice     = "ExtraServicePrice"
	TypeFrpcInfo              = "FrpcInfo"
	TypeFrpsInfo              = "FrpsInfo"
	TypeGiftMissionConfig     = "GiftMissionConfig"
	TypeGpu                   = "Gpu"
	TypeHmacKeyPair           = "HmacKeyPair"
	TypeIncomeManage          = "IncomeManage"
	TypeInputLog              = "InputLog"
	TypeInvite                = "Invite"
	TypeInvokeModelOrder      = "InvokeModelOrder"
	TypeLoginRecord           = "LoginRecord"
	TypeLotto                 = "Lotto"
	TypeLottoChanceRule       = "LottoChanceRule"
	TypeLottoGetCountRecord   = "LottoGetCountRecord"
	TypeLottoPrize            = "LottoPrize"
	TypeLottoRecord           = "LottoRecord"
	TypeLottoUserCount        = "LottoUserCount"
	TypeMission               = "Mission"
	TypeMissionBatch          = "MissionBatch"
	TypeMissionCategory       = "MissionCategory"
	TypeMissionConsumeOrder   = "MissionConsumeOrder"
	TypeMissionExtraService   = "MissionExtraService"
	TypeMissionFailedFeedback = "MissionFailedFeedback"
	TypeMissionKeyPair        = "MissionKeyPair"
	TypeMissionKind           = "MissionKind"
	TypeMissionOrder          = "MissionOrder"
	TypeMissionProduceOrder   = "MissionProduceOrder"
	TypeMissionProduction     = "MissionProduction"
	TypeModel                 = "Model"
	TypeModelPrice            = "ModelPrice"
	TypeOutputLog             = "OutputLog"
	TypePlatformAccount       = "PlatformAccount"
	TypePrice                 = "Price"
	TypeProfitAccount         = "ProfitAccount"
	TypeProfitSetting         = "ProfitSetting"
	TypeRechargeCampaignRule  = "RechargeCampaignRule"
	TypeRechargeOrder         = "RechargeOrder"
	TypeRenewalAgreement      = "RenewalAgreement"
	TypeSurvey                = "Survey"
	TypeSurveyAnswer          = "SurveyAnswer"
	TypeSurveyQuestion        = "SurveyQuestion"
	TypeSurveyResponse        = "SurveyResponse"
	TypeSymbol                = "Symbol"
	TypeTransferOrder         = "TransferOrder"
	TypeTroubleDeduct         = "TroubleDeduct"
	TypeUser                  = "User"
	TypeUserDevice            = "UserDevice"
	TypeUserModel             = "UserModel"
	TypeVXAccount             = "VXAccount"
	TypeVXSocial              = "VXSocial"
	TypeWallet                = "Wallet"
	TypeWithdrawAccount       = "WithdrawAccount"
	TypeWithdrawRecord        = "WithdrawRecord"
)

// ApiTokenMutation represents an operation that mutates the ApiToken nodes in the graph.
type ApiTokenMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	name                       *string
	token                      *string
	status                     *enums.ApiTokenStatus
	clearedFields              map[string]struct{}
	invoke_model_orders        map[int64]struct{}
	removedinvoke_model_orders map[int64]struct{}
	clearedinvoke_model_orders bool
	user                       *int64
	cleareduser                bool
	done                       bool
	oldValue                   func(context.Context) (*ApiToken, error)
	predicates                 []predicate.ApiToken
}

var _ ent.Mutation = (*ApiTokenMutation)(nil)

// apitokenOption allows management of the mutation configuration using functional options.
type apitokenOption func(*ApiTokenMutation)

// newApiTokenMutation creates new mutation for the ApiToken entity.
func newApiTokenMutation(c config, op Op, opts ...apitokenOption) *ApiTokenMutation {
	m := &ApiTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeApiToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiTokenID sets the ID field of the mutation.
func withApiTokenID(id int64) apitokenOption {
	return func(m *ApiTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiToken
		)
		m.oldValue = func(ctx context.Context) (*ApiToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiToken sets the old ApiToken of the mutation.
func withApiToken(node *ApiToken) apitokenOption {
	return func(m *ApiTokenMutation) {
		m.oldValue = func(context.Context) (*ApiToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiToken entities.
func (m *ApiTokenMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiTokenMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiTokenMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ApiTokenMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ApiTokenMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ApiTokenMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ApiTokenMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ApiTokenMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ApiTokenMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ApiTokenMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ApiTokenMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ApiTokenMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ApiTokenMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApiTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApiTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApiTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ApiTokenMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApiTokenMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApiTokenMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *ApiTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApiTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApiTokenMutation) ResetName() {
	m.name = nil
}

// SetToken sets the "token" field.
func (m *ApiTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *ApiTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *ApiTokenMutation) ResetToken() {
	m.token = nil
}

// SetStatus sets the "status" field.
func (m *ApiTokenMutation) SetStatus(ets enums.ApiTokenStatus) {
	m.status = &ets
}

// Status returns the value of the "status" field in the mutation.
func (m *ApiTokenMutation) Status() (r enums.ApiTokenStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldStatus(ctx context.Context) (v enums.ApiTokenStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ApiTokenMutation) ResetStatus() {
	m.status = nil
}

// AddInvokeModelOrderIDs adds the "invoke_model_orders" edge to the InvokeModelOrder entity by ids.
func (m *ApiTokenMutation) AddInvokeModelOrderIDs(ids ...int64) {
	if m.invoke_model_orders == nil {
		m.invoke_model_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.invoke_model_orders[ids[i]] = struct{}{}
	}
}

// ClearInvokeModelOrders clears the "invoke_model_orders" edge to the InvokeModelOrder entity.
func (m *ApiTokenMutation) ClearInvokeModelOrders() {
	m.clearedinvoke_model_orders = true
}

// InvokeModelOrdersCleared reports if the "invoke_model_orders" edge to the InvokeModelOrder entity was cleared.
func (m *ApiTokenMutation) InvokeModelOrdersCleared() bool {
	return m.clearedinvoke_model_orders
}

// RemoveInvokeModelOrderIDs removes the "invoke_model_orders" edge to the InvokeModelOrder entity by IDs.
func (m *ApiTokenMutation) RemoveInvokeModelOrderIDs(ids ...int64) {
	if m.removedinvoke_model_orders == nil {
		m.removedinvoke_model_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invoke_model_orders, ids[i])
		m.removedinvoke_model_orders[ids[i]] = struct{}{}
	}
}

// RemovedInvokeModelOrders returns the removed IDs of the "invoke_model_orders" edge to the InvokeModelOrder entity.
func (m *ApiTokenMutation) RemovedInvokeModelOrdersIDs() (ids []int64) {
	for id := range m.removedinvoke_model_orders {
		ids = append(ids, id)
	}
	return
}

// InvokeModelOrdersIDs returns the "invoke_model_orders" edge IDs in the mutation.
func (m *ApiTokenMutation) InvokeModelOrdersIDs() (ids []int64) {
	for id := range m.invoke_model_orders {
		ids = append(ids, id)
	}
	return
}

// ResetInvokeModelOrders resets all changes to the "invoke_model_orders" edge.
func (m *ApiTokenMutation) ResetInvokeModelOrders() {
	m.invoke_model_orders = nil
	m.clearedinvoke_model_orders = false
	m.removedinvoke_model_orders = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApiTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apitoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApiTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApiTokenMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApiTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ApiTokenMutation builder.
func (m *ApiTokenMutation) Where(ps ...predicate.ApiToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiToken).
func (m *ApiTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiTokenMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, apitoken.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, apitoken.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, apitoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apitoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apitoken.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, apitoken.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, apitoken.FieldName)
	}
	if m.token != nil {
		fields = append(fields, apitoken.FieldToken)
	}
	if m.status != nil {
		fields = append(fields, apitoken.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldCreatedBy:
		return m.CreatedBy()
	case apitoken.FieldUpdatedBy:
		return m.UpdatedBy()
	case apitoken.FieldCreatedAt:
		return m.CreatedAt()
	case apitoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case apitoken.FieldDeletedAt:
		return m.DeletedAt()
	case apitoken.FieldUserID:
		return m.UserID()
	case apitoken.FieldName:
		return m.Name()
	case apitoken.FieldToken:
		return m.Token()
	case apitoken.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitoken.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case apitoken.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case apitoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apitoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apitoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apitoken.FieldUserID:
		return m.OldUserID(ctx)
	case apitoken.FieldName:
		return m.OldName(ctx)
	case apitoken.FieldToken:
		return m.OldToken(ctx)
	case apitoken.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ApiToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case apitoken.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case apitoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apitoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apitoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apitoken.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apitoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apitoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case apitoken.FieldStatus:
		v, ok := value.(enums.ApiTokenStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiTokenMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, apitoken.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, apitoken.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldCreatedBy:
		return m.AddedCreatedBy()
	case apitoken.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case apitoken.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ApiToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiTokenMutation) ResetField(name string) error {
	switch name {
	case apitoken.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case apitoken.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case apitoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apitoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apitoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apitoken.FieldUserID:
		m.ResetUserID()
		return nil
	case apitoken.FieldName:
		m.ResetName()
		return nil
	case apitoken.FieldToken:
		m.ResetToken()
		return nil
	case apitoken.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invoke_model_orders != nil {
		edges = append(edges, apitoken.EdgeInvokeModelOrders)
	}
	if m.user != nil {
		edges = append(edges, apitoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeInvokeModelOrders:
		ids := make([]ent.Value, 0, len(m.invoke_model_orders))
		for id := range m.invoke_model_orders {
			ids = append(ids, id)
		}
		return ids
	case apitoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinvoke_model_orders != nil {
		edges = append(edges, apitoken.EdgeInvokeModelOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeInvokeModelOrders:
		ids := make([]ent.Value, 0, len(m.removedinvoke_model_orders))
		for id := range m.removedinvoke_model_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvoke_model_orders {
		edges = append(edges, apitoken.EdgeInvokeModelOrders)
	}
	if m.cleareduser {
		edges = append(edges, apitoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case apitoken.EdgeInvokeModelOrders:
		return m.clearedinvoke_model_orders
	case apitoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiTokenMutation) ClearEdge(name string) error {
	switch name {
	case apitoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ApiToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiTokenMutation) ResetEdge(name string) error {
	switch name {
	case apitoken.EdgeInvokeModelOrders:
		m.ResetInvokeModelOrders()
		return nil
	case apitoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ApiToken edge %s", name)
}

// ArtworkMutation represents an operation that mutates the Artwork nodes in the graph.
type ArtworkMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_by           *int64
	addcreated_by        *int64
	updated_by           *int64
	addupdated_by        *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	url                  *string
	clearedFields        map[string]struct{}
	author               *int64
	clearedauthor        bool
	artwork_likes        map[int64]struct{}
	removedartwork_likes map[int64]struct{}
	clearedartwork_likes bool
	done                 bool
	oldValue             func(context.Context) (*Artwork, error)
	predicates           []predicate.Artwork
}

var _ ent.Mutation = (*ArtworkMutation)(nil)

// artworkOption allows management of the mutation configuration using functional options.
type artworkOption func(*ArtworkMutation)

// newArtworkMutation creates new mutation for the Artwork entity.
func newArtworkMutation(c config, op Op, opts ...artworkOption) *ArtworkMutation {
	m := &ArtworkMutation{
		config:        c,
		op:            op,
		typ:           TypeArtwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtworkID sets the ID field of the mutation.
func withArtworkID(id int64) artworkOption {
	return func(m *ArtworkMutation) {
		var (
			err   error
			once  sync.Once
			value *Artwork
		)
		m.oldValue = func(ctx context.Context) (*Artwork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtwork sets the old Artwork of the mutation.
func withArtwork(node *Artwork) artworkOption {
	return func(m *ArtworkMutation) {
		m.oldValue = func(context.Context) (*Artwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Artwork entities.
func (m *ArtworkMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtworkMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtworkMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artwork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ArtworkMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ArtworkMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ArtworkMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ArtworkMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ArtworkMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ArtworkMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ArtworkMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ArtworkMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ArtworkMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ArtworkMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtworkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtworkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtworkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtworkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtworkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtworkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArtworkMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArtworkMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArtworkMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *ArtworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtworkMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *ArtworkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ArtworkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ArtworkMutation) ResetURL() {
	m.url = nil
}

// SetAuthorID sets the "author_id" field.
func (m *ArtworkMutation) SetAuthorID(i int64) {
	m.author = &i
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *ArtworkMutation) AuthorID() (r int64, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldAuthorID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *ArtworkMutation) ResetAuthorID() {
	m.author = nil
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *ArtworkMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[artwork.FieldAuthorID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *ArtworkMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *ArtworkMutation) AuthorIDs() (ids []int64) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *ArtworkMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// AddArtworkLikeIDs adds the "artwork_likes" edge to the ArtworkLike entity by ids.
func (m *ArtworkMutation) AddArtworkLikeIDs(ids ...int64) {
	if m.artwork_likes == nil {
		m.artwork_likes = make(map[int64]struct{})
	}
	for i := range ids {
		m.artwork_likes[ids[i]] = struct{}{}
	}
}

// ClearArtworkLikes clears the "artwork_likes" edge to the ArtworkLike entity.
func (m *ArtworkMutation) ClearArtworkLikes() {
	m.clearedartwork_likes = true
}

// ArtworkLikesCleared reports if the "artwork_likes" edge to the ArtworkLike entity was cleared.
func (m *ArtworkMutation) ArtworkLikesCleared() bool {
	return m.clearedartwork_likes
}

// RemoveArtworkLikeIDs removes the "artwork_likes" edge to the ArtworkLike entity by IDs.
func (m *ArtworkMutation) RemoveArtworkLikeIDs(ids ...int64) {
	if m.removedartwork_likes == nil {
		m.removedartwork_likes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.artwork_likes, ids[i])
		m.removedartwork_likes[ids[i]] = struct{}{}
	}
}

// RemovedArtworkLikes returns the removed IDs of the "artwork_likes" edge to the ArtworkLike entity.
func (m *ArtworkMutation) RemovedArtworkLikesIDs() (ids []int64) {
	for id := range m.removedartwork_likes {
		ids = append(ids, id)
	}
	return
}

// ArtworkLikesIDs returns the "artwork_likes" edge IDs in the mutation.
func (m *ArtworkMutation) ArtworkLikesIDs() (ids []int64) {
	for id := range m.artwork_likes {
		ids = append(ids, id)
	}
	return
}

// ResetArtworkLikes resets all changes to the "artwork_likes" edge.
func (m *ArtworkMutation) ResetArtworkLikes() {
	m.artwork_likes = nil
	m.clearedartwork_likes = false
	m.removedartwork_likes = nil
}

// Where appends a list predicates to the ArtworkMutation builder.
func (m *ArtworkMutation) Where(ps ...predicate.Artwork) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtworkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtworkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artwork, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtworkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtworkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artwork).
func (m *ArtworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtworkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, artwork.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, artwork.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, artwork.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, artwork.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, artwork.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, artwork.FieldName)
	}
	if m.url != nil {
		fields = append(fields, artwork.FieldURL)
	}
	if m.author != nil {
		fields = append(fields, artwork.FieldAuthorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artwork.FieldCreatedBy:
		return m.CreatedBy()
	case artwork.FieldUpdatedBy:
		return m.UpdatedBy()
	case artwork.FieldCreatedAt:
		return m.CreatedAt()
	case artwork.FieldUpdatedAt:
		return m.UpdatedAt()
	case artwork.FieldDeletedAt:
		return m.DeletedAt()
	case artwork.FieldName:
		return m.Name()
	case artwork.FieldURL:
		return m.URL()
	case artwork.FieldAuthorID:
		return m.AuthorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artwork.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case artwork.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case artwork.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artwork.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artwork.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case artwork.FieldName:
		return m.OldName(ctx)
	case artwork.FieldURL:
		return m.OldURL(ctx)
	case artwork.FieldAuthorID:
		return m.OldAuthorID(ctx)
	}
	return nil, fmt.Errorf("unknown Artwork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artwork.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case artwork.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case artwork.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artwork.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artwork.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case artwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case artwork.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case artwork.FieldAuthorID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	}
	return fmt.Errorf("unknown Artwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtworkMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, artwork.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, artwork.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtworkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case artwork.FieldCreatedBy:
		return m.AddedCreatedBy()
	case artwork.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case artwork.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case artwork.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Artwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artwork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtworkMutation) ResetField(name string) error {
	switch name {
	case artwork.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case artwork.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case artwork.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artwork.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artwork.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case artwork.FieldName:
		m.ResetName()
		return nil
	case artwork.FieldURL:
		m.ResetURL()
		return nil
	case artwork.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	}
	return fmt.Errorf("unknown Artwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.author != nil {
		edges = append(edges, artwork.EdgeAuthor)
	}
	if m.artwork_likes != nil {
		edges = append(edges, artwork.EdgeArtworkLikes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artwork.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case artwork.EdgeArtworkLikes:
		ids := make([]ent.Value, 0, len(m.artwork_likes))
		for id := range m.artwork_likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedartwork_likes != nil {
		edges = append(edges, artwork.EdgeArtworkLikes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artwork.EdgeArtworkLikes:
		ids := make([]ent.Value, 0, len(m.removedartwork_likes))
		for id := range m.removedartwork_likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauthor {
		edges = append(edges, artwork.EdgeAuthor)
	}
	if m.clearedartwork_likes {
		edges = append(edges, artwork.EdgeArtworkLikes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtworkMutation) EdgeCleared(name string) bool {
	switch name {
	case artwork.EdgeAuthor:
		return m.clearedauthor
	case artwork.EdgeArtworkLikes:
		return m.clearedartwork_likes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtworkMutation) ClearEdge(name string) error {
	switch name {
	case artwork.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Artwork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtworkMutation) ResetEdge(name string) error {
	switch name {
	case artwork.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case artwork.EdgeArtworkLikes:
		m.ResetArtworkLikes()
		return nil
	}
	return fmt.Errorf("unknown Artwork edge %s", name)
}

// ArtworkLikeMutation represents an operation that mutates the ArtworkLike nodes in the graph.
type ArtworkLikeMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_by     *int64
	addcreated_by  *int64
	updated_by     *int64
	addupdated_by  *int64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	date           *int32
	adddate        *int32
	clearedFields  map[string]struct{}
	user           *int64
	cleareduser    bool
	artwork        *int64
	clearedartwork bool
	done           bool
	oldValue       func(context.Context) (*ArtworkLike, error)
	predicates     []predicate.ArtworkLike
}

var _ ent.Mutation = (*ArtworkLikeMutation)(nil)

// artworklikeOption allows management of the mutation configuration using functional options.
type artworklikeOption func(*ArtworkLikeMutation)

// newArtworkLikeMutation creates new mutation for the ArtworkLike entity.
func newArtworkLikeMutation(c config, op Op, opts ...artworklikeOption) *ArtworkLikeMutation {
	m := &ArtworkLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeArtworkLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtworkLikeID sets the ID field of the mutation.
func withArtworkLikeID(id int64) artworklikeOption {
	return func(m *ArtworkLikeMutation) {
		var (
			err   error
			once  sync.Once
			value *ArtworkLike
		)
		m.oldValue = func(ctx context.Context) (*ArtworkLike, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArtworkLike.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtworkLike sets the old ArtworkLike of the mutation.
func withArtworkLike(node *ArtworkLike) artworklikeOption {
	return func(m *ArtworkLikeMutation) {
		m.oldValue = func(context.Context) (*ArtworkLike, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtworkLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtworkLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArtworkLike entities.
func (m *ArtworkLikeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtworkLikeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtworkLikeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArtworkLike.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ArtworkLikeMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ArtworkLikeMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ArtworkLikeMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ArtworkLikeMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ArtworkLikeMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ArtworkLikeMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ArtworkLikeMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ArtworkLikeMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ArtworkLikeMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ArtworkLikeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtworkLikeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtworkLikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtworkLikeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtworkLikeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtworkLikeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtworkLikeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArtworkLikeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArtworkLikeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArtworkLikeMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ArtworkLikeMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ArtworkLikeMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ArtworkLikeMutation) ResetUserID() {
	m.user = nil
}

// SetArtworkID sets the "artwork_id" field.
func (m *ArtworkLikeMutation) SetArtworkID(i int64) {
	m.artwork = &i
}

// ArtworkID returns the value of the "artwork_id" field in the mutation.
func (m *ArtworkLikeMutation) ArtworkID() (r int64, exists bool) {
	v := m.artwork
	if v == nil {
		return
	}
	return *v, true
}

// OldArtworkID returns the old "artwork_id" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldArtworkID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtworkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtworkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtworkID: %w", err)
	}
	return oldValue.ArtworkID, nil
}

// ResetArtworkID resets all changes to the "artwork_id" field.
func (m *ArtworkLikeMutation) ResetArtworkID() {
	m.artwork = nil
}

// SetDate sets the "date" field.
func (m *ArtworkLikeMutation) SetDate(i int32) {
	m.date = &i
	m.adddate = nil
}

// Date returns the value of the "date" field in the mutation.
func (m *ArtworkLikeMutation) Date() (r int32, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldDate(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to the "date" field.
func (m *ArtworkLikeMutation) AddDate(i int32) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the "date" field in this mutation.
func (m *ArtworkLikeMutation) AddedDate() (r int32, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate resets all changes to the "date" field.
func (m *ArtworkLikeMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ArtworkLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[artworklike.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ArtworkLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ArtworkLikeMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ArtworkLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearArtwork clears the "artwork" edge to the Artwork entity.
func (m *ArtworkLikeMutation) ClearArtwork() {
	m.clearedartwork = true
	m.clearedFields[artworklike.FieldArtworkID] = struct{}{}
}

// ArtworkCleared reports if the "artwork" edge to the Artwork entity was cleared.
func (m *ArtworkLikeMutation) ArtworkCleared() bool {
	return m.clearedartwork
}

// ArtworkIDs returns the "artwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtworkID instead. It exists only for internal usage by the builders.
func (m *ArtworkLikeMutation) ArtworkIDs() (ids []int64) {
	if id := m.artwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtwork resets all changes to the "artwork" edge.
func (m *ArtworkLikeMutation) ResetArtwork() {
	m.artwork = nil
	m.clearedartwork = false
}

// Where appends a list predicates to the ArtworkLikeMutation builder.
func (m *ArtworkLikeMutation) Where(ps ...predicate.ArtworkLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtworkLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtworkLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArtworkLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtworkLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtworkLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArtworkLike).
func (m *ArtworkLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtworkLikeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, artworklike.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, artworklike.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, artworklike.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, artworklike.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, artworklike.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, artworklike.FieldUserID)
	}
	if m.artwork != nil {
		fields = append(fields, artworklike.FieldArtworkID)
	}
	if m.date != nil {
		fields = append(fields, artworklike.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtworkLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artworklike.FieldCreatedBy:
		return m.CreatedBy()
	case artworklike.FieldUpdatedBy:
		return m.UpdatedBy()
	case artworklike.FieldCreatedAt:
		return m.CreatedAt()
	case artworklike.FieldUpdatedAt:
		return m.UpdatedAt()
	case artworklike.FieldDeletedAt:
		return m.DeletedAt()
	case artworklike.FieldUserID:
		return m.UserID()
	case artworklike.FieldArtworkID:
		return m.ArtworkID()
	case artworklike.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtworkLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artworklike.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case artworklike.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case artworklike.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artworklike.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artworklike.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case artworklike.FieldUserID:
		return m.OldUserID(ctx)
	case artworklike.FieldArtworkID:
		return m.OldArtworkID(ctx)
	case artworklike.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown ArtworkLike field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtworkLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artworklike.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case artworklike.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case artworklike.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artworklike.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artworklike.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case artworklike.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case artworklike.FieldArtworkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtworkID(v)
		return nil
	case artworklike.FieldDate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtworkLikeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, artworklike.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, artworklike.FieldUpdatedBy)
	}
	if m.adddate != nil {
		fields = append(fields, artworklike.FieldDate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtworkLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case artworklike.FieldCreatedBy:
		return m.AddedCreatedBy()
	case artworklike.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case artworklike.FieldDate:
		return m.AddedDate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtworkLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case artworklike.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case artworklike.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case artworklike.FieldDate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtworkLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtworkLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtworkLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArtworkLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtworkLikeMutation) ResetField(name string) error {
	switch name {
	case artworklike.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case artworklike.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case artworklike.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artworklike.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artworklike.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case artworklike.FieldUserID:
		m.ResetUserID()
		return nil
	case artworklike.FieldArtworkID:
		m.ResetArtworkID()
		return nil
	case artworklike.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtworkLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, artworklike.EdgeUser)
	}
	if m.artwork != nil {
		edges = append(edges, artworklike.EdgeArtwork)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtworkLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artworklike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case artworklike.EdgeArtwork:
		if id := m.artwork; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtworkLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtworkLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtworkLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, artworklike.EdgeUser)
	}
	if m.clearedartwork {
		edges = append(edges, artworklike.EdgeArtwork)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtworkLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case artworklike.EdgeUser:
		return m.cleareduser
	case artworklike.EdgeArtwork:
		return m.clearedartwork
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtworkLikeMutation) ClearEdge(name string) error {
	switch name {
	case artworklike.EdgeUser:
		m.ClearUser()
		return nil
	case artworklike.EdgeArtwork:
		m.ClearArtwork()
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtworkLikeMutation) ResetEdge(name string) error {
	switch name {
	case artworklike.EdgeUser:
		m.ResetUser()
		return nil
	case artworklike.EdgeArtwork:
		m.ResetArtwork()
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike edge %s", name)
}

// BillMutation represents an operation that mutates the Bill nodes in the graph.
type BillMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int64
	created_by                *int64
	addcreated_by             *int64
	updated_by                *int64
	addupdated_by             *int64
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	_type                     *enums.BillType
	way                       *enums.BillWay
	profit_symbol_id          *int64
	addprofit_symbol_id       *int64
	amount                    *int64
	addamount                 *int64
	target_before_amount      *int64
	addtarget_before_amount   *int64
	target_after_amount       *int64
	addtarget_after_amount    *int64
	source_before_amount      *int64
	addsource_before_amount   *int64
	source_after_amount       *int64
	addsource_after_amount    *int64
	serial_number             *string
	clearedFields             map[string]struct{}
	source_user               *int64
	clearedsource_user        bool
	target_user               *int64
	clearedtarget_user        bool
	transfer_order            *int64
	clearedtransfer_order     bool
	mission_order             *int64
	clearedmission_order      bool
	invoke_model_order        *int64
	clearedinvoke_model_order bool
	invite                    *int64
	clearedinvite             bool
	symbol                    *int64
	clearedsymbol             bool
	target_symbol             *int64
	clearedtarget_symbol      bool
	done                      bool
	oldValue                  func(context.Context) (*Bill, error)
	predicates                []predicate.Bill
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows management of the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for the Bill entity.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the ID field of the mutation.
func withBillID(id int64) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bill entities.
func (m *BillMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *BillMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BillMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *BillMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *BillMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BillMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BillMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BillMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *BillMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *BillMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BillMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *BillMutation) SetType(et enums.BillType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *BillMutation) GetType() (r enums.BillType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldType(ctx context.Context) (v enums.BillType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BillMutation) ResetType() {
	m._type = nil
}

// SetOrderID sets the "order_id" field.
func (m *BillMutation) SetOrderID(i int64) {
	m.transfer_order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *BillMutation) OrderID() (r int64, exists bool) {
	v := m.transfer_order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *BillMutation) ClearOrderID() {
	m.transfer_order = nil
	m.clearedFields[bill.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *BillMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[bill.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *BillMutation) ResetOrderID() {
	m.transfer_order = nil
	delete(m.clearedFields, bill.FieldOrderID)
}

// SetWay sets the "way" field.
func (m *BillMutation) SetWay(ew enums.BillWay) {
	m.way = &ew
}

// Way returns the value of the "way" field in the mutation.
func (m *BillMutation) Way() (r enums.BillWay, exists bool) {
	v := m.way
	if v == nil {
		return
	}
	return *v, true
}

// OldWay returns the old "way" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldWay(ctx context.Context) (v enums.BillWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWay: %w", err)
	}
	return oldValue.Way, nil
}

// ResetWay resets all changes to the "way" field.
func (m *BillMutation) ResetWay() {
	m.way = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *BillMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *BillMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *BillMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetTargetSymbolID sets the "target_symbol_id" field.
func (m *BillMutation) SetTargetSymbolID(i int64) {
	m.target_symbol = &i
}

// TargetSymbolID returns the value of the "target_symbol_id" field in the mutation.
func (m *BillMutation) TargetSymbolID() (r int64, exists bool) {
	v := m.target_symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetSymbolID returns the old "target_symbol_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldTargetSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetSymbolID: %w", err)
	}
	return oldValue.TargetSymbolID, nil
}

// ResetTargetSymbolID resets all changes to the "target_symbol_id" field.
func (m *BillMutation) ResetTargetSymbolID() {
	m.target_symbol = nil
}

// SetProfitSymbolID sets the "profit_symbol_id" field.
func (m *BillMutation) SetProfitSymbolID(i int64) {
	m.profit_symbol_id = &i
	m.addprofit_symbol_id = nil
}

// ProfitSymbolID returns the value of the "profit_symbol_id" field in the mutation.
func (m *BillMutation) ProfitSymbolID() (r int64, exists bool) {
	v := m.profit_symbol_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitSymbolID returns the old "profit_symbol_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldProfitSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitSymbolID: %w", err)
	}
	return oldValue.ProfitSymbolID, nil
}

// AddProfitSymbolID adds i to the "profit_symbol_id" field.
func (m *BillMutation) AddProfitSymbolID(i int64) {
	if m.addprofit_symbol_id != nil {
		*m.addprofit_symbol_id += i
	} else {
		m.addprofit_symbol_id = &i
	}
}

// AddedProfitSymbolID returns the value that was added to the "profit_symbol_id" field in this mutation.
func (m *BillMutation) AddedProfitSymbolID() (r int64, exists bool) {
	v := m.addprofit_symbol_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitSymbolID resets all changes to the "profit_symbol_id" field.
func (m *BillMutation) ResetProfitSymbolID() {
	m.profit_symbol_id = nil
	m.addprofit_symbol_id = nil
}

// SetAmount sets the "amount" field.
func (m *BillMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *BillMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *BillMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *BillMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *BillMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetTargetUserID sets the "target_user_id" field.
func (m *BillMutation) SetTargetUserID(i int64) {
	m.target_user = &i
}

// TargetUserID returns the value of the "target_user_id" field in the mutation.
func (m *BillMutation) TargetUserID() (r int64, exists bool) {
	v := m.target_user
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetUserID returns the old "target_user_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldTargetUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetUserID: %w", err)
	}
	return oldValue.TargetUserID, nil
}

// ResetTargetUserID resets all changes to the "target_user_id" field.
func (m *BillMutation) ResetTargetUserID() {
	m.target_user = nil
}

// SetTargetBeforeAmount sets the "target_before_amount" field.
func (m *BillMutation) SetTargetBeforeAmount(i int64) {
	m.target_before_amount = &i
	m.addtarget_before_amount = nil
}

// TargetBeforeAmount returns the value of the "target_before_amount" field in the mutation.
func (m *BillMutation) TargetBeforeAmount() (r int64, exists bool) {
	v := m.target_before_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetBeforeAmount returns the old "target_before_amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldTargetBeforeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetBeforeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetBeforeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetBeforeAmount: %w", err)
	}
	return oldValue.TargetBeforeAmount, nil
}

// AddTargetBeforeAmount adds i to the "target_before_amount" field.
func (m *BillMutation) AddTargetBeforeAmount(i int64) {
	if m.addtarget_before_amount != nil {
		*m.addtarget_before_amount += i
	} else {
		m.addtarget_before_amount = &i
	}
}

// AddedTargetBeforeAmount returns the value that was added to the "target_before_amount" field in this mutation.
func (m *BillMutation) AddedTargetBeforeAmount() (r int64, exists bool) {
	v := m.addtarget_before_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetBeforeAmount resets all changes to the "target_before_amount" field.
func (m *BillMutation) ResetTargetBeforeAmount() {
	m.target_before_amount = nil
	m.addtarget_before_amount = nil
}

// SetTargetAfterAmount sets the "target_after_amount" field.
func (m *BillMutation) SetTargetAfterAmount(i int64) {
	m.target_after_amount = &i
	m.addtarget_after_amount = nil
}

// TargetAfterAmount returns the value of the "target_after_amount" field in the mutation.
func (m *BillMutation) TargetAfterAmount() (r int64, exists bool) {
	v := m.target_after_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetAfterAmount returns the old "target_after_amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldTargetAfterAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetAfterAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetAfterAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetAfterAmount: %w", err)
	}
	return oldValue.TargetAfterAmount, nil
}

// AddTargetAfterAmount adds i to the "target_after_amount" field.
func (m *BillMutation) AddTargetAfterAmount(i int64) {
	if m.addtarget_after_amount != nil {
		*m.addtarget_after_amount += i
	} else {
		m.addtarget_after_amount = &i
	}
}

// AddedTargetAfterAmount returns the value that was added to the "target_after_amount" field in this mutation.
func (m *BillMutation) AddedTargetAfterAmount() (r int64, exists bool) {
	v := m.addtarget_after_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetAfterAmount resets all changes to the "target_after_amount" field.
func (m *BillMutation) ResetTargetAfterAmount() {
	m.target_after_amount = nil
	m.addtarget_after_amount = nil
}

// SetSourceUserID sets the "source_user_id" field.
func (m *BillMutation) SetSourceUserID(i int64) {
	m.source_user = &i
}

// SourceUserID returns the value of the "source_user_id" field in the mutation.
func (m *BillMutation) SourceUserID() (r int64, exists bool) {
	v := m.source_user
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceUserID returns the old "source_user_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSourceUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceUserID: %w", err)
	}
	return oldValue.SourceUserID, nil
}

// ResetSourceUserID resets all changes to the "source_user_id" field.
func (m *BillMutation) ResetSourceUserID() {
	m.source_user = nil
}

// SetSourceBeforeAmount sets the "source_before_amount" field.
func (m *BillMutation) SetSourceBeforeAmount(i int64) {
	m.source_before_amount = &i
	m.addsource_before_amount = nil
}

// SourceBeforeAmount returns the value of the "source_before_amount" field in the mutation.
func (m *BillMutation) SourceBeforeAmount() (r int64, exists bool) {
	v := m.source_before_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceBeforeAmount returns the old "source_before_amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSourceBeforeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceBeforeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceBeforeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceBeforeAmount: %w", err)
	}
	return oldValue.SourceBeforeAmount, nil
}

// AddSourceBeforeAmount adds i to the "source_before_amount" field.
func (m *BillMutation) AddSourceBeforeAmount(i int64) {
	if m.addsource_before_amount != nil {
		*m.addsource_before_amount += i
	} else {
		m.addsource_before_amount = &i
	}
}

// AddedSourceBeforeAmount returns the value that was added to the "source_before_amount" field in this mutation.
func (m *BillMutation) AddedSourceBeforeAmount() (r int64, exists bool) {
	v := m.addsource_before_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSourceBeforeAmount resets all changes to the "source_before_amount" field.
func (m *BillMutation) ResetSourceBeforeAmount() {
	m.source_before_amount = nil
	m.addsource_before_amount = nil
}

// SetSourceAfterAmount sets the "source_after_amount" field.
func (m *BillMutation) SetSourceAfterAmount(i int64) {
	m.source_after_amount = &i
	m.addsource_after_amount = nil
}

// SourceAfterAmount returns the value of the "source_after_amount" field in the mutation.
func (m *BillMutation) SourceAfterAmount() (r int64, exists bool) {
	v := m.source_after_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceAfterAmount returns the old "source_after_amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSourceAfterAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceAfterAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceAfterAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceAfterAmount: %w", err)
	}
	return oldValue.SourceAfterAmount, nil
}

// AddSourceAfterAmount adds i to the "source_after_amount" field.
func (m *BillMutation) AddSourceAfterAmount(i int64) {
	if m.addsource_after_amount != nil {
		*m.addsource_after_amount += i
	} else {
		m.addsource_after_amount = &i
	}
}

// AddedSourceAfterAmount returns the value that was added to the "source_after_amount" field in this mutation.
func (m *BillMutation) AddedSourceAfterAmount() (r int64, exists bool) {
	v := m.addsource_after_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSourceAfterAmount resets all changes to the "source_after_amount" field.
func (m *BillMutation) ResetSourceAfterAmount() {
	m.source_after_amount = nil
	m.addsource_after_amount = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *BillMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *BillMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *BillMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetInviteID sets the "invite_id" field.
func (m *BillMutation) SetInviteID(i int64) {
	m.invite = &i
}

// InviteID returns the value of the "invite_id" field in the mutation.
func (m *BillMutation) InviteID() (r int64, exists bool) {
	v := m.invite
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteID returns the old "invite_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldInviteID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteID: %w", err)
	}
	return oldValue.InviteID, nil
}

// ResetInviteID resets all changes to the "invite_id" field.
func (m *BillMutation) ResetInviteID() {
	m.invite = nil
}

// ClearSourceUser clears the "source_user" edge to the User entity.
func (m *BillMutation) ClearSourceUser() {
	m.clearedsource_user = true
	m.clearedFields[bill.FieldSourceUserID] = struct{}{}
}

// SourceUserCleared reports if the "source_user" edge to the User entity was cleared.
func (m *BillMutation) SourceUserCleared() bool {
	return m.clearedsource_user
}

// SourceUserIDs returns the "source_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceUserID instead. It exists only for internal usage by the builders.
func (m *BillMutation) SourceUserIDs() (ids []int64) {
	if id := m.source_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceUser resets all changes to the "source_user" edge.
func (m *BillMutation) ResetSourceUser() {
	m.source_user = nil
	m.clearedsource_user = false
}

// ClearTargetUser clears the "target_user" edge to the User entity.
func (m *BillMutation) ClearTargetUser() {
	m.clearedtarget_user = true
	m.clearedFields[bill.FieldTargetUserID] = struct{}{}
}

// TargetUserCleared reports if the "target_user" edge to the User entity was cleared.
func (m *BillMutation) TargetUserCleared() bool {
	return m.clearedtarget_user
}

// TargetUserIDs returns the "target_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetUserID instead. It exists only for internal usage by the builders.
func (m *BillMutation) TargetUserIDs() (ids []int64) {
	if id := m.target_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetUser resets all changes to the "target_user" edge.
func (m *BillMutation) ResetTargetUser() {
	m.target_user = nil
	m.clearedtarget_user = false
}

// SetTransferOrderID sets the "transfer_order" edge to the TransferOrder entity by id.
func (m *BillMutation) SetTransferOrderID(id int64) {
	m.transfer_order = &id
}

// ClearTransferOrder clears the "transfer_order" edge to the TransferOrder entity.
func (m *BillMutation) ClearTransferOrder() {
	m.clearedtransfer_order = true
	m.clearedFields[bill.FieldOrderID] = struct{}{}
}

// TransferOrderCleared reports if the "transfer_order" edge to the TransferOrder entity was cleared.
func (m *BillMutation) TransferOrderCleared() bool {
	return m.OrderIDCleared() || m.clearedtransfer_order
}

// TransferOrderID returns the "transfer_order" edge ID in the mutation.
func (m *BillMutation) TransferOrderID() (id int64, exists bool) {
	if m.transfer_order != nil {
		return *m.transfer_order, true
	}
	return
}

// TransferOrderIDs returns the "transfer_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferOrderID instead. It exists only for internal usage by the builders.
func (m *BillMutation) TransferOrderIDs() (ids []int64) {
	if id := m.transfer_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransferOrder resets all changes to the "transfer_order" edge.
func (m *BillMutation) ResetTransferOrder() {
	m.transfer_order = nil
	m.clearedtransfer_order = false
}

// SetMissionOrderID sets the "mission_order" edge to the MissionOrder entity by id.
func (m *BillMutation) SetMissionOrderID(id int64) {
	m.mission_order = &id
}

// ClearMissionOrder clears the "mission_order" edge to the MissionOrder entity.
func (m *BillMutation) ClearMissionOrder() {
	m.clearedmission_order = true
	m.clearedFields[bill.FieldOrderID] = struct{}{}
}

// MissionOrderCleared reports if the "mission_order" edge to the MissionOrder entity was cleared.
func (m *BillMutation) MissionOrderCleared() bool {
	return m.OrderIDCleared() || m.clearedmission_order
}

// MissionOrderID returns the "mission_order" edge ID in the mutation.
func (m *BillMutation) MissionOrderID() (id int64, exists bool) {
	if m.mission_order != nil {
		return *m.mission_order, true
	}
	return
}

// MissionOrderIDs returns the "mission_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionOrderID instead. It exists only for internal usage by the builders.
func (m *BillMutation) MissionOrderIDs() (ids []int64) {
	if id := m.mission_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionOrder resets all changes to the "mission_order" edge.
func (m *BillMutation) ResetMissionOrder() {
	m.mission_order = nil
	m.clearedmission_order = false
}

// SetInvokeModelOrderID sets the "invoke_model_order" edge to the InvokeModelOrder entity by id.
func (m *BillMutation) SetInvokeModelOrderID(id int64) {
	m.invoke_model_order = &id
}

// ClearInvokeModelOrder clears the "invoke_model_order" edge to the InvokeModelOrder entity.
func (m *BillMutation) ClearInvokeModelOrder() {
	m.clearedinvoke_model_order = true
	m.clearedFields[bill.FieldOrderID] = struct{}{}
}

// InvokeModelOrderCleared reports if the "invoke_model_order" edge to the InvokeModelOrder entity was cleared.
func (m *BillMutation) InvokeModelOrderCleared() bool {
	return m.OrderIDCleared() || m.clearedinvoke_model_order
}

// InvokeModelOrderID returns the "invoke_model_order" edge ID in the mutation.
func (m *BillMutation) InvokeModelOrderID() (id int64, exists bool) {
	if m.invoke_model_order != nil {
		return *m.invoke_model_order, true
	}
	return
}

// InvokeModelOrderIDs returns the "invoke_model_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvokeModelOrderID instead. It exists only for internal usage by the builders.
func (m *BillMutation) InvokeModelOrderIDs() (ids []int64) {
	if id := m.invoke_model_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvokeModelOrder resets all changes to the "invoke_model_order" edge.
func (m *BillMutation) ResetInvokeModelOrder() {
	m.invoke_model_order = nil
	m.clearedinvoke_model_order = false
}

// ClearInvite clears the "invite" edge to the Invite entity.
func (m *BillMutation) ClearInvite() {
	m.clearedinvite = true
	m.clearedFields[bill.FieldInviteID] = struct{}{}
}

// InviteCleared reports if the "invite" edge to the Invite entity was cleared.
func (m *BillMutation) InviteCleared() bool {
	return m.clearedinvite
}

// InviteIDs returns the "invite" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviteID instead. It exists only for internal usage by the builders.
func (m *BillMutation) InviteIDs() (ids []int64) {
	if id := m.invite; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvite resets all changes to the "invite" edge.
func (m *BillMutation) ResetInvite() {
	m.invite = nil
	m.clearedinvite = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *BillMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[bill.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *BillMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *BillMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *BillMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// ClearTargetSymbol clears the "target_symbol" edge to the Symbol entity.
func (m *BillMutation) ClearTargetSymbol() {
	m.clearedtarget_symbol = true
	m.clearedFields[bill.FieldTargetSymbolID] = struct{}{}
}

// TargetSymbolCleared reports if the "target_symbol" edge to the Symbol entity was cleared.
func (m *BillMutation) TargetSymbolCleared() bool {
	return m.clearedtarget_symbol
}

// TargetSymbolIDs returns the "target_symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetSymbolID instead. It exists only for internal usage by the builders.
func (m *BillMutation) TargetSymbolIDs() (ids []int64) {
	if id := m.target_symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetSymbol resets all changes to the "target_symbol" edge.
func (m *BillMutation) ResetTargetSymbol() {
	m.target_symbol = nil
	m.clearedtarget_symbol = false
}

// Where appends a list predicates to the BillMutation builder.
func (m *BillMutation) Where(ps ...predicate.Bill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_by != nil {
		fields = append(fields, bill.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, bill.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, bill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, bill.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, bill.FieldType)
	}
	if m.transfer_order != nil {
		fields = append(fields, bill.FieldOrderID)
	}
	if m.way != nil {
		fields = append(fields, bill.FieldWay)
	}
	if m.symbol != nil {
		fields = append(fields, bill.FieldSymbolID)
	}
	if m.target_symbol != nil {
		fields = append(fields, bill.FieldTargetSymbolID)
	}
	if m.profit_symbol_id != nil {
		fields = append(fields, bill.FieldProfitSymbolID)
	}
	if m.amount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	if m.target_user != nil {
		fields = append(fields, bill.FieldTargetUserID)
	}
	if m.target_before_amount != nil {
		fields = append(fields, bill.FieldTargetBeforeAmount)
	}
	if m.target_after_amount != nil {
		fields = append(fields, bill.FieldTargetAfterAmount)
	}
	if m.source_user != nil {
		fields = append(fields, bill.FieldSourceUserID)
	}
	if m.source_before_amount != nil {
		fields = append(fields, bill.FieldSourceBeforeAmount)
	}
	if m.source_after_amount != nil {
		fields = append(fields, bill.FieldSourceAfterAmount)
	}
	if m.serial_number != nil {
		fields = append(fields, bill.FieldSerialNumber)
	}
	if m.invite != nil {
		fields = append(fields, bill.FieldInviteID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldCreatedBy:
		return m.CreatedBy()
	case bill.FieldUpdatedBy:
		return m.UpdatedBy()
	case bill.FieldCreatedAt:
		return m.CreatedAt()
	case bill.FieldUpdatedAt:
		return m.UpdatedAt()
	case bill.FieldDeletedAt:
		return m.DeletedAt()
	case bill.FieldType:
		return m.GetType()
	case bill.FieldOrderID:
		return m.OrderID()
	case bill.FieldWay:
		return m.Way()
	case bill.FieldSymbolID:
		return m.SymbolID()
	case bill.FieldTargetSymbolID:
		return m.TargetSymbolID()
	case bill.FieldProfitSymbolID:
		return m.ProfitSymbolID()
	case bill.FieldAmount:
		return m.Amount()
	case bill.FieldTargetUserID:
		return m.TargetUserID()
	case bill.FieldTargetBeforeAmount:
		return m.TargetBeforeAmount()
	case bill.FieldTargetAfterAmount:
		return m.TargetAfterAmount()
	case bill.FieldSourceUserID:
		return m.SourceUserID()
	case bill.FieldSourceBeforeAmount:
		return m.SourceBeforeAmount()
	case bill.FieldSourceAfterAmount:
		return m.SourceAfterAmount()
	case bill.FieldSerialNumber:
		return m.SerialNumber()
	case bill.FieldInviteID:
		return m.InviteID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case bill.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case bill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case bill.FieldType:
		return m.OldType(ctx)
	case bill.FieldOrderID:
		return m.OldOrderID(ctx)
	case bill.FieldWay:
		return m.OldWay(ctx)
	case bill.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case bill.FieldTargetSymbolID:
		return m.OldTargetSymbolID(ctx)
	case bill.FieldProfitSymbolID:
		return m.OldProfitSymbolID(ctx)
	case bill.FieldAmount:
		return m.OldAmount(ctx)
	case bill.FieldTargetUserID:
		return m.OldTargetUserID(ctx)
	case bill.FieldTargetBeforeAmount:
		return m.OldTargetBeforeAmount(ctx)
	case bill.FieldTargetAfterAmount:
		return m.OldTargetAfterAmount(ctx)
	case bill.FieldSourceUserID:
		return m.OldSourceUserID(ctx)
	case bill.FieldSourceBeforeAmount:
		return m.OldSourceBeforeAmount(ctx)
	case bill.FieldSourceAfterAmount:
		return m.OldSourceAfterAmount(ctx)
	case bill.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case bill.FieldInviteID:
		return m.OldInviteID(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case bill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case bill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case bill.FieldType:
		v, ok := value.(enums.BillType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case bill.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case bill.FieldWay:
		v, ok := value.(enums.BillWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWay(v)
		return nil
	case bill.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case bill.FieldTargetSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetSymbolID(v)
		return nil
	case bill.FieldProfitSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitSymbolID(v)
		return nil
	case bill.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case bill.FieldTargetUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetUserID(v)
		return nil
	case bill.FieldTargetBeforeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetBeforeAmount(v)
		return nil
	case bill.FieldTargetAfterAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetAfterAmount(v)
		return nil
	case bill.FieldSourceUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceUserID(v)
		return nil
	case bill.FieldSourceBeforeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceBeforeAmount(v)
		return nil
	case bill.FieldSourceAfterAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceAfterAmount(v)
		return nil
	case bill.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case bill.FieldInviteID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteID(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, bill.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, bill.FieldUpdatedBy)
	}
	if m.addprofit_symbol_id != nil {
		fields = append(fields, bill.FieldProfitSymbolID)
	}
	if m.addamount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	if m.addtarget_before_amount != nil {
		fields = append(fields, bill.FieldTargetBeforeAmount)
	}
	if m.addtarget_after_amount != nil {
		fields = append(fields, bill.FieldTargetAfterAmount)
	}
	if m.addsource_before_amount != nil {
		fields = append(fields, bill.FieldSourceBeforeAmount)
	}
	if m.addsource_after_amount != nil {
		fields = append(fields, bill.FieldSourceAfterAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldCreatedBy:
		return m.AddedCreatedBy()
	case bill.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case bill.FieldProfitSymbolID:
		return m.AddedProfitSymbolID()
	case bill.FieldAmount:
		return m.AddedAmount()
	case bill.FieldTargetBeforeAmount:
		return m.AddedTargetBeforeAmount()
	case bill.FieldTargetAfterAmount:
		return m.AddedTargetAfterAmount()
	case bill.FieldSourceBeforeAmount:
		return m.AddedSourceBeforeAmount()
	case bill.FieldSourceAfterAmount:
		return m.AddedSourceAfterAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case bill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case bill.FieldProfitSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitSymbolID(v)
		return nil
	case bill.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case bill.FieldTargetBeforeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetBeforeAmount(v)
		return nil
	case bill.FieldTargetAfterAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetAfterAmount(v)
		return nil
	case bill.FieldSourceBeforeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceBeforeAmount(v)
		return nil
	case bill.FieldSourceAfterAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceAfterAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bill.FieldOrderID) {
		fields = append(fields, bill.FieldOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	switch name {
	case bill.FieldOrderID:
		m.ClearOrderID()
		return nil
	}
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case bill.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case bill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case bill.FieldType:
		m.ResetType()
		return nil
	case bill.FieldOrderID:
		m.ResetOrderID()
		return nil
	case bill.FieldWay:
		m.ResetWay()
		return nil
	case bill.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case bill.FieldTargetSymbolID:
		m.ResetTargetSymbolID()
		return nil
	case bill.FieldProfitSymbolID:
		m.ResetProfitSymbolID()
		return nil
	case bill.FieldAmount:
		m.ResetAmount()
		return nil
	case bill.FieldTargetUserID:
		m.ResetTargetUserID()
		return nil
	case bill.FieldTargetBeforeAmount:
		m.ResetTargetBeforeAmount()
		return nil
	case bill.FieldTargetAfterAmount:
		m.ResetTargetAfterAmount()
		return nil
	case bill.FieldSourceUserID:
		m.ResetSourceUserID()
		return nil
	case bill.FieldSourceBeforeAmount:
		m.ResetSourceBeforeAmount()
		return nil
	case bill.FieldSourceAfterAmount:
		m.ResetSourceAfterAmount()
		return nil
	case bill.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case bill.FieldInviteID:
		m.ResetInviteID()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.source_user != nil {
		edges = append(edges, bill.EdgeSourceUser)
	}
	if m.target_user != nil {
		edges = append(edges, bill.EdgeTargetUser)
	}
	if m.transfer_order != nil {
		edges = append(edges, bill.EdgeTransferOrder)
	}
	if m.mission_order != nil {
		edges = append(edges, bill.EdgeMissionOrder)
	}
	if m.invoke_model_order != nil {
		edges = append(edges, bill.EdgeInvokeModelOrder)
	}
	if m.invite != nil {
		edges = append(edges, bill.EdgeInvite)
	}
	if m.symbol != nil {
		edges = append(edges, bill.EdgeSymbol)
	}
	if m.target_symbol != nil {
		edges = append(edges, bill.EdgeTargetSymbol)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgeSourceUser:
		if id := m.source_user; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeTargetUser:
		if id := m.target_user; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeTransferOrder:
		if id := m.transfer_order; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeMissionOrder:
		if id := m.mission_order; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeInvokeModelOrder:
		if id := m.invoke_model_order; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeInvite:
		if id := m.invite; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeTargetSymbol:
		if id := m.target_symbol; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedsource_user {
		edges = append(edges, bill.EdgeSourceUser)
	}
	if m.clearedtarget_user {
		edges = append(edges, bill.EdgeTargetUser)
	}
	if m.clearedtransfer_order {
		edges = append(edges, bill.EdgeTransferOrder)
	}
	if m.clearedmission_order {
		edges = append(edges, bill.EdgeMissionOrder)
	}
	if m.clearedinvoke_model_order {
		edges = append(edges, bill.EdgeInvokeModelOrder)
	}
	if m.clearedinvite {
		edges = append(edges, bill.EdgeInvite)
	}
	if m.clearedsymbol {
		edges = append(edges, bill.EdgeSymbol)
	}
	if m.clearedtarget_symbol {
		edges = append(edges, bill.EdgeTargetSymbol)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgeSourceUser:
		return m.clearedsource_user
	case bill.EdgeTargetUser:
		return m.clearedtarget_user
	case bill.EdgeTransferOrder:
		return m.clearedtransfer_order
	case bill.EdgeMissionOrder:
		return m.clearedmission_order
	case bill.EdgeInvokeModelOrder:
		return m.clearedinvoke_model_order
	case bill.EdgeInvite:
		return m.clearedinvite
	case bill.EdgeSymbol:
		return m.clearedsymbol
	case bill.EdgeTargetSymbol:
		return m.clearedtarget_symbol
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgeSourceUser:
		m.ClearSourceUser()
		return nil
	case bill.EdgeTargetUser:
		m.ClearTargetUser()
		return nil
	case bill.EdgeTransferOrder:
		m.ClearTransferOrder()
		return nil
	case bill.EdgeMissionOrder:
		m.ClearMissionOrder()
		return nil
	case bill.EdgeInvokeModelOrder:
		m.ClearInvokeModelOrder()
		return nil
	case bill.EdgeInvite:
		m.ClearInvite()
		return nil
	case bill.EdgeSymbol:
		m.ClearSymbol()
		return nil
	case bill.EdgeTargetSymbol:
		m.ClearTargetSymbol()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgeSourceUser:
		m.ResetSourceUser()
		return nil
	case bill.EdgeTargetUser:
		m.ResetTargetUser()
		return nil
	case bill.EdgeTransferOrder:
		m.ResetTransferOrder()
		return nil
	case bill.EdgeMissionOrder:
		m.ResetMissionOrder()
		return nil
	case bill.EdgeInvokeModelOrder:
		m.ResetInvokeModelOrder()
		return nil
	case bill.EdgeInvite:
		m.ResetInvite()
		return nil
	case bill.EdgeSymbol:
		m.ResetSymbol()
		return nil
	case bill.EdgeTargetSymbol:
		m.ResetTargetSymbol()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// CDKInfoMutation represents an operation that mutates the CDKInfo nodes in the graph.
type CDKInfoMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	cdk_number        *string
	_type             *enums.CDKType
	get_cep           *int64
	addget_cep        *int64
	get_time          *int64
	addget_time       *int64
	billing_type      *enums.MissionBillingType
	expired_at        *time.Time
	use_times         *int64
	adduse_times      *int64
	status            *enums.CDKStatus
	used_at           *time.Time
	clearedFields     map[string]struct{}
	issue_user        *int64
	clearedissue_user bool
	use_user          *int64
	cleareduse_user   bool
	done              bool
	oldValue          func(context.Context) (*CDKInfo, error)
	predicates        []predicate.CDKInfo
}

var _ ent.Mutation = (*CDKInfoMutation)(nil)

// cdkinfoOption allows management of the mutation configuration using functional options.
type cdkinfoOption func(*CDKInfoMutation)

// newCDKInfoMutation creates new mutation for the CDKInfo entity.
func newCDKInfoMutation(c config, op Op, opts ...cdkinfoOption) *CDKInfoMutation {
	m := &CDKInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeCDKInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCDKInfoID sets the ID field of the mutation.
func withCDKInfoID(id int64) cdkinfoOption {
	return func(m *CDKInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *CDKInfo
		)
		m.oldValue = func(ctx context.Context) (*CDKInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CDKInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCDKInfo sets the old CDKInfo of the mutation.
func withCDKInfo(node *CDKInfo) cdkinfoOption {
	return func(m *CDKInfoMutation) {
		m.oldValue = func(context.Context) (*CDKInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CDKInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CDKInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CDKInfo entities.
func (m *CDKInfoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CDKInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CDKInfoMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CDKInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CDKInfoMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CDKInfoMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CDKInfoMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CDKInfoMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CDKInfoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CDKInfoMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CDKInfoMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CDKInfoMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CDKInfoMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CDKInfoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CDKInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CDKInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CDKInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CDKInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CDKInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CDKInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CDKInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CDKInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CDKInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetIssueUserID sets the "issue_user_id" field.
func (m *CDKInfoMutation) SetIssueUserID(i int64) {
	m.issue_user = &i
}

// IssueUserID returns the value of the "issue_user_id" field in the mutation.
func (m *CDKInfoMutation) IssueUserID() (r int64, exists bool) {
	v := m.issue_user
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueUserID returns the old "issue_user_id" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldIssueUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueUserID: %w", err)
	}
	return oldValue.IssueUserID, nil
}

// ResetIssueUserID resets all changes to the "issue_user_id" field.
func (m *CDKInfoMutation) ResetIssueUserID() {
	m.issue_user = nil
}

// SetCdkNumber sets the "cdk_number" field.
func (m *CDKInfoMutation) SetCdkNumber(s string) {
	m.cdk_number = &s
}

// CdkNumber returns the value of the "cdk_number" field in the mutation.
func (m *CDKInfoMutation) CdkNumber() (r string, exists bool) {
	v := m.cdk_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCdkNumber returns the old "cdk_number" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldCdkNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdkNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdkNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdkNumber: %w", err)
	}
	return oldValue.CdkNumber, nil
}

// ResetCdkNumber resets all changes to the "cdk_number" field.
func (m *CDKInfoMutation) ResetCdkNumber() {
	m.cdk_number = nil
}

// SetType sets the "type" field.
func (m *CDKInfoMutation) SetType(et enums.CDKType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *CDKInfoMutation) GetType() (r enums.CDKType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldType(ctx context.Context) (v enums.CDKType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CDKInfoMutation) ResetType() {
	m._type = nil
}

// SetGetCep sets the "get_cep" field.
func (m *CDKInfoMutation) SetGetCep(i int64) {
	m.get_cep = &i
	m.addget_cep = nil
}

// GetCep returns the value of the "get_cep" field in the mutation.
func (m *CDKInfoMutation) GetCep() (r int64, exists bool) {
	v := m.get_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGetCep returns the old "get_cep" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldGetCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGetCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGetCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGetCep: %w", err)
	}
	return oldValue.GetCep, nil
}

// AddGetCep adds i to the "get_cep" field.
func (m *CDKInfoMutation) AddGetCep(i int64) {
	if m.addget_cep != nil {
		*m.addget_cep += i
	} else {
		m.addget_cep = &i
	}
}

// AddedGetCep returns the value that was added to the "get_cep" field in this mutation.
func (m *CDKInfoMutation) AddedGetCep() (r int64, exists bool) {
	v := m.addget_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGetCep resets all changes to the "get_cep" field.
func (m *CDKInfoMutation) ResetGetCep() {
	m.get_cep = nil
	m.addget_cep = nil
}

// SetGetTime sets the "get_time" field.
func (m *CDKInfoMutation) SetGetTime(i int64) {
	m.get_time = &i
	m.addget_time = nil
}

// GetTime returns the value of the "get_time" field in the mutation.
func (m *CDKInfoMutation) GetTime() (r int64, exists bool) {
	v := m.get_time
	if v == nil {
		return
	}
	return *v, true
}

// OldGetTime returns the old "get_time" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldGetTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGetTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGetTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGetTime: %w", err)
	}
	return oldValue.GetTime, nil
}

// AddGetTime adds i to the "get_time" field.
func (m *CDKInfoMutation) AddGetTime(i int64) {
	if m.addget_time != nil {
		*m.addget_time += i
	} else {
		m.addget_time = &i
	}
}

// AddedGetTime returns the value that was added to the "get_time" field in this mutation.
func (m *CDKInfoMutation) AddedGetTime() (r int64, exists bool) {
	v := m.addget_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetGetTime resets all changes to the "get_time" field.
func (m *CDKInfoMutation) ResetGetTime() {
	m.get_time = nil
	m.addget_time = nil
}

// SetBillingType sets the "billing_type" field.
func (m *CDKInfoMutation) SetBillingType(ebt enums.MissionBillingType) {
	m.billing_type = &ebt
}

// BillingType returns the value of the "billing_type" field in the mutation.
func (m *CDKInfoMutation) BillingType() (r enums.MissionBillingType, exists bool) {
	v := m.billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingType returns the old "billing_type" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingType: %w", err)
	}
	return oldValue.BillingType, nil
}

// ResetBillingType resets all changes to the "billing_type" field.
func (m *CDKInfoMutation) ResetBillingType() {
	m.billing_type = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *CDKInfoMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *CDKInfoMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *CDKInfoMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[cdkinfo.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *CDKInfoMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[cdkinfo.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *CDKInfoMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, cdkinfo.FieldExpiredAt)
}

// SetUseTimes sets the "use_times" field.
func (m *CDKInfoMutation) SetUseTimes(i int64) {
	m.use_times = &i
	m.adduse_times = nil
}

// UseTimes returns the value of the "use_times" field in the mutation.
func (m *CDKInfoMutation) UseTimes() (r int64, exists bool) {
	v := m.use_times
	if v == nil {
		return
	}
	return *v, true
}

// OldUseTimes returns the old "use_times" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUseTimes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseTimes: %w", err)
	}
	return oldValue.UseTimes, nil
}

// AddUseTimes adds i to the "use_times" field.
func (m *CDKInfoMutation) AddUseTimes(i int64) {
	if m.adduse_times != nil {
		*m.adduse_times += i
	} else {
		m.adduse_times = &i
	}
}

// AddedUseTimes returns the value that was added to the "use_times" field in this mutation.
func (m *CDKInfoMutation) AddedUseTimes() (r int64, exists bool) {
	v := m.adduse_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetUseTimes resets all changes to the "use_times" field.
func (m *CDKInfoMutation) ResetUseTimes() {
	m.use_times = nil
	m.adduse_times = nil
}

// SetStatus sets the "status" field.
func (m *CDKInfoMutation) SetStatus(es enums.CDKStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *CDKInfoMutation) Status() (r enums.CDKStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldStatus(ctx context.Context) (v enums.CDKStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CDKInfoMutation) ResetStatus() {
	m.status = nil
}

// SetUseUserID sets the "use_user_id" field.
func (m *CDKInfoMutation) SetUseUserID(i int64) {
	m.use_user = &i
}

// UseUserID returns the value of the "use_user_id" field in the mutation.
func (m *CDKInfoMutation) UseUserID() (r int64, exists bool) {
	v := m.use_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUseUserID returns the old "use_user_id" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUseUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseUserID: %w", err)
	}
	return oldValue.UseUserID, nil
}

// ResetUseUserID resets all changes to the "use_user_id" field.
func (m *CDKInfoMutation) ResetUseUserID() {
	m.use_user = nil
}

// SetUsedAt sets the "used_at" field.
func (m *CDKInfoMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *CDKInfoMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *CDKInfoMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[cdkinfo.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *CDKInfoMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[cdkinfo.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *CDKInfoMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, cdkinfo.FieldUsedAt)
}

// ClearIssueUser clears the "issue_user" edge to the User entity.
func (m *CDKInfoMutation) ClearIssueUser() {
	m.clearedissue_user = true
	m.clearedFields[cdkinfo.FieldIssueUserID] = struct{}{}
}

// IssueUserCleared reports if the "issue_user" edge to the User entity was cleared.
func (m *CDKInfoMutation) IssueUserCleared() bool {
	return m.clearedissue_user
}

// IssueUserIDs returns the "issue_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssueUserID instead. It exists only for internal usage by the builders.
func (m *CDKInfoMutation) IssueUserIDs() (ids []int64) {
	if id := m.issue_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssueUser resets all changes to the "issue_user" edge.
func (m *CDKInfoMutation) ResetIssueUser() {
	m.issue_user = nil
	m.clearedissue_user = false
}

// ClearUseUser clears the "use_user" edge to the User entity.
func (m *CDKInfoMutation) ClearUseUser() {
	m.cleareduse_user = true
	m.clearedFields[cdkinfo.FieldUseUserID] = struct{}{}
}

// UseUserCleared reports if the "use_user" edge to the User entity was cleared.
func (m *CDKInfoMutation) UseUserCleared() bool {
	return m.cleareduse_user
}

// UseUserIDs returns the "use_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UseUserID instead. It exists only for internal usage by the builders.
func (m *CDKInfoMutation) UseUserIDs() (ids []int64) {
	if id := m.use_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseUser resets all changes to the "use_user" edge.
func (m *CDKInfoMutation) ResetUseUser() {
	m.use_user = nil
	m.cleareduse_user = false
}

// Where appends a list predicates to the CDKInfoMutation builder.
func (m *CDKInfoMutation) Where(ps ...predicate.CDKInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CDKInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CDKInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CDKInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CDKInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CDKInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CDKInfo).
func (m *CDKInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CDKInfoMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, cdkinfo.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, cdkinfo.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, cdkinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cdkinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cdkinfo.FieldDeletedAt)
	}
	if m.issue_user != nil {
		fields = append(fields, cdkinfo.FieldIssueUserID)
	}
	if m.cdk_number != nil {
		fields = append(fields, cdkinfo.FieldCdkNumber)
	}
	if m._type != nil {
		fields = append(fields, cdkinfo.FieldType)
	}
	if m.get_cep != nil {
		fields = append(fields, cdkinfo.FieldGetCep)
	}
	if m.get_time != nil {
		fields = append(fields, cdkinfo.FieldGetTime)
	}
	if m.billing_type != nil {
		fields = append(fields, cdkinfo.FieldBillingType)
	}
	if m.expired_at != nil {
		fields = append(fields, cdkinfo.FieldExpiredAt)
	}
	if m.use_times != nil {
		fields = append(fields, cdkinfo.FieldUseTimes)
	}
	if m.status != nil {
		fields = append(fields, cdkinfo.FieldStatus)
	}
	if m.use_user != nil {
		fields = append(fields, cdkinfo.FieldUseUserID)
	}
	if m.used_at != nil {
		fields = append(fields, cdkinfo.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CDKInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cdkinfo.FieldCreatedBy:
		return m.CreatedBy()
	case cdkinfo.FieldUpdatedBy:
		return m.UpdatedBy()
	case cdkinfo.FieldCreatedAt:
		return m.CreatedAt()
	case cdkinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case cdkinfo.FieldDeletedAt:
		return m.DeletedAt()
	case cdkinfo.FieldIssueUserID:
		return m.IssueUserID()
	case cdkinfo.FieldCdkNumber:
		return m.CdkNumber()
	case cdkinfo.FieldType:
		return m.GetType()
	case cdkinfo.FieldGetCep:
		return m.GetCep()
	case cdkinfo.FieldGetTime:
		return m.GetTime()
	case cdkinfo.FieldBillingType:
		return m.BillingType()
	case cdkinfo.FieldExpiredAt:
		return m.ExpiredAt()
	case cdkinfo.FieldUseTimes:
		return m.UseTimes()
	case cdkinfo.FieldStatus:
		return m.Status()
	case cdkinfo.FieldUseUserID:
		return m.UseUserID()
	case cdkinfo.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CDKInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cdkinfo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case cdkinfo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case cdkinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cdkinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cdkinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cdkinfo.FieldIssueUserID:
		return m.OldIssueUserID(ctx)
	case cdkinfo.FieldCdkNumber:
		return m.OldCdkNumber(ctx)
	case cdkinfo.FieldType:
		return m.OldType(ctx)
	case cdkinfo.FieldGetCep:
		return m.OldGetCep(ctx)
	case cdkinfo.FieldGetTime:
		return m.OldGetTime(ctx)
	case cdkinfo.FieldBillingType:
		return m.OldBillingType(ctx)
	case cdkinfo.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case cdkinfo.FieldUseTimes:
		return m.OldUseTimes(ctx)
	case cdkinfo.FieldStatus:
		return m.OldStatus(ctx)
	case cdkinfo.FieldUseUserID:
		return m.OldUseUserID(ctx)
	case cdkinfo.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CDKInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CDKInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cdkinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case cdkinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case cdkinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cdkinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cdkinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cdkinfo.FieldIssueUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueUserID(v)
		return nil
	case cdkinfo.FieldCdkNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdkNumber(v)
		return nil
	case cdkinfo.FieldType:
		v, ok := value.(enums.CDKType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case cdkinfo.FieldGetCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGetCep(v)
		return nil
	case cdkinfo.FieldGetTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGetTime(v)
		return nil
	case cdkinfo.FieldBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingType(v)
		return nil
	case cdkinfo.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case cdkinfo.FieldUseTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseTimes(v)
		return nil
	case cdkinfo.FieldStatus:
		v, ok := value.(enums.CDKStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cdkinfo.FieldUseUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseUserID(v)
		return nil
	case cdkinfo.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CDKInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CDKInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, cdkinfo.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, cdkinfo.FieldUpdatedBy)
	}
	if m.addget_cep != nil {
		fields = append(fields, cdkinfo.FieldGetCep)
	}
	if m.addget_time != nil {
		fields = append(fields, cdkinfo.FieldGetTime)
	}
	if m.adduse_times != nil {
		fields = append(fields, cdkinfo.FieldUseTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CDKInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cdkinfo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case cdkinfo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case cdkinfo.FieldGetCep:
		return m.AddedGetCep()
	case cdkinfo.FieldGetTime:
		return m.AddedGetTime()
	case cdkinfo.FieldUseTimes:
		return m.AddedUseTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CDKInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cdkinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case cdkinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case cdkinfo.FieldGetCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGetCep(v)
		return nil
	case cdkinfo.FieldGetTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGetTime(v)
		return nil
	case cdkinfo.FieldUseTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseTimes(v)
		return nil
	}
	return fmt.Errorf("unknown CDKInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CDKInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cdkinfo.FieldExpiredAt) {
		fields = append(fields, cdkinfo.FieldExpiredAt)
	}
	if m.FieldCleared(cdkinfo.FieldUsedAt) {
		fields = append(fields, cdkinfo.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CDKInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CDKInfoMutation) ClearField(name string) error {
	switch name {
	case cdkinfo.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	case cdkinfo.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown CDKInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CDKInfoMutation) ResetField(name string) error {
	switch name {
	case cdkinfo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case cdkinfo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case cdkinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cdkinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cdkinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cdkinfo.FieldIssueUserID:
		m.ResetIssueUserID()
		return nil
	case cdkinfo.FieldCdkNumber:
		m.ResetCdkNumber()
		return nil
	case cdkinfo.FieldType:
		m.ResetType()
		return nil
	case cdkinfo.FieldGetCep:
		m.ResetGetCep()
		return nil
	case cdkinfo.FieldGetTime:
		m.ResetGetTime()
		return nil
	case cdkinfo.FieldBillingType:
		m.ResetBillingType()
		return nil
	case cdkinfo.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case cdkinfo.FieldUseTimes:
		m.ResetUseTimes()
		return nil
	case cdkinfo.FieldStatus:
		m.ResetStatus()
		return nil
	case cdkinfo.FieldUseUserID:
		m.ResetUseUserID()
		return nil
	case cdkinfo.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown CDKInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CDKInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.issue_user != nil {
		edges = append(edges, cdkinfo.EdgeIssueUser)
	}
	if m.use_user != nil {
		edges = append(edges, cdkinfo.EdgeUseUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CDKInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cdkinfo.EdgeIssueUser:
		if id := m.issue_user; id != nil {
			return []ent.Value{*id}
		}
	case cdkinfo.EdgeUseUser:
		if id := m.use_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CDKInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CDKInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CDKInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedissue_user {
		edges = append(edges, cdkinfo.EdgeIssueUser)
	}
	if m.cleareduse_user {
		edges = append(edges, cdkinfo.EdgeUseUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CDKInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case cdkinfo.EdgeIssueUser:
		return m.clearedissue_user
	case cdkinfo.EdgeUseUser:
		return m.cleareduse_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CDKInfoMutation) ClearEdge(name string) error {
	switch name {
	case cdkinfo.EdgeIssueUser:
		m.ClearIssueUser()
		return nil
	case cdkinfo.EdgeUseUser:
		m.ClearUseUser()
		return nil
	}
	return fmt.Errorf("unknown CDKInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CDKInfoMutation) ResetEdge(name string) error {
	switch name {
	case cdkinfo.EdgeIssueUser:
		m.ResetIssueUser()
		return nil
	case cdkinfo.EdgeUseUser:
		m.ResetUseUser()
		return nil
	}
	return fmt.Errorf("unknown CDKInfo edge %s", name)
}

// CampaignMutation represents an operation that mutates the Campaign nodes in the graph.
type CampaignMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_by             *int64
	addcreated_by          *int64
	updated_by             *int64
	addupdated_by          *int64
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	name                   *string
	_type                  *string
	started_at             *time.Time
	ended_at               *time.Time
	status                 *int
	addstatus              *int
	invite_id              *string
	clearedFields          map[string]struct{}
	invites                map[int64]struct{}
	removedinvites         map[int64]struct{}
	clearedinvites         bool
	campaign_orders        map[int64]struct{}
	removedcampaign_orders map[int64]struct{}
	clearedcampaign_orders bool
	done                   bool
	oldValue               func(context.Context) (*Campaign, error)
	predicates             []predicate.Campaign
}

var _ ent.Mutation = (*CampaignMutation)(nil)

// campaignOption allows management of the mutation configuration using functional options.
type campaignOption func(*CampaignMutation)

// newCampaignMutation creates new mutation for the Campaign entity.
func newCampaignMutation(c config, op Op, opts ...campaignOption) *CampaignMutation {
	m := &CampaignMutation{
		config:        c,
		op:            op,
		typ:           TypeCampaign,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCampaignID sets the ID field of the mutation.
func withCampaignID(id int64) campaignOption {
	return func(m *CampaignMutation) {
		var (
			err   error
			once  sync.Once
			value *Campaign
		)
		m.oldValue = func(ctx context.Context) (*Campaign, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Campaign.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCampaign sets the old Campaign of the mutation.
func withCampaign(node *Campaign) campaignOption {
	return func(m *CampaignMutation) {
		m.oldValue = func(context.Context) (*Campaign, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CampaignMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CampaignMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Campaign entities.
func (m *CampaignMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CampaignMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CampaignMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Campaign.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CampaignMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CampaignMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CampaignMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CampaignMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CampaignMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CampaignMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CampaignMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CampaignMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CampaignMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CampaignMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CampaignMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CampaignMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CampaignMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CampaignMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CampaignMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CampaignMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CampaignMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CampaignMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CampaignMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *CampaignMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CampaignMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CampaignMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *CampaignMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CampaignMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CampaignMutation) ResetType() {
	m._type = nil
}

// SetStartedAt sets the "started_at" field.
func (m *CampaignMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *CampaignMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *CampaignMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *CampaignMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *CampaignMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *CampaignMutation) ResetEndedAt() {
	m.ended_at = nil
}

// SetStatus sets the "status" field.
func (m *CampaignMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CampaignMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CampaignMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CampaignMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CampaignMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetInviteID sets the "invite_id" field.
func (m *CampaignMutation) SetInviteID(s string) {
	m.invite_id = &s
}

// InviteID returns the value of the "invite_id" field in the mutation.
func (m *CampaignMutation) InviteID() (r string, exists bool) {
	v := m.invite_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteID returns the old "invite_id" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldInviteID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteID: %w", err)
	}
	return oldValue.InviteID, nil
}

// ResetInviteID resets all changes to the "invite_id" field.
func (m *CampaignMutation) ResetInviteID() {
	m.invite_id = nil
}

// AddInviteIDs adds the "invites" edge to the Invite entity by ids.
func (m *CampaignMutation) AddInviteIDs(ids ...int64) {
	if m.invites == nil {
		m.invites = make(map[int64]struct{})
	}
	for i := range ids {
		m.invites[ids[i]] = struct{}{}
	}
}

// ClearInvites clears the "invites" edge to the Invite entity.
func (m *CampaignMutation) ClearInvites() {
	m.clearedinvites = true
}

// InvitesCleared reports if the "invites" edge to the Invite entity was cleared.
func (m *CampaignMutation) InvitesCleared() bool {
	return m.clearedinvites
}

// RemoveInviteIDs removes the "invites" edge to the Invite entity by IDs.
func (m *CampaignMutation) RemoveInviteIDs(ids ...int64) {
	if m.removedinvites == nil {
		m.removedinvites = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invites, ids[i])
		m.removedinvites[ids[i]] = struct{}{}
	}
}

// RemovedInvites returns the removed IDs of the "invites" edge to the Invite entity.
func (m *CampaignMutation) RemovedInvitesIDs() (ids []int64) {
	for id := range m.removedinvites {
		ids = append(ids, id)
	}
	return
}

// InvitesIDs returns the "invites" edge IDs in the mutation.
func (m *CampaignMutation) InvitesIDs() (ids []int64) {
	for id := range m.invites {
		ids = append(ids, id)
	}
	return
}

// ResetInvites resets all changes to the "invites" edge.
func (m *CampaignMutation) ResetInvites() {
	m.invites = nil
	m.clearedinvites = false
	m.removedinvites = nil
}

// AddCampaignOrderIDs adds the "campaign_orders" edge to the CampaignOrder entity by ids.
func (m *CampaignMutation) AddCampaignOrderIDs(ids ...int64) {
	if m.campaign_orders == nil {
		m.campaign_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.campaign_orders[ids[i]] = struct{}{}
	}
}

// ClearCampaignOrders clears the "campaign_orders" edge to the CampaignOrder entity.
func (m *CampaignMutation) ClearCampaignOrders() {
	m.clearedcampaign_orders = true
}

// CampaignOrdersCleared reports if the "campaign_orders" edge to the CampaignOrder entity was cleared.
func (m *CampaignMutation) CampaignOrdersCleared() bool {
	return m.clearedcampaign_orders
}

// RemoveCampaignOrderIDs removes the "campaign_orders" edge to the CampaignOrder entity by IDs.
func (m *CampaignMutation) RemoveCampaignOrderIDs(ids ...int64) {
	if m.removedcampaign_orders == nil {
		m.removedcampaign_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.campaign_orders, ids[i])
		m.removedcampaign_orders[ids[i]] = struct{}{}
	}
}

// RemovedCampaignOrders returns the removed IDs of the "campaign_orders" edge to the CampaignOrder entity.
func (m *CampaignMutation) RemovedCampaignOrdersIDs() (ids []int64) {
	for id := range m.removedcampaign_orders {
		ids = append(ids, id)
	}
	return
}

// CampaignOrdersIDs returns the "campaign_orders" edge IDs in the mutation.
func (m *CampaignMutation) CampaignOrdersIDs() (ids []int64) {
	for id := range m.campaign_orders {
		ids = append(ids, id)
	}
	return
}

// ResetCampaignOrders resets all changes to the "campaign_orders" edge.
func (m *CampaignMutation) ResetCampaignOrders() {
	m.campaign_orders = nil
	m.clearedcampaign_orders = false
	m.removedcampaign_orders = nil
}

// Where appends a list predicates to the CampaignMutation builder.
func (m *CampaignMutation) Where(ps ...predicate.Campaign) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CampaignMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CampaignMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Campaign, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CampaignMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CampaignMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Campaign).
func (m *CampaignMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CampaignMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, campaign.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, campaign.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, campaign.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, campaign.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, campaign.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, campaign.FieldName)
	}
	if m._type != nil {
		fields = append(fields, campaign.FieldType)
	}
	if m.started_at != nil {
		fields = append(fields, campaign.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, campaign.FieldEndedAt)
	}
	if m.status != nil {
		fields = append(fields, campaign.FieldStatus)
	}
	if m.invite_id != nil {
		fields = append(fields, campaign.FieldInviteID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CampaignMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case campaign.FieldCreatedBy:
		return m.CreatedBy()
	case campaign.FieldUpdatedBy:
		return m.UpdatedBy()
	case campaign.FieldCreatedAt:
		return m.CreatedAt()
	case campaign.FieldUpdatedAt:
		return m.UpdatedAt()
	case campaign.FieldDeletedAt:
		return m.DeletedAt()
	case campaign.FieldName:
		return m.Name()
	case campaign.FieldType:
		return m.GetType()
	case campaign.FieldStartedAt:
		return m.StartedAt()
	case campaign.FieldEndedAt:
		return m.EndedAt()
	case campaign.FieldStatus:
		return m.Status()
	case campaign.FieldInviteID:
		return m.InviteID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CampaignMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case campaign.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case campaign.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case campaign.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case campaign.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case campaign.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case campaign.FieldName:
		return m.OldName(ctx)
	case campaign.FieldType:
		return m.OldType(ctx)
	case campaign.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case campaign.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case campaign.FieldStatus:
		return m.OldStatus(ctx)
	case campaign.FieldInviteID:
		return m.OldInviteID(ctx)
	}
	return nil, fmt.Errorf("unknown Campaign field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignMutation) SetField(name string, value ent.Value) error {
	switch name {
	case campaign.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case campaign.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case campaign.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case campaign.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case campaign.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case campaign.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case campaign.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case campaign.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case campaign.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case campaign.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case campaign.FieldInviteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteID(v)
		return nil
	}
	return fmt.Errorf("unknown Campaign field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CampaignMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, campaign.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, campaign.FieldUpdatedBy)
	}
	if m.addstatus != nil {
		fields = append(fields, campaign.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CampaignMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case campaign.FieldCreatedBy:
		return m.AddedCreatedBy()
	case campaign.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case campaign.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignMutation) AddField(name string, value ent.Value) error {
	switch name {
	case campaign.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case campaign.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case campaign.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Campaign numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CampaignMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CampaignMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CampaignMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Campaign nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CampaignMutation) ResetField(name string) error {
	switch name {
	case campaign.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case campaign.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case campaign.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case campaign.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case campaign.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case campaign.FieldName:
		m.ResetName()
		return nil
	case campaign.FieldType:
		m.ResetType()
		return nil
	case campaign.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case campaign.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case campaign.FieldStatus:
		m.ResetStatus()
		return nil
	case campaign.FieldInviteID:
		m.ResetInviteID()
		return nil
	}
	return fmt.Errorf("unknown Campaign field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CampaignMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invites != nil {
		edges = append(edges, campaign.EdgeInvites)
	}
	if m.campaign_orders != nil {
		edges = append(edges, campaign.EdgeCampaignOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CampaignMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case campaign.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.invites))
		for id := range m.invites {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeCampaignOrders:
		ids := make([]ent.Value, 0, len(m.campaign_orders))
		for id := range m.campaign_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CampaignMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinvites != nil {
		edges = append(edges, campaign.EdgeInvites)
	}
	if m.removedcampaign_orders != nil {
		edges = append(edges, campaign.EdgeCampaignOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CampaignMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case campaign.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.removedinvites))
		for id := range m.removedinvites {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeCampaignOrders:
		ids := make([]ent.Value, 0, len(m.removedcampaign_orders))
		for id := range m.removedcampaign_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CampaignMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvites {
		edges = append(edges, campaign.EdgeInvites)
	}
	if m.clearedcampaign_orders {
		edges = append(edges, campaign.EdgeCampaignOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CampaignMutation) EdgeCleared(name string) bool {
	switch name {
	case campaign.EdgeInvites:
		return m.clearedinvites
	case campaign.EdgeCampaignOrders:
		return m.clearedcampaign_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CampaignMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Campaign unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CampaignMutation) ResetEdge(name string) error {
	switch name {
	case campaign.EdgeInvites:
		m.ResetInvites()
		return nil
	case campaign.EdgeCampaignOrders:
		m.ResetCampaignOrders()
		return nil
	}
	return fmt.Errorf("unknown Campaign edge %s", name)
}

// CampaignOrderMutation represents an operation that mutates the CampaignOrder nodes in the graph.
type CampaignOrderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	campaign              *int64
	clearedcampaign       bool
	cost_bills            map[int64]struct{}
	removedcost_bills     map[int64]struct{}
	clearedcost_bills     bool
	recharge_order        *int64
	clearedrecharge_order bool
	done                  bool
	oldValue              func(context.Context) (*CampaignOrder, error)
	predicates            []predicate.CampaignOrder
}

var _ ent.Mutation = (*CampaignOrderMutation)(nil)

// campaignorderOption allows management of the mutation configuration using functional options.
type campaignorderOption func(*CampaignOrderMutation)

// newCampaignOrderMutation creates new mutation for the CampaignOrder entity.
func newCampaignOrderMutation(c config, op Op, opts ...campaignorderOption) *CampaignOrderMutation {
	m := &CampaignOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeCampaignOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCampaignOrderID sets the ID field of the mutation.
func withCampaignOrderID(id int64) campaignorderOption {
	return func(m *CampaignOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *CampaignOrder
		)
		m.oldValue = func(ctx context.Context) (*CampaignOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CampaignOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCampaignOrder sets the old CampaignOrder of the mutation.
func withCampaignOrder(node *CampaignOrder) campaignorderOption {
	return func(m *CampaignOrderMutation) {
		m.oldValue = func(context.Context) (*CampaignOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CampaignOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CampaignOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CampaignOrder entities.
func (m *CampaignOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CampaignOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CampaignOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CampaignOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CampaignOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CampaignOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CampaignOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CampaignOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CampaignOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CampaignOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CampaignOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CampaignOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CampaignOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CampaignOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CampaignOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CampaignOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CampaignOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CampaignOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CampaignOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CampaignOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CampaignOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CampaignOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CampaignOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CampaignOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CampaignOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CampaignOrderMutation) ResetUserID() {
	m.user = nil
}

// SetCampaignID sets the "campaign_id" field.
func (m *CampaignOrderMutation) SetCampaignID(i int64) {
	m.campaign = &i
}

// CampaignID returns the value of the "campaign_id" field in the mutation.
func (m *CampaignOrderMutation) CampaignID() (r int64, exists bool) {
	v := m.campaign
	if v == nil {
		return
	}
	return *v, true
}

// OldCampaignID returns the old "campaign_id" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldCampaignID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCampaignID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCampaignID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCampaignID: %w", err)
	}
	return oldValue.CampaignID, nil
}

// ResetCampaignID resets all changes to the "campaign_id" field.
func (m *CampaignOrderMutation) ResetCampaignID() {
	m.campaign = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CampaignOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[campaignorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CampaignOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CampaignOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CampaignOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCampaign clears the "campaign" edge to the Campaign entity.
func (m *CampaignOrderMutation) ClearCampaign() {
	m.clearedcampaign = true
	m.clearedFields[campaignorder.FieldCampaignID] = struct{}{}
}

// CampaignCleared reports if the "campaign" edge to the Campaign entity was cleared.
func (m *CampaignOrderMutation) CampaignCleared() bool {
	return m.clearedcampaign
}

// CampaignIDs returns the "campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignID instead. It exists only for internal usage by the builders.
func (m *CampaignOrderMutation) CampaignIDs() (ids []int64) {
	if id := m.campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaign resets all changes to the "campaign" edge.
func (m *CampaignOrderMutation) ResetCampaign() {
	m.campaign = nil
	m.clearedcampaign = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *CampaignOrderMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *CampaignOrderMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *CampaignOrderMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *CampaignOrderMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *CampaignOrderMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *CampaignOrderMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *CampaignOrderMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// SetRechargeOrderID sets the "recharge_order" edge to the RechargeOrder entity by id.
func (m *CampaignOrderMutation) SetRechargeOrderID(id int64) {
	m.recharge_order = &id
}

// ClearRechargeOrder clears the "recharge_order" edge to the RechargeOrder entity.
func (m *CampaignOrderMutation) ClearRechargeOrder() {
	m.clearedrecharge_order = true
}

// RechargeOrderCleared reports if the "recharge_order" edge to the RechargeOrder entity was cleared.
func (m *CampaignOrderMutation) RechargeOrderCleared() bool {
	return m.clearedrecharge_order
}

// RechargeOrderID returns the "recharge_order" edge ID in the mutation.
func (m *CampaignOrderMutation) RechargeOrderID() (id int64, exists bool) {
	if m.recharge_order != nil {
		return *m.recharge_order, true
	}
	return
}

// RechargeOrderIDs returns the "recharge_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RechargeOrderID instead. It exists only for internal usage by the builders.
func (m *CampaignOrderMutation) RechargeOrderIDs() (ids []int64) {
	if id := m.recharge_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRechargeOrder resets all changes to the "recharge_order" edge.
func (m *CampaignOrderMutation) ResetRechargeOrder() {
	m.recharge_order = nil
	m.clearedrecharge_order = false
}

// Where appends a list predicates to the CampaignOrderMutation builder.
func (m *CampaignOrderMutation) Where(ps ...predicate.CampaignOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CampaignOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CampaignOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CampaignOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CampaignOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CampaignOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CampaignOrder).
func (m *CampaignOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CampaignOrderMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, campaignorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, campaignorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, campaignorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, campaignorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, campaignorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, campaignorder.FieldUserID)
	}
	if m.campaign != nil {
		fields = append(fields, campaignorder.FieldCampaignID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CampaignOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case campaignorder.FieldCreatedBy:
		return m.CreatedBy()
	case campaignorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case campaignorder.FieldCreatedAt:
		return m.CreatedAt()
	case campaignorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case campaignorder.FieldDeletedAt:
		return m.DeletedAt()
	case campaignorder.FieldUserID:
		return m.UserID()
	case campaignorder.FieldCampaignID:
		return m.CampaignID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CampaignOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case campaignorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case campaignorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case campaignorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case campaignorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case campaignorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case campaignorder.FieldUserID:
		return m.OldUserID(ctx)
	case campaignorder.FieldCampaignID:
		return m.OldCampaignID(ctx)
	}
	return nil, fmt.Errorf("unknown CampaignOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case campaignorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case campaignorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case campaignorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case campaignorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case campaignorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case campaignorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case campaignorder.FieldCampaignID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCampaignID(v)
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CampaignOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, campaignorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, campaignorder.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CampaignOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case campaignorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case campaignorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case campaignorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case campaignorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CampaignOrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CampaignOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CampaignOrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CampaignOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CampaignOrderMutation) ResetField(name string) error {
	switch name {
	case campaignorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case campaignorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case campaignorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case campaignorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case campaignorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case campaignorder.FieldUserID:
		m.ResetUserID()
		return nil
	case campaignorder.FieldCampaignID:
		m.ResetCampaignID()
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CampaignOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, campaignorder.EdgeUser)
	}
	if m.campaign != nil {
		edges = append(edges, campaignorder.EdgeCampaign)
	}
	if m.cost_bills != nil {
		edges = append(edges, campaignorder.EdgeCostBills)
	}
	if m.recharge_order != nil {
		edges = append(edges, campaignorder.EdgeRechargeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CampaignOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case campaignorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case campaignorder.EdgeCampaign:
		if id := m.campaign; id != nil {
			return []ent.Value{*id}
		}
	case campaignorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case campaignorder.EdgeRechargeOrder:
		if id := m.recharge_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CampaignOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcost_bills != nil {
		edges = append(edges, campaignorder.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CampaignOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case campaignorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CampaignOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, campaignorder.EdgeUser)
	}
	if m.clearedcampaign {
		edges = append(edges, campaignorder.EdgeCampaign)
	}
	if m.clearedcost_bills {
		edges = append(edges, campaignorder.EdgeCostBills)
	}
	if m.clearedrecharge_order {
		edges = append(edges, campaignorder.EdgeRechargeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CampaignOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case campaignorder.EdgeUser:
		return m.cleareduser
	case campaignorder.EdgeCampaign:
		return m.clearedcampaign
	case campaignorder.EdgeCostBills:
		return m.clearedcost_bills
	case campaignorder.EdgeRechargeOrder:
		return m.clearedrecharge_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CampaignOrderMutation) ClearEdge(name string) error {
	switch name {
	case campaignorder.EdgeUser:
		m.ClearUser()
		return nil
	case campaignorder.EdgeCampaign:
		m.ClearCampaign()
		return nil
	case campaignorder.EdgeRechargeOrder:
		m.ClearRechargeOrder()
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CampaignOrderMutation) ResetEdge(name string) error {
	switch name {
	case campaignorder.EdgeUser:
		m.ResetUser()
		return nil
	case campaignorder.EdgeCampaign:
		m.ResetCampaign()
		return nil
	case campaignorder.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case campaignorder.EdgeRechargeOrder:
		m.ResetRechargeOrder()
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder edge %s", name)
}

// CloudFileMutation represents an operation that mutates the CloudFile nodes in the graph.
type CloudFileMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	icon          *string
	size          *int64
	addsize       *int64
	md5           *string
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*CloudFile, error)
	predicates    []predicate.CloudFile
}

var _ ent.Mutation = (*CloudFileMutation)(nil)

// cloudfileOption allows management of the mutation configuration using functional options.
type cloudfileOption func(*CloudFileMutation)

// newCloudFileMutation creates new mutation for the CloudFile entity.
func newCloudFileMutation(c config, op Op, opts ...cloudfileOption) *CloudFileMutation {
	m := &CloudFileMutation{
		config:        c,
		op:            op,
		typ:           TypeCloudFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCloudFileID sets the ID field of the mutation.
func withCloudFileID(id int64) cloudfileOption {
	return func(m *CloudFileMutation) {
		var (
			err   error
			once  sync.Once
			value *CloudFile
		)
		m.oldValue = func(ctx context.Context) (*CloudFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CloudFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCloudFile sets the old CloudFile of the mutation.
func withCloudFile(node *CloudFile) cloudfileOption {
	return func(m *CloudFileMutation) {
		m.oldValue = func(context.Context) (*CloudFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CloudFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CloudFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CloudFile entities.
func (m *CloudFileMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CloudFileMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CloudFileMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CloudFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CloudFileMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CloudFileMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CloudFileMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CloudFileMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CloudFileMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CloudFileMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CloudFileMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CloudFileMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CloudFileMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CloudFileMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CloudFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CloudFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CloudFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CloudFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CloudFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CloudFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CloudFileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CloudFileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CloudFileMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CloudFileMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CloudFileMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CloudFileMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *CloudFileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CloudFileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CloudFileMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *CloudFileMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CloudFileMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *CloudFileMutation) ResetIcon() {
	m.icon = nil
}

// SetSize sets the "size" field.
func (m *CloudFileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *CloudFileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *CloudFileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *CloudFileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *CloudFileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetMd5 sets the "md5" field.
func (m *CloudFileMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the value of the "md5" field in the mutation.
func (m *CloudFileMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old "md5" field's value of the CloudFile entity.
// If the CloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudFileMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ResetMd5 resets all changes to the "md5" field.
func (m *CloudFileMutation) ResetMd5() {
	m.md5 = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CloudFileMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[cloudfile.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CloudFileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CloudFileMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CloudFileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CloudFileMutation builder.
func (m *CloudFileMutation) Where(ps ...predicate.CloudFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CloudFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CloudFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CloudFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CloudFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CloudFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CloudFile).
func (m *CloudFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CloudFileMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, cloudfile.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, cloudfile.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, cloudfile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cloudfile.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cloudfile.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, cloudfile.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, cloudfile.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, cloudfile.FieldIcon)
	}
	if m.size != nil {
		fields = append(fields, cloudfile.FieldSize)
	}
	if m.md5 != nil {
		fields = append(fields, cloudfile.FieldMd5)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CloudFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cloudfile.FieldCreatedBy:
		return m.CreatedBy()
	case cloudfile.FieldUpdatedBy:
		return m.UpdatedBy()
	case cloudfile.FieldCreatedAt:
		return m.CreatedAt()
	case cloudfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case cloudfile.FieldDeletedAt:
		return m.DeletedAt()
	case cloudfile.FieldUserID:
		return m.UserID()
	case cloudfile.FieldName:
		return m.Name()
	case cloudfile.FieldIcon:
		return m.Icon()
	case cloudfile.FieldSize:
		return m.Size()
	case cloudfile.FieldMd5:
		return m.Md5()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CloudFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cloudfile.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case cloudfile.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case cloudfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cloudfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cloudfile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cloudfile.FieldUserID:
		return m.OldUserID(ctx)
	case cloudfile.FieldName:
		return m.OldName(ctx)
	case cloudfile.FieldIcon:
		return m.OldIcon(ctx)
	case cloudfile.FieldSize:
		return m.OldSize(ctx)
	case cloudfile.FieldMd5:
		return m.OldMd5(ctx)
	}
	return nil, fmt.Errorf("unknown CloudFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cloudfile.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case cloudfile.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case cloudfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cloudfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cloudfile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cloudfile.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case cloudfile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cloudfile.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case cloudfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case cloudfile.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	}
	return fmt.Errorf("unknown CloudFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CloudFileMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, cloudfile.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, cloudfile.FieldUpdatedBy)
	}
	if m.addsize != nil {
		fields = append(fields, cloudfile.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CloudFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cloudfile.FieldCreatedBy:
		return m.AddedCreatedBy()
	case cloudfile.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case cloudfile.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cloudfile.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case cloudfile.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case cloudfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown CloudFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CloudFileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CloudFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CloudFileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CloudFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CloudFileMutation) ResetField(name string) error {
	switch name {
	case cloudfile.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case cloudfile.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case cloudfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cloudfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cloudfile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cloudfile.FieldUserID:
		m.ResetUserID()
		return nil
	case cloudfile.FieldName:
		m.ResetName()
		return nil
	case cloudfile.FieldIcon:
		m.ResetIcon()
		return nil
	case cloudfile.FieldSize:
		m.ResetSize()
		return nil
	case cloudfile.FieldMd5:
		m.ResetMd5()
		return nil
	}
	return fmt.Errorf("unknown CloudFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CloudFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, cloudfile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CloudFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cloudfile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CloudFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CloudFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CloudFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, cloudfile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CloudFileMutation) EdgeCleared(name string) bool {
	switch name {
	case cloudfile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CloudFileMutation) ClearEdge(name string) error {
	switch name {
	case cloudfile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CloudFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CloudFileMutation) ResetEdge(name string) error {
	switch name {
	case cloudfile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown CloudFile edge %s", name)
}

// CollectMutation represents an operation that mutates the Collect nodes in the graph.
type CollectMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	url           *string
	jpg_name      *int64
	addjpg_name   *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Collect, error)
	predicates    []predicate.Collect
}

var _ ent.Mutation = (*CollectMutation)(nil)

// collectOption allows management of the mutation configuration using functional options.
type collectOption func(*CollectMutation)

// newCollectMutation creates new mutation for the Collect entity.
func newCollectMutation(c config, op Op, opts ...collectOption) *CollectMutation {
	m := &CollectMutation{
		config:        c,
		op:            op,
		typ:           TypeCollect,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollectID sets the ID field of the mutation.
func withCollectID(id int64) collectOption {
	return func(m *CollectMutation) {
		var (
			err   error
			once  sync.Once
			value *Collect
		)
		m.oldValue = func(ctx context.Context) (*Collect, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collect.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollect sets the old Collect of the mutation.
func withCollect(node *Collect) collectOption {
	return func(m *CollectMutation) {
		m.oldValue = func(context.Context) (*Collect, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Collect entities.
func (m *CollectMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollectMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollectMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Collect.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CollectMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CollectMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CollectMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CollectMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CollectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CollectMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CollectMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CollectMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CollectMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CollectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CollectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CollectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CollectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CollectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CollectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CollectMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetURL sets the "url" field.
func (m *CollectMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CollectMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *CollectMutation) ResetURL() {
	m.url = nil
}

// SetUserID sets the "user_id" field.
func (m *CollectMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CollectMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CollectMutation) ResetUserID() {
	m.user = nil
}

// SetJpgName sets the "jpg_name" field.
func (m *CollectMutation) SetJpgName(i int64) {
	m.jpg_name = &i
	m.addjpg_name = nil
}

// JpgName returns the value of the "jpg_name" field in the mutation.
func (m *CollectMutation) JpgName() (r int64, exists bool) {
	v := m.jpg_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJpgName returns the old "jpg_name" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldJpgName(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJpgName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJpgName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJpgName: %w", err)
	}
	return oldValue.JpgName, nil
}

// AddJpgName adds i to the "jpg_name" field.
func (m *CollectMutation) AddJpgName(i int64) {
	if m.addjpg_name != nil {
		*m.addjpg_name += i
	} else {
		m.addjpg_name = &i
	}
}

// AddedJpgName returns the value that was added to the "jpg_name" field in this mutation.
func (m *CollectMutation) AddedJpgName() (r int64, exists bool) {
	v := m.addjpg_name
	if v == nil {
		return
	}
	return *v, true
}

// ResetJpgName resets all changes to the "jpg_name" field.
func (m *CollectMutation) ResetJpgName() {
	m.jpg_name = nil
	m.addjpg_name = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CollectMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[collect.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CollectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CollectMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CollectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CollectMutation builder.
func (m *CollectMutation) Where(ps ...predicate.Collect) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Collect, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Collect).
func (m *CollectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, collect.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, collect.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, collect.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, collect.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, collect.FieldDeletedAt)
	}
	if m.url != nil {
		fields = append(fields, collect.FieldURL)
	}
	if m.user != nil {
		fields = append(fields, collect.FieldUserID)
	}
	if m.jpg_name != nil {
		fields = append(fields, collect.FieldJpgName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collect.FieldCreatedBy:
		return m.CreatedBy()
	case collect.FieldUpdatedBy:
		return m.UpdatedBy()
	case collect.FieldCreatedAt:
		return m.CreatedAt()
	case collect.FieldUpdatedAt:
		return m.UpdatedAt()
	case collect.FieldDeletedAt:
		return m.DeletedAt()
	case collect.FieldURL:
		return m.URL()
	case collect.FieldUserID:
		return m.UserID()
	case collect.FieldJpgName:
		return m.JpgName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collect.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case collect.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case collect.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case collect.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case collect.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case collect.FieldURL:
		return m.OldURL(ctx)
	case collect.FieldUserID:
		return m.OldUserID(ctx)
	case collect.FieldJpgName:
		return m.OldJpgName(ctx)
	}
	return nil, fmt.Errorf("unknown Collect field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collect.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case collect.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case collect.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collect.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case collect.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case collect.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case collect.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case collect.FieldJpgName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJpgName(v)
		return nil
	}
	return fmt.Errorf("unknown Collect field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, collect.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, collect.FieldUpdatedBy)
	}
	if m.addjpg_name != nil {
		fields = append(fields, collect.FieldJpgName)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case collect.FieldCreatedBy:
		return m.AddedCreatedBy()
	case collect.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case collect.FieldJpgName:
		return m.AddedJpgName()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case collect.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case collect.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case collect.FieldJpgName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJpgName(v)
		return nil
	}
	return fmt.Errorf("unknown Collect numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Collect nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectMutation) ResetField(name string) error {
	switch name {
	case collect.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case collect.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case collect.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collect.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case collect.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case collect.FieldURL:
		m.ResetURL()
		return nil
	case collect.FieldUserID:
		m.ResetUserID()
		return nil
	case collect.FieldJpgName:
		m.ResetJpgName()
		return nil
	}
	return fmt.Errorf("unknown Collect field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, collect.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collect.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, collect.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectMutation) EdgeCleared(name string) bool {
	switch name {
	case collect.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectMutation) ClearEdge(name string) error {
	switch name {
	case collect.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Collect unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectMutation) ResetEdge(name string) error {
	switch name {
	case collect.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Collect edge %s", name)
}

// CostAccountMutation represents an operation that mutates the CostAccount nodes in the graph.
type CostAccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_by          *int64
	addcreated_by       *int64
	updated_by          *int64
	addupdated_by       *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	total_cep           *int64
	addtotal_cep        *int64
	sum_total_cep       *int64
	addsum_total_cep    *int64
	frozen_total_cep    *int64
	addfrozen_total_cep *int64
	pure_cep            *int64
	addpure_cep         *int64
	sum_pure_cep        *int64
	addsum_pure_cep     *int64
	frozen_pure_cep     *int64
	addfrozen_pure_cep  *int64
	gift_cep            *int64
	addgift_cep         *int64
	sum_gift_cep        *int64
	addsum_gift_cep     *int64
	frozen_gift_cep     *int64
	addfrozen_gift_cep  *int64
	clearedFields       map[string]struct{}
	user                *int64
	cleareduser         bool
	cost_bills          map[int64]struct{}
	removedcost_bills   map[int64]struct{}
	clearedcost_bills   bool
	done                bool
	oldValue            func(context.Context) (*CostAccount, error)
	predicates          []predicate.CostAccount
}

var _ ent.Mutation = (*CostAccountMutation)(nil)

// costaccountOption allows management of the mutation configuration using functional options.
type costaccountOption func(*CostAccountMutation)

// newCostAccountMutation creates new mutation for the CostAccount entity.
func newCostAccountMutation(c config, op Op, opts ...costaccountOption) *CostAccountMutation {
	m := &CostAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeCostAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostAccountID sets the ID field of the mutation.
func withCostAccountID(id int64) costaccountOption {
	return func(m *CostAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *CostAccount
		)
		m.oldValue = func(ctx context.Context) (*CostAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CostAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCostAccount sets the old CostAccount of the mutation.
func withCostAccount(node *CostAccount) costaccountOption {
	return func(m *CostAccountMutation) {
		m.oldValue = func(context.Context) (*CostAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CostAccount entities.
func (m *CostAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CostAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CostAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CostAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CostAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CostAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CostAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CostAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CostAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CostAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CostAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CostAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CostAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CostAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CostAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CostAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CostAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CostAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CostAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CostAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CostAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CostAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CostAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CostAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CostAccountMutation) ResetUserID() {
	m.user = nil
}

// SetTotalCep sets the "total_cep" field.
func (m *CostAccountMutation) SetTotalCep(i int64) {
	m.total_cep = &i
	m.addtotal_cep = nil
}

// TotalCep returns the value of the "total_cep" field in the mutation.
func (m *CostAccountMutation) TotalCep() (r int64, exists bool) {
	v := m.total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCep returns the old "total_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCep: %w", err)
	}
	return oldValue.TotalCep, nil
}

// AddTotalCep adds i to the "total_cep" field.
func (m *CostAccountMutation) AddTotalCep(i int64) {
	if m.addtotal_cep != nil {
		*m.addtotal_cep += i
	} else {
		m.addtotal_cep = &i
	}
}

// AddedTotalCep returns the value that was added to the "total_cep" field in this mutation.
func (m *CostAccountMutation) AddedTotalCep() (r int64, exists bool) {
	v := m.addtotal_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCep resets all changes to the "total_cep" field.
func (m *CostAccountMutation) ResetTotalCep() {
	m.total_cep = nil
	m.addtotal_cep = nil
}

// SetSumTotalCep sets the "sum_total_cep" field.
func (m *CostAccountMutation) SetSumTotalCep(i int64) {
	m.sum_total_cep = &i
	m.addsum_total_cep = nil
}

// SumTotalCep returns the value of the "sum_total_cep" field in the mutation.
func (m *CostAccountMutation) SumTotalCep() (r int64, exists bool) {
	v := m.sum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumTotalCep returns the old "sum_total_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldSumTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumTotalCep: %w", err)
	}
	return oldValue.SumTotalCep, nil
}

// AddSumTotalCep adds i to the "sum_total_cep" field.
func (m *CostAccountMutation) AddSumTotalCep(i int64) {
	if m.addsum_total_cep != nil {
		*m.addsum_total_cep += i
	} else {
		m.addsum_total_cep = &i
	}
}

// AddedSumTotalCep returns the value that was added to the "sum_total_cep" field in this mutation.
func (m *CostAccountMutation) AddedSumTotalCep() (r int64, exists bool) {
	v := m.addsum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumTotalCep resets all changes to the "sum_total_cep" field.
func (m *CostAccountMutation) ResetSumTotalCep() {
	m.sum_total_cep = nil
	m.addsum_total_cep = nil
}

// SetFrozenTotalCep sets the "frozen_total_cep" field.
func (m *CostAccountMutation) SetFrozenTotalCep(i int64) {
	m.frozen_total_cep = &i
	m.addfrozen_total_cep = nil
}

// FrozenTotalCep returns the value of the "frozen_total_cep" field in the mutation.
func (m *CostAccountMutation) FrozenTotalCep() (r int64, exists bool) {
	v := m.frozen_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenTotalCep returns the old "frozen_total_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldFrozenTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenTotalCep: %w", err)
	}
	return oldValue.FrozenTotalCep, nil
}

// AddFrozenTotalCep adds i to the "frozen_total_cep" field.
func (m *CostAccountMutation) AddFrozenTotalCep(i int64) {
	if m.addfrozen_total_cep != nil {
		*m.addfrozen_total_cep += i
	} else {
		m.addfrozen_total_cep = &i
	}
}

// AddedFrozenTotalCep returns the value that was added to the "frozen_total_cep" field in this mutation.
func (m *CostAccountMutation) AddedFrozenTotalCep() (r int64, exists bool) {
	v := m.addfrozen_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenTotalCep resets all changes to the "frozen_total_cep" field.
func (m *CostAccountMutation) ResetFrozenTotalCep() {
	m.frozen_total_cep = nil
	m.addfrozen_total_cep = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *CostAccountMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *CostAccountMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *CostAccountMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *CostAccountMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *CostAccountMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetSumPureCep sets the "sum_pure_cep" field.
func (m *CostAccountMutation) SetSumPureCep(i int64) {
	m.sum_pure_cep = &i
	m.addsum_pure_cep = nil
}

// SumPureCep returns the value of the "sum_pure_cep" field in the mutation.
func (m *CostAccountMutation) SumPureCep() (r int64, exists bool) {
	v := m.sum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumPureCep returns the old "sum_pure_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldSumPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumPureCep: %w", err)
	}
	return oldValue.SumPureCep, nil
}

// AddSumPureCep adds i to the "sum_pure_cep" field.
func (m *CostAccountMutation) AddSumPureCep(i int64) {
	if m.addsum_pure_cep != nil {
		*m.addsum_pure_cep += i
	} else {
		m.addsum_pure_cep = &i
	}
}

// AddedSumPureCep returns the value that was added to the "sum_pure_cep" field in this mutation.
func (m *CostAccountMutation) AddedSumPureCep() (r int64, exists bool) {
	v := m.addsum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumPureCep resets all changes to the "sum_pure_cep" field.
func (m *CostAccountMutation) ResetSumPureCep() {
	m.sum_pure_cep = nil
	m.addsum_pure_cep = nil
}

// SetFrozenPureCep sets the "frozen_pure_cep" field.
func (m *CostAccountMutation) SetFrozenPureCep(i int64) {
	m.frozen_pure_cep = &i
	m.addfrozen_pure_cep = nil
}

// FrozenPureCep returns the value of the "frozen_pure_cep" field in the mutation.
func (m *CostAccountMutation) FrozenPureCep() (r int64, exists bool) {
	v := m.frozen_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenPureCep returns the old "frozen_pure_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldFrozenPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenPureCep: %w", err)
	}
	return oldValue.FrozenPureCep, nil
}

// AddFrozenPureCep adds i to the "frozen_pure_cep" field.
func (m *CostAccountMutation) AddFrozenPureCep(i int64) {
	if m.addfrozen_pure_cep != nil {
		*m.addfrozen_pure_cep += i
	} else {
		m.addfrozen_pure_cep = &i
	}
}

// AddedFrozenPureCep returns the value that was added to the "frozen_pure_cep" field in this mutation.
func (m *CostAccountMutation) AddedFrozenPureCep() (r int64, exists bool) {
	v := m.addfrozen_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenPureCep resets all changes to the "frozen_pure_cep" field.
func (m *CostAccountMutation) ResetFrozenPureCep() {
	m.frozen_pure_cep = nil
	m.addfrozen_pure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *CostAccountMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *CostAccountMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *CostAccountMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *CostAccountMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *CostAccountMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetSumGiftCep sets the "sum_gift_cep" field.
func (m *CostAccountMutation) SetSumGiftCep(i int64) {
	m.sum_gift_cep = &i
	m.addsum_gift_cep = nil
}

// SumGiftCep returns the value of the "sum_gift_cep" field in the mutation.
func (m *CostAccountMutation) SumGiftCep() (r int64, exists bool) {
	v := m.sum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumGiftCep returns the old "sum_gift_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldSumGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumGiftCep: %w", err)
	}
	return oldValue.SumGiftCep, nil
}

// AddSumGiftCep adds i to the "sum_gift_cep" field.
func (m *CostAccountMutation) AddSumGiftCep(i int64) {
	if m.addsum_gift_cep != nil {
		*m.addsum_gift_cep += i
	} else {
		m.addsum_gift_cep = &i
	}
}

// AddedSumGiftCep returns the value that was added to the "sum_gift_cep" field in this mutation.
func (m *CostAccountMutation) AddedSumGiftCep() (r int64, exists bool) {
	v := m.addsum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumGiftCep resets all changes to the "sum_gift_cep" field.
func (m *CostAccountMutation) ResetSumGiftCep() {
	m.sum_gift_cep = nil
	m.addsum_gift_cep = nil
}

// SetFrozenGiftCep sets the "frozen_gift_cep" field.
func (m *CostAccountMutation) SetFrozenGiftCep(i int64) {
	m.frozen_gift_cep = &i
	m.addfrozen_gift_cep = nil
}

// FrozenGiftCep returns the value of the "frozen_gift_cep" field in the mutation.
func (m *CostAccountMutation) FrozenGiftCep() (r int64, exists bool) {
	v := m.frozen_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenGiftCep returns the old "frozen_gift_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldFrozenGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenGiftCep: %w", err)
	}
	return oldValue.FrozenGiftCep, nil
}

// AddFrozenGiftCep adds i to the "frozen_gift_cep" field.
func (m *CostAccountMutation) AddFrozenGiftCep(i int64) {
	if m.addfrozen_gift_cep != nil {
		*m.addfrozen_gift_cep += i
	} else {
		m.addfrozen_gift_cep = &i
	}
}

// AddedFrozenGiftCep returns the value that was added to the "frozen_gift_cep" field in this mutation.
func (m *CostAccountMutation) AddedFrozenGiftCep() (r int64, exists bool) {
	v := m.addfrozen_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenGiftCep resets all changes to the "frozen_gift_cep" field.
func (m *CostAccountMutation) ResetFrozenGiftCep() {
	m.frozen_gift_cep = nil
	m.addfrozen_gift_cep = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CostAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[costaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CostAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CostAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CostAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *CostAccountMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *CostAccountMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *CostAccountMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *CostAccountMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *CostAccountMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *CostAccountMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *CostAccountMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// Where appends a list predicates to the CostAccountMutation builder.
func (m *CostAccountMutation) Where(ps ...predicate.CostAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CostAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CostAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CostAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CostAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CostAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CostAccount).
func (m *CostAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostAccountMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, costaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, costaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, costaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, costaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, costaccount.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, costaccount.FieldUserID)
	}
	if m.total_cep != nil {
		fields = append(fields, costaccount.FieldTotalCep)
	}
	if m.sum_total_cep != nil {
		fields = append(fields, costaccount.FieldSumTotalCep)
	}
	if m.frozen_total_cep != nil {
		fields = append(fields, costaccount.FieldFrozenTotalCep)
	}
	if m.pure_cep != nil {
		fields = append(fields, costaccount.FieldPureCep)
	}
	if m.sum_pure_cep != nil {
		fields = append(fields, costaccount.FieldSumPureCep)
	}
	if m.frozen_pure_cep != nil {
		fields = append(fields, costaccount.FieldFrozenPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, costaccount.FieldGiftCep)
	}
	if m.sum_gift_cep != nil {
		fields = append(fields, costaccount.FieldSumGiftCep)
	}
	if m.frozen_gift_cep != nil {
		fields = append(fields, costaccount.FieldFrozenGiftCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case costaccount.FieldCreatedBy:
		return m.CreatedBy()
	case costaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case costaccount.FieldCreatedAt:
		return m.CreatedAt()
	case costaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case costaccount.FieldDeletedAt:
		return m.DeletedAt()
	case costaccount.FieldUserID:
		return m.UserID()
	case costaccount.FieldTotalCep:
		return m.TotalCep()
	case costaccount.FieldSumTotalCep:
		return m.SumTotalCep()
	case costaccount.FieldFrozenTotalCep:
		return m.FrozenTotalCep()
	case costaccount.FieldPureCep:
		return m.PureCep()
	case costaccount.FieldSumPureCep:
		return m.SumPureCep()
	case costaccount.FieldFrozenPureCep:
		return m.FrozenPureCep()
	case costaccount.FieldGiftCep:
		return m.GiftCep()
	case costaccount.FieldSumGiftCep:
		return m.SumGiftCep()
	case costaccount.FieldFrozenGiftCep:
		return m.FrozenGiftCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case costaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case costaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case costaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case costaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case costaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case costaccount.FieldUserID:
		return m.OldUserID(ctx)
	case costaccount.FieldTotalCep:
		return m.OldTotalCep(ctx)
	case costaccount.FieldSumTotalCep:
		return m.OldSumTotalCep(ctx)
	case costaccount.FieldFrozenTotalCep:
		return m.OldFrozenTotalCep(ctx)
	case costaccount.FieldPureCep:
		return m.OldPureCep(ctx)
	case costaccount.FieldSumPureCep:
		return m.OldSumPureCep(ctx)
	case costaccount.FieldFrozenPureCep:
		return m.OldFrozenPureCep(ctx)
	case costaccount.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case costaccount.FieldSumGiftCep:
		return m.OldSumGiftCep(ctx)
	case costaccount.FieldFrozenGiftCep:
		return m.OldFrozenGiftCep(ctx)
	}
	return nil, fmt.Errorf("unknown CostAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case costaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case costaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case costaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case costaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case costaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case costaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case costaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCep(v)
		return nil
	case costaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumTotalCep(v)
		return nil
	case costaccount.FieldFrozenTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenTotalCep(v)
		return nil
	case costaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case costaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumPureCep(v)
		return nil
	case costaccount.FieldFrozenPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenPureCep(v)
		return nil
	case costaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case costaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumGiftCep(v)
		return nil
	case costaccount.FieldFrozenGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown CostAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, costaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, costaccount.FieldUpdatedBy)
	}
	if m.addtotal_cep != nil {
		fields = append(fields, costaccount.FieldTotalCep)
	}
	if m.addsum_total_cep != nil {
		fields = append(fields, costaccount.FieldSumTotalCep)
	}
	if m.addfrozen_total_cep != nil {
		fields = append(fields, costaccount.FieldFrozenTotalCep)
	}
	if m.addpure_cep != nil {
		fields = append(fields, costaccount.FieldPureCep)
	}
	if m.addsum_pure_cep != nil {
		fields = append(fields, costaccount.FieldSumPureCep)
	}
	if m.addfrozen_pure_cep != nil {
		fields = append(fields, costaccount.FieldFrozenPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, costaccount.FieldGiftCep)
	}
	if m.addsum_gift_cep != nil {
		fields = append(fields, costaccount.FieldSumGiftCep)
	}
	if m.addfrozen_gift_cep != nil {
		fields = append(fields, costaccount.FieldFrozenGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case costaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case costaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case costaccount.FieldTotalCep:
		return m.AddedTotalCep()
	case costaccount.FieldSumTotalCep:
		return m.AddedSumTotalCep()
	case costaccount.FieldFrozenTotalCep:
		return m.AddedFrozenTotalCep()
	case costaccount.FieldPureCep:
		return m.AddedPureCep()
	case costaccount.FieldSumPureCep:
		return m.AddedSumPureCep()
	case costaccount.FieldFrozenPureCep:
		return m.AddedFrozenPureCep()
	case costaccount.FieldGiftCep:
		return m.AddedGiftCep()
	case costaccount.FieldSumGiftCep:
		return m.AddedSumGiftCep()
	case costaccount.FieldFrozenGiftCep:
		return m.AddedFrozenGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case costaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case costaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case costaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCep(v)
		return nil
	case costaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumTotalCep(v)
		return nil
	case costaccount.FieldFrozenTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenTotalCep(v)
		return nil
	case costaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case costaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumPureCep(v)
		return nil
	case costaccount.FieldFrozenPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenPureCep(v)
		return nil
	case costaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case costaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumGiftCep(v)
		return nil
	case costaccount.FieldFrozenGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown CostAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CostAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostAccountMutation) ResetField(name string) error {
	switch name {
	case costaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case costaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case costaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case costaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case costaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case costaccount.FieldUserID:
		m.ResetUserID()
		return nil
	case costaccount.FieldTotalCep:
		m.ResetTotalCep()
		return nil
	case costaccount.FieldSumTotalCep:
		m.ResetSumTotalCep()
		return nil
	case costaccount.FieldFrozenTotalCep:
		m.ResetFrozenTotalCep()
		return nil
	case costaccount.FieldPureCep:
		m.ResetPureCep()
		return nil
	case costaccount.FieldSumPureCep:
		m.ResetSumPureCep()
		return nil
	case costaccount.FieldFrozenPureCep:
		m.ResetFrozenPureCep()
		return nil
	case costaccount.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case costaccount.FieldSumGiftCep:
		m.ResetSumGiftCep()
		return nil
	case costaccount.FieldFrozenGiftCep:
		m.ResetFrozenGiftCep()
		return nil
	}
	return fmt.Errorf("unknown CostAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, costaccount.EdgeUser)
	}
	if m.cost_bills != nil {
		edges = append(edges, costaccount.EdgeCostBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case costaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case costaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcost_bills != nil {
		edges = append(edges, costaccount.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case costaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, costaccount.EdgeUser)
	}
	if m.clearedcost_bills {
		edges = append(edges, costaccount.EdgeCostBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case costaccount.EdgeUser:
		return m.cleareduser
	case costaccount.EdgeCostBills:
		return m.clearedcost_bills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostAccountMutation) ClearEdge(name string) error {
	switch name {
	case costaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CostAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostAccountMutation) ResetEdge(name string) error {
	switch name {
	case costaccount.EdgeUser:
		m.ResetUser()
		return nil
	case costaccount.EdgeCostBills:
		m.ResetCostBills()
		return nil
	}
	return fmt.Errorf("unknown CostAccount edge %s", name)
}

// CostBillMutation represents an operation that mutates the CostBill nodes in the graph.
type CostBillMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_by                   *int64
	addcreated_by                *int64
	updated_by                   *int64
	addupdated_by                *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	_type                        *costbill.Type
	way                          *costbill.Way
	is_add                       *bool
	serial_number                *string
	pure_cep                     *int64
	addpure_cep                  *int64
	gift_cep                     *int64
	addgift_cep                  *int64
	status                       *enums.BillStatus
	clearedFields                map[string]struct{}
	user                         *int64
	cleareduser                  bool
	cost_account                 *int64
	clearedcost_account          bool
	recharge_order               *int64
	clearedrecharge_order        bool
	mission_consume_order        *int64
	clearedmission_consume_order bool
	platform_account             *int64
	clearedplatform_account      bool
	campaign_order               *int64
	clearedcampaign_order        bool
	done                         bool
	oldValue                     func(context.Context) (*CostBill, error)
	predicates                   []predicate.CostBill
}

var _ ent.Mutation = (*CostBillMutation)(nil)

// costbillOption allows management of the mutation configuration using functional options.
type costbillOption func(*CostBillMutation)

// newCostBillMutation creates new mutation for the CostBill entity.
func newCostBillMutation(c config, op Op, opts ...costbillOption) *CostBillMutation {
	m := &CostBillMutation{
		config:        c,
		op:            op,
		typ:           TypeCostBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostBillID sets the ID field of the mutation.
func withCostBillID(id int64) costbillOption {
	return func(m *CostBillMutation) {
		var (
			err   error
			once  sync.Once
			value *CostBill
		)
		m.oldValue = func(ctx context.Context) (*CostBill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CostBill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCostBill sets the old CostBill of the mutation.
func withCostBill(node *CostBill) costbillOption {
	return func(m *CostBillMutation) {
		m.oldValue = func(context.Context) (*CostBill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostBillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostBillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CostBill entities.
func (m *CostBillMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostBillMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CostBillMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CostBill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CostBillMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CostBillMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CostBillMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CostBillMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CostBillMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CostBillMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CostBillMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CostBillMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CostBillMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CostBillMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CostBillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CostBillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CostBillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CostBillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CostBillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CostBillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CostBillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CostBillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CostBillMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *CostBillMutation) SetType(c costbill.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CostBillMutation) GetType() (r costbill.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldType(ctx context.Context) (v costbill.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CostBillMutation) ResetType() {
	m._type = nil
}

// SetWay sets the "way" field.
func (m *CostBillMutation) SetWay(c costbill.Way) {
	m.way = &c
}

// Way returns the value of the "way" field in the mutation.
func (m *CostBillMutation) Way() (r costbill.Way, exists bool) {
	v := m.way
	if v == nil {
		return
	}
	return *v, true
}

// OldWay returns the old "way" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldWay(ctx context.Context) (v costbill.Way, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWay: %w", err)
	}
	return oldValue.Way, nil
}

// ResetWay resets all changes to the "way" field.
func (m *CostBillMutation) ResetWay() {
	m.way = nil
}

// SetIsAdd sets the "is_add" field.
func (m *CostBillMutation) SetIsAdd(b bool) {
	m.is_add = &b
}

// IsAdd returns the value of the "is_add" field in the mutation.
func (m *CostBillMutation) IsAdd() (r bool, exists bool) {
	v := m.is_add
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdd returns the old "is_add" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldIsAdd(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdd: %w", err)
	}
	return oldValue.IsAdd, nil
}

// ResetIsAdd resets all changes to the "is_add" field.
func (m *CostBillMutation) ResetIsAdd() {
	m.is_add = nil
}

// SetUserID sets the "user_id" field.
func (m *CostBillMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CostBillMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CostBillMutation) ResetUserID() {
	m.user = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *CostBillMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *CostBillMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *CostBillMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetCostAccountID sets the "cost_account_id" field.
func (m *CostBillMutation) SetCostAccountID(i int64) {
	m.cost_account = &i
}

// CostAccountID returns the value of the "cost_account_id" field in the mutation.
func (m *CostBillMutation) CostAccountID() (r int64, exists bool) {
	v := m.cost_account
	if v == nil {
		return
	}
	return *v, true
}

// OldCostAccountID returns the old "cost_account_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCostAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostAccountID: %w", err)
	}
	return oldValue.CostAccountID, nil
}

// ResetCostAccountID resets all changes to the "cost_account_id" field.
func (m *CostBillMutation) ResetCostAccountID() {
	m.cost_account = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *CostBillMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *CostBillMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *CostBillMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *CostBillMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *CostBillMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *CostBillMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *CostBillMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *CostBillMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *CostBillMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *CostBillMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetReasonID sets the "reason_id" field.
func (m *CostBillMutation) SetReasonID(i int64) {
	m.recharge_order = &i
}

// ReasonID returns the value of the "reason_id" field in the mutation.
func (m *CostBillMutation) ReasonID() (r int64, exists bool) {
	v := m.recharge_order
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonID returns the old "reason_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldReasonID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonID: %w", err)
	}
	return oldValue.ReasonID, nil
}

// ClearReasonID clears the value of the "reason_id" field.
func (m *CostBillMutation) ClearReasonID() {
	m.recharge_order = nil
	m.clearedFields[costbill.FieldReasonID] = struct{}{}
}

// ReasonIDCleared returns if the "reason_id" field was cleared in this mutation.
func (m *CostBillMutation) ReasonIDCleared() bool {
	_, ok := m.clearedFields[costbill.FieldReasonID]
	return ok
}

// ResetReasonID resets all changes to the "reason_id" field.
func (m *CostBillMutation) ResetReasonID() {
	m.recharge_order = nil
	delete(m.clearedFields, costbill.FieldReasonID)
}

// SetStatus sets the "status" field.
func (m *CostBillMutation) SetStatus(es enums.BillStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *CostBillMutation) Status() (r enums.BillStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldStatus(ctx context.Context) (v enums.BillStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CostBillMutation) ResetStatus() {
	m.status = nil
}

// SetMarketAccountID sets the "market_account_id" field.
func (m *CostBillMutation) SetMarketAccountID(i int64) {
	m.platform_account = &i
}

// MarketAccountID returns the value of the "market_account_id" field in the mutation.
func (m *CostBillMutation) MarketAccountID() (r int64, exists bool) {
	v := m.platform_account
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketAccountID returns the old "market_account_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldMarketAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketAccountID: %w", err)
	}
	return oldValue.MarketAccountID, nil
}

// ResetMarketAccountID resets all changes to the "market_account_id" field.
func (m *CostBillMutation) ResetMarketAccountID() {
	m.platform_account = nil
}

// SetCampaignOrderID sets the "campaign_order_id" field.
func (m *CostBillMutation) SetCampaignOrderID(i int64) {
	m.campaign_order = &i
}

// CampaignOrderID returns the value of the "campaign_order_id" field in the mutation.
func (m *CostBillMutation) CampaignOrderID() (r int64, exists bool) {
	v := m.campaign_order
	if v == nil {
		return
	}
	return *v, true
}

// OldCampaignOrderID returns the old "campaign_order_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCampaignOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCampaignOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCampaignOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCampaignOrderID: %w", err)
	}
	return oldValue.CampaignOrderID, nil
}

// ResetCampaignOrderID resets all changes to the "campaign_order_id" field.
func (m *CostBillMutation) ResetCampaignOrderID() {
	m.campaign_order = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CostBillMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[costbill.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CostBillMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CostBillMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCostAccount clears the "cost_account" edge to the CostAccount entity.
func (m *CostBillMutation) ClearCostAccount() {
	m.clearedcost_account = true
	m.clearedFields[costbill.FieldCostAccountID] = struct{}{}
}

// CostAccountCleared reports if the "cost_account" edge to the CostAccount entity was cleared.
func (m *CostBillMutation) CostAccountCleared() bool {
	return m.clearedcost_account
}

// CostAccountIDs returns the "cost_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CostAccountID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) CostAccountIDs() (ids []int64) {
	if id := m.cost_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCostAccount resets all changes to the "cost_account" edge.
func (m *CostBillMutation) ResetCostAccount() {
	m.cost_account = nil
	m.clearedcost_account = false
}

// SetRechargeOrderID sets the "recharge_order" edge to the RechargeOrder entity by id.
func (m *CostBillMutation) SetRechargeOrderID(id int64) {
	m.recharge_order = &id
}

// ClearRechargeOrder clears the "recharge_order" edge to the RechargeOrder entity.
func (m *CostBillMutation) ClearRechargeOrder() {
	m.clearedrecharge_order = true
	m.clearedFields[costbill.FieldReasonID] = struct{}{}
}

// RechargeOrderCleared reports if the "recharge_order" edge to the RechargeOrder entity was cleared.
func (m *CostBillMutation) RechargeOrderCleared() bool {
	return m.ReasonIDCleared() || m.clearedrecharge_order
}

// RechargeOrderID returns the "recharge_order" edge ID in the mutation.
func (m *CostBillMutation) RechargeOrderID() (id int64, exists bool) {
	if m.recharge_order != nil {
		return *m.recharge_order, true
	}
	return
}

// RechargeOrderIDs returns the "recharge_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RechargeOrderID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) RechargeOrderIDs() (ids []int64) {
	if id := m.recharge_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRechargeOrder resets all changes to the "recharge_order" edge.
func (m *CostBillMutation) ResetRechargeOrder() {
	m.recharge_order = nil
	m.clearedrecharge_order = false
}

// SetMissionConsumeOrderID sets the "mission_consume_order" edge to the MissionConsumeOrder entity by id.
func (m *CostBillMutation) SetMissionConsumeOrderID(id int64) {
	m.mission_consume_order = &id
}

// ClearMissionConsumeOrder clears the "mission_consume_order" edge to the MissionConsumeOrder entity.
func (m *CostBillMutation) ClearMissionConsumeOrder() {
	m.clearedmission_consume_order = true
	m.clearedFields[costbill.FieldReasonID] = struct{}{}
}

// MissionConsumeOrderCleared reports if the "mission_consume_order" edge to the MissionConsumeOrder entity was cleared.
func (m *CostBillMutation) MissionConsumeOrderCleared() bool {
	return m.ReasonIDCleared() || m.clearedmission_consume_order
}

// MissionConsumeOrderID returns the "mission_consume_order" edge ID in the mutation.
func (m *CostBillMutation) MissionConsumeOrderID() (id int64, exists bool) {
	if m.mission_consume_order != nil {
		return *m.mission_consume_order, true
	}
	return
}

// MissionConsumeOrderIDs returns the "mission_consume_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionConsumeOrderID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) MissionConsumeOrderIDs() (ids []int64) {
	if id := m.mission_consume_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionConsumeOrder resets all changes to the "mission_consume_order" edge.
func (m *CostBillMutation) ResetMissionConsumeOrder() {
	m.mission_consume_order = nil
	m.clearedmission_consume_order = false
}

// SetPlatformAccountID sets the "platform_account" edge to the PlatformAccount entity by id.
func (m *CostBillMutation) SetPlatformAccountID(id int64) {
	m.platform_account = &id
}

// ClearPlatformAccount clears the "platform_account" edge to the PlatformAccount entity.
func (m *CostBillMutation) ClearPlatformAccount() {
	m.clearedplatform_account = true
	m.clearedFields[costbill.FieldMarketAccountID] = struct{}{}
}

// PlatformAccountCleared reports if the "platform_account" edge to the PlatformAccount entity was cleared.
func (m *CostBillMutation) PlatformAccountCleared() bool {
	return m.clearedplatform_account
}

// PlatformAccountID returns the "platform_account" edge ID in the mutation.
func (m *CostBillMutation) PlatformAccountID() (id int64, exists bool) {
	if m.platform_account != nil {
		return *m.platform_account, true
	}
	return
}

// PlatformAccountIDs returns the "platform_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlatformAccountID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) PlatformAccountIDs() (ids []int64) {
	if id := m.platform_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlatformAccount resets all changes to the "platform_account" edge.
func (m *CostBillMutation) ResetPlatformAccount() {
	m.platform_account = nil
	m.clearedplatform_account = false
}

// ClearCampaignOrder clears the "campaign_order" edge to the CampaignOrder entity.
func (m *CostBillMutation) ClearCampaignOrder() {
	m.clearedcampaign_order = true
	m.clearedFields[costbill.FieldCampaignOrderID] = struct{}{}
}

// CampaignOrderCleared reports if the "campaign_order" edge to the CampaignOrder entity was cleared.
func (m *CostBillMutation) CampaignOrderCleared() bool {
	return m.clearedcampaign_order
}

// CampaignOrderIDs returns the "campaign_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignOrderID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) CampaignOrderIDs() (ids []int64) {
	if id := m.campaign_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaignOrder resets all changes to the "campaign_order" edge.
func (m *CostBillMutation) ResetCampaignOrder() {
	m.campaign_order = nil
	m.clearedcampaign_order = false
}

// Where appends a list predicates to the CostBillMutation builder.
func (m *CostBillMutation) Where(ps ...predicate.CostBill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CostBillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CostBillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CostBill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CostBillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CostBillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CostBill).
func (m *CostBillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostBillMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, costbill.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, costbill.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, costbill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, costbill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, costbill.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, costbill.FieldType)
	}
	if m.way != nil {
		fields = append(fields, costbill.FieldWay)
	}
	if m.is_add != nil {
		fields = append(fields, costbill.FieldIsAdd)
	}
	if m.user != nil {
		fields = append(fields, costbill.FieldUserID)
	}
	if m.serial_number != nil {
		fields = append(fields, costbill.FieldSerialNumber)
	}
	if m.cost_account != nil {
		fields = append(fields, costbill.FieldCostAccountID)
	}
	if m.pure_cep != nil {
		fields = append(fields, costbill.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, costbill.FieldGiftCep)
	}
	if m.recharge_order != nil {
		fields = append(fields, costbill.FieldReasonID)
	}
	if m.status != nil {
		fields = append(fields, costbill.FieldStatus)
	}
	if m.platform_account != nil {
		fields = append(fields, costbill.FieldMarketAccountID)
	}
	if m.campaign_order != nil {
		fields = append(fields, costbill.FieldCampaignOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostBillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case costbill.FieldCreatedBy:
		return m.CreatedBy()
	case costbill.FieldUpdatedBy:
		return m.UpdatedBy()
	case costbill.FieldCreatedAt:
		return m.CreatedAt()
	case costbill.FieldUpdatedAt:
		return m.UpdatedAt()
	case costbill.FieldDeletedAt:
		return m.DeletedAt()
	case costbill.FieldType:
		return m.GetType()
	case costbill.FieldWay:
		return m.Way()
	case costbill.FieldIsAdd:
		return m.IsAdd()
	case costbill.FieldUserID:
		return m.UserID()
	case costbill.FieldSerialNumber:
		return m.SerialNumber()
	case costbill.FieldCostAccountID:
		return m.CostAccountID()
	case costbill.FieldPureCep:
		return m.PureCep()
	case costbill.FieldGiftCep:
		return m.GiftCep()
	case costbill.FieldReasonID:
		return m.ReasonID()
	case costbill.FieldStatus:
		return m.Status()
	case costbill.FieldMarketAccountID:
		return m.MarketAccountID()
	case costbill.FieldCampaignOrderID:
		return m.CampaignOrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostBillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case costbill.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case costbill.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case costbill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case costbill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case costbill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case costbill.FieldType:
		return m.OldType(ctx)
	case costbill.FieldWay:
		return m.OldWay(ctx)
	case costbill.FieldIsAdd:
		return m.OldIsAdd(ctx)
	case costbill.FieldUserID:
		return m.OldUserID(ctx)
	case costbill.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case costbill.FieldCostAccountID:
		return m.OldCostAccountID(ctx)
	case costbill.FieldPureCep:
		return m.OldPureCep(ctx)
	case costbill.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case costbill.FieldReasonID:
		return m.OldReasonID(ctx)
	case costbill.FieldStatus:
		return m.OldStatus(ctx)
	case costbill.FieldMarketAccountID:
		return m.OldMarketAccountID(ctx)
	case costbill.FieldCampaignOrderID:
		return m.OldCampaignOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown CostBill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostBillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case costbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case costbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case costbill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case costbill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case costbill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case costbill.FieldType:
		v, ok := value.(costbill.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case costbill.FieldWay:
		v, ok := value.(costbill.Way)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWay(v)
		return nil
	case costbill.FieldIsAdd:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdd(v)
		return nil
	case costbill.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case costbill.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case costbill.FieldCostAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostAccountID(v)
		return nil
	case costbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case costbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case costbill.FieldReasonID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonID(v)
		return nil
	case costbill.FieldStatus:
		v, ok := value.(enums.BillStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case costbill.FieldMarketAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketAccountID(v)
		return nil
	case costbill.FieldCampaignOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCampaignOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown CostBill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostBillMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, costbill.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, costbill.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, costbill.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, costbill.FieldGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostBillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case costbill.FieldCreatedBy:
		return m.AddedCreatedBy()
	case costbill.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case costbill.FieldPureCep:
		return m.AddedPureCep()
	case costbill.FieldGiftCep:
		return m.AddedGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostBillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case costbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case costbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case costbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case costbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown CostBill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostBillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(costbill.FieldReasonID) {
		fields = append(fields, costbill.FieldReasonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostBillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostBillMutation) ClearField(name string) error {
	switch name {
	case costbill.FieldReasonID:
		m.ClearReasonID()
		return nil
	}
	return fmt.Errorf("unknown CostBill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostBillMutation) ResetField(name string) error {
	switch name {
	case costbill.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case costbill.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case costbill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case costbill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case costbill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case costbill.FieldType:
		m.ResetType()
		return nil
	case costbill.FieldWay:
		m.ResetWay()
		return nil
	case costbill.FieldIsAdd:
		m.ResetIsAdd()
		return nil
	case costbill.FieldUserID:
		m.ResetUserID()
		return nil
	case costbill.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case costbill.FieldCostAccountID:
		m.ResetCostAccountID()
		return nil
	case costbill.FieldPureCep:
		m.ResetPureCep()
		return nil
	case costbill.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case costbill.FieldReasonID:
		m.ResetReasonID()
		return nil
	case costbill.FieldStatus:
		m.ResetStatus()
		return nil
	case costbill.FieldMarketAccountID:
		m.ResetMarketAccountID()
		return nil
	case costbill.FieldCampaignOrderID:
		m.ResetCampaignOrderID()
		return nil
	}
	return fmt.Errorf("unknown CostBill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostBillMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.user != nil {
		edges = append(edges, costbill.EdgeUser)
	}
	if m.cost_account != nil {
		edges = append(edges, costbill.EdgeCostAccount)
	}
	if m.recharge_order != nil {
		edges = append(edges, costbill.EdgeRechargeOrder)
	}
	if m.mission_consume_order != nil {
		edges = append(edges, costbill.EdgeMissionConsumeOrder)
	}
	if m.platform_account != nil {
		edges = append(edges, costbill.EdgePlatformAccount)
	}
	if m.campaign_order != nil {
		edges = append(edges, costbill.EdgeCampaignOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostBillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case costbill.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeCostAccount:
		if id := m.cost_account; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeRechargeOrder:
		if id := m.recharge_order; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeMissionConsumeOrder:
		if id := m.mission_consume_order; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgePlatformAccount:
		if id := m.platform_account; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeCampaignOrder:
		if id := m.campaign_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostBillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostBillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostBillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareduser {
		edges = append(edges, costbill.EdgeUser)
	}
	if m.clearedcost_account {
		edges = append(edges, costbill.EdgeCostAccount)
	}
	if m.clearedrecharge_order {
		edges = append(edges, costbill.EdgeRechargeOrder)
	}
	if m.clearedmission_consume_order {
		edges = append(edges, costbill.EdgeMissionConsumeOrder)
	}
	if m.clearedplatform_account {
		edges = append(edges, costbill.EdgePlatformAccount)
	}
	if m.clearedcampaign_order {
		edges = append(edges, costbill.EdgeCampaignOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostBillMutation) EdgeCleared(name string) bool {
	switch name {
	case costbill.EdgeUser:
		return m.cleareduser
	case costbill.EdgeCostAccount:
		return m.clearedcost_account
	case costbill.EdgeRechargeOrder:
		return m.clearedrecharge_order
	case costbill.EdgeMissionConsumeOrder:
		return m.clearedmission_consume_order
	case costbill.EdgePlatformAccount:
		return m.clearedplatform_account
	case costbill.EdgeCampaignOrder:
		return m.clearedcampaign_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostBillMutation) ClearEdge(name string) error {
	switch name {
	case costbill.EdgeUser:
		m.ClearUser()
		return nil
	case costbill.EdgeCostAccount:
		m.ClearCostAccount()
		return nil
	case costbill.EdgeRechargeOrder:
		m.ClearRechargeOrder()
		return nil
	case costbill.EdgeMissionConsumeOrder:
		m.ClearMissionConsumeOrder()
		return nil
	case costbill.EdgePlatformAccount:
		m.ClearPlatformAccount()
		return nil
	case costbill.EdgeCampaignOrder:
		m.ClearCampaignOrder()
		return nil
	}
	return fmt.Errorf("unknown CostBill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostBillMutation) ResetEdge(name string) error {
	switch name {
	case costbill.EdgeUser:
		m.ResetUser()
		return nil
	case costbill.EdgeCostAccount:
		m.ResetCostAccount()
		return nil
	case costbill.EdgeRechargeOrder:
		m.ResetRechargeOrder()
		return nil
	case costbill.EdgeMissionConsumeOrder:
		m.ResetMissionConsumeOrder()
		return nil
	case costbill.EdgePlatformAccount:
		m.ResetPlatformAccount()
		return nil
	case costbill.EdgeCampaignOrder:
		m.ResetCampaignOrder()
		return nil
	}
	return fmt.Errorf("unknown CostBill edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int64
	created_by                      *int64
	addcreated_by                   *int64
	updated_by                      *int64
	addupdated_by                   *int64
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	serial_number                   *string
	state                           *device.State
	sum_cep                         *int64
	addsum_cep                      *int64
	linking                         *bool
	binding_status                  *enums.DeviceBindingStatus
	status                          *enums.DeviceStatus
	name                            *string
	manage_name                     *string
	_type                           *enums.DeviceType
	cores_number                    *int64
	addcores_number                 *int64
	cpu                             *string
	cpus                            *[]string
	memory                          *int64
	addmemory                       *int64
	disk                            *float32
	adddisk                         *float32
	delay                           *float64
	adddelay                        *float64
	gpu_temperature                 *float64
	addgpu_temperature              *float64
	cpu_temperature                 *float64
	addcpu_temperature              *float64
	stability                       *enums.DeviceStabilityType
	version                         *string
	fault                           *enums.DeviceFaultType
	rank                            *enums.DeviceRankType
	free_gpu_num                    *int
	addfree_gpu_num                 *int
	rank_at                         *time.Time
	stability_at                    *time.Time
	high_temperature_at             *time.Time
	hosting_type                    *enums.DeviceHostingType
	clearedFields                   map[string]struct{}
	user                            *int64
	cleareduser                     bool
	gift_mission_config             *int64
	clearedgift_mission_config      bool
	mission_produce_orders          map[int64]struct{}
	removedmission_produce_orders   map[int64]struct{}
	clearedmission_produce_orders   bool
	user_devices                    map[int64]struct{}
	removeduser_devices             map[int64]struct{}
	cleareduser_devices             bool
	device_gpu_missions             map[int64]struct{}
	removeddevice_gpu_missions      map[int64]struct{}
	cleareddevice_gpu_missions      bool
	frpc_infos                      map[int64]struct{}
	removedfrpc_infos               map[int64]struct{}
	clearedfrpc_infos               bool
	mission_orders                  map[int64]struct{}
	removedmission_orders           map[int64]struct{}
	clearedmission_orders           bool
	mission_productions             map[int64]struct{}
	removedmission_productions      map[int64]struct{}
	clearedmission_productions      bool
	device_reboot_times             map[int64]struct{}
	removeddevice_reboot_times      map[int64]struct{}
	cleareddevice_reboot_times      bool
	trouble_deducts                 map[int64]struct{}
	removedtrouble_deducts          map[int64]struct{}
	clearedtrouble_deducts          bool
	device_states                   map[int64]struct{}
	removeddevice_states            map[int64]struct{}
	cleareddevice_states            bool
	device_offline_records          map[int64]struct{}
	removeddevice_offline_records   map[int64]struct{}
	cleareddevice_offline_records   bool
	mission_failed_feedbacks        map[int64]struct{}
	removedmission_failed_feedbacks map[int64]struct{}
	clearedmission_failed_feedbacks bool
	done                            bool
	oldValue                        func(context.Context) (*Device, error)
	predicates                      []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int64) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeviceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeviceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeviceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeviceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *DeviceMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceMutation) ResetUserID() {
	m.user = nil
}

// SetGiftMissionConfigID sets the "gift_mission_config_id" field.
func (m *DeviceMutation) SetGiftMissionConfigID(i int64) {
	m.gift_mission_config = &i
}

// GiftMissionConfigID returns the value of the "gift_mission_config_id" field in the mutation.
func (m *DeviceMutation) GiftMissionConfigID() (r int64, exists bool) {
	v := m.gift_mission_config
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftMissionConfigID returns the old "gift_mission_config_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldGiftMissionConfigID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftMissionConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftMissionConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftMissionConfigID: %w", err)
	}
	return oldValue.GiftMissionConfigID, nil
}

// ResetGiftMissionConfigID resets all changes to the "gift_mission_config_id" field.
func (m *DeviceMutation) ResetGiftMissionConfigID() {
	m.gift_mission_config = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *DeviceMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *DeviceMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *DeviceMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetState sets the "state" field.
func (m *DeviceMutation) SetState(d device.State) {
	m.state = &d
}

// State returns the value of the "state" field in the mutation.
func (m *DeviceMutation) State() (r device.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldState(ctx context.Context) (v device.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *DeviceMutation) ResetState() {
	m.state = nil
}

// SetSumCep sets the "sum_cep" field.
func (m *DeviceMutation) SetSumCep(i int64) {
	m.sum_cep = &i
	m.addsum_cep = nil
}

// SumCep returns the value of the "sum_cep" field in the mutation.
func (m *DeviceMutation) SumCep() (r int64, exists bool) {
	v := m.sum_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumCep returns the old "sum_cep" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSumCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumCep: %w", err)
	}
	return oldValue.SumCep, nil
}

// AddSumCep adds i to the "sum_cep" field.
func (m *DeviceMutation) AddSumCep(i int64) {
	if m.addsum_cep != nil {
		*m.addsum_cep += i
	} else {
		m.addsum_cep = &i
	}
}

// AddedSumCep returns the value that was added to the "sum_cep" field in this mutation.
func (m *DeviceMutation) AddedSumCep() (r int64, exists bool) {
	v := m.addsum_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumCep resets all changes to the "sum_cep" field.
func (m *DeviceMutation) ResetSumCep() {
	m.sum_cep = nil
	m.addsum_cep = nil
}

// SetLinking sets the "linking" field.
func (m *DeviceMutation) SetLinking(b bool) {
	m.linking = &b
}

// Linking returns the value of the "linking" field in the mutation.
func (m *DeviceMutation) Linking() (r bool, exists bool) {
	v := m.linking
	if v == nil {
		return
	}
	return *v, true
}

// OldLinking returns the old "linking" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldLinking(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinking: %w", err)
	}
	return oldValue.Linking, nil
}

// ResetLinking resets all changes to the "linking" field.
func (m *DeviceMutation) ResetLinking() {
	m.linking = nil
}

// SetBindingStatus sets the "binding_status" field.
func (m *DeviceMutation) SetBindingStatus(ebs enums.DeviceBindingStatus) {
	m.binding_status = &ebs
}

// BindingStatus returns the value of the "binding_status" field in the mutation.
func (m *DeviceMutation) BindingStatus() (r enums.DeviceBindingStatus, exists bool) {
	v := m.binding_status
	if v == nil {
		return
	}
	return *v, true
}

// OldBindingStatus returns the old "binding_status" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldBindingStatus(ctx context.Context) (v enums.DeviceBindingStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindingStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindingStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindingStatus: %w", err)
	}
	return oldValue.BindingStatus, nil
}

// ResetBindingStatus resets all changes to the "binding_status" field.
func (m *DeviceMutation) ResetBindingStatus() {
	m.binding_status = nil
}

// SetStatus sets the "status" field.
func (m *DeviceMutation) SetStatus(es enums.DeviceStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *DeviceMutation) Status() (r enums.DeviceStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldStatus(ctx context.Context) (v enums.DeviceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DeviceMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *DeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeviceMutation) ResetName() {
	m.name = nil
}

// SetManageName sets the "manage_name" field.
func (m *DeviceMutation) SetManageName(s string) {
	m.manage_name = &s
}

// ManageName returns the value of the "manage_name" field in the mutation.
func (m *DeviceMutation) ManageName() (r string, exists bool) {
	v := m.manage_name
	if v == nil {
		return
	}
	return *v, true
}

// OldManageName returns the old "manage_name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldManageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManageName: %w", err)
	}
	return oldValue.ManageName, nil
}

// ResetManageName resets all changes to the "manage_name" field.
func (m *DeviceMutation) ResetManageName() {
	m.manage_name = nil
}

// SetType sets the "type" field.
func (m *DeviceMutation) SetType(et enums.DeviceType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceMutation) GetType() (r enums.DeviceType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldType(ctx context.Context) (v enums.DeviceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DeviceMutation) ResetType() {
	m._type = nil
}

// SetCoresNumber sets the "cores_number" field.
func (m *DeviceMutation) SetCoresNumber(i int64) {
	m.cores_number = &i
	m.addcores_number = nil
}

// CoresNumber returns the value of the "cores_number" field in the mutation.
func (m *DeviceMutation) CoresNumber() (r int64, exists bool) {
	v := m.cores_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCoresNumber returns the old "cores_number" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCoresNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoresNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoresNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoresNumber: %w", err)
	}
	return oldValue.CoresNumber, nil
}

// AddCoresNumber adds i to the "cores_number" field.
func (m *DeviceMutation) AddCoresNumber(i int64) {
	if m.addcores_number != nil {
		*m.addcores_number += i
	} else {
		m.addcores_number = &i
	}
}

// AddedCoresNumber returns the value that was added to the "cores_number" field in this mutation.
func (m *DeviceMutation) AddedCoresNumber() (r int64, exists bool) {
	v := m.addcores_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoresNumber resets all changes to the "cores_number" field.
func (m *DeviceMutation) ResetCoresNumber() {
	m.cores_number = nil
	m.addcores_number = nil
}

// SetCPU sets the "cpu" field.
func (m *DeviceMutation) SetCPU(s string) {
	m.cpu = &s
}

// CPU returns the value of the "cpu" field in the mutation.
func (m *DeviceMutation) CPU() (r string, exists bool) {
	v := m.cpu
	if v == nil {
		return
	}
	return *v, true
}

// OldCPU returns the old "cpu" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCPU(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPU: %w", err)
	}
	return oldValue.CPU, nil
}

// ResetCPU resets all changes to the "cpu" field.
func (m *DeviceMutation) ResetCPU() {
	m.cpu = nil
}

// SetCpus sets the "cpus" field.
func (m *DeviceMutation) SetCpus(s []string) {
	m.cpus = &s
}

// Cpus returns the value of the "cpus" field in the mutation.
func (m *DeviceMutation) Cpus() (r []string, exists bool) {
	v := m.cpus
	if v == nil {
		return
	}
	return *v, true
}

// OldCpus returns the old "cpus" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCpus(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCpus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCpus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCpus: %w", err)
	}
	return oldValue.Cpus, nil
}

// ClearCpus clears the value of the "cpus" field.
func (m *DeviceMutation) ClearCpus() {
	m.cpus = nil
	m.clearedFields[device.FieldCpus] = struct{}{}
}

// CpusCleared returns if the "cpus" field was cleared in this mutation.
func (m *DeviceMutation) CpusCleared() bool {
	_, ok := m.clearedFields[device.FieldCpus]
	return ok
}

// ResetCpus resets all changes to the "cpus" field.
func (m *DeviceMutation) ResetCpus() {
	m.cpus = nil
	delete(m.clearedFields, device.FieldCpus)
}

// SetMemory sets the "memory" field.
func (m *DeviceMutation) SetMemory(i int64) {
	m.memory = &i
	m.addmemory = nil
}

// Memory returns the value of the "memory" field in the mutation.
func (m *DeviceMutation) Memory() (r int64, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldMemory(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// AddMemory adds i to the "memory" field.
func (m *DeviceMutation) AddMemory(i int64) {
	if m.addmemory != nil {
		*m.addmemory += i
	} else {
		m.addmemory = &i
	}
}

// AddedMemory returns the value that was added to the "memory" field in this mutation.
func (m *DeviceMutation) AddedMemory() (r int64, exists bool) {
	v := m.addmemory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemory resets all changes to the "memory" field.
func (m *DeviceMutation) ResetMemory() {
	m.memory = nil
	m.addmemory = nil
}

// SetDisk sets the "disk" field.
func (m *DeviceMutation) SetDisk(f float32) {
	m.disk = &f
	m.adddisk = nil
}

// Disk returns the value of the "disk" field in the mutation.
func (m *DeviceMutation) Disk() (r float32, exists bool) {
	v := m.disk
	if v == nil {
		return
	}
	return *v, true
}

// OldDisk returns the old "disk" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDisk(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisk: %w", err)
	}
	return oldValue.Disk, nil
}

// AddDisk adds f to the "disk" field.
func (m *DeviceMutation) AddDisk(f float32) {
	if m.adddisk != nil {
		*m.adddisk += f
	} else {
		m.adddisk = &f
	}
}

// AddedDisk returns the value that was added to the "disk" field in this mutation.
func (m *DeviceMutation) AddedDisk() (r float32, exists bool) {
	v := m.adddisk
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisk resets all changes to the "disk" field.
func (m *DeviceMutation) ResetDisk() {
	m.disk = nil
	m.adddisk = nil
}

// SetDelay sets the "delay" field.
func (m *DeviceMutation) SetDelay(f float64) {
	m.delay = &f
	m.adddelay = nil
}

// Delay returns the value of the "delay" field in the mutation.
func (m *DeviceMutation) Delay() (r float64, exists bool) {
	v := m.delay
	if v == nil {
		return
	}
	return *v, true
}

// OldDelay returns the old "delay" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDelay(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelay: %w", err)
	}
	return oldValue.Delay, nil
}

// AddDelay adds f to the "delay" field.
func (m *DeviceMutation) AddDelay(f float64) {
	if m.adddelay != nil {
		*m.adddelay += f
	} else {
		m.adddelay = &f
	}
}

// AddedDelay returns the value that was added to the "delay" field in this mutation.
func (m *DeviceMutation) AddedDelay() (r float64, exists bool) {
	v := m.adddelay
	if v == nil {
		return
	}
	return *v, true
}

// ResetDelay resets all changes to the "delay" field.
func (m *DeviceMutation) ResetDelay() {
	m.delay = nil
	m.adddelay = nil
}

// SetGpuTemperature sets the "gpu_temperature" field.
func (m *DeviceMutation) SetGpuTemperature(f float64) {
	m.gpu_temperature = &f
	m.addgpu_temperature = nil
}

// GpuTemperature returns the value of the "gpu_temperature" field in the mutation.
func (m *DeviceMutation) GpuTemperature() (r float64, exists bool) {
	v := m.gpu_temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuTemperature returns the old "gpu_temperature" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldGpuTemperature(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuTemperature: %w", err)
	}
	return oldValue.GpuTemperature, nil
}

// AddGpuTemperature adds f to the "gpu_temperature" field.
func (m *DeviceMutation) AddGpuTemperature(f float64) {
	if m.addgpu_temperature != nil {
		*m.addgpu_temperature += f
	} else {
		m.addgpu_temperature = &f
	}
}

// AddedGpuTemperature returns the value that was added to the "gpu_temperature" field in this mutation.
func (m *DeviceMutation) AddedGpuTemperature() (r float64, exists bool) {
	v := m.addgpu_temperature
	if v == nil {
		return
	}
	return *v, true
}

// ResetGpuTemperature resets all changes to the "gpu_temperature" field.
func (m *DeviceMutation) ResetGpuTemperature() {
	m.gpu_temperature = nil
	m.addgpu_temperature = nil
}

// SetCPUTemperature sets the "cpu_temperature" field.
func (m *DeviceMutation) SetCPUTemperature(f float64) {
	m.cpu_temperature = &f
	m.addcpu_temperature = nil
}

// CPUTemperature returns the value of the "cpu_temperature" field in the mutation.
func (m *DeviceMutation) CPUTemperature() (r float64, exists bool) {
	v := m.cpu_temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUTemperature returns the old "cpu_temperature" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCPUTemperature(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUTemperature: %w", err)
	}
	return oldValue.CPUTemperature, nil
}

// AddCPUTemperature adds f to the "cpu_temperature" field.
func (m *DeviceMutation) AddCPUTemperature(f float64) {
	if m.addcpu_temperature != nil {
		*m.addcpu_temperature += f
	} else {
		m.addcpu_temperature = &f
	}
}

// AddedCPUTemperature returns the value that was added to the "cpu_temperature" field in this mutation.
func (m *DeviceMutation) AddedCPUTemperature() (r float64, exists bool) {
	v := m.addcpu_temperature
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUTemperature resets all changes to the "cpu_temperature" field.
func (m *DeviceMutation) ResetCPUTemperature() {
	m.cpu_temperature = nil
	m.addcpu_temperature = nil
}

// SetStability sets the "stability" field.
func (m *DeviceMutation) SetStability(est enums.DeviceStabilityType) {
	m.stability = &est
}

// Stability returns the value of the "stability" field in the mutation.
func (m *DeviceMutation) Stability() (r enums.DeviceStabilityType, exists bool) {
	v := m.stability
	if v == nil {
		return
	}
	return *v, true
}

// OldStability returns the old "stability" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldStability(ctx context.Context) (v enums.DeviceStabilityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStability: %w", err)
	}
	return oldValue.Stability, nil
}

// ResetStability resets all changes to the "stability" field.
func (m *DeviceMutation) ResetStability() {
	m.stability = nil
}

// SetVersion sets the "version" field.
func (m *DeviceMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *DeviceMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *DeviceMutation) ResetVersion() {
	m.version = nil
}

// SetFault sets the "fault" field.
func (m *DeviceMutation) SetFault(eft enums.DeviceFaultType) {
	m.fault = &eft
}

// Fault returns the value of the "fault" field in the mutation.
func (m *DeviceMutation) Fault() (r enums.DeviceFaultType, exists bool) {
	v := m.fault
	if v == nil {
		return
	}
	return *v, true
}

// OldFault returns the old "fault" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldFault(ctx context.Context) (v enums.DeviceFaultType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFault: %w", err)
	}
	return oldValue.Fault, nil
}

// ResetFault resets all changes to the "fault" field.
func (m *DeviceMutation) ResetFault() {
	m.fault = nil
}

// SetRank sets the "rank" field.
func (m *DeviceMutation) SetRank(ert enums.DeviceRankType) {
	m.rank = &ert
}

// Rank returns the value of the "rank" field in the mutation.
func (m *DeviceMutation) Rank() (r enums.DeviceRankType, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldRank(ctx context.Context) (v enums.DeviceRankType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// ResetRank resets all changes to the "rank" field.
func (m *DeviceMutation) ResetRank() {
	m.rank = nil
}

// SetFreeGpuNum sets the "free_gpu_num" field.
func (m *DeviceMutation) SetFreeGpuNum(i int) {
	m.free_gpu_num = &i
	m.addfree_gpu_num = nil
}

// FreeGpuNum returns the value of the "free_gpu_num" field in the mutation.
func (m *DeviceMutation) FreeGpuNum() (r int, exists bool) {
	v := m.free_gpu_num
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeGpuNum returns the old "free_gpu_num" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldFreeGpuNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeGpuNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeGpuNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeGpuNum: %w", err)
	}
	return oldValue.FreeGpuNum, nil
}

// AddFreeGpuNum adds i to the "free_gpu_num" field.
func (m *DeviceMutation) AddFreeGpuNum(i int) {
	if m.addfree_gpu_num != nil {
		*m.addfree_gpu_num += i
	} else {
		m.addfree_gpu_num = &i
	}
}

// AddedFreeGpuNum returns the value that was added to the "free_gpu_num" field in this mutation.
func (m *DeviceMutation) AddedFreeGpuNum() (r int, exists bool) {
	v := m.addfree_gpu_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreeGpuNum resets all changes to the "free_gpu_num" field.
func (m *DeviceMutation) ResetFreeGpuNum() {
	m.free_gpu_num = nil
	m.addfree_gpu_num = nil
}

// SetRankAt sets the "rank_at" field.
func (m *DeviceMutation) SetRankAt(t time.Time) {
	m.rank_at = &t
}

// RankAt returns the value of the "rank_at" field in the mutation.
func (m *DeviceMutation) RankAt() (r time.Time, exists bool) {
	v := m.rank_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRankAt returns the old "rank_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldRankAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRankAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRankAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRankAt: %w", err)
	}
	return oldValue.RankAt, nil
}

// ClearRankAt clears the value of the "rank_at" field.
func (m *DeviceMutation) ClearRankAt() {
	m.rank_at = nil
	m.clearedFields[device.FieldRankAt] = struct{}{}
}

// RankAtCleared returns if the "rank_at" field was cleared in this mutation.
func (m *DeviceMutation) RankAtCleared() bool {
	_, ok := m.clearedFields[device.FieldRankAt]
	return ok
}

// ResetRankAt resets all changes to the "rank_at" field.
func (m *DeviceMutation) ResetRankAt() {
	m.rank_at = nil
	delete(m.clearedFields, device.FieldRankAt)
}

// SetStabilityAt sets the "stability_at" field.
func (m *DeviceMutation) SetStabilityAt(t time.Time) {
	m.stability_at = &t
}

// StabilityAt returns the value of the "stability_at" field in the mutation.
func (m *DeviceMutation) StabilityAt() (r time.Time, exists bool) {
	v := m.stability_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStabilityAt returns the old "stability_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldStabilityAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStabilityAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStabilityAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStabilityAt: %w", err)
	}
	return oldValue.StabilityAt, nil
}

// ClearStabilityAt clears the value of the "stability_at" field.
func (m *DeviceMutation) ClearStabilityAt() {
	m.stability_at = nil
	m.clearedFields[device.FieldStabilityAt] = struct{}{}
}

// StabilityAtCleared returns if the "stability_at" field was cleared in this mutation.
func (m *DeviceMutation) StabilityAtCleared() bool {
	_, ok := m.clearedFields[device.FieldStabilityAt]
	return ok
}

// ResetStabilityAt resets all changes to the "stability_at" field.
func (m *DeviceMutation) ResetStabilityAt() {
	m.stability_at = nil
	delete(m.clearedFields, device.FieldStabilityAt)
}

// SetHighTemperatureAt sets the "high_temperature_at" field.
func (m *DeviceMutation) SetHighTemperatureAt(t time.Time) {
	m.high_temperature_at = &t
}

// HighTemperatureAt returns the value of the "high_temperature_at" field in the mutation.
func (m *DeviceMutation) HighTemperatureAt() (r time.Time, exists bool) {
	v := m.high_temperature_at
	if v == nil {
		return
	}
	return *v, true
}

// OldHighTemperatureAt returns the old "high_temperature_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldHighTemperatureAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighTemperatureAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighTemperatureAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighTemperatureAt: %w", err)
	}
	return oldValue.HighTemperatureAt, nil
}

// ClearHighTemperatureAt clears the value of the "high_temperature_at" field.
func (m *DeviceMutation) ClearHighTemperatureAt() {
	m.high_temperature_at = nil
	m.clearedFields[device.FieldHighTemperatureAt] = struct{}{}
}

// HighTemperatureAtCleared returns if the "high_temperature_at" field was cleared in this mutation.
func (m *DeviceMutation) HighTemperatureAtCleared() bool {
	_, ok := m.clearedFields[device.FieldHighTemperatureAt]
	return ok
}

// ResetHighTemperatureAt resets all changes to the "high_temperature_at" field.
func (m *DeviceMutation) ResetHighTemperatureAt() {
	m.high_temperature_at = nil
	delete(m.clearedFields, device.FieldHighTemperatureAt)
}

// SetHostingType sets the "hosting_type" field.
func (m *DeviceMutation) SetHostingType(eht enums.DeviceHostingType) {
	m.hosting_type = &eht
}

// HostingType returns the value of the "hosting_type" field in the mutation.
func (m *DeviceMutation) HostingType() (r enums.DeviceHostingType, exists bool) {
	v := m.hosting_type
	if v == nil {
		return
	}
	return *v, true
}

// OldHostingType returns the old "hosting_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldHostingType(ctx context.Context) (v enums.DeviceHostingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostingType: %w", err)
	}
	return oldValue.HostingType, nil
}

// ResetHostingType resets all changes to the "hosting_type" field.
func (m *DeviceMutation) ResetHostingType() {
	m.hosting_type = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[device.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGiftMissionConfig clears the "gift_mission_config" edge to the GiftMissionConfig entity.
func (m *DeviceMutation) ClearGiftMissionConfig() {
	m.clearedgift_mission_config = true
	m.clearedFields[device.FieldGiftMissionConfigID] = struct{}{}
}

// GiftMissionConfigCleared reports if the "gift_mission_config" edge to the GiftMissionConfig entity was cleared.
func (m *DeviceMutation) GiftMissionConfigCleared() bool {
	return m.clearedgift_mission_config
}

// GiftMissionConfigIDs returns the "gift_mission_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GiftMissionConfigID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) GiftMissionConfigIDs() (ids []int64) {
	if id := m.gift_mission_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGiftMissionConfig resets all changes to the "gift_mission_config" edge.
func (m *DeviceMutation) ResetGiftMissionConfig() {
	m.gift_mission_config = nil
	m.clearedgift_mission_config = false
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *DeviceMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *DeviceMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *DeviceMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *DeviceMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *DeviceMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *DeviceMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *DeviceMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// AddUserDeviceIDs adds the "user_devices" edge to the UserDevice entity by ids.
func (m *DeviceMutation) AddUserDeviceIDs(ids ...int64) {
	if m.user_devices == nil {
		m.user_devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_devices[ids[i]] = struct{}{}
	}
}

// ClearUserDevices clears the "user_devices" edge to the UserDevice entity.
func (m *DeviceMutation) ClearUserDevices() {
	m.cleareduser_devices = true
}

// UserDevicesCleared reports if the "user_devices" edge to the UserDevice entity was cleared.
func (m *DeviceMutation) UserDevicesCleared() bool {
	return m.cleareduser_devices
}

// RemoveUserDeviceIDs removes the "user_devices" edge to the UserDevice entity by IDs.
func (m *DeviceMutation) RemoveUserDeviceIDs(ids ...int64) {
	if m.removeduser_devices == nil {
		m.removeduser_devices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_devices, ids[i])
		m.removeduser_devices[ids[i]] = struct{}{}
	}
}

// RemovedUserDevices returns the removed IDs of the "user_devices" edge to the UserDevice entity.
func (m *DeviceMutation) RemovedUserDevicesIDs() (ids []int64) {
	for id := range m.removeduser_devices {
		ids = append(ids, id)
	}
	return
}

// UserDevicesIDs returns the "user_devices" edge IDs in the mutation.
func (m *DeviceMutation) UserDevicesIDs() (ids []int64) {
	for id := range m.user_devices {
		ids = append(ids, id)
	}
	return
}

// ResetUserDevices resets all changes to the "user_devices" edge.
func (m *DeviceMutation) ResetUserDevices() {
	m.user_devices = nil
	m.cleareduser_devices = false
	m.removeduser_devices = nil
}

// AddDeviceGpuMissionIDs adds the "device_gpu_missions" edge to the DeviceGpuMission entity by ids.
func (m *DeviceMutation) AddDeviceGpuMissionIDs(ids ...int64) {
	if m.device_gpu_missions == nil {
		m.device_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_gpu_missions[ids[i]] = struct{}{}
	}
}

// ClearDeviceGpuMissions clears the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *DeviceMutation) ClearDeviceGpuMissions() {
	m.cleareddevice_gpu_missions = true
}

// DeviceGpuMissionsCleared reports if the "device_gpu_missions" edge to the DeviceGpuMission entity was cleared.
func (m *DeviceMutation) DeviceGpuMissionsCleared() bool {
	return m.cleareddevice_gpu_missions
}

// RemoveDeviceGpuMissionIDs removes the "device_gpu_missions" edge to the DeviceGpuMission entity by IDs.
func (m *DeviceMutation) RemoveDeviceGpuMissionIDs(ids ...int64) {
	if m.removeddevice_gpu_missions == nil {
		m.removeddevice_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_gpu_missions, ids[i])
		m.removeddevice_gpu_missions[ids[i]] = struct{}{}
	}
}

// RemovedDeviceGpuMissions returns the removed IDs of the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *DeviceMutation) RemovedDeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.removeddevice_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// DeviceGpuMissionsIDs returns the "device_gpu_missions" edge IDs in the mutation.
func (m *DeviceMutation) DeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.device_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceGpuMissions resets all changes to the "device_gpu_missions" edge.
func (m *DeviceMutation) ResetDeviceGpuMissions() {
	m.device_gpu_missions = nil
	m.cleareddevice_gpu_missions = false
	m.removeddevice_gpu_missions = nil
}

// AddFrpcInfoIDs adds the "frpc_infos" edge to the FrpcInfo entity by ids.
func (m *DeviceMutation) AddFrpcInfoIDs(ids ...int64) {
	if m.frpc_infos == nil {
		m.frpc_infos = make(map[int64]struct{})
	}
	for i := range ids {
		m.frpc_infos[ids[i]] = struct{}{}
	}
}

// ClearFrpcInfos clears the "frpc_infos" edge to the FrpcInfo entity.
func (m *DeviceMutation) ClearFrpcInfos() {
	m.clearedfrpc_infos = true
}

// FrpcInfosCleared reports if the "frpc_infos" edge to the FrpcInfo entity was cleared.
func (m *DeviceMutation) FrpcInfosCleared() bool {
	return m.clearedfrpc_infos
}

// RemoveFrpcInfoIDs removes the "frpc_infos" edge to the FrpcInfo entity by IDs.
func (m *DeviceMutation) RemoveFrpcInfoIDs(ids ...int64) {
	if m.removedfrpc_infos == nil {
		m.removedfrpc_infos = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.frpc_infos, ids[i])
		m.removedfrpc_infos[ids[i]] = struct{}{}
	}
}

// RemovedFrpcInfos returns the removed IDs of the "frpc_infos" edge to the FrpcInfo entity.
func (m *DeviceMutation) RemovedFrpcInfosIDs() (ids []int64) {
	for id := range m.removedfrpc_infos {
		ids = append(ids, id)
	}
	return
}

// FrpcInfosIDs returns the "frpc_infos" edge IDs in the mutation.
func (m *DeviceMutation) FrpcInfosIDs() (ids []int64) {
	for id := range m.frpc_infos {
		ids = append(ids, id)
	}
	return
}

// ResetFrpcInfos resets all changes to the "frpc_infos" edge.
func (m *DeviceMutation) ResetFrpcInfos() {
	m.frpc_infos = nil
	m.clearedfrpc_infos = false
	m.removedfrpc_infos = nil
}

// AddMissionOrderIDs adds the "mission_orders" edge to the MissionOrder entity by ids.
func (m *DeviceMutation) AddMissionOrderIDs(ids ...int64) {
	if m.mission_orders == nil {
		m.mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionOrders clears the "mission_orders" edge to the MissionOrder entity.
func (m *DeviceMutation) ClearMissionOrders() {
	m.clearedmission_orders = true
}

// MissionOrdersCleared reports if the "mission_orders" edge to the MissionOrder entity was cleared.
func (m *DeviceMutation) MissionOrdersCleared() bool {
	return m.clearedmission_orders
}

// RemoveMissionOrderIDs removes the "mission_orders" edge to the MissionOrder entity by IDs.
func (m *DeviceMutation) RemoveMissionOrderIDs(ids ...int64) {
	if m.removedmission_orders == nil {
		m.removedmission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_orders, ids[i])
		m.removedmission_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionOrders returns the removed IDs of the "mission_orders" edge to the MissionOrder entity.
func (m *DeviceMutation) RemovedMissionOrdersIDs() (ids []int64) {
	for id := range m.removedmission_orders {
		ids = append(ids, id)
	}
	return
}

// MissionOrdersIDs returns the "mission_orders" edge IDs in the mutation.
func (m *DeviceMutation) MissionOrdersIDs() (ids []int64) {
	for id := range m.mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionOrders resets all changes to the "mission_orders" edge.
func (m *DeviceMutation) ResetMissionOrders() {
	m.mission_orders = nil
	m.clearedmission_orders = false
	m.removedmission_orders = nil
}

// AddMissionProductionIDs adds the "mission_productions" edge to the MissionProduction entity by ids.
func (m *DeviceMutation) AddMissionProductionIDs(ids ...int64) {
	if m.mission_productions == nil {
		m.mission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_productions[ids[i]] = struct{}{}
	}
}

// ClearMissionProductions clears the "mission_productions" edge to the MissionProduction entity.
func (m *DeviceMutation) ClearMissionProductions() {
	m.clearedmission_productions = true
}

// MissionProductionsCleared reports if the "mission_productions" edge to the MissionProduction entity was cleared.
func (m *DeviceMutation) MissionProductionsCleared() bool {
	return m.clearedmission_productions
}

// RemoveMissionProductionIDs removes the "mission_productions" edge to the MissionProduction entity by IDs.
func (m *DeviceMutation) RemoveMissionProductionIDs(ids ...int64) {
	if m.removedmission_productions == nil {
		m.removedmission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_productions, ids[i])
		m.removedmission_productions[ids[i]] = struct{}{}
	}
}

// RemovedMissionProductions returns the removed IDs of the "mission_productions" edge to the MissionProduction entity.
func (m *DeviceMutation) RemovedMissionProductionsIDs() (ids []int64) {
	for id := range m.removedmission_productions {
		ids = append(ids, id)
	}
	return
}

// MissionProductionsIDs returns the "mission_productions" edge IDs in the mutation.
func (m *DeviceMutation) MissionProductionsIDs() (ids []int64) {
	for id := range m.mission_productions {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProductions resets all changes to the "mission_productions" edge.
func (m *DeviceMutation) ResetMissionProductions() {
	m.mission_productions = nil
	m.clearedmission_productions = false
	m.removedmission_productions = nil
}

// AddDeviceRebootTimeIDs adds the "device_reboot_times" edge to the DeviceRebootTime entity by ids.
func (m *DeviceMutation) AddDeviceRebootTimeIDs(ids ...int64) {
	if m.device_reboot_times == nil {
		m.device_reboot_times = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_reboot_times[ids[i]] = struct{}{}
	}
}

// ClearDeviceRebootTimes clears the "device_reboot_times" edge to the DeviceRebootTime entity.
func (m *DeviceMutation) ClearDeviceRebootTimes() {
	m.cleareddevice_reboot_times = true
}

// DeviceRebootTimesCleared reports if the "device_reboot_times" edge to the DeviceRebootTime entity was cleared.
func (m *DeviceMutation) DeviceRebootTimesCleared() bool {
	return m.cleareddevice_reboot_times
}

// RemoveDeviceRebootTimeIDs removes the "device_reboot_times" edge to the DeviceRebootTime entity by IDs.
func (m *DeviceMutation) RemoveDeviceRebootTimeIDs(ids ...int64) {
	if m.removeddevice_reboot_times == nil {
		m.removeddevice_reboot_times = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_reboot_times, ids[i])
		m.removeddevice_reboot_times[ids[i]] = struct{}{}
	}
}

// RemovedDeviceRebootTimes returns the removed IDs of the "device_reboot_times" edge to the DeviceRebootTime entity.
func (m *DeviceMutation) RemovedDeviceRebootTimesIDs() (ids []int64) {
	for id := range m.removeddevice_reboot_times {
		ids = append(ids, id)
	}
	return
}

// DeviceRebootTimesIDs returns the "device_reboot_times" edge IDs in the mutation.
func (m *DeviceMutation) DeviceRebootTimesIDs() (ids []int64) {
	for id := range m.device_reboot_times {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceRebootTimes resets all changes to the "device_reboot_times" edge.
func (m *DeviceMutation) ResetDeviceRebootTimes() {
	m.device_reboot_times = nil
	m.cleareddevice_reboot_times = false
	m.removeddevice_reboot_times = nil
}

// AddTroubleDeductIDs adds the "trouble_deducts" edge to the TroubleDeduct entity by ids.
func (m *DeviceMutation) AddTroubleDeductIDs(ids ...int64) {
	if m.trouble_deducts == nil {
		m.trouble_deducts = make(map[int64]struct{})
	}
	for i := range ids {
		m.trouble_deducts[ids[i]] = struct{}{}
	}
}

// ClearTroubleDeducts clears the "trouble_deducts" edge to the TroubleDeduct entity.
func (m *DeviceMutation) ClearTroubleDeducts() {
	m.clearedtrouble_deducts = true
}

// TroubleDeductsCleared reports if the "trouble_deducts" edge to the TroubleDeduct entity was cleared.
func (m *DeviceMutation) TroubleDeductsCleared() bool {
	return m.clearedtrouble_deducts
}

// RemoveTroubleDeductIDs removes the "trouble_deducts" edge to the TroubleDeduct entity by IDs.
func (m *DeviceMutation) RemoveTroubleDeductIDs(ids ...int64) {
	if m.removedtrouble_deducts == nil {
		m.removedtrouble_deducts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.trouble_deducts, ids[i])
		m.removedtrouble_deducts[ids[i]] = struct{}{}
	}
}

// RemovedTroubleDeducts returns the removed IDs of the "trouble_deducts" edge to the TroubleDeduct entity.
func (m *DeviceMutation) RemovedTroubleDeductsIDs() (ids []int64) {
	for id := range m.removedtrouble_deducts {
		ids = append(ids, id)
	}
	return
}

// TroubleDeductsIDs returns the "trouble_deducts" edge IDs in the mutation.
func (m *DeviceMutation) TroubleDeductsIDs() (ids []int64) {
	for id := range m.trouble_deducts {
		ids = append(ids, id)
	}
	return
}

// ResetTroubleDeducts resets all changes to the "trouble_deducts" edge.
func (m *DeviceMutation) ResetTroubleDeducts() {
	m.trouble_deducts = nil
	m.clearedtrouble_deducts = false
	m.removedtrouble_deducts = nil
}

// AddDeviceStateIDs adds the "device_states" edge to the DeviceState entity by ids.
func (m *DeviceMutation) AddDeviceStateIDs(ids ...int64) {
	if m.device_states == nil {
		m.device_states = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_states[ids[i]] = struct{}{}
	}
}

// ClearDeviceStates clears the "device_states" edge to the DeviceState entity.
func (m *DeviceMutation) ClearDeviceStates() {
	m.cleareddevice_states = true
}

// DeviceStatesCleared reports if the "device_states" edge to the DeviceState entity was cleared.
func (m *DeviceMutation) DeviceStatesCleared() bool {
	return m.cleareddevice_states
}

// RemoveDeviceStateIDs removes the "device_states" edge to the DeviceState entity by IDs.
func (m *DeviceMutation) RemoveDeviceStateIDs(ids ...int64) {
	if m.removeddevice_states == nil {
		m.removeddevice_states = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_states, ids[i])
		m.removeddevice_states[ids[i]] = struct{}{}
	}
}

// RemovedDeviceStates returns the removed IDs of the "device_states" edge to the DeviceState entity.
func (m *DeviceMutation) RemovedDeviceStatesIDs() (ids []int64) {
	for id := range m.removeddevice_states {
		ids = append(ids, id)
	}
	return
}

// DeviceStatesIDs returns the "device_states" edge IDs in the mutation.
func (m *DeviceMutation) DeviceStatesIDs() (ids []int64) {
	for id := range m.device_states {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceStates resets all changes to the "device_states" edge.
func (m *DeviceMutation) ResetDeviceStates() {
	m.device_states = nil
	m.cleareddevice_states = false
	m.removeddevice_states = nil
}

// AddDeviceOfflineRecordIDs adds the "device_offline_records" edge to the DeviceOfflineRecord entity by ids.
func (m *DeviceMutation) AddDeviceOfflineRecordIDs(ids ...int64) {
	if m.device_offline_records == nil {
		m.device_offline_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_offline_records[ids[i]] = struct{}{}
	}
}

// ClearDeviceOfflineRecords clears the "device_offline_records" edge to the DeviceOfflineRecord entity.
func (m *DeviceMutation) ClearDeviceOfflineRecords() {
	m.cleareddevice_offline_records = true
}

// DeviceOfflineRecordsCleared reports if the "device_offline_records" edge to the DeviceOfflineRecord entity was cleared.
func (m *DeviceMutation) DeviceOfflineRecordsCleared() bool {
	return m.cleareddevice_offline_records
}

// RemoveDeviceOfflineRecordIDs removes the "device_offline_records" edge to the DeviceOfflineRecord entity by IDs.
func (m *DeviceMutation) RemoveDeviceOfflineRecordIDs(ids ...int64) {
	if m.removeddevice_offline_records == nil {
		m.removeddevice_offline_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_offline_records, ids[i])
		m.removeddevice_offline_records[ids[i]] = struct{}{}
	}
}

// RemovedDeviceOfflineRecords returns the removed IDs of the "device_offline_records" edge to the DeviceOfflineRecord entity.
func (m *DeviceMutation) RemovedDeviceOfflineRecordsIDs() (ids []int64) {
	for id := range m.removeddevice_offline_records {
		ids = append(ids, id)
	}
	return
}

// DeviceOfflineRecordsIDs returns the "device_offline_records" edge IDs in the mutation.
func (m *DeviceMutation) DeviceOfflineRecordsIDs() (ids []int64) {
	for id := range m.device_offline_records {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceOfflineRecords resets all changes to the "device_offline_records" edge.
func (m *DeviceMutation) ResetDeviceOfflineRecords() {
	m.device_offline_records = nil
	m.cleareddevice_offline_records = false
	m.removeddevice_offline_records = nil
}

// AddMissionFailedFeedbackIDs adds the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity by ids.
func (m *DeviceMutation) AddMissionFailedFeedbackIDs(ids ...int64) {
	if m.mission_failed_feedbacks == nil {
		m.mission_failed_feedbacks = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_failed_feedbacks[ids[i]] = struct{}{}
	}
}

// ClearMissionFailedFeedbacks clears the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity.
func (m *DeviceMutation) ClearMissionFailedFeedbacks() {
	m.clearedmission_failed_feedbacks = true
}

// MissionFailedFeedbacksCleared reports if the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity was cleared.
func (m *DeviceMutation) MissionFailedFeedbacksCleared() bool {
	return m.clearedmission_failed_feedbacks
}

// RemoveMissionFailedFeedbackIDs removes the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity by IDs.
func (m *DeviceMutation) RemoveMissionFailedFeedbackIDs(ids ...int64) {
	if m.removedmission_failed_feedbacks == nil {
		m.removedmission_failed_feedbacks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_failed_feedbacks, ids[i])
		m.removedmission_failed_feedbacks[ids[i]] = struct{}{}
	}
}

// RemovedMissionFailedFeedbacks returns the removed IDs of the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity.
func (m *DeviceMutation) RemovedMissionFailedFeedbacksIDs() (ids []int64) {
	for id := range m.removedmission_failed_feedbacks {
		ids = append(ids, id)
	}
	return
}

// MissionFailedFeedbacksIDs returns the "mission_failed_feedbacks" edge IDs in the mutation.
func (m *DeviceMutation) MissionFailedFeedbacksIDs() (ids []int64) {
	for id := range m.mission_failed_feedbacks {
		ids = append(ids, id)
	}
	return
}

// ResetMissionFailedFeedbacks resets all changes to the "mission_failed_feedbacks" edge.
func (m *DeviceMutation) ResetMissionFailedFeedbacks() {
	m.mission_failed_feedbacks = nil
	m.clearedmission_failed_feedbacks = false
	m.removedmission_failed_feedbacks = nil
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m.created_by != nil {
		fields = append(fields, device.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, device.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, device.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, device.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, device.FieldUserID)
	}
	if m.gift_mission_config != nil {
		fields = append(fields, device.FieldGiftMissionConfigID)
	}
	if m.serial_number != nil {
		fields = append(fields, device.FieldSerialNumber)
	}
	if m.state != nil {
		fields = append(fields, device.FieldState)
	}
	if m.sum_cep != nil {
		fields = append(fields, device.FieldSumCep)
	}
	if m.linking != nil {
		fields = append(fields, device.FieldLinking)
	}
	if m.binding_status != nil {
		fields = append(fields, device.FieldBindingStatus)
	}
	if m.status != nil {
		fields = append(fields, device.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, device.FieldName)
	}
	if m.manage_name != nil {
		fields = append(fields, device.FieldManageName)
	}
	if m._type != nil {
		fields = append(fields, device.FieldType)
	}
	if m.cores_number != nil {
		fields = append(fields, device.FieldCoresNumber)
	}
	if m.cpu != nil {
		fields = append(fields, device.FieldCPU)
	}
	if m.cpus != nil {
		fields = append(fields, device.FieldCpus)
	}
	if m.memory != nil {
		fields = append(fields, device.FieldMemory)
	}
	if m.disk != nil {
		fields = append(fields, device.FieldDisk)
	}
	if m.delay != nil {
		fields = append(fields, device.FieldDelay)
	}
	if m.gpu_temperature != nil {
		fields = append(fields, device.FieldGpuTemperature)
	}
	if m.cpu_temperature != nil {
		fields = append(fields, device.FieldCPUTemperature)
	}
	if m.stability != nil {
		fields = append(fields, device.FieldStability)
	}
	if m.version != nil {
		fields = append(fields, device.FieldVersion)
	}
	if m.fault != nil {
		fields = append(fields, device.FieldFault)
	}
	if m.rank != nil {
		fields = append(fields, device.FieldRank)
	}
	if m.free_gpu_num != nil {
		fields = append(fields, device.FieldFreeGpuNum)
	}
	if m.rank_at != nil {
		fields = append(fields, device.FieldRankAt)
	}
	if m.stability_at != nil {
		fields = append(fields, device.FieldStabilityAt)
	}
	if m.high_temperature_at != nil {
		fields = append(fields, device.FieldHighTemperatureAt)
	}
	if m.hosting_type != nil {
		fields = append(fields, device.FieldHostingType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedBy:
		return m.CreatedBy()
	case device.FieldUpdatedBy:
		return m.UpdatedBy()
	case device.FieldCreatedAt:
		return m.CreatedAt()
	case device.FieldUpdatedAt:
		return m.UpdatedAt()
	case device.FieldDeletedAt:
		return m.DeletedAt()
	case device.FieldUserID:
		return m.UserID()
	case device.FieldGiftMissionConfigID:
		return m.GiftMissionConfigID()
	case device.FieldSerialNumber:
		return m.SerialNumber()
	case device.FieldState:
		return m.State()
	case device.FieldSumCep:
		return m.SumCep()
	case device.FieldLinking:
		return m.Linking()
	case device.FieldBindingStatus:
		return m.BindingStatus()
	case device.FieldStatus:
		return m.Status()
	case device.FieldName:
		return m.Name()
	case device.FieldManageName:
		return m.ManageName()
	case device.FieldType:
		return m.GetType()
	case device.FieldCoresNumber:
		return m.CoresNumber()
	case device.FieldCPU:
		return m.CPU()
	case device.FieldCpus:
		return m.Cpus()
	case device.FieldMemory:
		return m.Memory()
	case device.FieldDisk:
		return m.Disk()
	case device.FieldDelay:
		return m.Delay()
	case device.FieldGpuTemperature:
		return m.GpuTemperature()
	case device.FieldCPUTemperature:
		return m.CPUTemperature()
	case device.FieldStability:
		return m.Stability()
	case device.FieldVersion:
		return m.Version()
	case device.FieldFault:
		return m.Fault()
	case device.FieldRank:
		return m.Rank()
	case device.FieldFreeGpuNum:
		return m.FreeGpuNum()
	case device.FieldRankAt:
		return m.RankAt()
	case device.FieldStabilityAt:
		return m.StabilityAt()
	case device.FieldHighTemperatureAt:
		return m.HighTemperatureAt()
	case device.FieldHostingType:
		return m.HostingType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case device.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case device.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case device.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case device.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case device.FieldUserID:
		return m.OldUserID(ctx)
	case device.FieldGiftMissionConfigID:
		return m.OldGiftMissionConfigID(ctx)
	case device.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case device.FieldState:
		return m.OldState(ctx)
	case device.FieldSumCep:
		return m.OldSumCep(ctx)
	case device.FieldLinking:
		return m.OldLinking(ctx)
	case device.FieldBindingStatus:
		return m.OldBindingStatus(ctx)
	case device.FieldStatus:
		return m.OldStatus(ctx)
	case device.FieldName:
		return m.OldName(ctx)
	case device.FieldManageName:
		return m.OldManageName(ctx)
	case device.FieldType:
		return m.OldType(ctx)
	case device.FieldCoresNumber:
		return m.OldCoresNumber(ctx)
	case device.FieldCPU:
		return m.OldCPU(ctx)
	case device.FieldCpus:
		return m.OldCpus(ctx)
	case device.FieldMemory:
		return m.OldMemory(ctx)
	case device.FieldDisk:
		return m.OldDisk(ctx)
	case device.FieldDelay:
		return m.OldDelay(ctx)
	case device.FieldGpuTemperature:
		return m.OldGpuTemperature(ctx)
	case device.FieldCPUTemperature:
		return m.OldCPUTemperature(ctx)
	case device.FieldStability:
		return m.OldStability(ctx)
	case device.FieldVersion:
		return m.OldVersion(ctx)
	case device.FieldFault:
		return m.OldFault(ctx)
	case device.FieldRank:
		return m.OldRank(ctx)
	case device.FieldFreeGpuNum:
		return m.OldFreeGpuNum(ctx)
	case device.FieldRankAt:
		return m.OldRankAt(ctx)
	case device.FieldStabilityAt:
		return m.OldStabilityAt(ctx)
	case device.FieldHighTemperatureAt:
		return m.OldHighTemperatureAt(ctx)
	case device.FieldHostingType:
		return m.OldHostingType(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case device.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case device.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case device.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case device.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case device.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case device.FieldGiftMissionConfigID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftMissionConfigID(v)
		return nil
	case device.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case device.FieldState:
		v, ok := value.(device.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case device.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumCep(v)
		return nil
	case device.FieldLinking:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinking(v)
		return nil
	case device.FieldBindingStatus:
		v, ok := value.(enums.DeviceBindingStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindingStatus(v)
		return nil
	case device.FieldStatus:
		v, ok := value.(enums.DeviceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case device.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case device.FieldManageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManageName(v)
		return nil
	case device.FieldType:
		v, ok := value.(enums.DeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case device.FieldCoresNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoresNumber(v)
		return nil
	case device.FieldCPU:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPU(v)
		return nil
	case device.FieldCpus:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCpus(v)
		return nil
	case device.FieldMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case device.FieldDisk:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisk(v)
		return nil
	case device.FieldDelay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelay(v)
		return nil
	case device.FieldGpuTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuTemperature(v)
		return nil
	case device.FieldCPUTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUTemperature(v)
		return nil
	case device.FieldStability:
		v, ok := value.(enums.DeviceStabilityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStability(v)
		return nil
	case device.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case device.FieldFault:
		v, ok := value.(enums.DeviceFaultType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFault(v)
		return nil
	case device.FieldRank:
		v, ok := value.(enums.DeviceRankType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case device.FieldFreeGpuNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeGpuNum(v)
		return nil
	case device.FieldRankAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRankAt(v)
		return nil
	case device.FieldStabilityAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStabilityAt(v)
		return nil
	case device.FieldHighTemperatureAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighTemperatureAt(v)
		return nil
	case device.FieldHostingType:
		v, ok := value.(enums.DeviceHostingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostingType(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, device.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, device.FieldUpdatedBy)
	}
	if m.addsum_cep != nil {
		fields = append(fields, device.FieldSumCep)
	}
	if m.addcores_number != nil {
		fields = append(fields, device.FieldCoresNumber)
	}
	if m.addmemory != nil {
		fields = append(fields, device.FieldMemory)
	}
	if m.adddisk != nil {
		fields = append(fields, device.FieldDisk)
	}
	if m.adddelay != nil {
		fields = append(fields, device.FieldDelay)
	}
	if m.addgpu_temperature != nil {
		fields = append(fields, device.FieldGpuTemperature)
	}
	if m.addcpu_temperature != nil {
		fields = append(fields, device.FieldCPUTemperature)
	}
	if m.addfree_gpu_num != nil {
		fields = append(fields, device.FieldFreeGpuNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedBy:
		return m.AddedCreatedBy()
	case device.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case device.FieldSumCep:
		return m.AddedSumCep()
	case device.FieldCoresNumber:
		return m.AddedCoresNumber()
	case device.FieldMemory:
		return m.AddedMemory()
	case device.FieldDisk:
		return m.AddedDisk()
	case device.FieldDelay:
		return m.AddedDelay()
	case device.FieldGpuTemperature:
		return m.AddedGpuTemperature()
	case device.FieldCPUTemperature:
		return m.AddedCPUTemperature()
	case device.FieldFreeGpuNum:
		return m.AddedFreeGpuNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case device.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case device.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumCep(v)
		return nil
	case device.FieldCoresNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoresNumber(v)
		return nil
	case device.FieldMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemory(v)
		return nil
	case device.FieldDisk:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisk(v)
		return nil
	case device.FieldDelay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelay(v)
		return nil
	case device.FieldGpuTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGpuTemperature(v)
		return nil
	case device.FieldCPUTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUTemperature(v)
		return nil
	case device.FieldFreeGpuNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeGpuNum(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldCpus) {
		fields = append(fields, device.FieldCpus)
	}
	if m.FieldCleared(device.FieldRankAt) {
		fields = append(fields, device.FieldRankAt)
	}
	if m.FieldCleared(device.FieldStabilityAt) {
		fields = append(fields, device.FieldStabilityAt)
	}
	if m.FieldCleared(device.FieldHighTemperatureAt) {
		fields = append(fields, device.FieldHighTemperatureAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldCpus:
		m.ClearCpus()
		return nil
	case device.FieldRankAt:
		m.ClearRankAt()
		return nil
	case device.FieldStabilityAt:
		m.ClearStabilityAt()
		return nil
	case device.FieldHighTemperatureAt:
		m.ClearHighTemperatureAt()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case device.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case device.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case device.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case device.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case device.FieldUserID:
		m.ResetUserID()
		return nil
	case device.FieldGiftMissionConfigID:
		m.ResetGiftMissionConfigID()
		return nil
	case device.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case device.FieldState:
		m.ResetState()
		return nil
	case device.FieldSumCep:
		m.ResetSumCep()
		return nil
	case device.FieldLinking:
		m.ResetLinking()
		return nil
	case device.FieldBindingStatus:
		m.ResetBindingStatus()
		return nil
	case device.FieldStatus:
		m.ResetStatus()
		return nil
	case device.FieldName:
		m.ResetName()
		return nil
	case device.FieldManageName:
		m.ResetManageName()
		return nil
	case device.FieldType:
		m.ResetType()
		return nil
	case device.FieldCoresNumber:
		m.ResetCoresNumber()
		return nil
	case device.FieldCPU:
		m.ResetCPU()
		return nil
	case device.FieldCpus:
		m.ResetCpus()
		return nil
	case device.FieldMemory:
		m.ResetMemory()
		return nil
	case device.FieldDisk:
		m.ResetDisk()
		return nil
	case device.FieldDelay:
		m.ResetDelay()
		return nil
	case device.FieldGpuTemperature:
		m.ResetGpuTemperature()
		return nil
	case device.FieldCPUTemperature:
		m.ResetCPUTemperature()
		return nil
	case device.FieldStability:
		m.ResetStability()
		return nil
	case device.FieldVersion:
		m.ResetVersion()
		return nil
	case device.FieldFault:
		m.ResetFault()
		return nil
	case device.FieldRank:
		m.ResetRank()
		return nil
	case device.FieldFreeGpuNum:
		m.ResetFreeGpuNum()
		return nil
	case device.FieldRankAt:
		m.ResetRankAt()
		return nil
	case device.FieldStabilityAt:
		m.ResetStabilityAt()
		return nil
	case device.FieldHighTemperatureAt:
		m.ResetHighTemperatureAt()
		return nil
	case device.FieldHostingType:
		m.ResetHostingType()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.user != nil {
		edges = append(edges, device.EdgeUser)
	}
	if m.gift_mission_config != nil {
		edges = append(edges, device.EdgeGiftMissionConfig)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, device.EdgeMissionProduceOrders)
	}
	if m.user_devices != nil {
		edges = append(edges, device.EdgeUserDevices)
	}
	if m.device_gpu_missions != nil {
		edges = append(edges, device.EdgeDeviceGpuMissions)
	}
	if m.frpc_infos != nil {
		edges = append(edges, device.EdgeFrpcInfos)
	}
	if m.mission_orders != nil {
		edges = append(edges, device.EdgeMissionOrders)
	}
	if m.mission_productions != nil {
		edges = append(edges, device.EdgeMissionProductions)
	}
	if m.device_reboot_times != nil {
		edges = append(edges, device.EdgeDeviceRebootTimes)
	}
	if m.trouble_deducts != nil {
		edges = append(edges, device.EdgeTroubleDeducts)
	}
	if m.device_states != nil {
		edges = append(edges, device.EdgeDeviceStates)
	}
	if m.device_offline_records != nil {
		edges = append(edges, device.EdgeDeviceOfflineRecords)
	}
	if m.mission_failed_feedbacks != nil {
		edges = append(edges, device.EdgeMissionFailedFeedbacks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeGiftMissionConfig:
		if id := m.gift_mission_config; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.user_devices))
		for id := range m.user_devices {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.device_gpu_missions))
		for id := range m.device_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeFrpcInfos:
		ids := make([]ent.Value, 0, len(m.frpc_infos))
		for id := range m.frpc_infos {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.mission_orders))
		for id := range m.mission_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.mission_productions))
		for id := range m.mission_productions {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceRebootTimes:
		ids := make([]ent.Value, 0, len(m.device_reboot_times))
		for id := range m.device_reboot_times {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeTroubleDeducts:
		ids := make([]ent.Value, 0, len(m.trouble_deducts))
		for id := range m.trouble_deducts {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceStates:
		ids := make([]ent.Value, 0, len(m.device_states))
		for id := range m.device_states {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceOfflineRecords:
		ids := make([]ent.Value, 0, len(m.device_offline_records))
		for id := range m.device_offline_records {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionFailedFeedbacks:
		ids := make([]ent.Value, 0, len(m.mission_failed_feedbacks))
		for id := range m.mission_failed_feedbacks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedmission_produce_orders != nil {
		edges = append(edges, device.EdgeMissionProduceOrders)
	}
	if m.removeduser_devices != nil {
		edges = append(edges, device.EdgeUserDevices)
	}
	if m.removeddevice_gpu_missions != nil {
		edges = append(edges, device.EdgeDeviceGpuMissions)
	}
	if m.removedfrpc_infos != nil {
		edges = append(edges, device.EdgeFrpcInfos)
	}
	if m.removedmission_orders != nil {
		edges = append(edges, device.EdgeMissionOrders)
	}
	if m.removedmission_productions != nil {
		edges = append(edges, device.EdgeMissionProductions)
	}
	if m.removeddevice_reboot_times != nil {
		edges = append(edges, device.EdgeDeviceRebootTimes)
	}
	if m.removedtrouble_deducts != nil {
		edges = append(edges, device.EdgeTroubleDeducts)
	}
	if m.removeddevice_states != nil {
		edges = append(edges, device.EdgeDeviceStates)
	}
	if m.removeddevice_offline_records != nil {
		edges = append(edges, device.EdgeDeviceOfflineRecords)
	}
	if m.removedmission_failed_feedbacks != nil {
		edges = append(edges, device.EdgeMissionFailedFeedbacks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.removeduser_devices))
		for id := range m.removeduser_devices {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.removeddevice_gpu_missions))
		for id := range m.removeddevice_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeFrpcInfos:
		ids := make([]ent.Value, 0, len(m.removedfrpc_infos))
		for id := range m.removedfrpc_infos {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_orders))
		for id := range m.removedmission_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.removedmission_productions))
		for id := range m.removedmission_productions {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceRebootTimes:
		ids := make([]ent.Value, 0, len(m.removeddevice_reboot_times))
		for id := range m.removeddevice_reboot_times {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeTroubleDeducts:
		ids := make([]ent.Value, 0, len(m.removedtrouble_deducts))
		for id := range m.removedtrouble_deducts {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceStates:
		ids := make([]ent.Value, 0, len(m.removeddevice_states))
		for id := range m.removeddevice_states {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceOfflineRecords:
		ids := make([]ent.Value, 0, len(m.removeddevice_offline_records))
		for id := range m.removeddevice_offline_records {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionFailedFeedbacks:
		ids := make([]ent.Value, 0, len(m.removedmission_failed_feedbacks))
		for id := range m.removedmission_failed_feedbacks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.cleareduser {
		edges = append(edges, device.EdgeUser)
	}
	if m.clearedgift_mission_config {
		edges = append(edges, device.EdgeGiftMissionConfig)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, device.EdgeMissionProduceOrders)
	}
	if m.cleareduser_devices {
		edges = append(edges, device.EdgeUserDevices)
	}
	if m.cleareddevice_gpu_missions {
		edges = append(edges, device.EdgeDeviceGpuMissions)
	}
	if m.clearedfrpc_infos {
		edges = append(edges, device.EdgeFrpcInfos)
	}
	if m.clearedmission_orders {
		edges = append(edges, device.EdgeMissionOrders)
	}
	if m.clearedmission_productions {
		edges = append(edges, device.EdgeMissionProductions)
	}
	if m.cleareddevice_reboot_times {
		edges = append(edges, device.EdgeDeviceRebootTimes)
	}
	if m.clearedtrouble_deducts {
		edges = append(edges, device.EdgeTroubleDeducts)
	}
	if m.cleareddevice_states {
		edges = append(edges, device.EdgeDeviceStates)
	}
	if m.cleareddevice_offline_records {
		edges = append(edges, device.EdgeDeviceOfflineRecords)
	}
	if m.clearedmission_failed_feedbacks {
		edges = append(edges, device.EdgeMissionFailedFeedbacks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeUser:
		return m.cleareduser
	case device.EdgeGiftMissionConfig:
		return m.clearedgift_mission_config
	case device.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case device.EdgeUserDevices:
		return m.cleareduser_devices
	case device.EdgeDeviceGpuMissions:
		return m.cleareddevice_gpu_missions
	case device.EdgeFrpcInfos:
		return m.clearedfrpc_infos
	case device.EdgeMissionOrders:
		return m.clearedmission_orders
	case device.EdgeMissionProductions:
		return m.clearedmission_productions
	case device.EdgeDeviceRebootTimes:
		return m.cleareddevice_reboot_times
	case device.EdgeTroubleDeducts:
		return m.clearedtrouble_deducts
	case device.EdgeDeviceStates:
		return m.cleareddevice_states
	case device.EdgeDeviceOfflineRecords:
		return m.cleareddevice_offline_records
	case device.EdgeMissionFailedFeedbacks:
		return m.clearedmission_failed_feedbacks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ClearUser()
		return nil
	case device.EdgeGiftMissionConfig:
		m.ClearGiftMissionConfig()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ResetUser()
		return nil
	case device.EdgeGiftMissionConfig:
		m.ResetGiftMissionConfig()
		return nil
	case device.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case device.EdgeUserDevices:
		m.ResetUserDevices()
		return nil
	case device.EdgeDeviceGpuMissions:
		m.ResetDeviceGpuMissions()
		return nil
	case device.EdgeFrpcInfos:
		m.ResetFrpcInfos()
		return nil
	case device.EdgeMissionOrders:
		m.ResetMissionOrders()
		return nil
	case device.EdgeMissionProductions:
		m.ResetMissionProductions()
		return nil
	case device.EdgeDeviceRebootTimes:
		m.ResetDeviceRebootTimes()
		return nil
	case device.EdgeTroubleDeducts:
		m.ResetTroubleDeducts()
		return nil
	case device.EdgeDeviceStates:
		m.ResetDeviceStates()
		return nil
	case device.EdgeDeviceOfflineRecords:
		m.ResetDeviceOfflineRecords()
		return nil
	case device.EdgeMissionFailedFeedbacks:
		m.ResetMissionFailedFeedbacks()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DeviceGpuMissionMutation represents an operation that mutates the DeviceGpuMission nodes in the graph.
type DeviceGpuMissionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	able_mission_kind     *[]string
	device_slot           *int8
	adddevice_slot        *int8
	max_online_mission    *int8
	addmax_online_mission *int8
	gpu_status            *enums.GpuStatus
	mission_id            *[]int64
	clearedFields         map[string]struct{}
	device                *int64
	cleareddevice         bool
	gpu                   *int64
	clearedgpu            bool
	done                  bool
	oldValue              func(context.Context) (*DeviceGpuMission, error)
	predicates            []predicate.DeviceGpuMission
}

var _ ent.Mutation = (*DeviceGpuMissionMutation)(nil)

// devicegpumissionOption allows management of the mutation configuration using functional options.
type devicegpumissionOption func(*DeviceGpuMissionMutation)

// newDeviceGpuMissionMutation creates new mutation for the DeviceGpuMission entity.
func newDeviceGpuMissionMutation(c config, op Op, opts ...devicegpumissionOption) *DeviceGpuMissionMutation {
	m := &DeviceGpuMissionMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceGpuMission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceGpuMissionID sets the ID field of the mutation.
func withDeviceGpuMissionID(id int64) devicegpumissionOption {
	return func(m *DeviceGpuMissionMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceGpuMission
		)
		m.oldValue = func(ctx context.Context) (*DeviceGpuMission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceGpuMission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceGpuMission sets the old DeviceGpuMission of the mutation.
func withDeviceGpuMission(node *DeviceGpuMission) devicegpumissionOption {
	return func(m *DeviceGpuMissionMutation) {
		m.oldValue = func(context.Context) (*DeviceGpuMission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceGpuMissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceGpuMissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceGpuMission entities.
func (m *DeviceGpuMissionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceGpuMissionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceGpuMissionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceGpuMission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceGpuMissionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceGpuMissionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeviceGpuMissionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceGpuMissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceGpuMissionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceGpuMissionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeviceGpuMissionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceGpuMissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceGpuMissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceGpuMissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceGpuMissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceGpuMissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceGpuMissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceGpuMissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceGpuMissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceGpuMissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceGpuMissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceGpuMissionMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceGpuMissionMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceGpuMissionMutation) ResetDeviceID() {
	m.device = nil
}

// SetGpuID sets the "gpu_id" field.
func (m *DeviceGpuMissionMutation) SetGpuID(i int64) {
	m.gpu = &i
}

// GpuID returns the value of the "gpu_id" field in the mutation.
func (m *DeviceGpuMissionMutation) GpuID() (r int64, exists bool) {
	v := m.gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuID returns the old "gpu_id" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldGpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuID: %w", err)
	}
	return oldValue.GpuID, nil
}

// ResetGpuID resets all changes to the "gpu_id" field.
func (m *DeviceGpuMissionMutation) ResetGpuID() {
	m.gpu = nil
}

// SetAbleMissionKind sets the "able_mission_kind" field.
func (m *DeviceGpuMissionMutation) SetAbleMissionKind(s []string) {
	m.able_mission_kind = &s
}

// AbleMissionKind returns the value of the "able_mission_kind" field in the mutation.
func (m *DeviceGpuMissionMutation) AbleMissionKind() (r []string, exists bool) {
	v := m.able_mission_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldAbleMissionKind returns the old "able_mission_kind" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldAbleMissionKind(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbleMissionKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbleMissionKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbleMissionKind: %w", err)
	}
	return oldValue.AbleMissionKind, nil
}

// ClearAbleMissionKind clears the value of the "able_mission_kind" field.
func (m *DeviceGpuMissionMutation) ClearAbleMissionKind() {
	m.able_mission_kind = nil
	m.clearedFields[devicegpumission.FieldAbleMissionKind] = struct{}{}
}

// AbleMissionKindCleared returns if the "able_mission_kind" field was cleared in this mutation.
func (m *DeviceGpuMissionMutation) AbleMissionKindCleared() bool {
	_, ok := m.clearedFields[devicegpumission.FieldAbleMissionKind]
	return ok
}

// ResetAbleMissionKind resets all changes to the "able_mission_kind" field.
func (m *DeviceGpuMissionMutation) ResetAbleMissionKind() {
	m.able_mission_kind = nil
	delete(m.clearedFields, devicegpumission.FieldAbleMissionKind)
}

// SetDeviceSlot sets the "device_slot" field.
func (m *DeviceGpuMissionMutation) SetDeviceSlot(i int8) {
	m.device_slot = &i
	m.adddevice_slot = nil
}

// DeviceSlot returns the value of the "device_slot" field in the mutation.
func (m *DeviceGpuMissionMutation) DeviceSlot() (r int8, exists bool) {
	v := m.device_slot
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceSlot returns the old "device_slot" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldDeviceSlot(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceSlot: %w", err)
	}
	return oldValue.DeviceSlot, nil
}

// AddDeviceSlot adds i to the "device_slot" field.
func (m *DeviceGpuMissionMutation) AddDeviceSlot(i int8) {
	if m.adddevice_slot != nil {
		*m.adddevice_slot += i
	} else {
		m.adddevice_slot = &i
	}
}

// AddedDeviceSlot returns the value that was added to the "device_slot" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedDeviceSlot() (r int8, exists bool) {
	v := m.adddevice_slot
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceSlot resets all changes to the "device_slot" field.
func (m *DeviceGpuMissionMutation) ResetDeviceSlot() {
	m.device_slot = nil
	m.adddevice_slot = nil
}

// SetMaxOnlineMission sets the "max_online_mission" field.
func (m *DeviceGpuMissionMutation) SetMaxOnlineMission(i int8) {
	m.max_online_mission = &i
	m.addmax_online_mission = nil
}

// MaxOnlineMission returns the value of the "max_online_mission" field in the mutation.
func (m *DeviceGpuMissionMutation) MaxOnlineMission() (r int8, exists bool) {
	v := m.max_online_mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxOnlineMission returns the old "max_online_mission" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldMaxOnlineMission(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxOnlineMission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxOnlineMission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxOnlineMission: %w", err)
	}
	return oldValue.MaxOnlineMission, nil
}

// AddMaxOnlineMission adds i to the "max_online_mission" field.
func (m *DeviceGpuMissionMutation) AddMaxOnlineMission(i int8) {
	if m.addmax_online_mission != nil {
		*m.addmax_online_mission += i
	} else {
		m.addmax_online_mission = &i
	}
}

// AddedMaxOnlineMission returns the value that was added to the "max_online_mission" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedMaxOnlineMission() (r int8, exists bool) {
	v := m.addmax_online_mission
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxOnlineMission resets all changes to the "max_online_mission" field.
func (m *DeviceGpuMissionMutation) ResetMaxOnlineMission() {
	m.max_online_mission = nil
	m.addmax_online_mission = nil
}

// SetGpuStatus sets the "gpu_status" field.
func (m *DeviceGpuMissionMutation) SetGpuStatus(es enums.GpuStatus) {
	m.gpu_status = &es
}

// GpuStatus returns the value of the "gpu_status" field in the mutation.
func (m *DeviceGpuMissionMutation) GpuStatus() (r enums.GpuStatus, exists bool) {
	v := m.gpu_status
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuStatus returns the old "gpu_status" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldGpuStatus(ctx context.Context) (v enums.GpuStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuStatus: %w", err)
	}
	return oldValue.GpuStatus, nil
}

// ResetGpuStatus resets all changes to the "gpu_status" field.
func (m *DeviceGpuMissionMutation) ResetGpuStatus() {
	m.gpu_status = nil
}

// SetMissionID sets the "mission_id" field.
func (m *DeviceGpuMissionMutation) SetMissionID(i []int64) {
	m.mission_id = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *DeviceGpuMissionMutation) MissionID() (r []int64, exists bool) {
	v := m.mission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldMissionID(ctx context.Context) (v []int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ClearMissionID clears the value of the "mission_id" field.
func (m *DeviceGpuMissionMutation) ClearMissionID() {
	m.mission_id = nil
	m.clearedFields[devicegpumission.FieldMissionID] = struct{}{}
}

// MissionIDCleared returns if the "mission_id" field was cleared in this mutation.
func (m *DeviceGpuMissionMutation) MissionIDCleared() bool {
	_, ok := m.clearedFields[devicegpumission.FieldMissionID]
	return ok
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *DeviceGpuMissionMutation) ResetMissionID() {
	m.mission_id = nil
	delete(m.clearedFields, devicegpumission.FieldMissionID)
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *DeviceGpuMissionMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[devicegpumission.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *DeviceGpuMissionMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceGpuMissionMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceGpuMissionMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// ClearGpu clears the "gpu" edge to the Gpu entity.
func (m *DeviceGpuMissionMutation) ClearGpu() {
	m.clearedgpu = true
	m.clearedFields[devicegpumission.FieldGpuID] = struct{}{}
}

// GpuCleared reports if the "gpu" edge to the Gpu entity was cleared.
func (m *DeviceGpuMissionMutation) GpuCleared() bool {
	return m.clearedgpu
}

// GpuIDs returns the "gpu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GpuID instead. It exists only for internal usage by the builders.
func (m *DeviceGpuMissionMutation) GpuIDs() (ids []int64) {
	if id := m.gpu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGpu resets all changes to the "gpu" edge.
func (m *DeviceGpuMissionMutation) ResetGpu() {
	m.gpu = nil
	m.clearedgpu = false
}

// Where appends a list predicates to the DeviceGpuMissionMutation builder.
func (m *DeviceGpuMissionMutation) Where(ps ...predicate.DeviceGpuMission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceGpuMissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceGpuMissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceGpuMission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceGpuMissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceGpuMissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceGpuMission).
func (m *DeviceGpuMissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceGpuMissionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, devicegpumission.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, devicegpumission.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, devicegpumission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicegpumission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, devicegpumission.FieldDeletedAt)
	}
	if m.device != nil {
		fields = append(fields, devicegpumission.FieldDeviceID)
	}
	if m.gpu != nil {
		fields = append(fields, devicegpumission.FieldGpuID)
	}
	if m.able_mission_kind != nil {
		fields = append(fields, devicegpumission.FieldAbleMissionKind)
	}
	if m.device_slot != nil {
		fields = append(fields, devicegpumission.FieldDeviceSlot)
	}
	if m.max_online_mission != nil {
		fields = append(fields, devicegpumission.FieldMaxOnlineMission)
	}
	if m.gpu_status != nil {
		fields = append(fields, devicegpumission.FieldGpuStatus)
	}
	if m.mission_id != nil {
		fields = append(fields, devicegpumission.FieldMissionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceGpuMissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicegpumission.FieldCreatedBy:
		return m.CreatedBy()
	case devicegpumission.FieldUpdatedBy:
		return m.UpdatedBy()
	case devicegpumission.FieldCreatedAt:
		return m.CreatedAt()
	case devicegpumission.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicegpumission.FieldDeletedAt:
		return m.DeletedAt()
	case devicegpumission.FieldDeviceID:
		return m.DeviceID()
	case devicegpumission.FieldGpuID:
		return m.GpuID()
	case devicegpumission.FieldAbleMissionKind:
		return m.AbleMissionKind()
	case devicegpumission.FieldDeviceSlot:
		return m.DeviceSlot()
	case devicegpumission.FieldMaxOnlineMission:
		return m.MaxOnlineMission()
	case devicegpumission.FieldGpuStatus:
		return m.GpuStatus()
	case devicegpumission.FieldMissionID:
		return m.MissionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceGpuMissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicegpumission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case devicegpumission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case devicegpumission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicegpumission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicegpumission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case devicegpumission.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case devicegpumission.FieldGpuID:
		return m.OldGpuID(ctx)
	case devicegpumission.FieldAbleMissionKind:
		return m.OldAbleMissionKind(ctx)
	case devicegpumission.FieldDeviceSlot:
		return m.OldDeviceSlot(ctx)
	case devicegpumission.FieldMaxOnlineMission:
		return m.OldMaxOnlineMission(ctx)
	case devicegpumission.FieldGpuStatus:
		return m.OldGpuStatus(ctx)
	case devicegpumission.FieldMissionID:
		return m.OldMissionID(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceGpuMission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceGpuMissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicegpumission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case devicegpumission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case devicegpumission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicegpumission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicegpumission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case devicegpumission.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case devicegpumission.FieldGpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuID(v)
		return nil
	case devicegpumission.FieldAbleMissionKind:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbleMissionKind(v)
		return nil
	case devicegpumission.FieldDeviceSlot:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceSlot(v)
		return nil
	case devicegpumission.FieldMaxOnlineMission:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxOnlineMission(v)
		return nil
	case devicegpumission.FieldGpuStatus:
		v, ok := value.(enums.GpuStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuStatus(v)
		return nil
	case devicegpumission.FieldMissionID:
		v, ok := value.([]int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceGpuMissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, devicegpumission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, devicegpumission.FieldUpdatedBy)
	}
	if m.adddevice_slot != nil {
		fields = append(fields, devicegpumission.FieldDeviceSlot)
	}
	if m.addmax_online_mission != nil {
		fields = append(fields, devicegpumission.FieldMaxOnlineMission)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceGpuMissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicegpumission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case devicegpumission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case devicegpumission.FieldDeviceSlot:
		return m.AddedDeviceSlot()
	case devicegpumission.FieldMaxOnlineMission:
		return m.AddedMaxOnlineMission()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceGpuMissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicegpumission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case devicegpumission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case devicegpumission.FieldDeviceSlot:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceSlot(v)
		return nil
	case devicegpumission.FieldMaxOnlineMission:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxOnlineMission(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceGpuMissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicegpumission.FieldAbleMissionKind) {
		fields = append(fields, devicegpumission.FieldAbleMissionKind)
	}
	if m.FieldCleared(devicegpumission.FieldMissionID) {
		fields = append(fields, devicegpumission.FieldMissionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceGpuMissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceGpuMissionMutation) ClearField(name string) error {
	switch name {
	case devicegpumission.FieldAbleMissionKind:
		m.ClearAbleMissionKind()
		return nil
	case devicegpumission.FieldMissionID:
		m.ClearMissionID()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceGpuMissionMutation) ResetField(name string) error {
	switch name {
	case devicegpumission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case devicegpumission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case devicegpumission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicegpumission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicegpumission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case devicegpumission.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case devicegpumission.FieldGpuID:
		m.ResetGpuID()
		return nil
	case devicegpumission.FieldAbleMissionKind:
		m.ResetAbleMissionKind()
		return nil
	case devicegpumission.FieldDeviceSlot:
		m.ResetDeviceSlot()
		return nil
	case devicegpumission.FieldMaxOnlineMission:
		m.ResetMaxOnlineMission()
		return nil
	case devicegpumission.FieldGpuStatus:
		m.ResetGpuStatus()
		return nil
	case devicegpumission.FieldMissionID:
		m.ResetMissionID()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceGpuMissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.device != nil {
		edges = append(edges, devicegpumission.EdgeDevice)
	}
	if m.gpu != nil {
		edges = append(edges, devicegpumission.EdgeGpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceGpuMissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicegpumission.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case devicegpumission.EdgeGpu:
		if id := m.gpu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceGpuMissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceGpuMissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceGpuMissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddevice {
		edges = append(edges, devicegpumission.EdgeDevice)
	}
	if m.clearedgpu {
		edges = append(edges, devicegpumission.EdgeGpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceGpuMissionMutation) EdgeCleared(name string) bool {
	switch name {
	case devicegpumission.EdgeDevice:
		return m.cleareddevice
	case devicegpumission.EdgeGpu:
		return m.clearedgpu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceGpuMissionMutation) ClearEdge(name string) error {
	switch name {
	case devicegpumission.EdgeDevice:
		m.ClearDevice()
		return nil
	case devicegpumission.EdgeGpu:
		m.ClearGpu()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceGpuMissionMutation) ResetEdge(name string) error {
	switch name {
	case devicegpumission.EdgeDevice:
		m.ResetDevice()
		return nil
	case devicegpumission.EdgeGpu:
		m.ResetGpu()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission edge %s", name)
}

// DeviceOfflineRecordMutation represents an operation that mutates the DeviceOfflineRecord nodes in the graph.
type DeviceOfflineRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	device        *int64
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*DeviceOfflineRecord, error)
	predicates    []predicate.DeviceOfflineRecord
}

var _ ent.Mutation = (*DeviceOfflineRecordMutation)(nil)

// deviceofflinerecordOption allows management of the mutation configuration using functional options.
type deviceofflinerecordOption func(*DeviceOfflineRecordMutation)

// newDeviceOfflineRecordMutation creates new mutation for the DeviceOfflineRecord entity.
func newDeviceOfflineRecordMutation(c config, op Op, opts ...deviceofflinerecordOption) *DeviceOfflineRecordMutation {
	m := &DeviceOfflineRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceOfflineRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceOfflineRecordID sets the ID field of the mutation.
func withDeviceOfflineRecordID(id int64) deviceofflinerecordOption {
	return func(m *DeviceOfflineRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceOfflineRecord
		)
		m.oldValue = func(ctx context.Context) (*DeviceOfflineRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceOfflineRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceOfflineRecord sets the old DeviceOfflineRecord of the mutation.
func withDeviceOfflineRecord(node *DeviceOfflineRecord) deviceofflinerecordOption {
	return func(m *DeviceOfflineRecordMutation) {
		m.oldValue = func(context.Context) (*DeviceOfflineRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceOfflineRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceOfflineRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceOfflineRecord entities.
func (m *DeviceOfflineRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceOfflineRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceOfflineRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceOfflineRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceOfflineRecordMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceOfflineRecordMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeviceOfflineRecord entity.
// If the DeviceOfflineRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceOfflineRecordMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeviceOfflineRecordMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeviceOfflineRecordMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceOfflineRecordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceOfflineRecordMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceOfflineRecordMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeviceOfflineRecord entity.
// If the DeviceOfflineRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceOfflineRecordMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeviceOfflineRecordMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeviceOfflineRecordMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceOfflineRecordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceOfflineRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceOfflineRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceOfflineRecord entity.
// If the DeviceOfflineRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceOfflineRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceOfflineRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceOfflineRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceOfflineRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceOfflineRecord entity.
// If the DeviceOfflineRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceOfflineRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceOfflineRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceOfflineRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceOfflineRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceOfflineRecord entity.
// If the DeviceOfflineRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceOfflineRecordMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceOfflineRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceOfflineRecordMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceOfflineRecordMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceOfflineRecord entity.
// If the DeviceOfflineRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceOfflineRecordMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceOfflineRecordMutation) ResetDeviceID() {
	m.device = nil
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *DeviceOfflineRecordMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[deviceofflinerecord.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *DeviceOfflineRecordMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceOfflineRecordMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceOfflineRecordMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the DeviceOfflineRecordMutation builder.
func (m *DeviceOfflineRecordMutation) Where(ps ...predicate.DeviceOfflineRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceOfflineRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceOfflineRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceOfflineRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceOfflineRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceOfflineRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceOfflineRecord).
func (m *DeviceOfflineRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceOfflineRecordMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_by != nil {
		fields = append(fields, deviceofflinerecord.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, deviceofflinerecord.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, deviceofflinerecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceofflinerecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, deviceofflinerecord.FieldDeletedAt)
	}
	if m.device != nil {
		fields = append(fields, deviceofflinerecord.FieldDeviceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceOfflineRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceofflinerecord.FieldCreatedBy:
		return m.CreatedBy()
	case deviceofflinerecord.FieldUpdatedBy:
		return m.UpdatedBy()
	case deviceofflinerecord.FieldCreatedAt:
		return m.CreatedAt()
	case deviceofflinerecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceofflinerecord.FieldDeletedAt:
		return m.DeletedAt()
	case deviceofflinerecord.FieldDeviceID:
		return m.DeviceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceOfflineRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceofflinerecord.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case deviceofflinerecord.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case deviceofflinerecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceofflinerecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceofflinerecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case deviceofflinerecord.FieldDeviceID:
		return m.OldDeviceID(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceOfflineRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceOfflineRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceofflinerecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case deviceofflinerecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case deviceofflinerecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceofflinerecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceofflinerecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case deviceofflinerecord.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceOfflineRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceOfflineRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, deviceofflinerecord.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, deviceofflinerecord.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceOfflineRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deviceofflinerecord.FieldCreatedBy:
		return m.AddedCreatedBy()
	case deviceofflinerecord.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceOfflineRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deviceofflinerecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case deviceofflinerecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceOfflineRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceOfflineRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceOfflineRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceOfflineRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceOfflineRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceOfflineRecordMutation) ResetField(name string) error {
	switch name {
	case deviceofflinerecord.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case deviceofflinerecord.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case deviceofflinerecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceofflinerecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceofflinerecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case deviceofflinerecord.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	}
	return fmt.Errorf("unknown DeviceOfflineRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceOfflineRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device != nil {
		edges = append(edges, deviceofflinerecord.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceOfflineRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceofflinerecord.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceOfflineRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceOfflineRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceOfflineRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice {
		edges = append(edges, deviceofflinerecord.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceOfflineRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceofflinerecord.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceOfflineRecordMutation) ClearEdge(name string) error {
	switch name {
	case deviceofflinerecord.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceOfflineRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceOfflineRecordMutation) ResetEdge(name string) error {
	switch name {
	case deviceofflinerecord.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceOfflineRecord edge %s", name)
}

// DeviceRebootTimeMutation represents an operation that mutates the DeviceRebootTime nodes in the graph.
type DeviceRebootTimeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	start_time    *time.Time
	end_time      *time.Time
	now_time      *time.Time
	online_time   *string
	offline_time  *string
	clearedFields map[string]struct{}
	device        *int64
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*DeviceRebootTime, error)
	predicates    []predicate.DeviceRebootTime
}

var _ ent.Mutation = (*DeviceRebootTimeMutation)(nil)

// devicereboottimeOption allows management of the mutation configuration using functional options.
type devicereboottimeOption func(*DeviceRebootTimeMutation)

// newDeviceRebootTimeMutation creates new mutation for the DeviceRebootTime entity.
func newDeviceRebootTimeMutation(c config, op Op, opts ...devicereboottimeOption) *DeviceRebootTimeMutation {
	m := &DeviceRebootTimeMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceRebootTime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceRebootTimeID sets the ID field of the mutation.
func withDeviceRebootTimeID(id int64) devicereboottimeOption {
	return func(m *DeviceRebootTimeMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceRebootTime
		)
		m.oldValue = func(ctx context.Context) (*DeviceRebootTime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceRebootTime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceRebootTime sets the old DeviceRebootTime of the mutation.
func withDeviceRebootTime(node *DeviceRebootTime) devicereboottimeOption {
	return func(m *DeviceRebootTimeMutation) {
		m.oldValue = func(context.Context) (*DeviceRebootTime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceRebootTimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceRebootTimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceRebootTime entities.
func (m *DeviceRebootTimeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceRebootTimeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceRebootTimeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceRebootTime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceRebootTimeMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceRebootTimeMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeviceRebootTimeMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeviceRebootTimeMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceRebootTimeMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceRebootTimeMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceRebootTimeMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeviceRebootTimeMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeviceRebootTimeMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceRebootTimeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceRebootTimeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceRebootTimeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceRebootTimeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceRebootTimeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceRebootTimeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceRebootTimeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceRebootTimeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceRebootTimeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceRebootTimeMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceRebootTimeMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceRebootTimeMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceRebootTimeMutation) ResetDeviceID() {
	m.device = nil
}

// SetStartTime sets the "start_time" field.
func (m *DeviceRebootTimeMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *DeviceRebootTimeMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *DeviceRebootTimeMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *DeviceRebootTimeMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *DeviceRebootTimeMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *DeviceRebootTimeMutation) ResetEndTime() {
	m.end_time = nil
}

// SetNowTime sets the "now_time" field.
func (m *DeviceRebootTimeMutation) SetNowTime(t time.Time) {
	m.now_time = &t
}

// NowTime returns the value of the "now_time" field in the mutation.
func (m *DeviceRebootTimeMutation) NowTime() (r time.Time, exists bool) {
	v := m.now_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNowTime returns the old "now_time" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldNowTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNowTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNowTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNowTime: %w", err)
	}
	return oldValue.NowTime, nil
}

// ResetNowTime resets all changes to the "now_time" field.
func (m *DeviceRebootTimeMutation) ResetNowTime() {
	m.now_time = nil
}

// SetOnlineTime sets the "online_time" field.
func (m *DeviceRebootTimeMutation) SetOnlineTime(s string) {
	m.online_time = &s
}

// OnlineTime returns the value of the "online_time" field in the mutation.
func (m *DeviceRebootTimeMutation) OnlineTime() (r string, exists bool) {
	v := m.online_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOnlineTime returns the old "online_time" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldOnlineTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnlineTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnlineTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnlineTime: %w", err)
	}
	return oldValue.OnlineTime, nil
}

// ResetOnlineTime resets all changes to the "online_time" field.
func (m *DeviceRebootTimeMutation) ResetOnlineTime() {
	m.online_time = nil
}

// SetOfflineTime sets the "offline_time" field.
func (m *DeviceRebootTimeMutation) SetOfflineTime(s string) {
	m.offline_time = &s
}

// OfflineTime returns the value of the "offline_time" field in the mutation.
func (m *DeviceRebootTimeMutation) OfflineTime() (r string, exists bool) {
	v := m.offline_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOfflineTime returns the old "offline_time" field's value of the DeviceRebootTime entity.
// If the DeviceRebootTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRebootTimeMutation) OldOfflineTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfflineTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfflineTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfflineTime: %w", err)
	}
	return oldValue.OfflineTime, nil
}

// ResetOfflineTime resets all changes to the "offline_time" field.
func (m *DeviceRebootTimeMutation) ResetOfflineTime() {
	m.offline_time = nil
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *DeviceRebootTimeMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[devicereboottime.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *DeviceRebootTimeMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceRebootTimeMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceRebootTimeMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the DeviceRebootTimeMutation builder.
func (m *DeviceRebootTimeMutation) Where(ps ...predicate.DeviceRebootTime) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceRebootTimeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceRebootTimeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceRebootTime, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceRebootTimeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceRebootTimeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceRebootTime).
func (m *DeviceRebootTimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceRebootTimeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, devicereboottime.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, devicereboottime.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, devicereboottime.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicereboottime.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, devicereboottime.FieldDeletedAt)
	}
	if m.device != nil {
		fields = append(fields, devicereboottime.FieldDeviceID)
	}
	if m.start_time != nil {
		fields = append(fields, devicereboottime.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, devicereboottime.FieldEndTime)
	}
	if m.now_time != nil {
		fields = append(fields, devicereboottime.FieldNowTime)
	}
	if m.online_time != nil {
		fields = append(fields, devicereboottime.FieldOnlineTime)
	}
	if m.offline_time != nil {
		fields = append(fields, devicereboottime.FieldOfflineTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceRebootTimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicereboottime.FieldCreatedBy:
		return m.CreatedBy()
	case devicereboottime.FieldUpdatedBy:
		return m.UpdatedBy()
	case devicereboottime.FieldCreatedAt:
		return m.CreatedAt()
	case devicereboottime.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicereboottime.FieldDeletedAt:
		return m.DeletedAt()
	case devicereboottime.FieldDeviceID:
		return m.DeviceID()
	case devicereboottime.FieldStartTime:
		return m.StartTime()
	case devicereboottime.FieldEndTime:
		return m.EndTime()
	case devicereboottime.FieldNowTime:
		return m.NowTime()
	case devicereboottime.FieldOnlineTime:
		return m.OnlineTime()
	case devicereboottime.FieldOfflineTime:
		return m.OfflineTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceRebootTimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicereboottime.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case devicereboottime.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case devicereboottime.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicereboottime.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicereboottime.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case devicereboottime.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case devicereboottime.FieldStartTime:
		return m.OldStartTime(ctx)
	case devicereboottime.FieldEndTime:
		return m.OldEndTime(ctx)
	case devicereboottime.FieldNowTime:
		return m.OldNowTime(ctx)
	case devicereboottime.FieldOnlineTime:
		return m.OldOnlineTime(ctx)
	case devicereboottime.FieldOfflineTime:
		return m.OldOfflineTime(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceRebootTime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceRebootTimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicereboottime.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case devicereboottime.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case devicereboottime.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicereboottime.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicereboottime.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case devicereboottime.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case devicereboottime.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case devicereboottime.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case devicereboottime.FieldNowTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNowTime(v)
		return nil
	case devicereboottime.FieldOnlineTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnlineTime(v)
		return nil
	case devicereboottime.FieldOfflineTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfflineTime(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceRebootTime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceRebootTimeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, devicereboottime.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, devicereboottime.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceRebootTimeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicereboottime.FieldCreatedBy:
		return m.AddedCreatedBy()
	case devicereboottime.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceRebootTimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicereboottime.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case devicereboottime.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceRebootTime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceRebootTimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceRebootTimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceRebootTimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceRebootTime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceRebootTimeMutation) ResetField(name string) error {
	switch name {
	case devicereboottime.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case devicereboottime.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case devicereboottime.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicereboottime.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicereboottime.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case devicereboottime.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case devicereboottime.FieldStartTime:
		m.ResetStartTime()
		return nil
	case devicereboottime.FieldEndTime:
		m.ResetEndTime()
		return nil
	case devicereboottime.FieldNowTime:
		m.ResetNowTime()
		return nil
	case devicereboottime.FieldOnlineTime:
		m.ResetOnlineTime()
		return nil
	case devicereboottime.FieldOfflineTime:
		m.ResetOfflineTime()
		return nil
	}
	return fmt.Errorf("unknown DeviceRebootTime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceRebootTimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device != nil {
		edges = append(edges, devicereboottime.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceRebootTimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicereboottime.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceRebootTimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceRebootTimeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceRebootTimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice {
		edges = append(edges, devicereboottime.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceRebootTimeMutation) EdgeCleared(name string) bool {
	switch name {
	case devicereboottime.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceRebootTimeMutation) ClearEdge(name string) error {
	switch name {
	case devicereboottime.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceRebootTime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceRebootTimeMutation) ResetEdge(name string) error {
	switch name {
	case devicereboottime.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceRebootTime edge %s", name)
}

// DeviceStateMutation represents an operation that mutates the DeviceState nodes in the graph.
type DeviceStateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	delay         *float64
	adddelay      *float64
	clearedFields map[string]struct{}
	device        *int64
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*DeviceState, error)
	predicates    []predicate.DeviceState
}

var _ ent.Mutation = (*DeviceStateMutation)(nil)

// devicestateOption allows management of the mutation configuration using functional options.
type devicestateOption func(*DeviceStateMutation)

// newDeviceStateMutation creates new mutation for the DeviceState entity.
func newDeviceStateMutation(c config, op Op, opts ...devicestateOption) *DeviceStateMutation {
	m := &DeviceStateMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceStateID sets the ID field of the mutation.
func withDeviceStateID(id int64) devicestateOption {
	return func(m *DeviceStateMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceState
		)
		m.oldValue = func(ctx context.Context) (*DeviceState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceState sets the old DeviceState of the mutation.
func withDeviceState(node *DeviceState) devicestateOption {
	return func(m *DeviceStateMutation) {
		m.oldValue = func(context.Context) (*DeviceState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceState entities.
func (m *DeviceStateMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceStateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceStateMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceStateMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceStateMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeviceState entity.
// If the DeviceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceStateMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeviceStateMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeviceStateMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceStateMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceStateMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceStateMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeviceState entity.
// If the DeviceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceStateMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeviceStateMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeviceStateMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceStateMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceStateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceStateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceState entity.
// If the DeviceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceStateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceStateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceStateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceStateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceState entity.
// If the DeviceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceStateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceStateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceStateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceStateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceState entity.
// If the DeviceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceStateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceStateMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceStateMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceStateMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceState entity.
// If the DeviceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceStateMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceStateMutation) ResetDeviceID() {
	m.device = nil
}

// SetDelay sets the "delay" field.
func (m *DeviceStateMutation) SetDelay(f float64) {
	m.delay = &f
	m.adddelay = nil
}

// Delay returns the value of the "delay" field in the mutation.
func (m *DeviceStateMutation) Delay() (r float64, exists bool) {
	v := m.delay
	if v == nil {
		return
	}
	return *v, true
}

// OldDelay returns the old "delay" field's value of the DeviceState entity.
// If the DeviceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceStateMutation) OldDelay(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelay: %w", err)
	}
	return oldValue.Delay, nil
}

// AddDelay adds f to the "delay" field.
func (m *DeviceStateMutation) AddDelay(f float64) {
	if m.adddelay != nil {
		*m.adddelay += f
	} else {
		m.adddelay = &f
	}
}

// AddedDelay returns the value that was added to the "delay" field in this mutation.
func (m *DeviceStateMutation) AddedDelay() (r float64, exists bool) {
	v := m.adddelay
	if v == nil {
		return
	}
	return *v, true
}

// ResetDelay resets all changes to the "delay" field.
func (m *DeviceStateMutation) ResetDelay() {
	m.delay = nil
	m.adddelay = nil
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *DeviceStateMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[devicestate.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *DeviceStateMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceStateMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceStateMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the DeviceStateMutation builder.
func (m *DeviceStateMutation) Where(ps ...predicate.DeviceState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceState).
func (m *DeviceStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceStateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, devicestate.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, devicestate.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, devicestate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicestate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, devicestate.FieldDeletedAt)
	}
	if m.device != nil {
		fields = append(fields, devicestate.FieldDeviceID)
	}
	if m.delay != nil {
		fields = append(fields, devicestate.FieldDelay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicestate.FieldCreatedBy:
		return m.CreatedBy()
	case devicestate.FieldUpdatedBy:
		return m.UpdatedBy()
	case devicestate.FieldCreatedAt:
		return m.CreatedAt()
	case devicestate.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicestate.FieldDeletedAt:
		return m.DeletedAt()
	case devicestate.FieldDeviceID:
		return m.DeviceID()
	case devicestate.FieldDelay:
		return m.Delay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicestate.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case devicestate.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case devicestate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicestate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicestate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case devicestate.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case devicestate.FieldDelay:
		return m.OldDelay(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicestate.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case devicestate.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case devicestate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicestate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicestate.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case devicestate.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case devicestate.FieldDelay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelay(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceStateMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, devicestate.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, devicestate.FieldUpdatedBy)
	}
	if m.adddelay != nil {
		fields = append(fields, devicestate.FieldDelay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceStateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicestate.FieldCreatedBy:
		return m.AddedCreatedBy()
	case devicestate.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case devicestate.FieldDelay:
		return m.AddedDelay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicestate.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case devicestate.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case devicestate.FieldDelay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelay(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceStateMutation) ResetField(name string) error {
	switch name {
	case devicestate.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case devicestate.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case devicestate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicestate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicestate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case devicestate.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case devicestate.FieldDelay:
		m.ResetDelay()
		return nil
	}
	return fmt.Errorf("unknown DeviceState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device != nil {
		edges = append(edges, devicestate.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceStateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicestate.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice {
		edges = append(edges, devicestate.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceStateMutation) EdgeCleared(name string) bool {
	switch name {
	case devicestate.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceStateMutation) ClearEdge(name string) error {
	switch name {
	case devicestate.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceStateMutation) ResetEdge(name string) error {
	switch name {
	case devicestate.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceState edge %s", name)
}

// EarnBillMutation represents an operation that mutates the EarnBill nodes in the graph.
type EarnBillMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	_type                         *earnbill.Type
	is_minus                      *bool
	serial_number                 *string
	pure_cep                      *int64
	addpure_cep                   *int64
	gift_cep                      *int64
	addgift_cep                   *int64
	platform_pure_cep             *int64
	addplatform_pure_cep          *int64
	platform_gift_cep             *int64
	addplatform_gift_cep          *int64
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	profit_account                *int64
	clearedprofit_account         bool
	platform_account              *int64
	clearedplatform_account       bool
	mission_produce_orders        *int64
	clearedmission_produce_orders bool
	done                          bool
	oldValue                      func(context.Context) (*EarnBill, error)
	predicates                    []predicate.EarnBill
}

var _ ent.Mutation = (*EarnBillMutation)(nil)

// earnbillOption allows management of the mutation configuration using functional options.
type earnbillOption func(*EarnBillMutation)

// newEarnBillMutation creates new mutation for the EarnBill entity.
func newEarnBillMutation(c config, op Op, opts ...earnbillOption) *EarnBillMutation {
	m := &EarnBillMutation{
		config:        c,
		op:            op,
		typ:           TypeEarnBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEarnBillID sets the ID field of the mutation.
func withEarnBillID(id int64) earnbillOption {
	return func(m *EarnBillMutation) {
		var (
			err   error
			once  sync.Once
			value *EarnBill
		)
		m.oldValue = func(ctx context.Context) (*EarnBill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EarnBill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEarnBill sets the old EarnBill of the mutation.
func withEarnBill(node *EarnBill) earnbillOption {
	return func(m *EarnBillMutation) {
		m.oldValue = func(context.Context) (*EarnBill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EarnBillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EarnBillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EarnBill entities.
func (m *EarnBillMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EarnBillMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EarnBillMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EarnBill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *EarnBillMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EarnBillMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EarnBillMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EarnBillMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EarnBillMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EarnBillMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EarnBillMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EarnBillMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EarnBillMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EarnBillMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EarnBillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EarnBillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EarnBillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EarnBillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EarnBillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EarnBillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EarnBillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EarnBillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EarnBillMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *EarnBillMutation) SetType(e earnbill.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *EarnBillMutation) GetType() (r earnbill.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldType(ctx context.Context) (v earnbill.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EarnBillMutation) ResetType() {
	m._type = nil
}

// SetIsMinus sets the "is_minus" field.
func (m *EarnBillMutation) SetIsMinus(b bool) {
	m.is_minus = &b
}

// IsMinus returns the value of the "is_minus" field in the mutation.
func (m *EarnBillMutation) IsMinus() (r bool, exists bool) {
	v := m.is_minus
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMinus returns the old "is_minus" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldIsMinus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMinus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMinus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMinus: %w", err)
	}
	return oldValue.IsMinus, nil
}

// ResetIsMinus resets all changes to the "is_minus" field.
func (m *EarnBillMutation) ResetIsMinus() {
	m.is_minus = nil
}

// SetUserID sets the "user_id" field.
func (m *EarnBillMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EarnBillMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EarnBillMutation) ResetUserID() {
	m.user = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *EarnBillMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *EarnBillMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *EarnBillMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetProfitAccountID sets the "profit_account_id" field.
func (m *EarnBillMutation) SetProfitAccountID(i int64) {
	m.profit_account = &i
}

// ProfitAccountID returns the value of the "profit_account_id" field in the mutation.
func (m *EarnBillMutation) ProfitAccountID() (r int64, exists bool) {
	v := m.profit_account
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAccountID returns the old "profit_account_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldProfitAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAccountID: %w", err)
	}
	return oldValue.ProfitAccountID, nil
}

// ResetProfitAccountID resets all changes to the "profit_account_id" field.
func (m *EarnBillMutation) ResetProfitAccountID() {
	m.profit_account = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *EarnBillMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *EarnBillMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *EarnBillMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *EarnBillMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *EarnBillMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *EarnBillMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *EarnBillMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *EarnBillMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *EarnBillMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *EarnBillMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetPlatformAccountID sets the "platform_account_id" field.
func (m *EarnBillMutation) SetPlatformAccountID(i int64) {
	m.platform_account = &i
}

// PlatformAccountID returns the value of the "platform_account_id" field in the mutation.
func (m *EarnBillMutation) PlatformAccountID() (r int64, exists bool) {
	v := m.platform_account
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformAccountID returns the old "platform_account_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPlatformAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformAccountID: %w", err)
	}
	return oldValue.PlatformAccountID, nil
}

// ResetPlatformAccountID resets all changes to the "platform_account_id" field.
func (m *EarnBillMutation) ResetPlatformAccountID() {
	m.platform_account = nil
}

// SetPlatformPureCep sets the "platform_pure_cep" field.
func (m *EarnBillMutation) SetPlatformPureCep(i int64) {
	m.platform_pure_cep = &i
	m.addplatform_pure_cep = nil
}

// PlatformPureCep returns the value of the "platform_pure_cep" field in the mutation.
func (m *EarnBillMutation) PlatformPureCep() (r int64, exists bool) {
	v := m.platform_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformPureCep returns the old "platform_pure_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPlatformPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformPureCep: %w", err)
	}
	return oldValue.PlatformPureCep, nil
}

// AddPlatformPureCep adds i to the "platform_pure_cep" field.
func (m *EarnBillMutation) AddPlatformPureCep(i int64) {
	if m.addplatform_pure_cep != nil {
		*m.addplatform_pure_cep += i
	} else {
		m.addplatform_pure_cep = &i
	}
}

// AddedPlatformPureCep returns the value that was added to the "platform_pure_cep" field in this mutation.
func (m *EarnBillMutation) AddedPlatformPureCep() (r int64, exists bool) {
	v := m.addplatform_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformPureCep resets all changes to the "platform_pure_cep" field.
func (m *EarnBillMutation) ResetPlatformPureCep() {
	m.platform_pure_cep = nil
	m.addplatform_pure_cep = nil
}

// SetPlatformGiftCep sets the "platform_gift_cep" field.
func (m *EarnBillMutation) SetPlatformGiftCep(i int64) {
	m.platform_gift_cep = &i
	m.addplatform_gift_cep = nil
}

// PlatformGiftCep returns the value of the "platform_gift_cep" field in the mutation.
func (m *EarnBillMutation) PlatformGiftCep() (r int64, exists bool) {
	v := m.platform_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformGiftCep returns the old "platform_gift_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPlatformGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformGiftCep: %w", err)
	}
	return oldValue.PlatformGiftCep, nil
}

// AddPlatformGiftCep adds i to the "platform_gift_cep" field.
func (m *EarnBillMutation) AddPlatformGiftCep(i int64) {
	if m.addplatform_gift_cep != nil {
		*m.addplatform_gift_cep += i
	} else {
		m.addplatform_gift_cep = &i
	}
}

// AddedPlatformGiftCep returns the value that was added to the "platform_gift_cep" field in this mutation.
func (m *EarnBillMutation) AddedPlatformGiftCep() (r int64, exists bool) {
	v := m.addplatform_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformGiftCep resets all changes to the "platform_gift_cep" field.
func (m *EarnBillMutation) ResetPlatformGiftCep() {
	m.platform_gift_cep = nil
	m.addplatform_gift_cep = nil
}

// SetReasonID sets the "reason_id" field.
func (m *EarnBillMutation) SetReasonID(i int64) {
	m.mission_produce_orders = &i
}

// ReasonID returns the value of the "reason_id" field in the mutation.
func (m *EarnBillMutation) ReasonID() (r int64, exists bool) {
	v := m.mission_produce_orders
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonID returns the old "reason_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldReasonID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonID: %w", err)
	}
	return oldValue.ReasonID, nil
}

// ClearReasonID clears the value of the "reason_id" field.
func (m *EarnBillMutation) ClearReasonID() {
	m.mission_produce_orders = nil
	m.clearedFields[earnbill.FieldReasonID] = struct{}{}
}

// ReasonIDCleared returns if the "reason_id" field was cleared in this mutation.
func (m *EarnBillMutation) ReasonIDCleared() bool {
	_, ok := m.clearedFields[earnbill.FieldReasonID]
	return ok
}

// ResetReasonID resets all changes to the "reason_id" field.
func (m *EarnBillMutation) ResetReasonID() {
	m.mission_produce_orders = nil
	delete(m.clearedFields, earnbill.FieldReasonID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *EarnBillMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[earnbill.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EarnBillMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EarnBillMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProfitAccount clears the "profit_account" edge to the ProfitAccount entity.
func (m *EarnBillMutation) ClearProfitAccount() {
	m.clearedprofit_account = true
	m.clearedFields[earnbill.FieldProfitAccountID] = struct{}{}
}

// ProfitAccountCleared reports if the "profit_account" edge to the ProfitAccount entity was cleared.
func (m *EarnBillMutation) ProfitAccountCleared() bool {
	return m.clearedprofit_account
}

// ProfitAccountIDs returns the "profit_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfitAccountID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) ProfitAccountIDs() (ids []int64) {
	if id := m.profit_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfitAccount resets all changes to the "profit_account" edge.
func (m *EarnBillMutation) ResetProfitAccount() {
	m.profit_account = nil
	m.clearedprofit_account = false
}

// ClearPlatformAccount clears the "platform_account" edge to the PlatformAccount entity.
func (m *EarnBillMutation) ClearPlatformAccount() {
	m.clearedplatform_account = true
	m.clearedFields[earnbill.FieldPlatformAccountID] = struct{}{}
}

// PlatformAccountCleared reports if the "platform_account" edge to the PlatformAccount entity was cleared.
func (m *EarnBillMutation) PlatformAccountCleared() bool {
	return m.clearedplatform_account
}

// PlatformAccountIDs returns the "platform_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlatformAccountID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) PlatformAccountIDs() (ids []int64) {
	if id := m.platform_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlatformAccount resets all changes to the "platform_account" edge.
func (m *EarnBillMutation) ResetPlatformAccount() {
	m.platform_account = nil
	m.clearedplatform_account = false
}

// SetMissionProduceOrdersID sets the "mission_produce_orders" edge to the MissionProduceOrder entity by id.
func (m *EarnBillMutation) SetMissionProduceOrdersID(id int64) {
	m.mission_produce_orders = &id
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *EarnBillMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
	m.clearedFields[earnbill.FieldReasonID] = struct{}{}
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *EarnBillMutation) MissionProduceOrdersCleared() bool {
	return m.ReasonIDCleared() || m.clearedmission_produce_orders
}

// MissionProduceOrdersID returns the "mission_produce_orders" edge ID in the mutation.
func (m *EarnBillMutation) MissionProduceOrdersID() (id int64, exists bool) {
	if m.mission_produce_orders != nil {
		return *m.mission_produce_orders, true
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionProduceOrdersID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) MissionProduceOrdersIDs() (ids []int64) {
	if id := m.mission_produce_orders; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *EarnBillMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
}

// Where appends a list predicates to the EarnBillMutation builder.
func (m *EarnBillMutation) Where(ps ...predicate.EarnBill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EarnBillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EarnBillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EarnBill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EarnBillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EarnBillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EarnBill).
func (m *EarnBillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EarnBillMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, earnbill.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, earnbill.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, earnbill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, earnbill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, earnbill.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, earnbill.FieldType)
	}
	if m.is_minus != nil {
		fields = append(fields, earnbill.FieldIsMinus)
	}
	if m.user != nil {
		fields = append(fields, earnbill.FieldUserID)
	}
	if m.serial_number != nil {
		fields = append(fields, earnbill.FieldSerialNumber)
	}
	if m.profit_account != nil {
		fields = append(fields, earnbill.FieldProfitAccountID)
	}
	if m.pure_cep != nil {
		fields = append(fields, earnbill.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, earnbill.FieldGiftCep)
	}
	if m.platform_account != nil {
		fields = append(fields, earnbill.FieldPlatformAccountID)
	}
	if m.platform_pure_cep != nil {
		fields = append(fields, earnbill.FieldPlatformPureCep)
	}
	if m.platform_gift_cep != nil {
		fields = append(fields, earnbill.FieldPlatformGiftCep)
	}
	if m.mission_produce_orders != nil {
		fields = append(fields, earnbill.FieldReasonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EarnBillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case earnbill.FieldCreatedBy:
		return m.CreatedBy()
	case earnbill.FieldUpdatedBy:
		return m.UpdatedBy()
	case earnbill.FieldCreatedAt:
		return m.CreatedAt()
	case earnbill.FieldUpdatedAt:
		return m.UpdatedAt()
	case earnbill.FieldDeletedAt:
		return m.DeletedAt()
	case earnbill.FieldType:
		return m.GetType()
	case earnbill.FieldIsMinus:
		return m.IsMinus()
	case earnbill.FieldUserID:
		return m.UserID()
	case earnbill.FieldSerialNumber:
		return m.SerialNumber()
	case earnbill.FieldProfitAccountID:
		return m.ProfitAccountID()
	case earnbill.FieldPureCep:
		return m.PureCep()
	case earnbill.FieldGiftCep:
		return m.GiftCep()
	case earnbill.FieldPlatformAccountID:
		return m.PlatformAccountID()
	case earnbill.FieldPlatformPureCep:
		return m.PlatformPureCep()
	case earnbill.FieldPlatformGiftCep:
		return m.PlatformGiftCep()
	case earnbill.FieldReasonID:
		return m.ReasonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EarnBillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case earnbill.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case earnbill.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case earnbill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case earnbill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case earnbill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case earnbill.FieldType:
		return m.OldType(ctx)
	case earnbill.FieldIsMinus:
		return m.OldIsMinus(ctx)
	case earnbill.FieldUserID:
		return m.OldUserID(ctx)
	case earnbill.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case earnbill.FieldProfitAccountID:
		return m.OldProfitAccountID(ctx)
	case earnbill.FieldPureCep:
		return m.OldPureCep(ctx)
	case earnbill.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case earnbill.FieldPlatformAccountID:
		return m.OldPlatformAccountID(ctx)
	case earnbill.FieldPlatformPureCep:
		return m.OldPlatformPureCep(ctx)
	case earnbill.FieldPlatformGiftCep:
		return m.OldPlatformGiftCep(ctx)
	case earnbill.FieldReasonID:
		return m.OldReasonID(ctx)
	}
	return nil, fmt.Errorf("unknown EarnBill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarnBillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case earnbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case earnbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case earnbill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case earnbill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case earnbill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case earnbill.FieldType:
		v, ok := value.(earnbill.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case earnbill.FieldIsMinus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMinus(v)
		return nil
	case earnbill.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case earnbill.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case earnbill.FieldProfitAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAccountID(v)
		return nil
	case earnbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case earnbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case earnbill.FieldPlatformAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformAccountID(v)
		return nil
	case earnbill.FieldPlatformPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformPureCep(v)
		return nil
	case earnbill.FieldPlatformGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformGiftCep(v)
		return nil
	case earnbill.FieldReasonID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonID(v)
		return nil
	}
	return fmt.Errorf("unknown EarnBill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EarnBillMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, earnbill.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, earnbill.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, earnbill.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, earnbill.FieldGiftCep)
	}
	if m.addplatform_pure_cep != nil {
		fields = append(fields, earnbill.FieldPlatformPureCep)
	}
	if m.addplatform_gift_cep != nil {
		fields = append(fields, earnbill.FieldPlatformGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EarnBillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case earnbill.FieldCreatedBy:
		return m.AddedCreatedBy()
	case earnbill.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case earnbill.FieldPureCep:
		return m.AddedPureCep()
	case earnbill.FieldGiftCep:
		return m.AddedGiftCep()
	case earnbill.FieldPlatformPureCep:
		return m.AddedPlatformPureCep()
	case earnbill.FieldPlatformGiftCep:
		return m.AddedPlatformGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarnBillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case earnbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case earnbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case earnbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case earnbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case earnbill.FieldPlatformPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatformPureCep(v)
		return nil
	case earnbill.FieldPlatformGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatformGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown EarnBill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EarnBillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(earnbill.FieldReasonID) {
		fields = append(fields, earnbill.FieldReasonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EarnBillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EarnBillMutation) ClearField(name string) error {
	switch name {
	case earnbill.FieldReasonID:
		m.ClearReasonID()
		return nil
	}
	return fmt.Errorf("unknown EarnBill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EarnBillMutation) ResetField(name string) error {
	switch name {
	case earnbill.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case earnbill.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case earnbill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case earnbill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case earnbill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case earnbill.FieldType:
		m.ResetType()
		return nil
	case earnbill.FieldIsMinus:
		m.ResetIsMinus()
		return nil
	case earnbill.FieldUserID:
		m.ResetUserID()
		return nil
	case earnbill.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case earnbill.FieldProfitAccountID:
		m.ResetProfitAccountID()
		return nil
	case earnbill.FieldPureCep:
		m.ResetPureCep()
		return nil
	case earnbill.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case earnbill.FieldPlatformAccountID:
		m.ResetPlatformAccountID()
		return nil
	case earnbill.FieldPlatformPureCep:
		m.ResetPlatformPureCep()
		return nil
	case earnbill.FieldPlatformGiftCep:
		m.ResetPlatformGiftCep()
		return nil
	case earnbill.FieldReasonID:
		m.ResetReasonID()
		return nil
	}
	return fmt.Errorf("unknown EarnBill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EarnBillMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, earnbill.EdgeUser)
	}
	if m.profit_account != nil {
		edges = append(edges, earnbill.EdgeProfitAccount)
	}
	if m.platform_account != nil {
		edges = append(edges, earnbill.EdgePlatformAccount)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, earnbill.EdgeMissionProduceOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EarnBillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case earnbill.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case earnbill.EdgeProfitAccount:
		if id := m.profit_account; id != nil {
			return []ent.Value{*id}
		}
	case earnbill.EdgePlatformAccount:
		if id := m.platform_account; id != nil {
			return []ent.Value{*id}
		}
	case earnbill.EdgeMissionProduceOrders:
		if id := m.mission_produce_orders; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EarnBillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EarnBillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EarnBillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, earnbill.EdgeUser)
	}
	if m.clearedprofit_account {
		edges = append(edges, earnbill.EdgeProfitAccount)
	}
	if m.clearedplatform_account {
		edges = append(edges, earnbill.EdgePlatformAccount)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, earnbill.EdgeMissionProduceOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EarnBillMutation) EdgeCleared(name string) bool {
	switch name {
	case earnbill.EdgeUser:
		return m.cleareduser
	case earnbill.EdgeProfitAccount:
		return m.clearedprofit_account
	case earnbill.EdgePlatformAccount:
		return m.clearedplatform_account
	case earnbill.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EarnBillMutation) ClearEdge(name string) error {
	switch name {
	case earnbill.EdgeUser:
		m.ClearUser()
		return nil
	case earnbill.EdgeProfitAccount:
		m.ClearProfitAccount()
		return nil
	case earnbill.EdgePlatformAccount:
		m.ClearPlatformAccount()
		return nil
	case earnbill.EdgeMissionProduceOrders:
		m.ClearMissionProduceOrders()
		return nil
	}
	return fmt.Errorf("unknown EarnBill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EarnBillMutation) ResetEdge(name string) error {
	switch name {
	case earnbill.EdgeUser:
		m.ResetUser()
		return nil
	case earnbill.EdgeProfitAccount:
		m.ResetProfitAccount()
		return nil
	case earnbill.EdgePlatformAccount:
		m.ResetPlatformAccount()
		return nil
	case earnbill.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	}
	return fmt.Errorf("unknown EarnBill edge %s", name)
}

// EnumConditionMutation represents an operation that mutates the EnumCondition nodes in the graph.
type EnumConditionMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_by       *int64
	addcreated_by    *int64
	updated_by       *int64
	addupdated_by    *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	front_type       *string
	mission_type     *string
	mission_call_way *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*EnumCondition, error)
	predicates       []predicate.EnumCondition
}

var _ ent.Mutation = (*EnumConditionMutation)(nil)

// enumconditionOption allows management of the mutation configuration using functional options.
type enumconditionOption func(*EnumConditionMutation)

// newEnumConditionMutation creates new mutation for the EnumCondition entity.
func newEnumConditionMutation(c config, op Op, opts ...enumconditionOption) *EnumConditionMutation {
	m := &EnumConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeEnumCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnumConditionID sets the ID field of the mutation.
func withEnumConditionID(id int64) enumconditionOption {
	return func(m *EnumConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *EnumCondition
		)
		m.oldValue = func(ctx context.Context) (*EnumCondition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnumCondition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnumCondition sets the old EnumCondition of the mutation.
func withEnumCondition(node *EnumCondition) enumconditionOption {
	return func(m *EnumConditionMutation) {
		m.oldValue = func(context.Context) (*EnumCondition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnumConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnumConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnumCondition entities.
func (m *EnumConditionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnumConditionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnumConditionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnumCondition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *EnumConditionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EnumConditionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EnumConditionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EnumConditionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EnumConditionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EnumConditionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EnumConditionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EnumConditionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EnumConditionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EnumConditionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EnumConditionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnumConditionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnumConditionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnumConditionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnumConditionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnumConditionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnumConditionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnumConditionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnumConditionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetFrontType sets the "front_type" field.
func (m *EnumConditionMutation) SetFrontType(s string) {
	m.front_type = &s
}

// FrontType returns the value of the "front_type" field in the mutation.
func (m *EnumConditionMutation) FrontType() (r string, exists bool) {
	v := m.front_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFrontType returns the old "front_type" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldFrontType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrontType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrontType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrontType: %w", err)
	}
	return oldValue.FrontType, nil
}

// ResetFrontType resets all changes to the "front_type" field.
func (m *EnumConditionMutation) ResetFrontType() {
	m.front_type = nil
}

// SetMissionType sets the "mission_type" field.
func (m *EnumConditionMutation) SetMissionType(s string) {
	m.mission_type = &s
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *EnumConditionMutation) MissionType() (r string, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldMissionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *EnumConditionMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionCallWay sets the "mission_call_way" field.
func (m *EnumConditionMutation) SetMissionCallWay(s string) {
	m.mission_call_way = &s
}

// MissionCallWay returns the value of the "mission_call_way" field in the mutation.
func (m *EnumConditionMutation) MissionCallWay() (r string, exists bool) {
	v := m.mission_call_way
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionCallWay returns the old "mission_call_way" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldMissionCallWay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionCallWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionCallWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionCallWay: %w", err)
	}
	return oldValue.MissionCallWay, nil
}

// ResetMissionCallWay resets all changes to the "mission_call_way" field.
func (m *EnumConditionMutation) ResetMissionCallWay() {
	m.mission_call_way = nil
}

// Where appends a list predicates to the EnumConditionMutation builder.
func (m *EnumConditionMutation) Where(ps ...predicate.EnumCondition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnumConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnumConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnumCondition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnumConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnumConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnumCondition).
func (m *EnumConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnumConditionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, enumcondition.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, enumcondition.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, enumcondition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enumcondition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enumcondition.FieldDeletedAt)
	}
	if m.front_type != nil {
		fields = append(fields, enumcondition.FieldFrontType)
	}
	if m.mission_type != nil {
		fields = append(fields, enumcondition.FieldMissionType)
	}
	if m.mission_call_way != nil {
		fields = append(fields, enumcondition.FieldMissionCallWay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnumConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enumcondition.FieldCreatedBy:
		return m.CreatedBy()
	case enumcondition.FieldUpdatedBy:
		return m.UpdatedBy()
	case enumcondition.FieldCreatedAt:
		return m.CreatedAt()
	case enumcondition.FieldUpdatedAt:
		return m.UpdatedAt()
	case enumcondition.FieldDeletedAt:
		return m.DeletedAt()
	case enumcondition.FieldFrontType:
		return m.FrontType()
	case enumcondition.FieldMissionType:
		return m.MissionType()
	case enumcondition.FieldMissionCallWay:
		return m.MissionCallWay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnumConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enumcondition.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case enumcondition.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case enumcondition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enumcondition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enumcondition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enumcondition.FieldFrontType:
		return m.OldFrontType(ctx)
	case enumcondition.FieldMissionType:
		return m.OldMissionType(ctx)
	case enumcondition.FieldMissionCallWay:
		return m.OldMissionCallWay(ctx)
	}
	return nil, fmt.Errorf("unknown EnumCondition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enumcondition.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case enumcondition.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case enumcondition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enumcondition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enumcondition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enumcondition.FieldFrontType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrontType(v)
		return nil
	case enumcondition.FieldMissionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case enumcondition.FieldMissionCallWay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionCallWay(v)
		return nil
	}
	return fmt.Errorf("unknown EnumCondition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnumConditionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, enumcondition.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, enumcondition.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnumConditionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enumcondition.FieldCreatedBy:
		return m.AddedCreatedBy()
	case enumcondition.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enumcondition.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case enumcondition.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown EnumCondition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnumConditionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnumConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnumConditionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnumCondition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnumConditionMutation) ResetField(name string) error {
	switch name {
	case enumcondition.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case enumcondition.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case enumcondition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enumcondition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enumcondition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enumcondition.FieldFrontType:
		m.ResetFrontType()
		return nil
	case enumcondition.FieldMissionType:
		m.ResetMissionType()
		return nil
	case enumcondition.FieldMissionCallWay:
		m.ResetMissionCallWay()
		return nil
	}
	return fmt.Errorf("unknown EnumCondition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnumConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnumConditionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnumConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnumConditionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnumConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnumConditionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnumConditionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EnumCondition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnumConditionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EnumCondition edge %s", name)
}

// EnumMissionStatusMutation represents an operation that mutates the EnumMissionStatus nodes in the graph.
type EnumMissionStatusMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_by     *int64
	addcreated_by  *int64
	updated_by     *int64
	addupdated_by  *int64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	front_status   *string
	mission_type   *string
	mission_status *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*EnumMissionStatus, error)
	predicates     []predicate.EnumMissionStatus
}

var _ ent.Mutation = (*EnumMissionStatusMutation)(nil)

// enummissionstatusOption allows management of the mutation configuration using functional options.
type enummissionstatusOption func(*EnumMissionStatusMutation)

// newEnumMissionStatusMutation creates new mutation for the EnumMissionStatus entity.
func newEnumMissionStatusMutation(c config, op Op, opts ...enummissionstatusOption) *EnumMissionStatusMutation {
	m := &EnumMissionStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeEnumMissionStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnumMissionStatusID sets the ID field of the mutation.
func withEnumMissionStatusID(id int64) enummissionstatusOption {
	return func(m *EnumMissionStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *EnumMissionStatus
		)
		m.oldValue = func(ctx context.Context) (*EnumMissionStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnumMissionStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnumMissionStatus sets the old EnumMissionStatus of the mutation.
func withEnumMissionStatus(node *EnumMissionStatus) enummissionstatusOption {
	return func(m *EnumMissionStatusMutation) {
		m.oldValue = func(context.Context) (*EnumMissionStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnumMissionStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnumMissionStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnumMissionStatus entities.
func (m *EnumMissionStatusMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnumMissionStatusMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnumMissionStatusMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnumMissionStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *EnumMissionStatusMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EnumMissionStatusMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EnumMissionStatusMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EnumMissionStatusMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EnumMissionStatusMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EnumMissionStatusMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EnumMissionStatusMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EnumMissionStatusMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EnumMissionStatusMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EnumMissionStatusMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EnumMissionStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnumMissionStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnumMissionStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnumMissionStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnumMissionStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnumMissionStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnumMissionStatusMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnumMissionStatusMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnumMissionStatusMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetFrontStatus sets the "front_status" field.
func (m *EnumMissionStatusMutation) SetFrontStatus(s string) {
	m.front_status = &s
}

// FrontStatus returns the value of the "front_status" field in the mutation.
func (m *EnumMissionStatusMutation) FrontStatus() (r string, exists bool) {
	v := m.front_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFrontStatus returns the old "front_status" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldFrontStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrontStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrontStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrontStatus: %w", err)
	}
	return oldValue.FrontStatus, nil
}

// ResetFrontStatus resets all changes to the "front_status" field.
func (m *EnumMissionStatusMutation) ResetFrontStatus() {
	m.front_status = nil
}

// SetMissionType sets the "mission_type" field.
func (m *EnumMissionStatusMutation) SetMissionType(s string) {
	m.mission_type = &s
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *EnumMissionStatusMutation) MissionType() (r string, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldMissionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *EnumMissionStatusMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionStatus sets the "mission_status" field.
func (m *EnumMissionStatusMutation) SetMissionStatus(s string) {
	m.mission_status = &s
}

// MissionStatus returns the value of the "mission_status" field in the mutation.
func (m *EnumMissionStatusMutation) MissionStatus() (r string, exists bool) {
	v := m.mission_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionStatus returns the old "mission_status" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldMissionStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionStatus: %w", err)
	}
	return oldValue.MissionStatus, nil
}

// ResetMissionStatus resets all changes to the "mission_status" field.
func (m *EnumMissionStatusMutation) ResetMissionStatus() {
	m.mission_status = nil
}

// Where appends a list predicates to the EnumMissionStatusMutation builder.
func (m *EnumMissionStatusMutation) Where(ps ...predicate.EnumMissionStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnumMissionStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnumMissionStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnumMissionStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnumMissionStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnumMissionStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnumMissionStatus).
func (m *EnumMissionStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnumMissionStatusMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, enummissionstatus.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, enummissionstatus.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, enummissionstatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enummissionstatus.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enummissionstatus.FieldDeletedAt)
	}
	if m.front_status != nil {
		fields = append(fields, enummissionstatus.FieldFrontStatus)
	}
	if m.mission_type != nil {
		fields = append(fields, enummissionstatus.FieldMissionType)
	}
	if m.mission_status != nil {
		fields = append(fields, enummissionstatus.FieldMissionStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnumMissionStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		return m.CreatedBy()
	case enummissionstatus.FieldUpdatedBy:
		return m.UpdatedBy()
	case enummissionstatus.FieldCreatedAt:
		return m.CreatedAt()
	case enummissionstatus.FieldUpdatedAt:
		return m.UpdatedAt()
	case enummissionstatus.FieldDeletedAt:
		return m.DeletedAt()
	case enummissionstatus.FieldFrontStatus:
		return m.FrontStatus()
	case enummissionstatus.FieldMissionType:
		return m.MissionType()
	case enummissionstatus.FieldMissionStatus:
		return m.MissionStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnumMissionStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case enummissionstatus.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case enummissionstatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enummissionstatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enummissionstatus.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enummissionstatus.FieldFrontStatus:
		return m.OldFrontStatus(ctx)
	case enummissionstatus.FieldMissionType:
		return m.OldMissionType(ctx)
	case enummissionstatus.FieldMissionStatus:
		return m.OldMissionStatus(ctx)
	}
	return nil, fmt.Errorf("unknown EnumMissionStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumMissionStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case enummissionstatus.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case enummissionstatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enummissionstatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enummissionstatus.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enummissionstatus.FieldFrontStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrontStatus(v)
		return nil
	case enummissionstatus.FieldMissionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case enummissionstatus.FieldMissionStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EnumMissionStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnumMissionStatusMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, enummissionstatus.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, enummissionstatus.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnumMissionStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		return m.AddedCreatedBy()
	case enummissionstatus.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumMissionStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case enummissionstatus.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown EnumMissionStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnumMissionStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnumMissionStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnumMissionStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnumMissionStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnumMissionStatusMutation) ResetField(name string) error {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case enummissionstatus.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case enummissionstatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enummissionstatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enummissionstatus.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enummissionstatus.FieldFrontStatus:
		m.ResetFrontStatus()
		return nil
	case enummissionstatus.FieldMissionType:
		m.ResetMissionType()
		return nil
	case enummissionstatus.FieldMissionStatus:
		m.ResetMissionStatus()
		return nil
	}
	return fmt.Errorf("unknown EnumMissionStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnumMissionStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnumMissionStatusMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnumMissionStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnumMissionStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnumMissionStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnumMissionStatusMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnumMissionStatusMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EnumMissionStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnumMissionStatusMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EnumMissionStatus edge %s", name)
}

// ExtraServiceMutation represents an operation that mutates the ExtraService nodes in the graph.
type ExtraServiceMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	name                          *string
	extra_service_type            *enums.ExtraServiceType
	started_at                    *time.Time
	finished_at                   *time.Time
	clearedFields                 map[string]struct{}
	missions                      map[int64]struct{}
	removedmissions               map[int64]struct{}
	clearedmissions               bool
	mission_extra_services        map[int64]struct{}
	removedmission_extra_services map[int64]struct{}
	clearedmission_extra_services bool
	extra_service_prices          map[int64]struct{}
	removedextra_service_prices   map[int64]struct{}
	clearedextra_service_prices   bool
	done                          bool
	oldValue                      func(context.Context) (*ExtraService, error)
	predicates                    []predicate.ExtraService
}

var _ ent.Mutation = (*ExtraServiceMutation)(nil)

// extraserviceOption allows management of the mutation configuration using functional options.
type extraserviceOption func(*ExtraServiceMutation)

// newExtraServiceMutation creates new mutation for the ExtraService entity.
func newExtraServiceMutation(c config, op Op, opts ...extraserviceOption) *ExtraServiceMutation {
	m := &ExtraServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeExtraService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtraServiceID sets the ID field of the mutation.
func withExtraServiceID(id int64) extraserviceOption {
	return func(m *ExtraServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *ExtraService
		)
		m.oldValue = func(ctx context.Context) (*ExtraService, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExtraService.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtraService sets the old ExtraService of the mutation.
func withExtraService(node *ExtraService) extraserviceOption {
	return func(m *ExtraServiceMutation) {
		m.oldValue = func(context.Context) (*ExtraService, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtraServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtraServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExtraService entities.
func (m *ExtraServiceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtraServiceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtraServiceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExtraService.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ExtraServiceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ExtraServiceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ExtraServiceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ExtraServiceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ExtraServiceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ExtraServiceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ExtraServiceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ExtraServiceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ExtraServiceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ExtraServiceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExtraServiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExtraServiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExtraServiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExtraServiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExtraServiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExtraServiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExtraServiceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExtraServiceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExtraServiceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *ExtraServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExtraServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExtraServiceMutation) ResetName() {
	m.name = nil
}

// SetExtraServiceType sets the "extra_service_type" field.
func (m *ExtraServiceMutation) SetExtraServiceType(est enums.ExtraServiceType) {
	m.extra_service_type = &est
}

// ExtraServiceType returns the value of the "extra_service_type" field in the mutation.
func (m *ExtraServiceMutation) ExtraServiceType() (r enums.ExtraServiceType, exists bool) {
	v := m.extra_service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceType returns the old "extra_service_type" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldExtraServiceType(ctx context.Context) (v enums.ExtraServiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceType: %w", err)
	}
	return oldValue.ExtraServiceType, nil
}

// ResetExtraServiceType resets all changes to the "extra_service_type" field.
func (m *ExtraServiceMutation) ResetExtraServiceType() {
	m.extra_service_type = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ExtraServiceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ExtraServiceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *ExtraServiceMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[extraservice.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *ExtraServiceMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[extraservice.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ExtraServiceMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, extraservice.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *ExtraServiceMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ExtraServiceMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *ExtraServiceMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[extraservice.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *ExtraServiceMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[extraservice.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ExtraServiceMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, extraservice.FieldFinishedAt)
}

// AddMissionIDs adds the "missions" edge to the Mission entity by ids.
func (m *ExtraServiceMutation) AddMissionIDs(ids ...int64) {
	if m.missions == nil {
		m.missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.missions[ids[i]] = struct{}{}
	}
}

// ClearMissions clears the "missions" edge to the Mission entity.
func (m *ExtraServiceMutation) ClearMissions() {
	m.clearedmissions = true
}

// MissionsCleared reports if the "missions" edge to the Mission entity was cleared.
func (m *ExtraServiceMutation) MissionsCleared() bool {
	return m.clearedmissions
}

// RemoveMissionIDs removes the "missions" edge to the Mission entity by IDs.
func (m *ExtraServiceMutation) RemoveMissionIDs(ids ...int64) {
	if m.removedmissions == nil {
		m.removedmissions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.missions, ids[i])
		m.removedmissions[ids[i]] = struct{}{}
	}
}

// RemovedMissions returns the removed IDs of the "missions" edge to the Mission entity.
func (m *ExtraServiceMutation) RemovedMissionsIDs() (ids []int64) {
	for id := range m.removedmissions {
		ids = append(ids, id)
	}
	return
}

// MissionsIDs returns the "missions" edge IDs in the mutation.
func (m *ExtraServiceMutation) MissionsIDs() (ids []int64) {
	for id := range m.missions {
		ids = append(ids, id)
	}
	return
}

// ResetMissions resets all changes to the "missions" edge.
func (m *ExtraServiceMutation) ResetMissions() {
	m.missions = nil
	m.clearedmissions = false
	m.removedmissions = nil
}

// AddMissionExtraServiceIDs adds the "mission_extra_services" edge to the MissionExtraService entity by ids.
func (m *ExtraServiceMutation) AddMissionExtraServiceIDs(ids ...int64) {
	if m.mission_extra_services == nil {
		m.mission_extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_extra_services[ids[i]] = struct{}{}
	}
}

// ClearMissionExtraServices clears the "mission_extra_services" edge to the MissionExtraService entity.
func (m *ExtraServiceMutation) ClearMissionExtraServices() {
	m.clearedmission_extra_services = true
}

// MissionExtraServicesCleared reports if the "mission_extra_services" edge to the MissionExtraService entity was cleared.
func (m *ExtraServiceMutation) MissionExtraServicesCleared() bool {
	return m.clearedmission_extra_services
}

// RemoveMissionExtraServiceIDs removes the "mission_extra_services" edge to the MissionExtraService entity by IDs.
func (m *ExtraServiceMutation) RemoveMissionExtraServiceIDs(ids ...int64) {
	if m.removedmission_extra_services == nil {
		m.removedmission_extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_extra_services, ids[i])
		m.removedmission_extra_services[ids[i]] = struct{}{}
	}
}

// RemovedMissionExtraServices returns the removed IDs of the "mission_extra_services" edge to the MissionExtraService entity.
func (m *ExtraServiceMutation) RemovedMissionExtraServicesIDs() (ids []int64) {
	for id := range m.removedmission_extra_services {
		ids = append(ids, id)
	}
	return
}

// MissionExtraServicesIDs returns the "mission_extra_services" edge IDs in the mutation.
func (m *ExtraServiceMutation) MissionExtraServicesIDs() (ids []int64) {
	for id := range m.mission_extra_services {
		ids = append(ids, id)
	}
	return
}

// ResetMissionExtraServices resets all changes to the "mission_extra_services" edge.
func (m *ExtraServiceMutation) ResetMissionExtraServices() {
	m.mission_extra_services = nil
	m.clearedmission_extra_services = false
	m.removedmission_extra_services = nil
}

// AddExtraServicePriceIDs adds the "extra_service_prices" edge to the ExtraServicePrice entity by ids.
func (m *ExtraServiceMutation) AddExtraServicePriceIDs(ids ...int64) {
	if m.extra_service_prices == nil {
		m.extra_service_prices = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_prices[ids[i]] = struct{}{}
	}
}

// ClearExtraServicePrices clears the "extra_service_prices" edge to the ExtraServicePrice entity.
func (m *ExtraServiceMutation) ClearExtraServicePrices() {
	m.clearedextra_service_prices = true
}

// ExtraServicePricesCleared reports if the "extra_service_prices" edge to the ExtraServicePrice entity was cleared.
func (m *ExtraServiceMutation) ExtraServicePricesCleared() bool {
	return m.clearedextra_service_prices
}

// RemoveExtraServicePriceIDs removes the "extra_service_prices" edge to the ExtraServicePrice entity by IDs.
func (m *ExtraServiceMutation) RemoveExtraServicePriceIDs(ids ...int64) {
	if m.removedextra_service_prices == nil {
		m.removedextra_service_prices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_prices, ids[i])
		m.removedextra_service_prices[ids[i]] = struct{}{}
	}
}

// RemovedExtraServicePrices returns the removed IDs of the "extra_service_prices" edge to the ExtraServicePrice entity.
func (m *ExtraServiceMutation) RemovedExtraServicePricesIDs() (ids []int64) {
	for id := range m.removedextra_service_prices {
		ids = append(ids, id)
	}
	return
}

// ExtraServicePricesIDs returns the "extra_service_prices" edge IDs in the mutation.
func (m *ExtraServiceMutation) ExtraServicePricesIDs() (ids []int64) {
	for id := range m.extra_service_prices {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServicePrices resets all changes to the "extra_service_prices" edge.
func (m *ExtraServiceMutation) ResetExtraServicePrices() {
	m.extra_service_prices = nil
	m.clearedextra_service_prices = false
	m.removedextra_service_prices = nil
}

// Where appends a list predicates to the ExtraServiceMutation builder.
func (m *ExtraServiceMutation) Where(ps ...predicate.ExtraService) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExtraServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExtraServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExtraService, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExtraServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExtraServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExtraService).
func (m *ExtraServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtraServiceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, extraservice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, extraservice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, extraservice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, extraservice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, extraservice.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, extraservice.FieldName)
	}
	if m.extra_service_type != nil {
		fields = append(fields, extraservice.FieldExtraServiceType)
	}
	if m.started_at != nil {
		fields = append(fields, extraservice.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, extraservice.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtraServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extraservice.FieldCreatedBy:
		return m.CreatedBy()
	case extraservice.FieldUpdatedBy:
		return m.UpdatedBy()
	case extraservice.FieldCreatedAt:
		return m.CreatedAt()
	case extraservice.FieldUpdatedAt:
		return m.UpdatedAt()
	case extraservice.FieldDeletedAt:
		return m.DeletedAt()
	case extraservice.FieldName:
		return m.Name()
	case extraservice.FieldExtraServiceType:
		return m.ExtraServiceType()
	case extraservice.FieldStartedAt:
		return m.StartedAt()
	case extraservice.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtraServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extraservice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case extraservice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case extraservice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case extraservice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case extraservice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case extraservice.FieldName:
		return m.OldName(ctx)
	case extraservice.FieldExtraServiceType:
		return m.OldExtraServiceType(ctx)
	case extraservice.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case extraservice.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ExtraService field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extraservice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case extraservice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case extraservice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case extraservice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case extraservice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case extraservice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case extraservice.FieldExtraServiceType:
		v, ok := value.(enums.ExtraServiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceType(v)
		return nil
	case extraservice.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case extraservice.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraService field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtraServiceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, extraservice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, extraservice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtraServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case extraservice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case extraservice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case extraservice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case extraservice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraService numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtraServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extraservice.FieldStartedAt) {
		fields = append(fields, extraservice.FieldStartedAt)
	}
	if m.FieldCleared(extraservice.FieldFinishedAt) {
		fields = append(fields, extraservice.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtraServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtraServiceMutation) ClearField(name string) error {
	switch name {
	case extraservice.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case extraservice.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraService nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtraServiceMutation) ResetField(name string) error {
	switch name {
	case extraservice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case extraservice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case extraservice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case extraservice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case extraservice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case extraservice.FieldName:
		m.ResetName()
		return nil
	case extraservice.FieldExtraServiceType:
		m.ResetExtraServiceType()
		return nil
	case extraservice.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case extraservice.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraService field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtraServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.missions != nil {
		edges = append(edges, extraservice.EdgeMissions)
	}
	if m.mission_extra_services != nil {
		edges = append(edges, extraservice.EdgeMissionExtraServices)
	}
	if m.extra_service_prices != nil {
		edges = append(edges, extraservice.EdgeExtraServicePrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtraServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case extraservice.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.missions))
		for id := range m.missions {
			ids = append(ids, id)
		}
		return ids
	case extraservice.EdgeMissionExtraServices:
		ids := make([]ent.Value, 0, len(m.mission_extra_services))
		for id := range m.mission_extra_services {
			ids = append(ids, id)
		}
		return ids
	case extraservice.EdgeExtraServicePrices:
		ids := make([]ent.Value, 0, len(m.extra_service_prices))
		for id := range m.extra_service_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtraServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmissions != nil {
		edges = append(edges, extraservice.EdgeMissions)
	}
	if m.removedmission_extra_services != nil {
		edges = append(edges, extraservice.EdgeMissionExtraServices)
	}
	if m.removedextra_service_prices != nil {
		edges = append(edges, extraservice.EdgeExtraServicePrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtraServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case extraservice.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.removedmissions))
		for id := range m.removedmissions {
			ids = append(ids, id)
		}
		return ids
	case extraservice.EdgeMissionExtraServices:
		ids := make([]ent.Value, 0, len(m.removedmission_extra_services))
		for id := range m.removedmission_extra_services {
			ids = append(ids, id)
		}
		return ids
	case extraservice.EdgeExtraServicePrices:
		ids := make([]ent.Value, 0, len(m.removedextra_service_prices))
		for id := range m.removedextra_service_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtraServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmissions {
		edges = append(edges, extraservice.EdgeMissions)
	}
	if m.clearedmission_extra_services {
		edges = append(edges, extraservice.EdgeMissionExtraServices)
	}
	if m.clearedextra_service_prices {
		edges = append(edges, extraservice.EdgeExtraServicePrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtraServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case extraservice.EdgeMissions:
		return m.clearedmissions
	case extraservice.EdgeMissionExtraServices:
		return m.clearedmission_extra_services
	case extraservice.EdgeExtraServicePrices:
		return m.clearedextra_service_prices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtraServiceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ExtraService unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtraServiceMutation) ResetEdge(name string) error {
	switch name {
	case extraservice.EdgeMissions:
		m.ResetMissions()
		return nil
	case extraservice.EdgeMissionExtraServices:
		m.ResetMissionExtraServices()
		return nil
	case extraservice.EdgeExtraServicePrices:
		m.ResetExtraServicePrices()
		return nil
	}
	return fmt.Errorf("unknown ExtraService edge %s", name)
}

// ExtraServiceOrderMutation represents an operation that mutates the ExtraServiceOrder nodes in the graph.
type ExtraServiceOrderMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	extra_service_billing_type *enums.ExtraServiceBillingType
	amount                     *int64
	addamount                  *int64
	unit_cep                   *int64
	addunit_cep                *int64
	extra_service_type         *enums.ExtraServiceType
	buy_duration               *int64
	addbuy_duration            *int64
	started_at                 *time.Time
	finished_at                *time.Time
	plan_started_at            *time.Time
	plan_finished_at           *time.Time
	settled_amount             *int64
	addsettled_amount          *int64
	settled_count              *int64
	addsettled_count           *int64
	total_settle_count         *int64
	addtotal_settle_count      *int64
	lately_settled_at          *time.Time
	clearedFields              map[string]struct{}
	mission                    *int64
	clearedmission             bool
	mission_order              *int64
	clearedmission_order       bool
	symbol                     *int64
	clearedsymbol              bool
	mission_batch              *int64
	clearedmission_batch       bool
	done                       bool
	oldValue                   func(context.Context) (*ExtraServiceOrder, error)
	predicates                 []predicate.ExtraServiceOrder
}

var _ ent.Mutation = (*ExtraServiceOrderMutation)(nil)

// extraserviceorderOption allows management of the mutation configuration using functional options.
type extraserviceorderOption func(*ExtraServiceOrderMutation)

// newExtraServiceOrderMutation creates new mutation for the ExtraServiceOrder entity.
func newExtraServiceOrderMutation(c config, op Op, opts ...extraserviceorderOption) *ExtraServiceOrderMutation {
	m := &ExtraServiceOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeExtraServiceOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtraServiceOrderID sets the ID field of the mutation.
func withExtraServiceOrderID(id int64) extraserviceorderOption {
	return func(m *ExtraServiceOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *ExtraServiceOrder
		)
		m.oldValue = func(ctx context.Context) (*ExtraServiceOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExtraServiceOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtraServiceOrder sets the old ExtraServiceOrder of the mutation.
func withExtraServiceOrder(node *ExtraServiceOrder) extraserviceorderOption {
	return func(m *ExtraServiceOrderMutation) {
		m.oldValue = func(context.Context) (*ExtraServiceOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtraServiceOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtraServiceOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExtraServiceOrder entities.
func (m *ExtraServiceOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtraServiceOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtraServiceOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExtraServiceOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ExtraServiceOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ExtraServiceOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ExtraServiceOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ExtraServiceOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ExtraServiceOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ExtraServiceOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ExtraServiceOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ExtraServiceOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExtraServiceOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExtraServiceOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExtraServiceOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExtraServiceOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExtraServiceOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExtraServiceOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExtraServiceOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExtraServiceOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExtraServiceOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *ExtraServiceOrderMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *ExtraServiceOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *ExtraServiceOrderMutation) ResetMissionID() {
	m.mission = nil
}

// SetMissionOrderID sets the "mission_order_id" field.
func (m *ExtraServiceOrderMutation) SetMissionOrderID(i int64) {
	m.mission_order = &i
}

// MissionOrderID returns the value of the "mission_order_id" field in the mutation.
func (m *ExtraServiceOrderMutation) MissionOrderID() (r int64, exists bool) {
	v := m.mission_order
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionOrderID returns the old "mission_order_id" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldMissionOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionOrderID: %w", err)
	}
	return oldValue.MissionOrderID, nil
}

// ResetMissionOrderID resets all changes to the "mission_order_id" field.
func (m *ExtraServiceOrderMutation) ResetMissionOrderID() {
	m.mission_order = nil
}

// SetExtraServiceBillingType sets the "extra_service_billing_type" field.
func (m *ExtraServiceOrderMutation) SetExtraServiceBillingType(esbt enums.ExtraServiceBillingType) {
	m.extra_service_billing_type = &esbt
}

// ExtraServiceBillingType returns the value of the "extra_service_billing_type" field in the mutation.
func (m *ExtraServiceOrderMutation) ExtraServiceBillingType() (r enums.ExtraServiceBillingType, exists bool) {
	v := m.extra_service_billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceBillingType returns the old "extra_service_billing_type" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldExtraServiceBillingType(ctx context.Context) (v enums.ExtraServiceBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceBillingType: %w", err)
	}
	return oldValue.ExtraServiceBillingType, nil
}

// ResetExtraServiceBillingType resets all changes to the "extra_service_billing_type" field.
func (m *ExtraServiceOrderMutation) ResetExtraServiceBillingType() {
	m.extra_service_billing_type = nil
}

// SetAmount sets the "amount" field.
func (m *ExtraServiceOrderMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ExtraServiceOrderMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *ExtraServiceOrderMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *ExtraServiceOrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *ExtraServiceOrderMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *ExtraServiceOrderMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *ExtraServiceOrderMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetUnitCep sets the "unit_cep" field.
func (m *ExtraServiceOrderMutation) SetUnitCep(i int64) {
	m.unit_cep = &i
	m.addunit_cep = nil
}

// UnitCep returns the value of the "unit_cep" field in the mutation.
func (m *ExtraServiceOrderMutation) UnitCep() (r int64, exists bool) {
	v := m.unit_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCep returns the old "unit_cep" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldUnitCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCep: %w", err)
	}
	return oldValue.UnitCep, nil
}

// AddUnitCep adds i to the "unit_cep" field.
func (m *ExtraServiceOrderMutation) AddUnitCep(i int64) {
	if m.addunit_cep != nil {
		*m.addunit_cep += i
	} else {
		m.addunit_cep = &i
	}
}

// AddedUnitCep returns the value that was added to the "unit_cep" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedUnitCep() (r int64, exists bool) {
	v := m.addunit_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitCep resets all changes to the "unit_cep" field.
func (m *ExtraServiceOrderMutation) ResetUnitCep() {
	m.unit_cep = nil
	m.addunit_cep = nil
}

// SetExtraServiceType sets the "extra_service_type" field.
func (m *ExtraServiceOrderMutation) SetExtraServiceType(est enums.ExtraServiceType) {
	m.extra_service_type = &est
}

// ExtraServiceType returns the value of the "extra_service_type" field in the mutation.
func (m *ExtraServiceOrderMutation) ExtraServiceType() (r enums.ExtraServiceType, exists bool) {
	v := m.extra_service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceType returns the old "extra_service_type" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldExtraServiceType(ctx context.Context) (v enums.ExtraServiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceType: %w", err)
	}
	return oldValue.ExtraServiceType, nil
}

// ResetExtraServiceType resets all changes to the "extra_service_type" field.
func (m *ExtraServiceOrderMutation) ResetExtraServiceType() {
	m.extra_service_type = nil
}

// SetBuyDuration sets the "buy_duration" field.
func (m *ExtraServiceOrderMutation) SetBuyDuration(i int64) {
	m.buy_duration = &i
	m.addbuy_duration = nil
}

// BuyDuration returns the value of the "buy_duration" field in the mutation.
func (m *ExtraServiceOrderMutation) BuyDuration() (r int64, exists bool) {
	v := m.buy_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyDuration returns the old "buy_duration" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldBuyDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyDuration: %w", err)
	}
	return oldValue.BuyDuration, nil
}

// AddBuyDuration adds i to the "buy_duration" field.
func (m *ExtraServiceOrderMutation) AddBuyDuration(i int64) {
	if m.addbuy_duration != nil {
		*m.addbuy_duration += i
	} else {
		m.addbuy_duration = &i
	}
}

// AddedBuyDuration returns the value that was added to the "buy_duration" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedBuyDuration() (r int64, exists bool) {
	v := m.addbuy_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetBuyDuration resets all changes to the "buy_duration" field.
func (m *ExtraServiceOrderMutation) ResetBuyDuration() {
	m.buy_duration = nil
	m.addbuy_duration = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ExtraServiceOrderMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ExtraServiceOrderMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ExtraServiceOrderMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *ExtraServiceOrderMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ExtraServiceOrderMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ExtraServiceOrderMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetPlanStartedAt sets the "plan_started_at" field.
func (m *ExtraServiceOrderMutation) SetPlanStartedAt(t time.Time) {
	m.plan_started_at = &t
}

// PlanStartedAt returns the value of the "plan_started_at" field in the mutation.
func (m *ExtraServiceOrderMutation) PlanStartedAt() (r time.Time, exists bool) {
	v := m.plan_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanStartedAt returns the old "plan_started_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldPlanStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanStartedAt: %w", err)
	}
	return oldValue.PlanStartedAt, nil
}

// ClearPlanStartedAt clears the value of the "plan_started_at" field.
func (m *ExtraServiceOrderMutation) ClearPlanStartedAt() {
	m.plan_started_at = nil
	m.clearedFields[extraserviceorder.FieldPlanStartedAt] = struct{}{}
}

// PlanStartedAtCleared returns if the "plan_started_at" field was cleared in this mutation.
func (m *ExtraServiceOrderMutation) PlanStartedAtCleared() bool {
	_, ok := m.clearedFields[extraserviceorder.FieldPlanStartedAt]
	return ok
}

// ResetPlanStartedAt resets all changes to the "plan_started_at" field.
func (m *ExtraServiceOrderMutation) ResetPlanStartedAt() {
	m.plan_started_at = nil
	delete(m.clearedFields, extraserviceorder.FieldPlanStartedAt)
}

// SetPlanFinishedAt sets the "plan_finished_at" field.
func (m *ExtraServiceOrderMutation) SetPlanFinishedAt(t time.Time) {
	m.plan_finished_at = &t
}

// PlanFinishedAt returns the value of the "plan_finished_at" field in the mutation.
func (m *ExtraServiceOrderMutation) PlanFinishedAt() (r time.Time, exists bool) {
	v := m.plan_finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanFinishedAt returns the old "plan_finished_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldPlanFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanFinishedAt: %w", err)
	}
	return oldValue.PlanFinishedAt, nil
}

// ClearPlanFinishedAt clears the value of the "plan_finished_at" field.
func (m *ExtraServiceOrderMutation) ClearPlanFinishedAt() {
	m.plan_finished_at = nil
	m.clearedFields[extraserviceorder.FieldPlanFinishedAt] = struct{}{}
}

// PlanFinishedAtCleared returns if the "plan_finished_at" field was cleared in this mutation.
func (m *ExtraServiceOrderMutation) PlanFinishedAtCleared() bool {
	_, ok := m.clearedFields[extraserviceorder.FieldPlanFinishedAt]
	return ok
}

// ResetPlanFinishedAt resets all changes to the "plan_finished_at" field.
func (m *ExtraServiceOrderMutation) ResetPlanFinishedAt() {
	m.plan_finished_at = nil
	delete(m.clearedFields, extraserviceorder.FieldPlanFinishedAt)
}

// SetMissionBatchID sets the "mission_batch_id" field.
func (m *ExtraServiceOrderMutation) SetMissionBatchID(i int64) {
	m.mission_batch = &i
}

// MissionBatchID returns the value of the "mission_batch_id" field in the mutation.
func (m *ExtraServiceOrderMutation) MissionBatchID() (r int64, exists bool) {
	v := m.mission_batch
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchID returns the old "mission_batch_id" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldMissionBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchID: %w", err)
	}
	return oldValue.MissionBatchID, nil
}

// ResetMissionBatchID resets all changes to the "mission_batch_id" field.
func (m *ExtraServiceOrderMutation) ResetMissionBatchID() {
	m.mission_batch = nil
}

// SetSettledAmount sets the "settled_amount" field.
func (m *ExtraServiceOrderMutation) SetSettledAmount(i int64) {
	m.settled_amount = &i
	m.addsettled_amount = nil
}

// SettledAmount returns the value of the "settled_amount" field in the mutation.
func (m *ExtraServiceOrderMutation) SettledAmount() (r int64, exists bool) {
	v := m.settled_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledAmount returns the old "settled_amount" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldSettledAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledAmount: %w", err)
	}
	return oldValue.SettledAmount, nil
}

// AddSettledAmount adds i to the "settled_amount" field.
func (m *ExtraServiceOrderMutation) AddSettledAmount(i int64) {
	if m.addsettled_amount != nil {
		*m.addsettled_amount += i
	} else {
		m.addsettled_amount = &i
	}
}

// AddedSettledAmount returns the value that was added to the "settled_amount" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedSettledAmount() (r int64, exists bool) {
	v := m.addsettled_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettledAmount resets all changes to the "settled_amount" field.
func (m *ExtraServiceOrderMutation) ResetSettledAmount() {
	m.settled_amount = nil
	m.addsettled_amount = nil
}

// SetSettledCount sets the "settled_count" field.
func (m *ExtraServiceOrderMutation) SetSettledCount(i int64) {
	m.settled_count = &i
	m.addsettled_count = nil
}

// SettledCount returns the value of the "settled_count" field in the mutation.
func (m *ExtraServiceOrderMutation) SettledCount() (r int64, exists bool) {
	v := m.settled_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledCount returns the old "settled_count" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldSettledCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledCount: %w", err)
	}
	return oldValue.SettledCount, nil
}

// AddSettledCount adds i to the "settled_count" field.
func (m *ExtraServiceOrderMutation) AddSettledCount(i int64) {
	if m.addsettled_count != nil {
		*m.addsettled_count += i
	} else {
		m.addsettled_count = &i
	}
}

// AddedSettledCount returns the value that was added to the "settled_count" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedSettledCount() (r int64, exists bool) {
	v := m.addsettled_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettledCount resets all changes to the "settled_count" field.
func (m *ExtraServiceOrderMutation) ResetSettledCount() {
	m.settled_count = nil
	m.addsettled_count = nil
}

// SetTotalSettleCount sets the "total_settle_count" field.
func (m *ExtraServiceOrderMutation) SetTotalSettleCount(i int64) {
	m.total_settle_count = &i
	m.addtotal_settle_count = nil
}

// TotalSettleCount returns the value of the "total_settle_count" field in the mutation.
func (m *ExtraServiceOrderMutation) TotalSettleCount() (r int64, exists bool) {
	v := m.total_settle_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSettleCount returns the old "total_settle_count" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldTotalSettleCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSettleCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSettleCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSettleCount: %w", err)
	}
	return oldValue.TotalSettleCount, nil
}

// AddTotalSettleCount adds i to the "total_settle_count" field.
func (m *ExtraServiceOrderMutation) AddTotalSettleCount(i int64) {
	if m.addtotal_settle_count != nil {
		*m.addtotal_settle_count += i
	} else {
		m.addtotal_settle_count = &i
	}
}

// AddedTotalSettleCount returns the value that was added to the "total_settle_count" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedTotalSettleCount() (r int64, exists bool) {
	v := m.addtotal_settle_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSettleCount resets all changes to the "total_settle_count" field.
func (m *ExtraServiceOrderMutation) ResetTotalSettleCount() {
	m.total_settle_count = nil
	m.addtotal_settle_count = nil
}

// SetLatelySettledAt sets the "lately_settled_at" field.
func (m *ExtraServiceOrderMutation) SetLatelySettledAt(t time.Time) {
	m.lately_settled_at = &t
}

// LatelySettledAt returns the value of the "lately_settled_at" field in the mutation.
func (m *ExtraServiceOrderMutation) LatelySettledAt() (r time.Time, exists bool) {
	v := m.lately_settled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLatelySettledAt returns the old "lately_settled_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldLatelySettledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatelySettledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatelySettledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatelySettledAt: %w", err)
	}
	return oldValue.LatelySettledAt, nil
}

// ResetLatelySettledAt resets all changes to the "lately_settled_at" field.
func (m *ExtraServiceOrderMutation) ResetLatelySettledAt() {
	m.lately_settled_at = nil
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *ExtraServiceOrderMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[extraserviceorder.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *ExtraServiceOrderMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *ExtraServiceOrderMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *ExtraServiceOrderMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearMissionOrder clears the "mission_order" edge to the MissionOrder entity.
func (m *ExtraServiceOrderMutation) ClearMissionOrder() {
	m.clearedmission_order = true
	m.clearedFields[extraserviceorder.FieldMissionOrderID] = struct{}{}
}

// MissionOrderCleared reports if the "mission_order" edge to the MissionOrder entity was cleared.
func (m *ExtraServiceOrderMutation) MissionOrderCleared() bool {
	return m.clearedmission_order
}

// MissionOrderIDs returns the "mission_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionOrderID instead. It exists only for internal usage by the builders.
func (m *ExtraServiceOrderMutation) MissionOrderIDs() (ids []int64) {
	if id := m.mission_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionOrder resets all changes to the "mission_order" edge.
func (m *ExtraServiceOrderMutation) ResetMissionOrder() {
	m.mission_order = nil
	m.clearedmission_order = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *ExtraServiceOrderMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[extraserviceorder.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *ExtraServiceOrderMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *ExtraServiceOrderMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *ExtraServiceOrderMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// ClearMissionBatch clears the "mission_batch" edge to the MissionBatch entity.
func (m *ExtraServiceOrderMutation) ClearMissionBatch() {
	m.clearedmission_batch = true
	m.clearedFields[extraserviceorder.FieldMissionBatchID] = struct{}{}
}

// MissionBatchCleared reports if the "mission_batch" edge to the MissionBatch entity was cleared.
func (m *ExtraServiceOrderMutation) MissionBatchCleared() bool {
	return m.clearedmission_batch
}

// MissionBatchIDs returns the "mission_batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionBatchID instead. It exists only for internal usage by the builders.
func (m *ExtraServiceOrderMutation) MissionBatchIDs() (ids []int64) {
	if id := m.mission_batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionBatch resets all changes to the "mission_batch" edge.
func (m *ExtraServiceOrderMutation) ResetMissionBatch() {
	m.mission_batch = nil
	m.clearedmission_batch = false
}

// Where appends a list predicates to the ExtraServiceOrderMutation builder.
func (m *ExtraServiceOrderMutation) Where(ps ...predicate.ExtraServiceOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExtraServiceOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExtraServiceOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExtraServiceOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExtraServiceOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExtraServiceOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExtraServiceOrder).
func (m *ExtraServiceOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtraServiceOrderMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_by != nil {
		fields = append(fields, extraserviceorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, extraserviceorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, extraserviceorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, extraserviceorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, extraserviceorder.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, extraserviceorder.FieldMissionID)
	}
	if m.mission_order != nil {
		fields = append(fields, extraserviceorder.FieldMissionOrderID)
	}
	if m.extra_service_billing_type != nil {
		fields = append(fields, extraserviceorder.FieldExtraServiceBillingType)
	}
	if m.amount != nil {
		fields = append(fields, extraserviceorder.FieldAmount)
	}
	if m.symbol != nil {
		fields = append(fields, extraserviceorder.FieldSymbolID)
	}
	if m.unit_cep != nil {
		fields = append(fields, extraserviceorder.FieldUnitCep)
	}
	if m.extra_service_type != nil {
		fields = append(fields, extraserviceorder.FieldExtraServiceType)
	}
	if m.buy_duration != nil {
		fields = append(fields, extraserviceorder.FieldBuyDuration)
	}
	if m.started_at != nil {
		fields = append(fields, extraserviceorder.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, extraserviceorder.FieldFinishedAt)
	}
	if m.plan_started_at != nil {
		fields = append(fields, extraserviceorder.FieldPlanStartedAt)
	}
	if m.plan_finished_at != nil {
		fields = append(fields, extraserviceorder.FieldPlanFinishedAt)
	}
	if m.mission_batch != nil {
		fields = append(fields, extraserviceorder.FieldMissionBatchID)
	}
	if m.settled_amount != nil {
		fields = append(fields, extraserviceorder.FieldSettledAmount)
	}
	if m.settled_count != nil {
		fields = append(fields, extraserviceorder.FieldSettledCount)
	}
	if m.total_settle_count != nil {
		fields = append(fields, extraserviceorder.FieldTotalSettleCount)
	}
	if m.lately_settled_at != nil {
		fields = append(fields, extraserviceorder.FieldLatelySettledAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtraServiceOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		return m.CreatedBy()
	case extraserviceorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case extraserviceorder.FieldCreatedAt:
		return m.CreatedAt()
	case extraserviceorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case extraserviceorder.FieldDeletedAt:
		return m.DeletedAt()
	case extraserviceorder.FieldMissionID:
		return m.MissionID()
	case extraserviceorder.FieldMissionOrderID:
		return m.MissionOrderID()
	case extraserviceorder.FieldExtraServiceBillingType:
		return m.ExtraServiceBillingType()
	case extraserviceorder.FieldAmount:
		return m.Amount()
	case extraserviceorder.FieldSymbolID:
		return m.SymbolID()
	case extraserviceorder.FieldUnitCep:
		return m.UnitCep()
	case extraserviceorder.FieldExtraServiceType:
		return m.ExtraServiceType()
	case extraserviceorder.FieldBuyDuration:
		return m.BuyDuration()
	case extraserviceorder.FieldStartedAt:
		return m.StartedAt()
	case extraserviceorder.FieldFinishedAt:
		return m.FinishedAt()
	case extraserviceorder.FieldPlanStartedAt:
		return m.PlanStartedAt()
	case extraserviceorder.FieldPlanFinishedAt:
		return m.PlanFinishedAt()
	case extraserviceorder.FieldMissionBatchID:
		return m.MissionBatchID()
	case extraserviceorder.FieldSettledAmount:
		return m.SettledAmount()
	case extraserviceorder.FieldSettledCount:
		return m.SettledCount()
	case extraserviceorder.FieldTotalSettleCount:
		return m.TotalSettleCount()
	case extraserviceorder.FieldLatelySettledAt:
		return m.LatelySettledAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtraServiceOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case extraserviceorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case extraserviceorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case extraserviceorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case extraserviceorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case extraserviceorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case extraserviceorder.FieldMissionOrderID:
		return m.OldMissionOrderID(ctx)
	case extraserviceorder.FieldExtraServiceBillingType:
		return m.OldExtraServiceBillingType(ctx)
	case extraserviceorder.FieldAmount:
		return m.OldAmount(ctx)
	case extraserviceorder.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case extraserviceorder.FieldUnitCep:
		return m.OldUnitCep(ctx)
	case extraserviceorder.FieldExtraServiceType:
		return m.OldExtraServiceType(ctx)
	case extraserviceorder.FieldBuyDuration:
		return m.OldBuyDuration(ctx)
	case extraserviceorder.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case extraserviceorder.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case extraserviceorder.FieldPlanStartedAt:
		return m.OldPlanStartedAt(ctx)
	case extraserviceorder.FieldPlanFinishedAt:
		return m.OldPlanFinishedAt(ctx)
	case extraserviceorder.FieldMissionBatchID:
		return m.OldMissionBatchID(ctx)
	case extraserviceorder.FieldSettledAmount:
		return m.OldSettledAmount(ctx)
	case extraserviceorder.FieldSettledCount:
		return m.OldSettledCount(ctx)
	case extraserviceorder.FieldTotalSettleCount:
		return m.OldTotalSettleCount(ctx)
	case extraserviceorder.FieldLatelySettledAt:
		return m.OldLatelySettledAt(ctx)
	}
	return nil, fmt.Errorf("unknown ExtraServiceOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServiceOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case extraserviceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case extraserviceorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case extraserviceorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case extraserviceorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case extraserviceorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case extraserviceorder.FieldMissionOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionOrderID(v)
		return nil
	case extraserviceorder.FieldExtraServiceBillingType:
		v, ok := value.(enums.ExtraServiceBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceBillingType(v)
		return nil
	case extraserviceorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case extraserviceorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case extraserviceorder.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCep(v)
		return nil
	case extraserviceorder.FieldExtraServiceType:
		v, ok := value.(enums.ExtraServiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceType(v)
		return nil
	case extraserviceorder.FieldBuyDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyDuration(v)
		return nil
	case extraserviceorder.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case extraserviceorder.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case extraserviceorder.FieldPlanStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanStartedAt(v)
		return nil
	case extraserviceorder.FieldPlanFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanFinishedAt(v)
		return nil
	case extraserviceorder.FieldMissionBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchID(v)
		return nil
	case extraserviceorder.FieldSettledAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledAmount(v)
		return nil
	case extraserviceorder.FieldSettledCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledCount(v)
		return nil
	case extraserviceorder.FieldTotalSettleCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSettleCount(v)
		return nil
	case extraserviceorder.FieldLatelySettledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatelySettledAt(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtraServiceOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, extraserviceorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, extraserviceorder.FieldUpdatedBy)
	}
	if m.addamount != nil {
		fields = append(fields, extraserviceorder.FieldAmount)
	}
	if m.addunit_cep != nil {
		fields = append(fields, extraserviceorder.FieldUnitCep)
	}
	if m.addbuy_duration != nil {
		fields = append(fields, extraserviceorder.FieldBuyDuration)
	}
	if m.addsettled_amount != nil {
		fields = append(fields, extraserviceorder.FieldSettledAmount)
	}
	if m.addsettled_count != nil {
		fields = append(fields, extraserviceorder.FieldSettledCount)
	}
	if m.addtotal_settle_count != nil {
		fields = append(fields, extraserviceorder.FieldTotalSettleCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtraServiceOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case extraserviceorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case extraserviceorder.FieldAmount:
		return m.AddedAmount()
	case extraserviceorder.FieldUnitCep:
		return m.AddedUnitCep()
	case extraserviceorder.FieldBuyDuration:
		return m.AddedBuyDuration()
	case extraserviceorder.FieldSettledAmount:
		return m.AddedSettledAmount()
	case extraserviceorder.FieldSettledCount:
		return m.AddedSettledCount()
	case extraserviceorder.FieldTotalSettleCount:
		return m.AddedTotalSettleCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServiceOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case extraserviceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case extraserviceorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case extraserviceorder.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCep(v)
		return nil
	case extraserviceorder.FieldBuyDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuyDuration(v)
		return nil
	case extraserviceorder.FieldSettledAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettledAmount(v)
		return nil
	case extraserviceorder.FieldSettledCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettledCount(v)
		return nil
	case extraserviceorder.FieldTotalSettleCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSettleCount(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtraServiceOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extraserviceorder.FieldPlanStartedAt) {
		fields = append(fields, extraserviceorder.FieldPlanStartedAt)
	}
	if m.FieldCleared(extraserviceorder.FieldPlanFinishedAt) {
		fields = append(fields, extraserviceorder.FieldPlanFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtraServiceOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtraServiceOrderMutation) ClearField(name string) error {
	switch name {
	case extraserviceorder.FieldPlanStartedAt:
		m.ClearPlanStartedAt()
		return nil
	case extraserviceorder.FieldPlanFinishedAt:
		m.ClearPlanFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtraServiceOrderMutation) ResetField(name string) error {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case extraserviceorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case extraserviceorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case extraserviceorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case extraserviceorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case extraserviceorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case extraserviceorder.FieldMissionOrderID:
		m.ResetMissionOrderID()
		return nil
	case extraserviceorder.FieldExtraServiceBillingType:
		m.ResetExtraServiceBillingType()
		return nil
	case extraserviceorder.FieldAmount:
		m.ResetAmount()
		return nil
	case extraserviceorder.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case extraserviceorder.FieldUnitCep:
		m.ResetUnitCep()
		return nil
	case extraserviceorder.FieldExtraServiceType:
		m.ResetExtraServiceType()
		return nil
	case extraserviceorder.FieldBuyDuration:
		m.ResetBuyDuration()
		return nil
	case extraserviceorder.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case extraserviceorder.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case extraserviceorder.FieldPlanStartedAt:
		m.ResetPlanStartedAt()
		return nil
	case extraserviceorder.FieldPlanFinishedAt:
		m.ResetPlanFinishedAt()
		return nil
	case extraserviceorder.FieldMissionBatchID:
		m.ResetMissionBatchID()
		return nil
	case extraserviceorder.FieldSettledAmount:
		m.ResetSettledAmount()
		return nil
	case extraserviceorder.FieldSettledCount:
		m.ResetSettledCount()
		return nil
	case extraserviceorder.FieldTotalSettleCount:
		m.ResetTotalSettleCount()
		return nil
	case extraserviceorder.FieldLatelySettledAt:
		m.ResetLatelySettledAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtraServiceOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.mission != nil {
		edges = append(edges, extraserviceorder.EdgeMission)
	}
	if m.mission_order != nil {
		edges = append(edges, extraserviceorder.EdgeMissionOrder)
	}
	if m.symbol != nil {
		edges = append(edges, extraserviceorder.EdgeSymbol)
	}
	if m.mission_batch != nil {
		edges = append(edges, extraserviceorder.EdgeMissionBatch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtraServiceOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case extraserviceorder.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case extraserviceorder.EdgeMissionOrder:
		if id := m.mission_order; id != nil {
			return []ent.Value{*id}
		}
	case extraserviceorder.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	case extraserviceorder.EdgeMissionBatch:
		if id := m.mission_batch; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtraServiceOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtraServiceOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtraServiceOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmission {
		edges = append(edges, extraserviceorder.EdgeMission)
	}
	if m.clearedmission_order {
		edges = append(edges, extraserviceorder.EdgeMissionOrder)
	}
	if m.clearedsymbol {
		edges = append(edges, extraserviceorder.EdgeSymbol)
	}
	if m.clearedmission_batch {
		edges = append(edges, extraserviceorder.EdgeMissionBatch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtraServiceOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case extraserviceorder.EdgeMission:
		return m.clearedmission
	case extraserviceorder.EdgeMissionOrder:
		return m.clearedmission_order
	case extraserviceorder.EdgeSymbol:
		return m.clearedsymbol
	case extraserviceorder.EdgeMissionBatch:
		return m.clearedmission_batch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtraServiceOrderMutation) ClearEdge(name string) error {
	switch name {
	case extraserviceorder.EdgeMission:
		m.ClearMission()
		return nil
	case extraserviceorder.EdgeMissionOrder:
		m.ClearMissionOrder()
		return nil
	case extraserviceorder.EdgeSymbol:
		m.ClearSymbol()
		return nil
	case extraserviceorder.EdgeMissionBatch:
		m.ClearMissionBatch()
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtraServiceOrderMutation) ResetEdge(name string) error {
	switch name {
	case extraserviceorder.EdgeMission:
		m.ResetMission()
		return nil
	case extraserviceorder.EdgeMissionOrder:
		m.ResetMissionOrder()
		return nil
	case extraserviceorder.EdgeSymbol:
		m.ResetSymbol()
		return nil
	case extraserviceorder.EdgeMissionBatch:
		m.ResetMissionBatch()
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder edge %s", name)
}

// ExtraServicePriceMutation represents an operation that mutates the ExtraServicePrice nodes in the graph.
type ExtraServicePriceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	extra_service_type         *enums.ExtraServiceType
	extra_service_billing_type *enums.ExtraServiceBillingType
	cep                        *int64
	addcep                     *int64
	started_at                 *time.Time
	finished_at                *time.Time
	is_deprecated              *bool
	is_sensitive               *bool
	clearedFields              map[string]struct{}
	extra_service              *int64
	clearedextra_service       bool
	done                       bool
	oldValue                   func(context.Context) (*ExtraServicePrice, error)
	predicates                 []predicate.ExtraServicePrice
}

var _ ent.Mutation = (*ExtraServicePriceMutation)(nil)

// extraservicepriceOption allows management of the mutation configuration using functional options.
type extraservicepriceOption func(*ExtraServicePriceMutation)

// newExtraServicePriceMutation creates new mutation for the ExtraServicePrice entity.
func newExtraServicePriceMutation(c config, op Op, opts ...extraservicepriceOption) *ExtraServicePriceMutation {
	m := &ExtraServicePriceMutation{
		config:        c,
		op:            op,
		typ:           TypeExtraServicePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtraServicePriceID sets the ID field of the mutation.
func withExtraServicePriceID(id int64) extraservicepriceOption {
	return func(m *ExtraServicePriceMutation) {
		var (
			err   error
			once  sync.Once
			value *ExtraServicePrice
		)
		m.oldValue = func(ctx context.Context) (*ExtraServicePrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExtraServicePrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtraServicePrice sets the old ExtraServicePrice of the mutation.
func withExtraServicePrice(node *ExtraServicePrice) extraservicepriceOption {
	return func(m *ExtraServicePriceMutation) {
		m.oldValue = func(context.Context) (*ExtraServicePrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtraServicePriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtraServicePriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExtraServicePrice entities.
func (m *ExtraServicePriceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtraServicePriceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtraServicePriceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExtraServicePrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ExtraServicePriceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ExtraServicePriceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ExtraServicePriceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ExtraServicePriceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ExtraServicePriceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ExtraServicePriceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ExtraServicePriceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ExtraServicePriceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ExtraServicePriceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ExtraServicePriceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExtraServicePriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExtraServicePriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExtraServicePriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExtraServicePriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExtraServicePriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExtraServicePriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExtraServicePriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExtraServicePriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExtraServicePriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetExtraServiceType sets the "extra_service_type" field.
func (m *ExtraServicePriceMutation) SetExtraServiceType(est enums.ExtraServiceType) {
	m.extra_service_type = &est
}

// ExtraServiceType returns the value of the "extra_service_type" field in the mutation.
func (m *ExtraServicePriceMutation) ExtraServiceType() (r enums.ExtraServiceType, exists bool) {
	v := m.extra_service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceType returns the old "extra_service_type" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldExtraServiceType(ctx context.Context) (v enums.ExtraServiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceType: %w", err)
	}
	return oldValue.ExtraServiceType, nil
}

// ResetExtraServiceType resets all changes to the "extra_service_type" field.
func (m *ExtraServicePriceMutation) ResetExtraServiceType() {
	m.extra_service_type = nil
}

// SetExtraServiceBillingType sets the "extra_service_billing_type" field.
func (m *ExtraServicePriceMutation) SetExtraServiceBillingType(esbt enums.ExtraServiceBillingType) {
	m.extra_service_billing_type = &esbt
}

// ExtraServiceBillingType returns the value of the "extra_service_billing_type" field in the mutation.
func (m *ExtraServicePriceMutation) ExtraServiceBillingType() (r enums.ExtraServiceBillingType, exists bool) {
	v := m.extra_service_billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceBillingType returns the old "extra_service_billing_type" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldExtraServiceBillingType(ctx context.Context) (v enums.ExtraServiceBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceBillingType: %w", err)
	}
	return oldValue.ExtraServiceBillingType, nil
}

// ResetExtraServiceBillingType resets all changes to the "extra_service_billing_type" field.
func (m *ExtraServicePriceMutation) ResetExtraServiceBillingType() {
	m.extra_service_billing_type = nil
}

// SetExtraServiceID sets the "extra_service_id" field.
func (m *ExtraServicePriceMutation) SetExtraServiceID(i int64) {
	m.extra_service = &i
}

// ExtraServiceID returns the value of the "extra_service_id" field in the mutation.
func (m *ExtraServicePriceMutation) ExtraServiceID() (r int64, exists bool) {
	v := m.extra_service
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceID returns the old "extra_service_id" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldExtraServiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceID: %w", err)
	}
	return oldValue.ExtraServiceID, nil
}

// ResetExtraServiceID resets all changes to the "extra_service_id" field.
func (m *ExtraServicePriceMutation) ResetExtraServiceID() {
	m.extra_service = nil
}

// SetCep sets the "cep" field.
func (m *ExtraServicePriceMutation) SetCep(i int64) {
	m.cep = &i
	m.addcep = nil
}

// Cep returns the value of the "cep" field in the mutation.
func (m *ExtraServicePriceMutation) Cep() (r int64, exists bool) {
	v := m.cep
	if v == nil {
		return
	}
	return *v, true
}

// OldCep returns the old "cep" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCep: %w", err)
	}
	return oldValue.Cep, nil
}

// AddCep adds i to the "cep" field.
func (m *ExtraServicePriceMutation) AddCep(i int64) {
	if m.addcep != nil {
		*m.addcep += i
	} else {
		m.addcep = &i
	}
}

// AddedCep returns the value that was added to the "cep" field in this mutation.
func (m *ExtraServicePriceMutation) AddedCep() (r int64, exists bool) {
	v := m.addcep
	if v == nil {
		return
	}
	return *v, true
}

// ResetCep resets all changes to the "cep" field.
func (m *ExtraServicePriceMutation) ResetCep() {
	m.cep = nil
	m.addcep = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ExtraServicePriceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ExtraServicePriceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *ExtraServicePriceMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[extraserviceprice.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *ExtraServicePriceMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[extraserviceprice.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ExtraServicePriceMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, extraserviceprice.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *ExtraServicePriceMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ExtraServicePriceMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *ExtraServicePriceMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[extraserviceprice.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *ExtraServicePriceMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[extraserviceprice.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ExtraServicePriceMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, extraserviceprice.FieldFinishedAt)
}

// SetIsDeprecated sets the "is_deprecated" field.
func (m *ExtraServicePriceMutation) SetIsDeprecated(b bool) {
	m.is_deprecated = &b
}

// IsDeprecated returns the value of the "is_deprecated" field in the mutation.
func (m *ExtraServicePriceMutation) IsDeprecated() (r bool, exists bool) {
	v := m.is_deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeprecated returns the old "is_deprecated" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldIsDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeprecated: %w", err)
	}
	return oldValue.IsDeprecated, nil
}

// ResetIsDeprecated resets all changes to the "is_deprecated" field.
func (m *ExtraServicePriceMutation) ResetIsDeprecated() {
	m.is_deprecated = nil
}

// SetIsSensitive sets the "is_sensitive" field.
func (m *ExtraServicePriceMutation) SetIsSensitive(b bool) {
	m.is_sensitive = &b
}

// IsSensitive returns the value of the "is_sensitive" field in the mutation.
func (m *ExtraServicePriceMutation) IsSensitive() (r bool, exists bool) {
	v := m.is_sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSensitive returns the old "is_sensitive" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldIsSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSensitive: %w", err)
	}
	return oldValue.IsSensitive, nil
}

// ResetIsSensitive resets all changes to the "is_sensitive" field.
func (m *ExtraServicePriceMutation) ResetIsSensitive() {
	m.is_sensitive = nil
}

// ClearExtraService clears the "extra_service" edge to the ExtraService entity.
func (m *ExtraServicePriceMutation) ClearExtraService() {
	m.clearedextra_service = true
	m.clearedFields[extraserviceprice.FieldExtraServiceID] = struct{}{}
}

// ExtraServiceCleared reports if the "extra_service" edge to the ExtraService entity was cleared.
func (m *ExtraServicePriceMutation) ExtraServiceCleared() bool {
	return m.clearedextra_service
}

// ExtraServiceIDs returns the "extra_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExtraServiceID instead. It exists only for internal usage by the builders.
func (m *ExtraServicePriceMutation) ExtraServiceIDs() (ids []int64) {
	if id := m.extra_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExtraService resets all changes to the "extra_service" edge.
func (m *ExtraServicePriceMutation) ResetExtraService() {
	m.extra_service = nil
	m.clearedextra_service = false
}

// Where appends a list predicates to the ExtraServicePriceMutation builder.
func (m *ExtraServicePriceMutation) Where(ps ...predicate.ExtraServicePrice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExtraServicePriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExtraServicePriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExtraServicePrice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExtraServicePriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExtraServicePriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExtraServicePrice).
func (m *ExtraServicePriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtraServicePriceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, extraserviceprice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, extraserviceprice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, extraserviceprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, extraserviceprice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, extraserviceprice.FieldDeletedAt)
	}
	if m.extra_service_type != nil {
		fields = append(fields, extraserviceprice.FieldExtraServiceType)
	}
	if m.extra_service_billing_type != nil {
		fields = append(fields, extraserviceprice.FieldExtraServiceBillingType)
	}
	if m.extra_service != nil {
		fields = append(fields, extraserviceprice.FieldExtraServiceID)
	}
	if m.cep != nil {
		fields = append(fields, extraserviceprice.FieldCep)
	}
	if m.started_at != nil {
		fields = append(fields, extraserviceprice.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, extraserviceprice.FieldFinishedAt)
	}
	if m.is_deprecated != nil {
		fields = append(fields, extraserviceprice.FieldIsDeprecated)
	}
	if m.is_sensitive != nil {
		fields = append(fields, extraserviceprice.FieldIsSensitive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtraServicePriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		return m.CreatedBy()
	case extraserviceprice.FieldUpdatedBy:
		return m.UpdatedBy()
	case extraserviceprice.FieldCreatedAt:
		return m.CreatedAt()
	case extraserviceprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case extraserviceprice.FieldDeletedAt:
		return m.DeletedAt()
	case extraserviceprice.FieldExtraServiceType:
		return m.ExtraServiceType()
	case extraserviceprice.FieldExtraServiceBillingType:
		return m.ExtraServiceBillingType()
	case extraserviceprice.FieldExtraServiceID:
		return m.ExtraServiceID()
	case extraserviceprice.FieldCep:
		return m.Cep()
	case extraserviceprice.FieldStartedAt:
		return m.StartedAt()
	case extraserviceprice.FieldFinishedAt:
		return m.FinishedAt()
	case extraserviceprice.FieldIsDeprecated:
		return m.IsDeprecated()
	case extraserviceprice.FieldIsSensitive:
		return m.IsSensitive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtraServicePriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case extraserviceprice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case extraserviceprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case extraserviceprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case extraserviceprice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case extraserviceprice.FieldExtraServiceType:
		return m.OldExtraServiceType(ctx)
	case extraserviceprice.FieldExtraServiceBillingType:
		return m.OldExtraServiceBillingType(ctx)
	case extraserviceprice.FieldExtraServiceID:
		return m.OldExtraServiceID(ctx)
	case extraserviceprice.FieldCep:
		return m.OldCep(ctx)
	case extraserviceprice.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case extraserviceprice.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case extraserviceprice.FieldIsDeprecated:
		return m.OldIsDeprecated(ctx)
	case extraserviceprice.FieldIsSensitive:
		return m.OldIsSensitive(ctx)
	}
	return nil, fmt.Errorf("unknown ExtraServicePrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServicePriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case extraserviceprice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case extraserviceprice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case extraserviceprice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case extraserviceprice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case extraserviceprice.FieldExtraServiceType:
		v, ok := value.(enums.ExtraServiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceType(v)
		return nil
	case extraserviceprice.FieldExtraServiceBillingType:
		v, ok := value.(enums.ExtraServiceBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceBillingType(v)
		return nil
	case extraserviceprice.FieldExtraServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceID(v)
		return nil
	case extraserviceprice.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCep(v)
		return nil
	case extraserviceprice.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case extraserviceprice.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case extraserviceprice.FieldIsDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeprecated(v)
		return nil
	case extraserviceprice.FieldIsSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSensitive(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtraServicePriceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, extraserviceprice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, extraserviceprice.FieldUpdatedBy)
	}
	if m.addcep != nil {
		fields = append(fields, extraserviceprice.FieldCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtraServicePriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case extraserviceprice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case extraserviceprice.FieldCep:
		return m.AddedCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServicePriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case extraserviceprice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case extraserviceprice.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCep(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtraServicePriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extraserviceprice.FieldStartedAt) {
		fields = append(fields, extraserviceprice.FieldStartedAt)
	}
	if m.FieldCleared(extraserviceprice.FieldFinishedAt) {
		fields = append(fields, extraserviceprice.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtraServicePriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtraServicePriceMutation) ClearField(name string) error {
	switch name {
	case extraserviceprice.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case extraserviceprice.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtraServicePriceMutation) ResetField(name string) error {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case extraserviceprice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case extraserviceprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case extraserviceprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case extraserviceprice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case extraserviceprice.FieldExtraServiceType:
		m.ResetExtraServiceType()
		return nil
	case extraserviceprice.FieldExtraServiceBillingType:
		m.ResetExtraServiceBillingType()
		return nil
	case extraserviceprice.FieldExtraServiceID:
		m.ResetExtraServiceID()
		return nil
	case extraserviceprice.FieldCep:
		m.ResetCep()
		return nil
	case extraserviceprice.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case extraserviceprice.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case extraserviceprice.FieldIsDeprecated:
		m.ResetIsDeprecated()
		return nil
	case extraserviceprice.FieldIsSensitive:
		m.ResetIsSensitive()
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtraServicePriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.extra_service != nil {
		edges = append(edges, extraserviceprice.EdgeExtraService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtraServicePriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case extraserviceprice.EdgeExtraService:
		if id := m.extra_service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtraServicePriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtraServicePriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtraServicePriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedextra_service {
		edges = append(edges, extraserviceprice.EdgeExtraService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtraServicePriceMutation) EdgeCleared(name string) bool {
	switch name {
	case extraserviceprice.EdgeExtraService:
		return m.clearedextra_service
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtraServicePriceMutation) ClearEdge(name string) error {
	switch name {
	case extraserviceprice.EdgeExtraService:
		m.ClearExtraService()
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtraServicePriceMutation) ResetEdge(name string) error {
	switch name {
	case extraserviceprice.EdgeExtraService:
		m.ResetExtraService()
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice edge %s", name)
}

// FrpcInfoMutation represents an operation that mutates the FrpcInfo nodes in the graph.
type FrpcInfoMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_by       *int64
	addcreated_by    *int64
	updated_by       *int64
	addupdated_by    *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	tag              *string
	_type            *string
	local_ip         *string
	local_port       *int
	addlocal_port    *int
	remote_port      *int
	addremote_port   *int
	is_using         *bool
	clearedFields    map[string]struct{}
	frps_info        *int64
	clearedfrps_info bool
	device           *int64
	cleareddevice    bool
	done             bool
	oldValue         func(context.Context) (*FrpcInfo, error)
	predicates       []predicate.FrpcInfo
}

var _ ent.Mutation = (*FrpcInfoMutation)(nil)

// frpcinfoOption allows management of the mutation configuration using functional options.
type frpcinfoOption func(*FrpcInfoMutation)

// newFrpcInfoMutation creates new mutation for the FrpcInfo entity.
func newFrpcInfoMutation(c config, op Op, opts ...frpcinfoOption) *FrpcInfoMutation {
	m := &FrpcInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeFrpcInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFrpcInfoID sets the ID field of the mutation.
func withFrpcInfoID(id int64) frpcinfoOption {
	return func(m *FrpcInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *FrpcInfo
		)
		m.oldValue = func(ctx context.Context) (*FrpcInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FrpcInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFrpcInfo sets the old FrpcInfo of the mutation.
func withFrpcInfo(node *FrpcInfo) frpcinfoOption {
	return func(m *FrpcInfoMutation) {
		m.oldValue = func(context.Context) (*FrpcInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FrpcInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FrpcInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FrpcInfo entities.
func (m *FrpcInfoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FrpcInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FrpcInfoMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FrpcInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *FrpcInfoMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FrpcInfoMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FrpcInfoMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FrpcInfoMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FrpcInfoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FrpcInfoMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FrpcInfoMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FrpcInfoMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FrpcInfoMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FrpcInfoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FrpcInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FrpcInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FrpcInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FrpcInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FrpcInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FrpcInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FrpcInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FrpcInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FrpcInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTag sets the "tag" field.
func (m *FrpcInfoMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *FrpcInfoMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *FrpcInfoMutation) ResetTag() {
	m.tag = nil
}

// SetType sets the "type" field.
func (m *FrpcInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FrpcInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FrpcInfoMutation) ResetType() {
	m._type = nil
}

// SetLocalIP sets the "local_ip" field.
func (m *FrpcInfoMutation) SetLocalIP(s string) {
	m.local_ip = &s
}

// LocalIP returns the value of the "local_ip" field in the mutation.
func (m *FrpcInfoMutation) LocalIP() (r string, exists bool) {
	v := m.local_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalIP returns the old "local_ip" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldLocalIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalIP: %w", err)
	}
	return oldValue.LocalIP, nil
}

// ResetLocalIP resets all changes to the "local_ip" field.
func (m *FrpcInfoMutation) ResetLocalIP() {
	m.local_ip = nil
}

// SetLocalPort sets the "local_port" field.
func (m *FrpcInfoMutation) SetLocalPort(i int) {
	m.local_port = &i
	m.addlocal_port = nil
}

// LocalPort returns the value of the "local_port" field in the mutation.
func (m *FrpcInfoMutation) LocalPort() (r int, exists bool) {
	v := m.local_port
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalPort returns the old "local_port" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldLocalPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalPort: %w", err)
	}
	return oldValue.LocalPort, nil
}

// AddLocalPort adds i to the "local_port" field.
func (m *FrpcInfoMutation) AddLocalPort(i int) {
	if m.addlocal_port != nil {
		*m.addlocal_port += i
	} else {
		m.addlocal_port = &i
	}
}

// AddedLocalPort returns the value that was added to the "local_port" field in this mutation.
func (m *FrpcInfoMutation) AddedLocalPort() (r int, exists bool) {
	v := m.addlocal_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocalPort resets all changes to the "local_port" field.
func (m *FrpcInfoMutation) ResetLocalPort() {
	m.local_port = nil
	m.addlocal_port = nil
}

// SetRemotePort sets the "remote_port" field.
func (m *FrpcInfoMutation) SetRemotePort(i int) {
	m.remote_port = &i
	m.addremote_port = nil
}

// RemotePort returns the value of the "remote_port" field in the mutation.
func (m *FrpcInfoMutation) RemotePort() (r int, exists bool) {
	v := m.remote_port
	if v == nil {
		return
	}
	return *v, true
}

// OldRemotePort returns the old "remote_port" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldRemotePort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemotePort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemotePort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemotePort: %w", err)
	}
	return oldValue.RemotePort, nil
}

// AddRemotePort adds i to the "remote_port" field.
func (m *FrpcInfoMutation) AddRemotePort(i int) {
	if m.addremote_port != nil {
		*m.addremote_port += i
	} else {
		m.addremote_port = &i
	}
}

// AddedRemotePort returns the value that was added to the "remote_port" field in this mutation.
func (m *FrpcInfoMutation) AddedRemotePort() (r int, exists bool) {
	v := m.addremote_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemotePort resets all changes to the "remote_port" field.
func (m *FrpcInfoMutation) ResetRemotePort() {
	m.remote_port = nil
	m.addremote_port = nil
}

// SetIsUsing sets the "is_using" field.
func (m *FrpcInfoMutation) SetIsUsing(b bool) {
	m.is_using = &b
}

// IsUsing returns the value of the "is_using" field in the mutation.
func (m *FrpcInfoMutation) IsUsing() (r bool, exists bool) {
	v := m.is_using
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUsing returns the old "is_using" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldIsUsing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUsing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUsing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUsing: %w", err)
	}
	return oldValue.IsUsing, nil
}

// ResetIsUsing resets all changes to the "is_using" field.
func (m *FrpcInfoMutation) ResetIsUsing() {
	m.is_using = nil
}

// SetFrpsID sets the "frps_id" field.
func (m *FrpcInfoMutation) SetFrpsID(i int64) {
	m.frps_info = &i
}

// FrpsID returns the value of the "frps_id" field in the mutation.
func (m *FrpcInfoMutation) FrpsID() (r int64, exists bool) {
	v := m.frps_info
	if v == nil {
		return
	}
	return *v, true
}

// OldFrpsID returns the old "frps_id" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldFrpsID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrpsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrpsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrpsID: %w", err)
	}
	return oldValue.FrpsID, nil
}

// ResetFrpsID resets all changes to the "frps_id" field.
func (m *FrpcInfoMutation) ResetFrpsID() {
	m.frps_info = nil
}

// SetDeviceID sets the "device_id" field.
func (m *FrpcInfoMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *FrpcInfoMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *FrpcInfoMutation) ResetDeviceID() {
	m.device = nil
}

// SetFrpsInfoID sets the "frps_info" edge to the FrpsInfo entity by id.
func (m *FrpcInfoMutation) SetFrpsInfoID(id int64) {
	m.frps_info = &id
}

// ClearFrpsInfo clears the "frps_info" edge to the FrpsInfo entity.
func (m *FrpcInfoMutation) ClearFrpsInfo() {
	m.clearedfrps_info = true
	m.clearedFields[frpcinfo.FieldFrpsID] = struct{}{}
}

// FrpsInfoCleared reports if the "frps_info" edge to the FrpsInfo entity was cleared.
func (m *FrpcInfoMutation) FrpsInfoCleared() bool {
	return m.clearedfrps_info
}

// FrpsInfoID returns the "frps_info" edge ID in the mutation.
func (m *FrpcInfoMutation) FrpsInfoID() (id int64, exists bool) {
	if m.frps_info != nil {
		return *m.frps_info, true
	}
	return
}

// FrpsInfoIDs returns the "frps_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FrpsInfoID instead. It exists only for internal usage by the builders.
func (m *FrpcInfoMutation) FrpsInfoIDs() (ids []int64) {
	if id := m.frps_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFrpsInfo resets all changes to the "frps_info" edge.
func (m *FrpcInfoMutation) ResetFrpsInfo() {
	m.frps_info = nil
	m.clearedfrps_info = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *FrpcInfoMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[frpcinfo.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *FrpcInfoMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *FrpcInfoMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *FrpcInfoMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the FrpcInfoMutation builder.
func (m *FrpcInfoMutation) Where(ps ...predicate.FrpcInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FrpcInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FrpcInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FrpcInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FrpcInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FrpcInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FrpcInfo).
func (m *FrpcInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FrpcInfoMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, frpcinfo.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, frpcinfo.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, frpcinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, frpcinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, frpcinfo.FieldDeletedAt)
	}
	if m.tag != nil {
		fields = append(fields, frpcinfo.FieldTag)
	}
	if m._type != nil {
		fields = append(fields, frpcinfo.FieldType)
	}
	if m.local_ip != nil {
		fields = append(fields, frpcinfo.FieldLocalIP)
	}
	if m.local_port != nil {
		fields = append(fields, frpcinfo.FieldLocalPort)
	}
	if m.remote_port != nil {
		fields = append(fields, frpcinfo.FieldRemotePort)
	}
	if m.is_using != nil {
		fields = append(fields, frpcinfo.FieldIsUsing)
	}
	if m.frps_info != nil {
		fields = append(fields, frpcinfo.FieldFrpsID)
	}
	if m.device != nil {
		fields = append(fields, frpcinfo.FieldDeviceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FrpcInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case frpcinfo.FieldCreatedBy:
		return m.CreatedBy()
	case frpcinfo.FieldUpdatedBy:
		return m.UpdatedBy()
	case frpcinfo.FieldCreatedAt:
		return m.CreatedAt()
	case frpcinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case frpcinfo.FieldDeletedAt:
		return m.DeletedAt()
	case frpcinfo.FieldTag:
		return m.Tag()
	case frpcinfo.FieldType:
		return m.GetType()
	case frpcinfo.FieldLocalIP:
		return m.LocalIP()
	case frpcinfo.FieldLocalPort:
		return m.LocalPort()
	case frpcinfo.FieldRemotePort:
		return m.RemotePort()
	case frpcinfo.FieldIsUsing:
		return m.IsUsing()
	case frpcinfo.FieldFrpsID:
		return m.FrpsID()
	case frpcinfo.FieldDeviceID:
		return m.DeviceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FrpcInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case frpcinfo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case frpcinfo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case frpcinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case frpcinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case frpcinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case frpcinfo.FieldTag:
		return m.OldTag(ctx)
	case frpcinfo.FieldType:
		return m.OldType(ctx)
	case frpcinfo.FieldLocalIP:
		return m.OldLocalIP(ctx)
	case frpcinfo.FieldLocalPort:
		return m.OldLocalPort(ctx)
	case frpcinfo.FieldRemotePort:
		return m.OldRemotePort(ctx)
	case frpcinfo.FieldIsUsing:
		return m.OldIsUsing(ctx)
	case frpcinfo.FieldFrpsID:
		return m.OldFrpsID(ctx)
	case frpcinfo.FieldDeviceID:
		return m.OldDeviceID(ctx)
	}
	return nil, fmt.Errorf("unknown FrpcInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrpcInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case frpcinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case frpcinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case frpcinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case frpcinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case frpcinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case frpcinfo.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case frpcinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case frpcinfo.FieldLocalIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalIP(v)
		return nil
	case frpcinfo.FieldLocalPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalPort(v)
		return nil
	case frpcinfo.FieldRemotePort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemotePort(v)
		return nil
	case frpcinfo.FieldIsUsing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUsing(v)
		return nil
	case frpcinfo.FieldFrpsID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrpsID(v)
		return nil
	case frpcinfo.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FrpcInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, frpcinfo.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, frpcinfo.FieldUpdatedBy)
	}
	if m.addlocal_port != nil {
		fields = append(fields, frpcinfo.FieldLocalPort)
	}
	if m.addremote_port != nil {
		fields = append(fields, frpcinfo.FieldRemotePort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FrpcInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case frpcinfo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case frpcinfo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case frpcinfo.FieldLocalPort:
		return m.AddedLocalPort()
	case frpcinfo.FieldRemotePort:
		return m.AddedRemotePort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrpcInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case frpcinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case frpcinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case frpcinfo.FieldLocalPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocalPort(v)
		return nil
	case frpcinfo.FieldRemotePort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemotePort(v)
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FrpcInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FrpcInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FrpcInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FrpcInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FrpcInfoMutation) ResetField(name string) error {
	switch name {
	case frpcinfo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case frpcinfo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case frpcinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case frpcinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case frpcinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case frpcinfo.FieldTag:
		m.ResetTag()
		return nil
	case frpcinfo.FieldType:
		m.ResetType()
		return nil
	case frpcinfo.FieldLocalIP:
		m.ResetLocalIP()
		return nil
	case frpcinfo.FieldLocalPort:
		m.ResetLocalPort()
		return nil
	case frpcinfo.FieldRemotePort:
		m.ResetRemotePort()
		return nil
	case frpcinfo.FieldIsUsing:
		m.ResetIsUsing()
		return nil
	case frpcinfo.FieldFrpsID:
		m.ResetFrpsID()
		return nil
	case frpcinfo.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FrpcInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.frps_info != nil {
		edges = append(edges, frpcinfo.EdgeFrpsInfo)
	}
	if m.device != nil {
		edges = append(edges, frpcinfo.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FrpcInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case frpcinfo.EdgeFrpsInfo:
		if id := m.frps_info; id != nil {
			return []ent.Value{*id}
		}
	case frpcinfo.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FrpcInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FrpcInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FrpcInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrps_info {
		edges = append(edges, frpcinfo.EdgeFrpsInfo)
	}
	if m.cleareddevice {
		edges = append(edges, frpcinfo.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FrpcInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case frpcinfo.EdgeFrpsInfo:
		return m.clearedfrps_info
	case frpcinfo.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FrpcInfoMutation) ClearEdge(name string) error {
	switch name {
	case frpcinfo.EdgeFrpsInfo:
		m.ClearFrpsInfo()
		return nil
	case frpcinfo.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FrpcInfoMutation) ResetEdge(name string) error {
	switch name {
	case frpcinfo.EdgeFrpsInfo:
		m.ResetFrpsInfo()
		return nil
	case frpcinfo.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo edge %s", name)
}

// FrpsInfoMutation represents an operation that mutates the FrpsInfo nodes in the graph.
type FrpsInfoMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	tag                   *string
	domain                *string
	server_addr           *string
	server_port           *int
	addserver_port        *int
	authentication_method *string
	token                 *string
	_type                 *string
	clearedFields         map[string]struct{}
	frpc_infos            map[int64]struct{}
	removedfrpc_infos     map[int64]struct{}
	clearedfrpc_infos     bool
	done                  bool
	oldValue              func(context.Context) (*FrpsInfo, error)
	predicates            []predicate.FrpsInfo
}

var _ ent.Mutation = (*FrpsInfoMutation)(nil)

// frpsinfoOption allows management of the mutation configuration using functional options.
type frpsinfoOption func(*FrpsInfoMutation)

// newFrpsInfoMutation creates new mutation for the FrpsInfo entity.
func newFrpsInfoMutation(c config, op Op, opts ...frpsinfoOption) *FrpsInfoMutation {
	m := &FrpsInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeFrpsInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFrpsInfoID sets the ID field of the mutation.
func withFrpsInfoID(id int64) frpsinfoOption {
	return func(m *FrpsInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *FrpsInfo
		)
		m.oldValue = func(ctx context.Context) (*FrpsInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FrpsInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFrpsInfo sets the old FrpsInfo of the mutation.
func withFrpsInfo(node *FrpsInfo) frpsinfoOption {
	return func(m *FrpsInfoMutation) {
		m.oldValue = func(context.Context) (*FrpsInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FrpsInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FrpsInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FrpsInfo entities.
func (m *FrpsInfoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FrpsInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FrpsInfoMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FrpsInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *FrpsInfoMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FrpsInfoMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FrpsInfoMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FrpsInfoMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FrpsInfoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FrpsInfoMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FrpsInfoMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FrpsInfoMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FrpsInfoMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FrpsInfoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FrpsInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FrpsInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FrpsInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FrpsInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FrpsInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FrpsInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FrpsInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FrpsInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FrpsInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTag sets the "tag" field.
func (m *FrpsInfoMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *FrpsInfoMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *FrpsInfoMutation) ResetTag() {
	m.tag = nil
}

// SetDomain sets the "domain" field.
func (m *FrpsInfoMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *FrpsInfoMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *FrpsInfoMutation) ResetDomain() {
	m.domain = nil
}

// SetServerAddr sets the "server_addr" field.
func (m *FrpsInfoMutation) SetServerAddr(s string) {
	m.server_addr = &s
}

// ServerAddr returns the value of the "server_addr" field in the mutation.
func (m *FrpsInfoMutation) ServerAddr() (r string, exists bool) {
	v := m.server_addr
	if v == nil {
		return
	}
	return *v, true
}

// OldServerAddr returns the old "server_addr" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldServerAddr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerAddr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerAddr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerAddr: %w", err)
	}
	return oldValue.ServerAddr, nil
}

// ResetServerAddr resets all changes to the "server_addr" field.
func (m *FrpsInfoMutation) ResetServerAddr() {
	m.server_addr = nil
}

// SetServerPort sets the "server_port" field.
func (m *FrpsInfoMutation) SetServerPort(i int) {
	m.server_port = &i
	m.addserver_port = nil
}

// ServerPort returns the value of the "server_port" field in the mutation.
func (m *FrpsInfoMutation) ServerPort() (r int, exists bool) {
	v := m.server_port
	if v == nil {
		return
	}
	return *v, true
}

// OldServerPort returns the old "server_port" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldServerPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerPort: %w", err)
	}
	return oldValue.ServerPort, nil
}

// AddServerPort adds i to the "server_port" field.
func (m *FrpsInfoMutation) AddServerPort(i int) {
	if m.addserver_port != nil {
		*m.addserver_port += i
	} else {
		m.addserver_port = &i
	}
}

// AddedServerPort returns the value that was added to the "server_port" field in this mutation.
func (m *FrpsInfoMutation) AddedServerPort() (r int, exists bool) {
	v := m.addserver_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetServerPort resets all changes to the "server_port" field.
func (m *FrpsInfoMutation) ResetServerPort() {
	m.server_port = nil
	m.addserver_port = nil
}

// SetAuthenticationMethod sets the "authentication_method" field.
func (m *FrpsInfoMutation) SetAuthenticationMethod(s string) {
	m.authentication_method = &s
}

// AuthenticationMethod returns the value of the "authentication_method" field in the mutation.
func (m *FrpsInfoMutation) AuthenticationMethod() (r string, exists bool) {
	v := m.authentication_method
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthenticationMethod returns the old "authentication_method" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldAuthenticationMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthenticationMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthenticationMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthenticationMethod: %w", err)
	}
	return oldValue.AuthenticationMethod, nil
}

// ResetAuthenticationMethod resets all changes to the "authentication_method" field.
func (m *FrpsInfoMutation) ResetAuthenticationMethod() {
	m.authentication_method = nil
}

// SetToken sets the "token" field.
func (m *FrpsInfoMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *FrpsInfoMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *FrpsInfoMutation) ResetToken() {
	m.token = nil
}

// SetType sets the "type" field.
func (m *FrpsInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FrpsInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FrpsInfoMutation) ResetType() {
	m._type = nil
}

// AddFrpcInfoIDs adds the "frpc_infos" edge to the FrpcInfo entity by ids.
func (m *FrpsInfoMutation) AddFrpcInfoIDs(ids ...int64) {
	if m.frpc_infos == nil {
		m.frpc_infos = make(map[int64]struct{})
	}
	for i := range ids {
		m.frpc_infos[ids[i]] = struct{}{}
	}
}

// ClearFrpcInfos clears the "frpc_infos" edge to the FrpcInfo entity.
func (m *FrpsInfoMutation) ClearFrpcInfos() {
	m.clearedfrpc_infos = true
}

// FrpcInfosCleared reports if the "frpc_infos" edge to the FrpcInfo entity was cleared.
func (m *FrpsInfoMutation) FrpcInfosCleared() bool {
	return m.clearedfrpc_infos
}

// RemoveFrpcInfoIDs removes the "frpc_infos" edge to the FrpcInfo entity by IDs.
func (m *FrpsInfoMutation) RemoveFrpcInfoIDs(ids ...int64) {
	if m.removedfrpc_infos == nil {
		m.removedfrpc_infos = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.frpc_infos, ids[i])
		m.removedfrpc_infos[ids[i]] = struct{}{}
	}
}

// RemovedFrpcInfos returns the removed IDs of the "frpc_infos" edge to the FrpcInfo entity.
func (m *FrpsInfoMutation) RemovedFrpcInfosIDs() (ids []int64) {
	for id := range m.removedfrpc_infos {
		ids = append(ids, id)
	}
	return
}

// FrpcInfosIDs returns the "frpc_infos" edge IDs in the mutation.
func (m *FrpsInfoMutation) FrpcInfosIDs() (ids []int64) {
	for id := range m.frpc_infos {
		ids = append(ids, id)
	}
	return
}

// ResetFrpcInfos resets all changes to the "frpc_infos" edge.
func (m *FrpsInfoMutation) ResetFrpcInfos() {
	m.frpc_infos = nil
	m.clearedfrpc_infos = false
	m.removedfrpc_infos = nil
}

// Where appends a list predicates to the FrpsInfoMutation builder.
func (m *FrpsInfoMutation) Where(ps ...predicate.FrpsInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FrpsInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FrpsInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FrpsInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FrpsInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FrpsInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FrpsInfo).
func (m *FrpsInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FrpsInfoMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, frpsinfo.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, frpsinfo.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, frpsinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, frpsinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, frpsinfo.FieldDeletedAt)
	}
	if m.tag != nil {
		fields = append(fields, frpsinfo.FieldTag)
	}
	if m.domain != nil {
		fields = append(fields, frpsinfo.FieldDomain)
	}
	if m.server_addr != nil {
		fields = append(fields, frpsinfo.FieldServerAddr)
	}
	if m.server_port != nil {
		fields = append(fields, frpsinfo.FieldServerPort)
	}
	if m.authentication_method != nil {
		fields = append(fields, frpsinfo.FieldAuthenticationMethod)
	}
	if m.token != nil {
		fields = append(fields, frpsinfo.FieldToken)
	}
	if m._type != nil {
		fields = append(fields, frpsinfo.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FrpsInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case frpsinfo.FieldCreatedBy:
		return m.CreatedBy()
	case frpsinfo.FieldUpdatedBy:
		return m.UpdatedBy()
	case frpsinfo.FieldCreatedAt:
		return m.CreatedAt()
	case frpsinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case frpsinfo.FieldDeletedAt:
		return m.DeletedAt()
	case frpsinfo.FieldTag:
		return m.Tag()
	case frpsinfo.FieldDomain:
		return m.Domain()
	case frpsinfo.FieldServerAddr:
		return m.ServerAddr()
	case frpsinfo.FieldServerPort:
		return m.ServerPort()
	case frpsinfo.FieldAuthenticationMethod:
		return m.AuthenticationMethod()
	case frpsinfo.FieldToken:
		return m.Token()
	case frpsinfo.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FrpsInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case frpsinfo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case frpsinfo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case frpsinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case frpsinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case frpsinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case frpsinfo.FieldTag:
		return m.OldTag(ctx)
	case frpsinfo.FieldDomain:
		return m.OldDomain(ctx)
	case frpsinfo.FieldServerAddr:
		return m.OldServerAddr(ctx)
	case frpsinfo.FieldServerPort:
		return m.OldServerPort(ctx)
	case frpsinfo.FieldAuthenticationMethod:
		return m.OldAuthenticationMethod(ctx)
	case frpsinfo.FieldToken:
		return m.OldToken(ctx)
	case frpsinfo.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown FrpsInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrpsInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case frpsinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case frpsinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case frpsinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case frpsinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case frpsinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case frpsinfo.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case frpsinfo.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case frpsinfo.FieldServerAddr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerAddr(v)
		return nil
	case frpsinfo.FieldServerPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerPort(v)
		return nil
	case frpsinfo.FieldAuthenticationMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthenticationMethod(v)
		return nil
	case frpsinfo.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case frpsinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown FrpsInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FrpsInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, frpsinfo.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, frpsinfo.FieldUpdatedBy)
	}
	if m.addserver_port != nil {
		fields = append(fields, frpsinfo.FieldServerPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FrpsInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case frpsinfo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case frpsinfo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case frpsinfo.FieldServerPort:
		return m.AddedServerPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrpsInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case frpsinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case frpsinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case frpsinfo.FieldServerPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServerPort(v)
		return nil
	}
	return fmt.Errorf("unknown FrpsInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FrpsInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FrpsInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FrpsInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FrpsInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FrpsInfoMutation) ResetField(name string) error {
	switch name {
	case frpsinfo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case frpsinfo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case frpsinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case frpsinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case frpsinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case frpsinfo.FieldTag:
		m.ResetTag()
		return nil
	case frpsinfo.FieldDomain:
		m.ResetDomain()
		return nil
	case frpsinfo.FieldServerAddr:
		m.ResetServerAddr()
		return nil
	case frpsinfo.FieldServerPort:
		m.ResetServerPort()
		return nil
	case frpsinfo.FieldAuthenticationMethod:
		m.ResetAuthenticationMethod()
		return nil
	case frpsinfo.FieldToken:
		m.ResetToken()
		return nil
	case frpsinfo.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown FrpsInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FrpsInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.frpc_infos != nil {
		edges = append(edges, frpsinfo.EdgeFrpcInfos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FrpsInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case frpsinfo.EdgeFrpcInfos:
		ids := make([]ent.Value, 0, len(m.frpc_infos))
		for id := range m.frpc_infos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FrpsInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfrpc_infos != nil {
		edges = append(edges, frpsinfo.EdgeFrpcInfos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FrpsInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case frpsinfo.EdgeFrpcInfos:
		ids := make([]ent.Value, 0, len(m.removedfrpc_infos))
		for id := range m.removedfrpc_infos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FrpsInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfrpc_infos {
		edges = append(edges, frpsinfo.EdgeFrpcInfos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FrpsInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case frpsinfo.EdgeFrpcInfos:
		return m.clearedfrpc_infos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FrpsInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FrpsInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FrpsInfoMutation) ResetEdge(name string) error {
	switch name {
	case frpsinfo.EdgeFrpcInfos:
		m.ResetFrpcInfos()
		return nil
	}
	return fmt.Errorf("unknown FrpsInfo edge %s", name)
}

// GiftMissionConfigMutation represents an operation that mutates the GiftMissionConfig nodes in the graph.
type GiftMissionConfigMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	stability_level   *enums.DeviceStabilityType
	gpu_version       *enums.GpuVersion
	gap_base          *int64
	addgap_base       *int64
	gap_random_max    *int64
	addgap_random_max *int64
	gap_random_min    *int64
	addgap_random_min *int64
	clearedFields     map[string]struct{}
	devices           map[int64]struct{}
	removeddevices    map[int64]struct{}
	cleareddevices    bool
	done              bool
	oldValue          func(context.Context) (*GiftMissionConfig, error)
	predicates        []predicate.GiftMissionConfig
}

var _ ent.Mutation = (*GiftMissionConfigMutation)(nil)

// giftmissionconfigOption allows management of the mutation configuration using functional options.
type giftmissionconfigOption func(*GiftMissionConfigMutation)

// newGiftMissionConfigMutation creates new mutation for the GiftMissionConfig entity.
func newGiftMissionConfigMutation(c config, op Op, opts ...giftmissionconfigOption) *GiftMissionConfigMutation {
	m := &GiftMissionConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeGiftMissionConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGiftMissionConfigID sets the ID field of the mutation.
func withGiftMissionConfigID(id int64) giftmissionconfigOption {
	return func(m *GiftMissionConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *GiftMissionConfig
		)
		m.oldValue = func(ctx context.Context) (*GiftMissionConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GiftMissionConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGiftMissionConfig sets the old GiftMissionConfig of the mutation.
func withGiftMissionConfig(node *GiftMissionConfig) giftmissionconfigOption {
	return func(m *GiftMissionConfigMutation) {
		m.oldValue = func(context.Context) (*GiftMissionConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GiftMissionConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GiftMissionConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GiftMissionConfig entities.
func (m *GiftMissionConfigMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GiftMissionConfigMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GiftMissionConfigMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GiftMissionConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *GiftMissionConfigMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GiftMissionConfigMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *GiftMissionConfigMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *GiftMissionConfigMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GiftMissionConfigMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GiftMissionConfigMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GiftMissionConfigMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *GiftMissionConfigMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *GiftMissionConfigMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GiftMissionConfigMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GiftMissionConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GiftMissionConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GiftMissionConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GiftMissionConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GiftMissionConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GiftMissionConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GiftMissionConfigMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GiftMissionConfigMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GiftMissionConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetStabilityLevel sets the "stability_level" field.
func (m *GiftMissionConfigMutation) SetStabilityLevel(est enums.DeviceStabilityType) {
	m.stability_level = &est
}

// StabilityLevel returns the value of the "stability_level" field in the mutation.
func (m *GiftMissionConfigMutation) StabilityLevel() (r enums.DeviceStabilityType, exists bool) {
	v := m.stability_level
	if v == nil {
		return
	}
	return *v, true
}

// OldStabilityLevel returns the old "stability_level" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldStabilityLevel(ctx context.Context) (v enums.DeviceStabilityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStabilityLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStabilityLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStabilityLevel: %w", err)
	}
	return oldValue.StabilityLevel, nil
}

// ResetStabilityLevel resets all changes to the "stability_level" field.
func (m *GiftMissionConfigMutation) ResetStabilityLevel() {
	m.stability_level = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *GiftMissionConfigMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *GiftMissionConfigMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *GiftMissionConfigMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetGapBase sets the "gap_base" field.
func (m *GiftMissionConfigMutation) SetGapBase(i int64) {
	m.gap_base = &i
	m.addgap_base = nil
}

// GapBase returns the value of the "gap_base" field in the mutation.
func (m *GiftMissionConfigMutation) GapBase() (r int64, exists bool) {
	v := m.gap_base
	if v == nil {
		return
	}
	return *v, true
}

// OldGapBase returns the old "gap_base" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldGapBase(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGapBase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGapBase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGapBase: %w", err)
	}
	return oldValue.GapBase, nil
}

// AddGapBase adds i to the "gap_base" field.
func (m *GiftMissionConfigMutation) AddGapBase(i int64) {
	if m.addgap_base != nil {
		*m.addgap_base += i
	} else {
		m.addgap_base = &i
	}
}

// AddedGapBase returns the value that was added to the "gap_base" field in this mutation.
func (m *GiftMissionConfigMutation) AddedGapBase() (r int64, exists bool) {
	v := m.addgap_base
	if v == nil {
		return
	}
	return *v, true
}

// ResetGapBase resets all changes to the "gap_base" field.
func (m *GiftMissionConfigMutation) ResetGapBase() {
	m.gap_base = nil
	m.addgap_base = nil
}

// SetGapRandomMax sets the "gap_random_max" field.
func (m *GiftMissionConfigMutation) SetGapRandomMax(i int64) {
	m.gap_random_max = &i
	m.addgap_random_max = nil
}

// GapRandomMax returns the value of the "gap_random_max" field in the mutation.
func (m *GiftMissionConfigMutation) GapRandomMax() (r int64, exists bool) {
	v := m.gap_random_max
	if v == nil {
		return
	}
	return *v, true
}

// OldGapRandomMax returns the old "gap_random_max" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldGapRandomMax(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGapRandomMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGapRandomMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGapRandomMax: %w", err)
	}
	return oldValue.GapRandomMax, nil
}

// AddGapRandomMax adds i to the "gap_random_max" field.
func (m *GiftMissionConfigMutation) AddGapRandomMax(i int64) {
	if m.addgap_random_max != nil {
		*m.addgap_random_max += i
	} else {
		m.addgap_random_max = &i
	}
}

// AddedGapRandomMax returns the value that was added to the "gap_random_max" field in this mutation.
func (m *GiftMissionConfigMutation) AddedGapRandomMax() (r int64, exists bool) {
	v := m.addgap_random_max
	if v == nil {
		return
	}
	return *v, true
}

// ResetGapRandomMax resets all changes to the "gap_random_max" field.
func (m *GiftMissionConfigMutation) ResetGapRandomMax() {
	m.gap_random_max = nil
	m.addgap_random_max = nil
}

// SetGapRandomMin sets the "gap_random_min" field.
func (m *GiftMissionConfigMutation) SetGapRandomMin(i int64) {
	m.gap_random_min = &i
	m.addgap_random_min = nil
}

// GapRandomMin returns the value of the "gap_random_min" field in the mutation.
func (m *GiftMissionConfigMutation) GapRandomMin() (r int64, exists bool) {
	v := m.gap_random_min
	if v == nil {
		return
	}
	return *v, true
}

// OldGapRandomMin returns the old "gap_random_min" field's value of the GiftMissionConfig entity.
// If the GiftMissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GiftMissionConfigMutation) OldGapRandomMin(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGapRandomMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGapRandomMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGapRandomMin: %w", err)
	}
	return oldValue.GapRandomMin, nil
}

// AddGapRandomMin adds i to the "gap_random_min" field.
func (m *GiftMissionConfigMutation) AddGapRandomMin(i int64) {
	if m.addgap_random_min != nil {
		*m.addgap_random_min += i
	} else {
		m.addgap_random_min = &i
	}
}

// AddedGapRandomMin returns the value that was added to the "gap_random_min" field in this mutation.
func (m *GiftMissionConfigMutation) AddedGapRandomMin() (r int64, exists bool) {
	v := m.addgap_random_min
	if v == nil {
		return
	}
	return *v, true
}

// ResetGapRandomMin resets all changes to the "gap_random_min" field.
func (m *GiftMissionConfigMutation) ResetGapRandomMin() {
	m.gap_random_min = nil
	m.addgap_random_min = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *GiftMissionConfigMutation) AddDeviceIDs(ids ...int64) {
	if m.devices == nil {
		m.devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *GiftMissionConfigMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *GiftMissionConfigMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *GiftMissionConfigMutation) RemoveDeviceIDs(ids ...int64) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *GiftMissionConfigMutation) RemovedDevicesIDs() (ids []int64) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *GiftMissionConfigMutation) DevicesIDs() (ids []int64) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *GiftMissionConfigMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// Where appends a list predicates to the GiftMissionConfigMutation builder.
func (m *GiftMissionConfigMutation) Where(ps ...predicate.GiftMissionConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GiftMissionConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GiftMissionConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GiftMissionConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GiftMissionConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GiftMissionConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GiftMissionConfig).
func (m *GiftMissionConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GiftMissionConfigMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, giftmissionconfig.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, giftmissionconfig.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, giftmissionconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, giftmissionconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, giftmissionconfig.FieldDeletedAt)
	}
	if m.stability_level != nil {
		fields = append(fields, giftmissionconfig.FieldStabilityLevel)
	}
	if m.gpu_version != nil {
		fields = append(fields, giftmissionconfig.FieldGpuVersion)
	}
	if m.gap_base != nil {
		fields = append(fields, giftmissionconfig.FieldGapBase)
	}
	if m.gap_random_max != nil {
		fields = append(fields, giftmissionconfig.FieldGapRandomMax)
	}
	if m.gap_random_min != nil {
		fields = append(fields, giftmissionconfig.FieldGapRandomMin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GiftMissionConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case giftmissionconfig.FieldCreatedBy:
		return m.CreatedBy()
	case giftmissionconfig.FieldUpdatedBy:
		return m.UpdatedBy()
	case giftmissionconfig.FieldCreatedAt:
		return m.CreatedAt()
	case giftmissionconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case giftmissionconfig.FieldDeletedAt:
		return m.DeletedAt()
	case giftmissionconfig.FieldStabilityLevel:
		return m.StabilityLevel()
	case giftmissionconfig.FieldGpuVersion:
		return m.GpuVersion()
	case giftmissionconfig.FieldGapBase:
		return m.GapBase()
	case giftmissionconfig.FieldGapRandomMax:
		return m.GapRandomMax()
	case giftmissionconfig.FieldGapRandomMin:
		return m.GapRandomMin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GiftMissionConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case giftmissionconfig.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case giftmissionconfig.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case giftmissionconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case giftmissionconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case giftmissionconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case giftmissionconfig.FieldStabilityLevel:
		return m.OldStabilityLevel(ctx)
	case giftmissionconfig.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case giftmissionconfig.FieldGapBase:
		return m.OldGapBase(ctx)
	case giftmissionconfig.FieldGapRandomMax:
		return m.OldGapRandomMax(ctx)
	case giftmissionconfig.FieldGapRandomMin:
		return m.OldGapRandomMin(ctx)
	}
	return nil, fmt.Errorf("unknown GiftMissionConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GiftMissionConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case giftmissionconfig.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case giftmissionconfig.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case giftmissionconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case giftmissionconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case giftmissionconfig.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case giftmissionconfig.FieldStabilityLevel:
		v, ok := value.(enums.DeviceStabilityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStabilityLevel(v)
		return nil
	case giftmissionconfig.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case giftmissionconfig.FieldGapBase:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGapBase(v)
		return nil
	case giftmissionconfig.FieldGapRandomMax:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGapRandomMax(v)
		return nil
	case giftmissionconfig.FieldGapRandomMin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGapRandomMin(v)
		return nil
	}
	return fmt.Errorf("unknown GiftMissionConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GiftMissionConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, giftmissionconfig.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, giftmissionconfig.FieldUpdatedBy)
	}
	if m.addgap_base != nil {
		fields = append(fields, giftmissionconfig.FieldGapBase)
	}
	if m.addgap_random_max != nil {
		fields = append(fields, giftmissionconfig.FieldGapRandomMax)
	}
	if m.addgap_random_min != nil {
		fields = append(fields, giftmissionconfig.FieldGapRandomMin)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GiftMissionConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case giftmissionconfig.FieldCreatedBy:
		return m.AddedCreatedBy()
	case giftmissionconfig.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case giftmissionconfig.FieldGapBase:
		return m.AddedGapBase()
	case giftmissionconfig.FieldGapRandomMax:
		return m.AddedGapRandomMax()
	case giftmissionconfig.FieldGapRandomMin:
		return m.AddedGapRandomMin()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GiftMissionConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case giftmissionconfig.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case giftmissionconfig.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case giftmissionconfig.FieldGapBase:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGapBase(v)
		return nil
	case giftmissionconfig.FieldGapRandomMax:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGapRandomMax(v)
		return nil
	case giftmissionconfig.FieldGapRandomMin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGapRandomMin(v)
		return nil
	}
	return fmt.Errorf("unknown GiftMissionConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GiftMissionConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GiftMissionConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GiftMissionConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GiftMissionConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GiftMissionConfigMutation) ResetField(name string) error {
	switch name {
	case giftmissionconfig.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case giftmissionconfig.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case giftmissionconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case giftmissionconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case giftmissionconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case giftmissionconfig.FieldStabilityLevel:
		m.ResetStabilityLevel()
		return nil
	case giftmissionconfig.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case giftmissionconfig.FieldGapBase:
		m.ResetGapBase()
		return nil
	case giftmissionconfig.FieldGapRandomMax:
		m.ResetGapRandomMax()
		return nil
	case giftmissionconfig.FieldGapRandomMin:
		m.ResetGapRandomMin()
		return nil
	}
	return fmt.Errorf("unknown GiftMissionConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GiftMissionConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.devices != nil {
		edges = append(edges, giftmissionconfig.EdgeDevices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GiftMissionConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case giftmissionconfig.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GiftMissionConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddevices != nil {
		edges = append(edges, giftmissionconfig.EdgeDevices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GiftMissionConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case giftmissionconfig.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GiftMissionConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevices {
		edges = append(edges, giftmissionconfig.EdgeDevices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GiftMissionConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case giftmissionconfig.EdgeDevices:
		return m.cleareddevices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GiftMissionConfigMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GiftMissionConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GiftMissionConfigMutation) ResetEdge(name string) error {
	switch name {
	case giftmissionconfig.EdgeDevices:
		m.ResetDevices()
		return nil
	}
	return fmt.Errorf("unknown GiftMissionConfig edge %s", name)
}

// GpuMutation represents an operation that mutates the Gpu nodes in the graph.
type GpuMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	version                    *enums.GpuVersion
	power                      *int
	addpower                   *int
	video_memory               *int
	addvideo_memory            *int
	cpu                        *int
	addcpu                     *int
	memory                     *int
	addmemory                  *int
	lowest_earn_month          *int64
	addlowest_earn_month       *int64
	highest_earn_month         *int64
	addhighest_earn_month      *int64
	trouble_deduct_amount      *int64
	addtrouble_deduct_amount   *int64
	withdraw_retain_amount     *int64
	addwithdraw_retain_amount  *int64
	clearedFields              map[string]struct{}
	device_gpu_missions        map[int64]struct{}
	removeddevice_gpu_missions map[int64]struct{}
	cleareddevice_gpu_missions bool
	prices                     map[int64]struct{}
	removedprices              map[int64]struct{}
	clearedprices              bool
	done                       bool
	oldValue                   func(context.Context) (*Gpu, error)
	predicates                 []predicate.Gpu
}

var _ ent.Mutation = (*GpuMutation)(nil)

// gpuOption allows management of the mutation configuration using functional options.
type gpuOption func(*GpuMutation)

// newGpuMutation creates new mutation for the Gpu entity.
func newGpuMutation(c config, op Op, opts ...gpuOption) *GpuMutation {
	m := &GpuMutation{
		config:        c,
		op:            op,
		typ:           TypeGpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGpuID sets the ID field of the mutation.
func withGpuID(id int64) gpuOption {
	return func(m *GpuMutation) {
		var (
			err   error
			once  sync.Once
			value *Gpu
		)
		m.oldValue = func(ctx context.Context) (*Gpu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gpu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGpu sets the old Gpu of the mutation.
func withGpu(node *Gpu) gpuOption {
	return func(m *GpuMutation) {
		m.oldValue = func(context.Context) (*Gpu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GpuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GpuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Gpu entities.
func (m *GpuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GpuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GpuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Gpu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *GpuMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GpuMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *GpuMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *GpuMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GpuMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GpuMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GpuMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *GpuMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *GpuMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GpuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GpuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GpuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GpuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GpuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GpuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GpuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GpuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GpuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GpuMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetVersion sets the "version" field.
func (m *GpuMutation) SetVersion(ev enums.GpuVersion) {
	m.version = &ev
}

// Version returns the value of the "version" field in the mutation.
func (m *GpuMutation) Version() (r enums.GpuVersion, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *GpuMutation) ResetVersion() {
	m.version = nil
}

// SetPower sets the "power" field.
func (m *GpuMutation) SetPower(i int) {
	m.power = &i
	m.addpower = nil
}

// Power returns the value of the "power" field in the mutation.
func (m *GpuMutation) Power() (r int, exists bool) {
	v := m.power
	if v == nil {
		return
	}
	return *v, true
}

// OldPower returns the old "power" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldPower(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPower is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPower requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPower: %w", err)
	}
	return oldValue.Power, nil
}

// AddPower adds i to the "power" field.
func (m *GpuMutation) AddPower(i int) {
	if m.addpower != nil {
		*m.addpower += i
	} else {
		m.addpower = &i
	}
}

// AddedPower returns the value that was added to the "power" field in this mutation.
func (m *GpuMutation) AddedPower() (r int, exists bool) {
	v := m.addpower
	if v == nil {
		return
	}
	return *v, true
}

// ResetPower resets all changes to the "power" field.
func (m *GpuMutation) ResetPower() {
	m.power = nil
	m.addpower = nil
}

// SetVideoMemory sets the "video_memory" field.
func (m *GpuMutation) SetVideoMemory(i int) {
	m.video_memory = &i
	m.addvideo_memory = nil
}

// VideoMemory returns the value of the "video_memory" field in the mutation.
func (m *GpuMutation) VideoMemory() (r int, exists bool) {
	v := m.video_memory
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoMemory returns the old "video_memory" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldVideoMemory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoMemory: %w", err)
	}
	return oldValue.VideoMemory, nil
}

// AddVideoMemory adds i to the "video_memory" field.
func (m *GpuMutation) AddVideoMemory(i int) {
	if m.addvideo_memory != nil {
		*m.addvideo_memory += i
	} else {
		m.addvideo_memory = &i
	}
}

// AddedVideoMemory returns the value that was added to the "video_memory" field in this mutation.
func (m *GpuMutation) AddedVideoMemory() (r int, exists bool) {
	v := m.addvideo_memory
	if v == nil {
		return
	}
	return *v, true
}

// ResetVideoMemory resets all changes to the "video_memory" field.
func (m *GpuMutation) ResetVideoMemory() {
	m.video_memory = nil
	m.addvideo_memory = nil
}

// SetCPU sets the "cpu" field.
func (m *GpuMutation) SetCPU(i int) {
	m.cpu = &i
	m.addcpu = nil
}

// CPU returns the value of the "cpu" field in the mutation.
func (m *GpuMutation) CPU() (r int, exists bool) {
	v := m.cpu
	if v == nil {
		return
	}
	return *v, true
}

// OldCPU returns the old "cpu" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldCPU(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPU: %w", err)
	}
	return oldValue.CPU, nil
}

// AddCPU adds i to the "cpu" field.
func (m *GpuMutation) AddCPU(i int) {
	if m.addcpu != nil {
		*m.addcpu += i
	} else {
		m.addcpu = &i
	}
}

// AddedCPU returns the value that was added to the "cpu" field in this mutation.
func (m *GpuMutation) AddedCPU() (r int, exists bool) {
	v := m.addcpu
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPU resets all changes to the "cpu" field.
func (m *GpuMutation) ResetCPU() {
	m.cpu = nil
	m.addcpu = nil
}

// SetMemory sets the "memory" field.
func (m *GpuMutation) SetMemory(i int) {
	m.memory = &i
	m.addmemory = nil
}

// Memory returns the value of the "memory" field in the mutation.
func (m *GpuMutation) Memory() (r int, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldMemory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// AddMemory adds i to the "memory" field.
func (m *GpuMutation) AddMemory(i int) {
	if m.addmemory != nil {
		*m.addmemory += i
	} else {
		m.addmemory = &i
	}
}

// AddedMemory returns the value that was added to the "memory" field in this mutation.
func (m *GpuMutation) AddedMemory() (r int, exists bool) {
	v := m.addmemory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemory resets all changes to the "memory" field.
func (m *GpuMutation) ResetMemory() {
	m.memory = nil
	m.addmemory = nil
}

// SetLowestEarnMonth sets the "lowest_earn_month" field.
func (m *GpuMutation) SetLowestEarnMonth(i int64) {
	m.lowest_earn_month = &i
	m.addlowest_earn_month = nil
}

// LowestEarnMonth returns the value of the "lowest_earn_month" field in the mutation.
func (m *GpuMutation) LowestEarnMonth() (r int64, exists bool) {
	v := m.lowest_earn_month
	if v == nil {
		return
	}
	return *v, true
}

// OldLowestEarnMonth returns the old "lowest_earn_month" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldLowestEarnMonth(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowestEarnMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowestEarnMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowestEarnMonth: %w", err)
	}
	return oldValue.LowestEarnMonth, nil
}

// AddLowestEarnMonth adds i to the "lowest_earn_month" field.
func (m *GpuMutation) AddLowestEarnMonth(i int64) {
	if m.addlowest_earn_month != nil {
		*m.addlowest_earn_month += i
	} else {
		m.addlowest_earn_month = &i
	}
}

// AddedLowestEarnMonth returns the value that was added to the "lowest_earn_month" field in this mutation.
func (m *GpuMutation) AddedLowestEarnMonth() (r int64, exists bool) {
	v := m.addlowest_earn_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetLowestEarnMonth resets all changes to the "lowest_earn_month" field.
func (m *GpuMutation) ResetLowestEarnMonth() {
	m.lowest_earn_month = nil
	m.addlowest_earn_month = nil
}

// SetHighestEarnMonth sets the "highest_earn_month" field.
func (m *GpuMutation) SetHighestEarnMonth(i int64) {
	m.highest_earn_month = &i
	m.addhighest_earn_month = nil
}

// HighestEarnMonth returns the value of the "highest_earn_month" field in the mutation.
func (m *GpuMutation) HighestEarnMonth() (r int64, exists bool) {
	v := m.highest_earn_month
	if v == nil {
		return
	}
	return *v, true
}

// OldHighestEarnMonth returns the old "highest_earn_month" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldHighestEarnMonth(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighestEarnMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighestEarnMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighestEarnMonth: %w", err)
	}
	return oldValue.HighestEarnMonth, nil
}

// AddHighestEarnMonth adds i to the "highest_earn_month" field.
func (m *GpuMutation) AddHighestEarnMonth(i int64) {
	if m.addhighest_earn_month != nil {
		*m.addhighest_earn_month += i
	} else {
		m.addhighest_earn_month = &i
	}
}

// AddedHighestEarnMonth returns the value that was added to the "highest_earn_month" field in this mutation.
func (m *GpuMutation) AddedHighestEarnMonth() (r int64, exists bool) {
	v := m.addhighest_earn_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetHighestEarnMonth resets all changes to the "highest_earn_month" field.
func (m *GpuMutation) ResetHighestEarnMonth() {
	m.highest_earn_month = nil
	m.addhighest_earn_month = nil
}

// SetTroubleDeductAmount sets the "trouble_deduct_amount" field.
func (m *GpuMutation) SetTroubleDeductAmount(i int64) {
	m.trouble_deduct_amount = &i
	m.addtrouble_deduct_amount = nil
}

// TroubleDeductAmount returns the value of the "trouble_deduct_amount" field in the mutation.
func (m *GpuMutation) TroubleDeductAmount() (r int64, exists bool) {
	v := m.trouble_deduct_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTroubleDeductAmount returns the old "trouble_deduct_amount" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldTroubleDeductAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTroubleDeductAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTroubleDeductAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTroubleDeductAmount: %w", err)
	}
	return oldValue.TroubleDeductAmount, nil
}

// AddTroubleDeductAmount adds i to the "trouble_deduct_amount" field.
func (m *GpuMutation) AddTroubleDeductAmount(i int64) {
	if m.addtrouble_deduct_amount != nil {
		*m.addtrouble_deduct_amount += i
	} else {
		m.addtrouble_deduct_amount = &i
	}
}

// AddedTroubleDeductAmount returns the value that was added to the "trouble_deduct_amount" field in this mutation.
func (m *GpuMutation) AddedTroubleDeductAmount() (r int64, exists bool) {
	v := m.addtrouble_deduct_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTroubleDeductAmount resets all changes to the "trouble_deduct_amount" field.
func (m *GpuMutation) ResetTroubleDeductAmount() {
	m.trouble_deduct_amount = nil
	m.addtrouble_deduct_amount = nil
}

// SetWithdrawRetainAmount sets the "withdraw_retain_amount" field.
func (m *GpuMutation) SetWithdrawRetainAmount(i int64) {
	m.withdraw_retain_amount = &i
	m.addwithdraw_retain_amount = nil
}

// WithdrawRetainAmount returns the value of the "withdraw_retain_amount" field in the mutation.
func (m *GpuMutation) WithdrawRetainAmount() (r int64, exists bool) {
	v := m.withdraw_retain_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawRetainAmount returns the old "withdraw_retain_amount" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldWithdrawRetainAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawRetainAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawRetainAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawRetainAmount: %w", err)
	}
	return oldValue.WithdrawRetainAmount, nil
}

// AddWithdrawRetainAmount adds i to the "withdraw_retain_amount" field.
func (m *GpuMutation) AddWithdrawRetainAmount(i int64) {
	if m.addwithdraw_retain_amount != nil {
		*m.addwithdraw_retain_amount += i
	} else {
		m.addwithdraw_retain_amount = &i
	}
}

// AddedWithdrawRetainAmount returns the value that was added to the "withdraw_retain_amount" field in this mutation.
func (m *GpuMutation) AddedWithdrawRetainAmount() (r int64, exists bool) {
	v := m.addwithdraw_retain_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawRetainAmount resets all changes to the "withdraw_retain_amount" field.
func (m *GpuMutation) ResetWithdrawRetainAmount() {
	m.withdraw_retain_amount = nil
	m.addwithdraw_retain_amount = nil
}

// AddDeviceGpuMissionIDs adds the "device_gpu_missions" edge to the DeviceGpuMission entity by ids.
func (m *GpuMutation) AddDeviceGpuMissionIDs(ids ...int64) {
	if m.device_gpu_missions == nil {
		m.device_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_gpu_missions[ids[i]] = struct{}{}
	}
}

// ClearDeviceGpuMissions clears the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *GpuMutation) ClearDeviceGpuMissions() {
	m.cleareddevice_gpu_missions = true
}

// DeviceGpuMissionsCleared reports if the "device_gpu_missions" edge to the DeviceGpuMission entity was cleared.
func (m *GpuMutation) DeviceGpuMissionsCleared() bool {
	return m.cleareddevice_gpu_missions
}

// RemoveDeviceGpuMissionIDs removes the "device_gpu_missions" edge to the DeviceGpuMission entity by IDs.
func (m *GpuMutation) RemoveDeviceGpuMissionIDs(ids ...int64) {
	if m.removeddevice_gpu_missions == nil {
		m.removeddevice_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_gpu_missions, ids[i])
		m.removeddevice_gpu_missions[ids[i]] = struct{}{}
	}
}

// RemovedDeviceGpuMissions returns the removed IDs of the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *GpuMutation) RemovedDeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.removeddevice_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// DeviceGpuMissionsIDs returns the "device_gpu_missions" edge IDs in the mutation.
func (m *GpuMutation) DeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.device_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceGpuMissions resets all changes to the "device_gpu_missions" edge.
func (m *GpuMutation) ResetDeviceGpuMissions() {
	m.device_gpu_missions = nil
	m.cleareddevice_gpu_missions = false
	m.removeddevice_gpu_missions = nil
}

// AddPriceIDs adds the "prices" edge to the Price entity by ids.
func (m *GpuMutation) AddPriceIDs(ids ...int64) {
	if m.prices == nil {
		m.prices = make(map[int64]struct{})
	}
	for i := range ids {
		m.prices[ids[i]] = struct{}{}
	}
}

// ClearPrices clears the "prices" edge to the Price entity.
func (m *GpuMutation) ClearPrices() {
	m.clearedprices = true
}

// PricesCleared reports if the "prices" edge to the Price entity was cleared.
func (m *GpuMutation) PricesCleared() bool {
	return m.clearedprices
}

// RemovePriceIDs removes the "prices" edge to the Price entity by IDs.
func (m *GpuMutation) RemovePriceIDs(ids ...int64) {
	if m.removedprices == nil {
		m.removedprices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.prices, ids[i])
		m.removedprices[ids[i]] = struct{}{}
	}
}

// RemovedPrices returns the removed IDs of the "prices" edge to the Price entity.
func (m *GpuMutation) RemovedPricesIDs() (ids []int64) {
	for id := range m.removedprices {
		ids = append(ids, id)
	}
	return
}

// PricesIDs returns the "prices" edge IDs in the mutation.
func (m *GpuMutation) PricesIDs() (ids []int64) {
	for id := range m.prices {
		ids = append(ids, id)
	}
	return
}

// ResetPrices resets all changes to the "prices" edge.
func (m *GpuMutation) ResetPrices() {
	m.prices = nil
	m.clearedprices = false
	m.removedprices = nil
}

// Where appends a list predicates to the GpuMutation builder.
func (m *GpuMutation) Where(ps ...predicate.Gpu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GpuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GpuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Gpu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GpuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GpuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Gpu).
func (m *GpuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GpuMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, gpu.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, gpu.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, gpu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gpu.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, gpu.FieldDeletedAt)
	}
	if m.version != nil {
		fields = append(fields, gpu.FieldVersion)
	}
	if m.power != nil {
		fields = append(fields, gpu.FieldPower)
	}
	if m.video_memory != nil {
		fields = append(fields, gpu.FieldVideoMemory)
	}
	if m.cpu != nil {
		fields = append(fields, gpu.FieldCPU)
	}
	if m.memory != nil {
		fields = append(fields, gpu.FieldMemory)
	}
	if m.lowest_earn_month != nil {
		fields = append(fields, gpu.FieldLowestEarnMonth)
	}
	if m.highest_earn_month != nil {
		fields = append(fields, gpu.FieldHighestEarnMonth)
	}
	if m.trouble_deduct_amount != nil {
		fields = append(fields, gpu.FieldTroubleDeductAmount)
	}
	if m.withdraw_retain_amount != nil {
		fields = append(fields, gpu.FieldWithdrawRetainAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GpuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gpu.FieldCreatedBy:
		return m.CreatedBy()
	case gpu.FieldUpdatedBy:
		return m.UpdatedBy()
	case gpu.FieldCreatedAt:
		return m.CreatedAt()
	case gpu.FieldUpdatedAt:
		return m.UpdatedAt()
	case gpu.FieldDeletedAt:
		return m.DeletedAt()
	case gpu.FieldVersion:
		return m.Version()
	case gpu.FieldPower:
		return m.Power()
	case gpu.FieldVideoMemory:
		return m.VideoMemory()
	case gpu.FieldCPU:
		return m.CPU()
	case gpu.FieldMemory:
		return m.Memory()
	case gpu.FieldLowestEarnMonth:
		return m.LowestEarnMonth()
	case gpu.FieldHighestEarnMonth:
		return m.HighestEarnMonth()
	case gpu.FieldTroubleDeductAmount:
		return m.TroubleDeductAmount()
	case gpu.FieldWithdrawRetainAmount:
		return m.WithdrawRetainAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GpuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gpu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case gpu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case gpu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gpu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case gpu.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case gpu.FieldVersion:
		return m.OldVersion(ctx)
	case gpu.FieldPower:
		return m.OldPower(ctx)
	case gpu.FieldVideoMemory:
		return m.OldVideoMemory(ctx)
	case gpu.FieldCPU:
		return m.OldCPU(ctx)
	case gpu.FieldMemory:
		return m.OldMemory(ctx)
	case gpu.FieldLowestEarnMonth:
		return m.OldLowestEarnMonth(ctx)
	case gpu.FieldHighestEarnMonth:
		return m.OldHighestEarnMonth(ctx)
	case gpu.FieldTroubleDeductAmount:
		return m.OldTroubleDeductAmount(ctx)
	case gpu.FieldWithdrawRetainAmount:
		return m.OldWithdrawRetainAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Gpu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GpuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gpu.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case gpu.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case gpu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gpu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case gpu.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case gpu.FieldVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case gpu.FieldPower:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPower(v)
		return nil
	case gpu.FieldVideoMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoMemory(v)
		return nil
	case gpu.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPU(v)
		return nil
	case gpu.FieldMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case gpu.FieldLowestEarnMonth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowestEarnMonth(v)
		return nil
	case gpu.FieldHighestEarnMonth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighestEarnMonth(v)
		return nil
	case gpu.FieldTroubleDeductAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTroubleDeductAmount(v)
		return nil
	case gpu.FieldWithdrawRetainAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawRetainAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Gpu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GpuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, gpu.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, gpu.FieldUpdatedBy)
	}
	if m.addpower != nil {
		fields = append(fields, gpu.FieldPower)
	}
	if m.addvideo_memory != nil {
		fields = append(fields, gpu.FieldVideoMemory)
	}
	if m.addcpu != nil {
		fields = append(fields, gpu.FieldCPU)
	}
	if m.addmemory != nil {
		fields = append(fields, gpu.FieldMemory)
	}
	if m.addlowest_earn_month != nil {
		fields = append(fields, gpu.FieldLowestEarnMonth)
	}
	if m.addhighest_earn_month != nil {
		fields = append(fields, gpu.FieldHighestEarnMonth)
	}
	if m.addtrouble_deduct_amount != nil {
		fields = append(fields, gpu.FieldTroubleDeductAmount)
	}
	if m.addwithdraw_retain_amount != nil {
		fields = append(fields, gpu.FieldWithdrawRetainAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GpuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gpu.FieldCreatedBy:
		return m.AddedCreatedBy()
	case gpu.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case gpu.FieldPower:
		return m.AddedPower()
	case gpu.FieldVideoMemory:
		return m.AddedVideoMemory()
	case gpu.FieldCPU:
		return m.AddedCPU()
	case gpu.FieldMemory:
		return m.AddedMemory()
	case gpu.FieldLowestEarnMonth:
		return m.AddedLowestEarnMonth()
	case gpu.FieldHighestEarnMonth:
		return m.AddedHighestEarnMonth()
	case gpu.FieldTroubleDeductAmount:
		return m.AddedTroubleDeductAmount()
	case gpu.FieldWithdrawRetainAmount:
		return m.AddedWithdrawRetainAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GpuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gpu.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case gpu.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case gpu.FieldPower:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPower(v)
		return nil
	case gpu.FieldVideoMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoMemory(v)
		return nil
	case gpu.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPU(v)
		return nil
	case gpu.FieldMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemory(v)
		return nil
	case gpu.FieldLowestEarnMonth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowestEarnMonth(v)
		return nil
	case gpu.FieldHighestEarnMonth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighestEarnMonth(v)
		return nil
	case gpu.FieldTroubleDeductAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTroubleDeductAmount(v)
		return nil
	case gpu.FieldWithdrawRetainAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawRetainAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Gpu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GpuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GpuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GpuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gpu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GpuMutation) ResetField(name string) error {
	switch name {
	case gpu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case gpu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case gpu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gpu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case gpu.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case gpu.FieldVersion:
		m.ResetVersion()
		return nil
	case gpu.FieldPower:
		m.ResetPower()
		return nil
	case gpu.FieldVideoMemory:
		m.ResetVideoMemory()
		return nil
	case gpu.FieldCPU:
		m.ResetCPU()
		return nil
	case gpu.FieldMemory:
		m.ResetMemory()
		return nil
	case gpu.FieldLowestEarnMonth:
		m.ResetLowestEarnMonth()
		return nil
	case gpu.FieldHighestEarnMonth:
		m.ResetHighestEarnMonth()
		return nil
	case gpu.FieldTroubleDeductAmount:
		m.ResetTroubleDeductAmount()
		return nil
	case gpu.FieldWithdrawRetainAmount:
		m.ResetWithdrawRetainAmount()
		return nil
	}
	return fmt.Errorf("unknown Gpu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GpuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.device_gpu_missions != nil {
		edges = append(edges, gpu.EdgeDeviceGpuMissions)
	}
	if m.prices != nil {
		edges = append(edges, gpu.EdgePrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GpuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.device_gpu_missions))
		for id := range m.device_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	case gpu.EdgePrices:
		ids := make([]ent.Value, 0, len(m.prices))
		for id := range m.prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GpuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddevice_gpu_missions != nil {
		edges = append(edges, gpu.EdgeDeviceGpuMissions)
	}
	if m.removedprices != nil {
		edges = append(edges, gpu.EdgePrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GpuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.removeddevice_gpu_missions))
		for id := range m.removeddevice_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	case gpu.EdgePrices:
		ids := make([]ent.Value, 0, len(m.removedprices))
		for id := range m.removedprices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GpuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddevice_gpu_missions {
		edges = append(edges, gpu.EdgeDeviceGpuMissions)
	}
	if m.clearedprices {
		edges = append(edges, gpu.EdgePrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GpuMutation) EdgeCleared(name string) bool {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		return m.cleareddevice_gpu_missions
	case gpu.EdgePrices:
		return m.clearedprices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GpuMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gpu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GpuMutation) ResetEdge(name string) error {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		m.ResetDeviceGpuMissions()
		return nil
	case gpu.EdgePrices:
		m.ResetPrices()
		return nil
	}
	return fmt.Errorf("unknown Gpu edge %s", name)
}

// HmacKeyPairMutation represents an operation that mutates the HmacKeyPair nodes in the graph.
type HmacKeyPairMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_by               *int64
	addcreated_by            *int64
	updated_by               *int64
	addupdated_by            *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	key                      *string
	secret                   *string
	caller                   *string
	clearedFields            map[string]struct{}
	mission_key_pairs        map[int64]struct{}
	removedmission_key_pairs map[int64]struct{}
	clearedmission_key_pairs bool
	created_missions         map[int64]struct{}
	removedcreated_missions  map[int64]struct{}
	clearedcreated_missions  bool
	done                     bool
	oldValue                 func(context.Context) (*HmacKeyPair, error)
	predicates               []predicate.HmacKeyPair
}

var _ ent.Mutation = (*HmacKeyPairMutation)(nil)

// hmackeypairOption allows management of the mutation configuration using functional options.
type hmackeypairOption func(*HmacKeyPairMutation)

// newHmacKeyPairMutation creates new mutation for the HmacKeyPair entity.
func newHmacKeyPairMutation(c config, op Op, opts ...hmackeypairOption) *HmacKeyPairMutation {
	m := &HmacKeyPairMutation{
		config:        c,
		op:            op,
		typ:           TypeHmacKeyPair,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHmacKeyPairID sets the ID field of the mutation.
func withHmacKeyPairID(id int64) hmackeypairOption {
	return func(m *HmacKeyPairMutation) {
		var (
			err   error
			once  sync.Once
			value *HmacKeyPair
		)
		m.oldValue = func(ctx context.Context) (*HmacKeyPair, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HmacKeyPair.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHmacKeyPair sets the old HmacKeyPair of the mutation.
func withHmacKeyPair(node *HmacKeyPair) hmackeypairOption {
	return func(m *HmacKeyPairMutation) {
		m.oldValue = func(context.Context) (*HmacKeyPair, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HmacKeyPairMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HmacKeyPairMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HmacKeyPair entities.
func (m *HmacKeyPairMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HmacKeyPairMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HmacKeyPairMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HmacKeyPair.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *HmacKeyPairMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HmacKeyPairMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *HmacKeyPairMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *HmacKeyPairMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HmacKeyPairMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HmacKeyPairMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HmacKeyPairMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *HmacKeyPairMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *HmacKeyPairMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HmacKeyPairMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HmacKeyPairMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HmacKeyPairMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HmacKeyPairMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HmacKeyPairMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HmacKeyPairMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HmacKeyPairMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HmacKeyPairMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HmacKeyPairMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HmacKeyPairMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetKey sets the "key" field.
func (m *HmacKeyPairMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *HmacKeyPairMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *HmacKeyPairMutation) ResetKey() {
	m.key = nil
}

// SetSecret sets the "secret" field.
func (m *HmacKeyPairMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *HmacKeyPairMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *HmacKeyPairMutation) ResetSecret() {
	m.secret = nil
}

// SetCaller sets the "caller" field.
func (m *HmacKeyPairMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *HmacKeyPairMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *HmacKeyPairMutation) ResetCaller() {
	m.caller = nil
}

// AddMissionKeyPairIDs adds the "mission_key_pairs" edge to the MissionKeyPair entity by ids.
func (m *HmacKeyPairMutation) AddMissionKeyPairIDs(ids ...int64) {
	if m.mission_key_pairs == nil {
		m.mission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_key_pairs[ids[i]] = struct{}{}
	}
}

// ClearMissionKeyPairs clears the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *HmacKeyPairMutation) ClearMissionKeyPairs() {
	m.clearedmission_key_pairs = true
}

// MissionKeyPairsCleared reports if the "mission_key_pairs" edge to the MissionKeyPair entity was cleared.
func (m *HmacKeyPairMutation) MissionKeyPairsCleared() bool {
	return m.clearedmission_key_pairs
}

// RemoveMissionKeyPairIDs removes the "mission_key_pairs" edge to the MissionKeyPair entity by IDs.
func (m *HmacKeyPairMutation) RemoveMissionKeyPairIDs(ids ...int64) {
	if m.removedmission_key_pairs == nil {
		m.removedmission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_key_pairs, ids[i])
		m.removedmission_key_pairs[ids[i]] = struct{}{}
	}
}

// RemovedMissionKeyPairs returns the removed IDs of the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *HmacKeyPairMutation) RemovedMissionKeyPairsIDs() (ids []int64) {
	for id := range m.removedmission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// MissionKeyPairsIDs returns the "mission_key_pairs" edge IDs in the mutation.
func (m *HmacKeyPairMutation) MissionKeyPairsIDs() (ids []int64) {
	for id := range m.mission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// ResetMissionKeyPairs resets all changes to the "mission_key_pairs" edge.
func (m *HmacKeyPairMutation) ResetMissionKeyPairs() {
	m.mission_key_pairs = nil
	m.clearedmission_key_pairs = false
	m.removedmission_key_pairs = nil
}

// AddCreatedMissionIDs adds the "created_missions" edge to the Mission entity by ids.
func (m *HmacKeyPairMutation) AddCreatedMissionIDs(ids ...int64) {
	if m.created_missions == nil {
		m.created_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.created_missions[ids[i]] = struct{}{}
	}
}

// ClearCreatedMissions clears the "created_missions" edge to the Mission entity.
func (m *HmacKeyPairMutation) ClearCreatedMissions() {
	m.clearedcreated_missions = true
}

// CreatedMissionsCleared reports if the "created_missions" edge to the Mission entity was cleared.
func (m *HmacKeyPairMutation) CreatedMissionsCleared() bool {
	return m.clearedcreated_missions
}

// RemoveCreatedMissionIDs removes the "created_missions" edge to the Mission entity by IDs.
func (m *HmacKeyPairMutation) RemoveCreatedMissionIDs(ids ...int64) {
	if m.removedcreated_missions == nil {
		m.removedcreated_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.created_missions, ids[i])
		m.removedcreated_missions[ids[i]] = struct{}{}
	}
}

// RemovedCreatedMissions returns the removed IDs of the "created_missions" edge to the Mission entity.
func (m *HmacKeyPairMutation) RemovedCreatedMissionsIDs() (ids []int64) {
	for id := range m.removedcreated_missions {
		ids = append(ids, id)
	}
	return
}

// CreatedMissionsIDs returns the "created_missions" edge IDs in the mutation.
func (m *HmacKeyPairMutation) CreatedMissionsIDs() (ids []int64) {
	for id := range m.created_missions {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedMissions resets all changes to the "created_missions" edge.
func (m *HmacKeyPairMutation) ResetCreatedMissions() {
	m.created_missions = nil
	m.clearedcreated_missions = false
	m.removedcreated_missions = nil
}

// Where appends a list predicates to the HmacKeyPairMutation builder.
func (m *HmacKeyPairMutation) Where(ps ...predicate.HmacKeyPair) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HmacKeyPairMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HmacKeyPairMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HmacKeyPair, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HmacKeyPairMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HmacKeyPairMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HmacKeyPair).
func (m *HmacKeyPairMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HmacKeyPairMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, hmackeypair.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, hmackeypair.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, hmackeypair.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hmackeypair.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hmackeypair.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, hmackeypair.FieldKey)
	}
	if m.secret != nil {
		fields = append(fields, hmackeypair.FieldSecret)
	}
	if m.caller != nil {
		fields = append(fields, hmackeypair.FieldCaller)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HmacKeyPairMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hmackeypair.FieldCreatedBy:
		return m.CreatedBy()
	case hmackeypair.FieldUpdatedBy:
		return m.UpdatedBy()
	case hmackeypair.FieldCreatedAt:
		return m.CreatedAt()
	case hmackeypair.FieldUpdatedAt:
		return m.UpdatedAt()
	case hmackeypair.FieldDeletedAt:
		return m.DeletedAt()
	case hmackeypair.FieldKey:
		return m.Key()
	case hmackeypair.FieldSecret:
		return m.Secret()
	case hmackeypair.FieldCaller:
		return m.Caller()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HmacKeyPairMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hmackeypair.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hmackeypair.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case hmackeypair.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hmackeypair.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hmackeypair.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hmackeypair.FieldKey:
		return m.OldKey(ctx)
	case hmackeypair.FieldSecret:
		return m.OldSecret(ctx)
	case hmackeypair.FieldCaller:
		return m.OldCaller(ctx)
	}
	return nil, fmt.Errorf("unknown HmacKeyPair field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HmacKeyPairMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hmackeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hmackeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case hmackeypair.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hmackeypair.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hmackeypair.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hmackeypair.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case hmackeypair.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case hmackeypair.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HmacKeyPairMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, hmackeypair.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, hmackeypair.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HmacKeyPairMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hmackeypair.FieldCreatedBy:
		return m.AddedCreatedBy()
	case hmackeypair.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HmacKeyPairMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hmackeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case hmackeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HmacKeyPairMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HmacKeyPairMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HmacKeyPairMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HmacKeyPair nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HmacKeyPairMutation) ResetField(name string) error {
	switch name {
	case hmackeypair.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hmackeypair.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case hmackeypair.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hmackeypair.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hmackeypair.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hmackeypair.FieldKey:
		m.ResetKey()
		return nil
	case hmackeypair.FieldSecret:
		m.ResetSecret()
		return nil
	case hmackeypair.FieldCaller:
		m.ResetCaller()
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HmacKeyPairMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mission_key_pairs != nil {
		edges = append(edges, hmackeypair.EdgeMissionKeyPairs)
	}
	if m.created_missions != nil {
		edges = append(edges, hmackeypair.EdgeCreatedMissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HmacKeyPairMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.mission_key_pairs))
		for id := range m.mission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case hmackeypair.EdgeCreatedMissions:
		ids := make([]ent.Value, 0, len(m.created_missions))
		for id := range m.created_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HmacKeyPairMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmission_key_pairs != nil {
		edges = append(edges, hmackeypair.EdgeMissionKeyPairs)
	}
	if m.removedcreated_missions != nil {
		edges = append(edges, hmackeypair.EdgeCreatedMissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HmacKeyPairMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.removedmission_key_pairs))
		for id := range m.removedmission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case hmackeypair.EdgeCreatedMissions:
		ids := make([]ent.Value, 0, len(m.removedcreated_missions))
		for id := range m.removedcreated_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HmacKeyPairMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmission_key_pairs {
		edges = append(edges, hmackeypair.EdgeMissionKeyPairs)
	}
	if m.clearedcreated_missions {
		edges = append(edges, hmackeypair.EdgeCreatedMissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HmacKeyPairMutation) EdgeCleared(name string) bool {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		return m.clearedmission_key_pairs
	case hmackeypair.EdgeCreatedMissions:
		return m.clearedcreated_missions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HmacKeyPairMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HmacKeyPair unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HmacKeyPairMutation) ResetEdge(name string) error {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		m.ResetMissionKeyPairs()
		return nil
	case hmackeypair.EdgeCreatedMissions:
		m.ResetCreatedMissions()
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair edge %s", name)
}

// IncomeManageMutation represents an operation that mutates the IncomeManage nodes in the graph.
type IncomeManageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_by          *int64
	addcreated_by       *int64
	updated_by          *int64
	addupdated_by       *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	phone               *string
	_type               *enums.IncomeManageType
	amount              *int64
	addamount           *int64
	reason              *string
	current_balance     *int64
	addcurrent_balance  *int64
	last_edited_at      *time.Time
	reject_reason       *string
	status              *enums.IncomeManageStatus
	clearedFields       map[string]struct{}
	user                *int64
	cleareduser         bool
	approve_user        *int64
	clearedapprove_user bool
	done                bool
	oldValue            func(context.Context) (*IncomeManage, error)
	predicates          []predicate.IncomeManage
}

var _ ent.Mutation = (*IncomeManageMutation)(nil)

// incomemanageOption allows management of the mutation configuration using functional options.
type incomemanageOption func(*IncomeManageMutation)

// newIncomeManageMutation creates new mutation for the IncomeManage entity.
func newIncomeManageMutation(c config, op Op, opts ...incomemanageOption) *IncomeManageMutation {
	m := &IncomeManageMutation{
		config:        c,
		op:            op,
		typ:           TypeIncomeManage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncomeManageID sets the ID field of the mutation.
func withIncomeManageID(id int64) incomemanageOption {
	return func(m *IncomeManageMutation) {
		var (
			err   error
			once  sync.Once
			value *IncomeManage
		)
		m.oldValue = func(ctx context.Context) (*IncomeManage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncomeManage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncomeManage sets the old IncomeManage of the mutation.
func withIncomeManage(node *IncomeManage) incomemanageOption {
	return func(m *IncomeManageMutation) {
		m.oldValue = func(context.Context) (*IncomeManage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncomeManageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncomeManageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncomeManage entities.
func (m *IncomeManageMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncomeManageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncomeManageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncomeManage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *IncomeManageMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *IncomeManageMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *IncomeManageMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *IncomeManageMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *IncomeManageMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *IncomeManageMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *IncomeManageMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *IncomeManageMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *IncomeManageMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *IncomeManageMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncomeManageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncomeManageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncomeManageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncomeManageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncomeManageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncomeManageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IncomeManageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IncomeManageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IncomeManageMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *IncomeManageMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IncomeManageMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IncomeManageMutation) ResetUserID() {
	m.user = nil
}

// SetPhone sets the "phone" field.
func (m *IncomeManageMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *IncomeManageMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *IncomeManageMutation) ResetPhone() {
	m.phone = nil
}

// SetType sets the "type" field.
func (m *IncomeManageMutation) SetType(emt enums.IncomeManageType) {
	m._type = &emt
}

// GetType returns the value of the "type" field in the mutation.
func (m *IncomeManageMutation) GetType() (r enums.IncomeManageType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldType(ctx context.Context) (v enums.IncomeManageType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IncomeManageMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *IncomeManageMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *IncomeManageMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *IncomeManageMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *IncomeManageMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *IncomeManageMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetReason sets the "reason" field.
func (m *IncomeManageMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *IncomeManageMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *IncomeManageMutation) ResetReason() {
	m.reason = nil
}

// SetCurrentBalance sets the "current_balance" field.
func (m *IncomeManageMutation) SetCurrentBalance(i int64) {
	m.current_balance = &i
	m.addcurrent_balance = nil
}

// CurrentBalance returns the value of the "current_balance" field in the mutation.
func (m *IncomeManageMutation) CurrentBalance() (r int64, exists bool) {
	v := m.current_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentBalance returns the old "current_balance" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldCurrentBalance(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentBalance: %w", err)
	}
	return oldValue.CurrentBalance, nil
}

// AddCurrentBalance adds i to the "current_balance" field.
func (m *IncomeManageMutation) AddCurrentBalance(i int64) {
	if m.addcurrent_balance != nil {
		*m.addcurrent_balance += i
	} else {
		m.addcurrent_balance = &i
	}
}

// AddedCurrentBalance returns the value that was added to the "current_balance" field in this mutation.
func (m *IncomeManageMutation) AddedCurrentBalance() (r int64, exists bool) {
	v := m.addcurrent_balance
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentBalance resets all changes to the "current_balance" field.
func (m *IncomeManageMutation) ResetCurrentBalance() {
	m.current_balance = nil
	m.addcurrent_balance = nil
}

// SetLastEditedAt sets the "last_edited_at" field.
func (m *IncomeManageMutation) SetLastEditedAt(t time.Time) {
	m.last_edited_at = &t
}

// LastEditedAt returns the value of the "last_edited_at" field in the mutation.
func (m *IncomeManageMutation) LastEditedAt() (r time.Time, exists bool) {
	v := m.last_edited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEditedAt returns the old "last_edited_at" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldLastEditedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEditedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEditedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEditedAt: %w", err)
	}
	return oldValue.LastEditedAt, nil
}

// ResetLastEditedAt resets all changes to the "last_edited_at" field.
func (m *IncomeManageMutation) ResetLastEditedAt() {
	m.last_edited_at = nil
}

// SetRejectReason sets the "reject_reason" field.
func (m *IncomeManageMutation) SetRejectReason(s string) {
	m.reject_reason = &s
}

// RejectReason returns the value of the "reject_reason" field in the mutation.
func (m *IncomeManageMutation) RejectReason() (r string, exists bool) {
	v := m.reject_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectReason returns the old "reject_reason" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldRejectReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectReason: %w", err)
	}
	return oldValue.RejectReason, nil
}

// ResetRejectReason resets all changes to the "reject_reason" field.
func (m *IncomeManageMutation) ResetRejectReason() {
	m.reject_reason = nil
}

// SetStatus sets the "status" field.
func (m *IncomeManageMutation) SetStatus(ems enums.IncomeManageStatus) {
	m.status = &ems
}

// Status returns the value of the "status" field in the mutation.
func (m *IncomeManageMutation) Status() (r enums.IncomeManageStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldStatus(ctx context.Context) (v enums.IncomeManageStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IncomeManageMutation) ResetStatus() {
	m.status = nil
}

// SetApproveUserID sets the "approve_user_id" field.
func (m *IncomeManageMutation) SetApproveUserID(i int64) {
	m.approve_user = &i
}

// ApproveUserID returns the value of the "approve_user_id" field in the mutation.
func (m *IncomeManageMutation) ApproveUserID() (r int64, exists bool) {
	v := m.approve_user
	if v == nil {
		return
	}
	return *v, true
}

// OldApproveUserID returns the old "approve_user_id" field's value of the IncomeManage entity.
// If the IncomeManage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncomeManageMutation) OldApproveUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproveUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproveUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproveUserID: %w", err)
	}
	return oldValue.ApproveUserID, nil
}

// ResetApproveUserID resets all changes to the "approve_user_id" field.
func (m *IncomeManageMutation) ResetApproveUserID() {
	m.approve_user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *IncomeManageMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[incomemanage.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IncomeManageMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IncomeManageMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IncomeManageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearApproveUser clears the "approve_user" edge to the User entity.
func (m *IncomeManageMutation) ClearApproveUser() {
	m.clearedapprove_user = true
	m.clearedFields[incomemanage.FieldApproveUserID] = struct{}{}
}

// ApproveUserCleared reports if the "approve_user" edge to the User entity was cleared.
func (m *IncomeManageMutation) ApproveUserCleared() bool {
	return m.clearedapprove_user
}

// ApproveUserIDs returns the "approve_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApproveUserID instead. It exists only for internal usage by the builders.
func (m *IncomeManageMutation) ApproveUserIDs() (ids []int64) {
	if id := m.approve_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApproveUser resets all changes to the "approve_user" edge.
func (m *IncomeManageMutation) ResetApproveUser() {
	m.approve_user = nil
	m.clearedapprove_user = false
}

// Where appends a list predicates to the IncomeManageMutation builder.
func (m *IncomeManageMutation) Where(ps ...predicate.IncomeManage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncomeManageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncomeManageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncomeManage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncomeManageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncomeManageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncomeManage).
func (m *IncomeManageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncomeManageMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, incomemanage.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, incomemanage.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, incomemanage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incomemanage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, incomemanage.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, incomemanage.FieldUserID)
	}
	if m.phone != nil {
		fields = append(fields, incomemanage.FieldPhone)
	}
	if m._type != nil {
		fields = append(fields, incomemanage.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, incomemanage.FieldAmount)
	}
	if m.reason != nil {
		fields = append(fields, incomemanage.FieldReason)
	}
	if m.current_balance != nil {
		fields = append(fields, incomemanage.FieldCurrentBalance)
	}
	if m.last_edited_at != nil {
		fields = append(fields, incomemanage.FieldLastEditedAt)
	}
	if m.reject_reason != nil {
		fields = append(fields, incomemanage.FieldRejectReason)
	}
	if m.status != nil {
		fields = append(fields, incomemanage.FieldStatus)
	}
	if m.approve_user != nil {
		fields = append(fields, incomemanage.FieldApproveUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncomeManageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incomemanage.FieldCreatedBy:
		return m.CreatedBy()
	case incomemanage.FieldUpdatedBy:
		return m.UpdatedBy()
	case incomemanage.FieldCreatedAt:
		return m.CreatedAt()
	case incomemanage.FieldUpdatedAt:
		return m.UpdatedAt()
	case incomemanage.FieldDeletedAt:
		return m.DeletedAt()
	case incomemanage.FieldUserID:
		return m.UserID()
	case incomemanage.FieldPhone:
		return m.Phone()
	case incomemanage.FieldType:
		return m.GetType()
	case incomemanage.FieldAmount:
		return m.Amount()
	case incomemanage.FieldReason:
		return m.Reason()
	case incomemanage.FieldCurrentBalance:
		return m.CurrentBalance()
	case incomemanage.FieldLastEditedAt:
		return m.LastEditedAt()
	case incomemanage.FieldRejectReason:
		return m.RejectReason()
	case incomemanage.FieldStatus:
		return m.Status()
	case incomemanage.FieldApproveUserID:
		return m.ApproveUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncomeManageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incomemanage.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case incomemanage.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case incomemanage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incomemanage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case incomemanage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case incomemanage.FieldUserID:
		return m.OldUserID(ctx)
	case incomemanage.FieldPhone:
		return m.OldPhone(ctx)
	case incomemanage.FieldType:
		return m.OldType(ctx)
	case incomemanage.FieldAmount:
		return m.OldAmount(ctx)
	case incomemanage.FieldReason:
		return m.OldReason(ctx)
	case incomemanage.FieldCurrentBalance:
		return m.OldCurrentBalance(ctx)
	case incomemanage.FieldLastEditedAt:
		return m.OldLastEditedAt(ctx)
	case incomemanage.FieldRejectReason:
		return m.OldRejectReason(ctx)
	case incomemanage.FieldStatus:
		return m.OldStatus(ctx)
	case incomemanage.FieldApproveUserID:
		return m.OldApproveUserID(ctx)
	}
	return nil, fmt.Errorf("unknown IncomeManage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncomeManageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incomemanage.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case incomemanage.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case incomemanage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incomemanage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case incomemanage.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case incomemanage.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case incomemanage.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case incomemanage.FieldType:
		v, ok := value.(enums.IncomeManageType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case incomemanage.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case incomemanage.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case incomemanage.FieldCurrentBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentBalance(v)
		return nil
	case incomemanage.FieldLastEditedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEditedAt(v)
		return nil
	case incomemanage.FieldRejectReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectReason(v)
		return nil
	case incomemanage.FieldStatus:
		v, ok := value.(enums.IncomeManageStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case incomemanage.FieldApproveUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproveUserID(v)
		return nil
	}
	return fmt.Errorf("unknown IncomeManage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncomeManageMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, incomemanage.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, incomemanage.FieldUpdatedBy)
	}
	if m.addamount != nil {
		fields = append(fields, incomemanage.FieldAmount)
	}
	if m.addcurrent_balance != nil {
		fields = append(fields, incomemanage.FieldCurrentBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncomeManageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incomemanage.FieldCreatedBy:
		return m.AddedCreatedBy()
	case incomemanage.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case incomemanage.FieldAmount:
		return m.AddedAmount()
	case incomemanage.FieldCurrentBalance:
		return m.AddedCurrentBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncomeManageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incomemanage.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case incomemanage.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case incomemanage.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case incomemanage.FieldCurrentBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentBalance(v)
		return nil
	}
	return fmt.Errorf("unknown IncomeManage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncomeManageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncomeManageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncomeManageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncomeManage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncomeManageMutation) ResetField(name string) error {
	switch name {
	case incomemanage.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case incomemanage.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case incomemanage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incomemanage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case incomemanage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case incomemanage.FieldUserID:
		m.ResetUserID()
		return nil
	case incomemanage.FieldPhone:
		m.ResetPhone()
		return nil
	case incomemanage.FieldType:
		m.ResetType()
		return nil
	case incomemanage.FieldAmount:
		m.ResetAmount()
		return nil
	case incomemanage.FieldReason:
		m.ResetReason()
		return nil
	case incomemanage.FieldCurrentBalance:
		m.ResetCurrentBalance()
		return nil
	case incomemanage.FieldLastEditedAt:
		m.ResetLastEditedAt()
		return nil
	case incomemanage.FieldRejectReason:
		m.ResetRejectReason()
		return nil
	case incomemanage.FieldStatus:
		m.ResetStatus()
		return nil
	case incomemanage.FieldApproveUserID:
		m.ResetApproveUserID()
		return nil
	}
	return fmt.Errorf("unknown IncomeManage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncomeManageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, incomemanage.EdgeUser)
	}
	if m.approve_user != nil {
		edges = append(edges, incomemanage.EdgeApproveUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncomeManageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incomemanage.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case incomemanage.EdgeApproveUser:
		if id := m.approve_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncomeManageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncomeManageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncomeManageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, incomemanage.EdgeUser)
	}
	if m.clearedapprove_user {
		edges = append(edges, incomemanage.EdgeApproveUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncomeManageMutation) EdgeCleared(name string) bool {
	switch name {
	case incomemanage.EdgeUser:
		return m.cleareduser
	case incomemanage.EdgeApproveUser:
		return m.clearedapprove_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncomeManageMutation) ClearEdge(name string) error {
	switch name {
	case incomemanage.EdgeUser:
		m.ClearUser()
		return nil
	case incomemanage.EdgeApproveUser:
		m.ClearApproveUser()
		return nil
	}
	return fmt.Errorf("unknown IncomeManage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncomeManageMutation) ResetEdge(name string) error {
	switch name {
	case incomemanage.EdgeUser:
		m.ResetUser()
		return nil
	case incomemanage.EdgeApproveUser:
		m.ResetApproveUser()
		return nil
	}
	return fmt.Errorf("unknown IncomeManage edge %s", name)
}

// InputLogMutation represents an operation that mutates the InputLog nodes in the graph.
type InputLogMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	trace_id      *int64
	addtrace_id   *int64
	headers       *string
	body          *string
	query         *string
	url           *string
	ip            *string
	caller        *string
	method        *inputlog.Method
	hmac_key      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*InputLog, error)
	predicates    []predicate.InputLog
}

var _ ent.Mutation = (*InputLogMutation)(nil)

// inputlogOption allows management of the mutation configuration using functional options.
type inputlogOption func(*InputLogMutation)

// newInputLogMutation creates new mutation for the InputLog entity.
func newInputLogMutation(c config, op Op, opts ...inputlogOption) *InputLogMutation {
	m := &InputLogMutation{
		config:        c,
		op:            op,
		typ:           TypeInputLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInputLogID sets the ID field of the mutation.
func withInputLogID(id int64) inputlogOption {
	return func(m *InputLogMutation) {
		var (
			err   error
			once  sync.Once
			value *InputLog
		)
		m.oldValue = func(ctx context.Context) (*InputLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InputLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInputLog sets the old InputLog of the mutation.
func withInputLog(node *InputLog) inputlogOption {
	return func(m *InputLogMutation) {
		m.oldValue = func(context.Context) (*InputLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InputLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InputLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InputLog entities.
func (m *InputLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InputLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InputLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InputLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *InputLogMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InputLogMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *InputLogMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *InputLogMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InputLogMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InputLogMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InputLogMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *InputLogMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *InputLogMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InputLogMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InputLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InputLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InputLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InputLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InputLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InputLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InputLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InputLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InputLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTraceID sets the "trace_id" field.
func (m *InputLogMutation) SetTraceID(i int64) {
	m.trace_id = &i
	m.addtrace_id = nil
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *InputLogMutation) TraceID() (r int64, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldTraceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// AddTraceID adds i to the "trace_id" field.
func (m *InputLogMutation) AddTraceID(i int64) {
	if m.addtrace_id != nil {
		*m.addtrace_id += i
	} else {
		m.addtrace_id = &i
	}
}

// AddedTraceID returns the value that was added to the "trace_id" field in this mutation.
func (m *InputLogMutation) AddedTraceID() (r int64, exists bool) {
	v := m.addtrace_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *InputLogMutation) ResetTraceID() {
	m.trace_id = nil
	m.addtrace_id = nil
}

// SetHeaders sets the "headers" field.
func (m *InputLogMutation) SetHeaders(s string) {
	m.headers = &s
}

// Headers returns the value of the "headers" field in the mutation.
func (m *InputLogMutation) Headers() (r string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldHeaders(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ResetHeaders resets all changes to the "headers" field.
func (m *InputLogMutation) ResetHeaders() {
	m.headers = nil
}

// SetBody sets the "body" field.
func (m *InputLogMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *InputLogMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *InputLogMutation) ClearBody() {
	m.body = nil
	m.clearedFields[inputlog.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *InputLogMutation) BodyCleared() bool {
	_, ok := m.clearedFields[inputlog.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *InputLogMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, inputlog.FieldBody)
}

// SetQuery sets the "query" field.
func (m *InputLogMutation) SetQuery(s string) {
	m.query = &s
}

// Query returns the value of the "query" field in the mutation.
func (m *InputLogMutation) Query() (r string, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ClearQuery clears the value of the "query" field.
func (m *InputLogMutation) ClearQuery() {
	m.query = nil
	m.clearedFields[inputlog.FieldQuery] = struct{}{}
}

// QueryCleared returns if the "query" field was cleared in this mutation.
func (m *InputLogMutation) QueryCleared() bool {
	_, ok := m.clearedFields[inputlog.FieldQuery]
	return ok
}

// ResetQuery resets all changes to the "query" field.
func (m *InputLogMutation) ResetQuery() {
	m.query = nil
	delete(m.clearedFields, inputlog.FieldQuery)
}

// SetURL sets the "url" field.
func (m *InputLogMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *InputLogMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *InputLogMutation) ResetURL() {
	m.url = nil
}

// SetIP sets the "ip" field.
func (m *InputLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *InputLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *InputLogMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[inputlog.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *InputLogMutation) IPCleared() bool {
	_, ok := m.clearedFields[inputlog.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *InputLogMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, inputlog.FieldIP)
}

// SetCaller sets the "caller" field.
func (m *InputLogMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *InputLogMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *InputLogMutation) ResetCaller() {
	m.caller = nil
}

// SetMethod sets the "method" field.
func (m *InputLogMutation) SetMethod(i inputlog.Method) {
	m.method = &i
}

// Method returns the value of the "method" field in the mutation.
func (m *InputLogMutation) Method() (r inputlog.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldMethod(ctx context.Context) (v inputlog.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *InputLogMutation) ResetMethod() {
	m.method = nil
}

// SetHmacKey sets the "hmac_key" field.
func (m *InputLogMutation) SetHmacKey(s string) {
	m.hmac_key = &s
}

// HmacKey returns the value of the "hmac_key" field in the mutation.
func (m *InputLogMutation) HmacKey() (r string, exists bool) {
	v := m.hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHmacKey returns the old "hmac_key" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHmacKey: %w", err)
	}
	return oldValue.HmacKey, nil
}

// ResetHmacKey resets all changes to the "hmac_key" field.
func (m *InputLogMutation) ResetHmacKey() {
	m.hmac_key = nil
}

// Where appends a list predicates to the InputLogMutation builder.
func (m *InputLogMutation) Where(ps ...predicate.InputLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InputLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InputLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InputLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InputLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InputLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InputLog).
func (m *InputLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InputLogMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, inputlog.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, inputlog.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, inputlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inputlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inputlog.FieldDeletedAt)
	}
	if m.trace_id != nil {
		fields = append(fields, inputlog.FieldTraceID)
	}
	if m.headers != nil {
		fields = append(fields, inputlog.FieldHeaders)
	}
	if m.body != nil {
		fields = append(fields, inputlog.FieldBody)
	}
	if m.query != nil {
		fields = append(fields, inputlog.FieldQuery)
	}
	if m.url != nil {
		fields = append(fields, inputlog.FieldURL)
	}
	if m.ip != nil {
		fields = append(fields, inputlog.FieldIP)
	}
	if m.caller != nil {
		fields = append(fields, inputlog.FieldCaller)
	}
	if m.method != nil {
		fields = append(fields, inputlog.FieldMethod)
	}
	if m.hmac_key != nil {
		fields = append(fields, inputlog.FieldHmacKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InputLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inputlog.FieldCreatedBy:
		return m.CreatedBy()
	case inputlog.FieldUpdatedBy:
		return m.UpdatedBy()
	case inputlog.FieldCreatedAt:
		return m.CreatedAt()
	case inputlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case inputlog.FieldDeletedAt:
		return m.DeletedAt()
	case inputlog.FieldTraceID:
		return m.TraceID()
	case inputlog.FieldHeaders:
		return m.Headers()
	case inputlog.FieldBody:
		return m.Body()
	case inputlog.FieldQuery:
		return m.Query()
	case inputlog.FieldURL:
		return m.URL()
	case inputlog.FieldIP:
		return m.IP()
	case inputlog.FieldCaller:
		return m.Caller()
	case inputlog.FieldMethod:
		return m.Method()
	case inputlog.FieldHmacKey:
		return m.HmacKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InputLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inputlog.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case inputlog.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case inputlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inputlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inputlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inputlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case inputlog.FieldHeaders:
		return m.OldHeaders(ctx)
	case inputlog.FieldBody:
		return m.OldBody(ctx)
	case inputlog.FieldQuery:
		return m.OldQuery(ctx)
	case inputlog.FieldURL:
		return m.OldURL(ctx)
	case inputlog.FieldIP:
		return m.OldIP(ctx)
	case inputlog.FieldCaller:
		return m.OldCaller(ctx)
	case inputlog.FieldMethod:
		return m.OldMethod(ctx)
	case inputlog.FieldHmacKey:
		return m.OldHmacKey(ctx)
	}
	return nil, fmt.Errorf("unknown InputLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InputLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case inputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case inputlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inputlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inputlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case inputlog.FieldHeaders:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case inputlog.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case inputlog.FieldQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case inputlog.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case inputlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case inputlog.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case inputlog.FieldMethod:
		v, ok := value.(inputlog.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case inputlog.FieldHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHmacKey(v)
		return nil
	}
	return fmt.Errorf("unknown InputLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InputLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, inputlog.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, inputlog.FieldUpdatedBy)
	}
	if m.addtrace_id != nil {
		fields = append(fields, inputlog.FieldTraceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InputLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inputlog.FieldCreatedBy:
		return m.AddedCreatedBy()
	case inputlog.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case inputlog.FieldTraceID:
		return m.AddedTraceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InputLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case inputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case inputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraceID(v)
		return nil
	}
	return fmt.Errorf("unknown InputLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InputLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inputlog.FieldBody) {
		fields = append(fields, inputlog.FieldBody)
	}
	if m.FieldCleared(inputlog.FieldQuery) {
		fields = append(fields, inputlog.FieldQuery)
	}
	if m.FieldCleared(inputlog.FieldIP) {
		fields = append(fields, inputlog.FieldIP)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InputLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InputLogMutation) ClearField(name string) error {
	switch name {
	case inputlog.FieldBody:
		m.ClearBody()
		return nil
	case inputlog.FieldQuery:
		m.ClearQuery()
		return nil
	case inputlog.FieldIP:
		m.ClearIP()
		return nil
	}
	return fmt.Errorf("unknown InputLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InputLogMutation) ResetField(name string) error {
	switch name {
	case inputlog.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case inputlog.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case inputlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inputlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inputlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inputlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case inputlog.FieldHeaders:
		m.ResetHeaders()
		return nil
	case inputlog.FieldBody:
		m.ResetBody()
		return nil
	case inputlog.FieldQuery:
		m.ResetQuery()
		return nil
	case inputlog.FieldURL:
		m.ResetURL()
		return nil
	case inputlog.FieldIP:
		m.ResetIP()
		return nil
	case inputlog.FieldCaller:
		m.ResetCaller()
		return nil
	case inputlog.FieldMethod:
		m.ResetMethod()
		return nil
	case inputlog.FieldHmacKey:
		m.ResetHmacKey()
		return nil
	}
	return fmt.Errorf("unknown InputLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InputLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InputLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InputLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InputLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InputLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InputLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InputLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InputLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InputLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InputLog edge %s", name)
}

// InviteMutation represents an operation that mutates the Invite nodes in the graph.
type InviteMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	invite_code           *string
	share_cep             *int64
	addshare_cep          *int64
	reg_cep               *int64
	addreg_cep            *int64
	first_recharge_cep    *int64
	addfirst_recharge_cep *int64
	_type                 *enums.InviteType
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	campaign              *int64
	clearedcampaign       bool
	bills                 map[int64]struct{}
	removedbills          map[int64]struct{}
	clearedbills          bool
	done                  bool
	oldValue              func(context.Context) (*Invite, error)
	predicates            []predicate.Invite
}

var _ ent.Mutation = (*InviteMutation)(nil)

// inviteOption allows management of the mutation configuration using functional options.
type inviteOption func(*InviteMutation)

// newInviteMutation creates new mutation for the Invite entity.
func newInviteMutation(c config, op Op, opts ...inviteOption) *InviteMutation {
	m := &InviteMutation{
		config:        c,
		op:            op,
		typ:           TypeInvite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInviteID sets the ID field of the mutation.
func withInviteID(id int64) inviteOption {
	return func(m *InviteMutation) {
		var (
			err   error
			once  sync.Once
			value *Invite
		)
		m.oldValue = func(ctx context.Context) (*Invite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvite sets the old Invite of the mutation.
func withInvite(node *Invite) inviteOption {
	return func(m *InviteMutation) {
		m.oldValue = func(context.Context) (*Invite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invite entities.
func (m *InviteMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InviteMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InviteMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *InviteMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InviteMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *InviteMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *InviteMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InviteMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InviteMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InviteMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *InviteMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *InviteMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InviteMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InviteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InviteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InviteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InviteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InviteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InviteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InviteMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InviteMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InviteMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetInviteCode sets the "invite_code" field.
func (m *InviteMutation) SetInviteCode(s string) {
	m.invite_code = &s
}

// InviteCode returns the value of the "invite_code" field in the mutation.
func (m *InviteMutation) InviteCode() (r string, exists bool) {
	v := m.invite_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteCode returns the old "invite_code" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldInviteCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteCode: %w", err)
	}
	return oldValue.InviteCode, nil
}

// ResetInviteCode resets all changes to the "invite_code" field.
func (m *InviteMutation) ResetInviteCode() {
	m.invite_code = nil
}

// SetShareCep sets the "share_cep" field.
func (m *InviteMutation) SetShareCep(i int64) {
	m.share_cep = &i
	m.addshare_cep = nil
}

// ShareCep returns the value of the "share_cep" field in the mutation.
func (m *InviteMutation) ShareCep() (r int64, exists bool) {
	v := m.share_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldShareCep returns the old "share_cep" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldShareCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareCep: %w", err)
	}
	return oldValue.ShareCep, nil
}

// AddShareCep adds i to the "share_cep" field.
func (m *InviteMutation) AddShareCep(i int64) {
	if m.addshare_cep != nil {
		*m.addshare_cep += i
	} else {
		m.addshare_cep = &i
	}
}

// AddedShareCep returns the value that was added to the "share_cep" field in this mutation.
func (m *InviteMutation) AddedShareCep() (r int64, exists bool) {
	v := m.addshare_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetShareCep resets all changes to the "share_cep" field.
func (m *InviteMutation) ResetShareCep() {
	m.share_cep = nil
	m.addshare_cep = nil
}

// SetRegCep sets the "reg_cep" field.
func (m *InviteMutation) SetRegCep(i int64) {
	m.reg_cep = &i
	m.addreg_cep = nil
}

// RegCep returns the value of the "reg_cep" field in the mutation.
func (m *InviteMutation) RegCep() (r int64, exists bool) {
	v := m.reg_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldRegCep returns the old "reg_cep" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldRegCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegCep: %w", err)
	}
	return oldValue.RegCep, nil
}

// AddRegCep adds i to the "reg_cep" field.
func (m *InviteMutation) AddRegCep(i int64) {
	if m.addreg_cep != nil {
		*m.addreg_cep += i
	} else {
		m.addreg_cep = &i
	}
}

// AddedRegCep returns the value that was added to the "reg_cep" field in this mutation.
func (m *InviteMutation) AddedRegCep() (r int64, exists bool) {
	v := m.addreg_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegCep resets all changes to the "reg_cep" field.
func (m *InviteMutation) ResetRegCep() {
	m.reg_cep = nil
	m.addreg_cep = nil
}

// SetFirstRechargeCep sets the "first_recharge_cep" field.
func (m *InviteMutation) SetFirstRechargeCep(i int64) {
	m.first_recharge_cep = &i
	m.addfirst_recharge_cep = nil
}

// FirstRechargeCep returns the value of the "first_recharge_cep" field in the mutation.
func (m *InviteMutation) FirstRechargeCep() (r int64, exists bool) {
	v := m.first_recharge_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstRechargeCep returns the old "first_recharge_cep" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldFirstRechargeCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstRechargeCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstRechargeCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstRechargeCep: %w", err)
	}
	return oldValue.FirstRechargeCep, nil
}

// AddFirstRechargeCep adds i to the "first_recharge_cep" field.
func (m *InviteMutation) AddFirstRechargeCep(i int64) {
	if m.addfirst_recharge_cep != nil {
		*m.addfirst_recharge_cep += i
	} else {
		m.addfirst_recharge_cep = &i
	}
}

// AddedFirstRechargeCep returns the value that was added to the "first_recharge_cep" field in this mutation.
func (m *InviteMutation) AddedFirstRechargeCep() (r int64, exists bool) {
	v := m.addfirst_recharge_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstRechargeCep resets all changes to the "first_recharge_cep" field.
func (m *InviteMutation) ResetFirstRechargeCep() {
	m.first_recharge_cep = nil
	m.addfirst_recharge_cep = nil
}

// SetType sets the "type" field.
func (m *InviteMutation) SetType(et enums.InviteType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *InviteMutation) GetType() (r enums.InviteType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldType(ctx context.Context) (v enums.InviteType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InviteMutation) ResetType() {
	m._type = nil
}

// SetUserID sets the "user_id" field.
func (m *InviteMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InviteMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InviteMutation) ResetUserID() {
	m.user = nil
}

// SetCampaignID sets the "campaign_id" field.
func (m *InviteMutation) SetCampaignID(i int64) {
	m.campaign = &i
}

// CampaignID returns the value of the "campaign_id" field in the mutation.
func (m *InviteMutation) CampaignID() (r int64, exists bool) {
	v := m.campaign
	if v == nil {
		return
	}
	return *v, true
}

// OldCampaignID returns the old "campaign_id" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCampaignID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCampaignID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCampaignID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCampaignID: %w", err)
	}
	return oldValue.CampaignID, nil
}

// ResetCampaignID resets all changes to the "campaign_id" field.
func (m *InviteMutation) ResetCampaignID() {
	m.campaign = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InviteMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[invite.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InviteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InviteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCampaign clears the "campaign" edge to the Campaign entity.
func (m *InviteMutation) ClearCampaign() {
	m.clearedcampaign = true
	m.clearedFields[invite.FieldCampaignID] = struct{}{}
}

// CampaignCleared reports if the "campaign" edge to the Campaign entity was cleared.
func (m *InviteMutation) CampaignCleared() bool {
	return m.clearedcampaign
}

// CampaignIDs returns the "campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) CampaignIDs() (ids []int64) {
	if id := m.campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaign resets all changes to the "campaign" edge.
func (m *InviteMutation) ResetCampaign() {
	m.campaign = nil
	m.clearedcampaign = false
}

// AddBillIDs adds the "bills" edge to the Bill entity by ids.
func (m *InviteMutation) AddBillIDs(ids ...int64) {
	if m.bills == nil {
		m.bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the Bill entity.
func (m *InviteMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the Bill entity was cleared.
func (m *InviteMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the Bill entity by IDs.
func (m *InviteMutation) RemoveBillIDs(ids ...int64) {
	if m.removedbills == nil {
		m.removedbills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the Bill entity.
func (m *InviteMutation) RemovedBillsIDs() (ids []int64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *InviteMutation) BillsIDs() (ids []int64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *InviteMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// Where appends a list predicates to the InviteMutation builder.
func (m *InviteMutation) Where(ps ...predicate.Invite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InviteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InviteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InviteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InviteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invite).
func (m *InviteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, invite.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, invite.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, invite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invite.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, invite.FieldDeletedAt)
	}
	if m.invite_code != nil {
		fields = append(fields, invite.FieldInviteCode)
	}
	if m.share_cep != nil {
		fields = append(fields, invite.FieldShareCep)
	}
	if m.reg_cep != nil {
		fields = append(fields, invite.FieldRegCep)
	}
	if m.first_recharge_cep != nil {
		fields = append(fields, invite.FieldFirstRechargeCep)
	}
	if m._type != nil {
		fields = append(fields, invite.FieldType)
	}
	if m.user != nil {
		fields = append(fields, invite.FieldUserID)
	}
	if m.campaign != nil {
		fields = append(fields, invite.FieldCampaignID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldCreatedBy:
		return m.CreatedBy()
	case invite.FieldUpdatedBy:
		return m.UpdatedBy()
	case invite.FieldCreatedAt:
		return m.CreatedAt()
	case invite.FieldUpdatedAt:
		return m.UpdatedAt()
	case invite.FieldDeletedAt:
		return m.DeletedAt()
	case invite.FieldInviteCode:
		return m.InviteCode()
	case invite.FieldShareCep:
		return m.ShareCep()
	case invite.FieldRegCep:
		return m.RegCep()
	case invite.FieldFirstRechargeCep:
		return m.FirstRechargeCep()
	case invite.FieldType:
		return m.GetType()
	case invite.FieldUserID:
		return m.UserID()
	case invite.FieldCampaignID:
		return m.CampaignID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invite.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case invite.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case invite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invite.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invite.FieldInviteCode:
		return m.OldInviteCode(ctx)
	case invite.FieldShareCep:
		return m.OldShareCep(ctx)
	case invite.FieldRegCep:
		return m.OldRegCep(ctx)
	case invite.FieldFirstRechargeCep:
		return m.OldFirstRechargeCep(ctx)
	case invite.FieldType:
		return m.OldType(ctx)
	case invite.FieldUserID:
		return m.OldUserID(ctx)
	case invite.FieldCampaignID:
		return m.OldCampaignID(ctx)
	}
	return nil, fmt.Errorf("unknown Invite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invite.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case invite.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case invite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invite.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invite.FieldInviteCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteCode(v)
		return nil
	case invite.FieldShareCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareCep(v)
		return nil
	case invite.FieldRegCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegCep(v)
		return nil
	case invite.FieldFirstRechargeCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstRechargeCep(v)
		return nil
	case invite.FieldType:
		v, ok := value.(enums.InviteType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case invite.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invite.FieldCampaignID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCampaignID(v)
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, invite.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, invite.FieldUpdatedBy)
	}
	if m.addshare_cep != nil {
		fields = append(fields, invite.FieldShareCep)
	}
	if m.addreg_cep != nil {
		fields = append(fields, invite.FieldRegCep)
	}
	if m.addfirst_recharge_cep != nil {
		fields = append(fields, invite.FieldFirstRechargeCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldCreatedBy:
		return m.AddedCreatedBy()
	case invite.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case invite.FieldShareCep:
		return m.AddedShareCep()
	case invite.FieldRegCep:
		return m.AddedRegCep()
	case invite.FieldFirstRechargeCep:
		return m.AddedFirstRechargeCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invite.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case invite.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case invite.FieldShareCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShareCep(v)
		return nil
	case invite.FieldRegCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegCep(v)
		return nil
	case invite.FieldFirstRechargeCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstRechargeCep(v)
		return nil
	}
	return fmt.Errorf("unknown Invite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Invite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteMutation) ResetField(name string) error {
	switch name {
	case invite.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case invite.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case invite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invite.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invite.FieldInviteCode:
		m.ResetInviteCode()
		return nil
	case invite.FieldShareCep:
		m.ResetShareCep()
		return nil
	case invite.FieldRegCep:
		m.ResetRegCep()
		return nil
	case invite.FieldFirstRechargeCep:
		m.ResetFirstRechargeCep()
		return nil
	case invite.FieldType:
		m.ResetType()
		return nil
	case invite.FieldUserID:
		m.ResetUserID()
		return nil
	case invite.FieldCampaignID:
		m.ResetCampaignID()
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, invite.EdgeUser)
	}
	if m.campaign != nil {
		edges = append(edges, invite.EdgeCampaign)
	}
	if m.bills != nil {
		edges = append(edges, invite.EdgeBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invite.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeCampaign:
		if id := m.campaign; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbills != nil {
		edges = append(edges, invite.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invite.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, invite.EdgeUser)
	}
	if m.clearedcampaign {
		edges = append(edges, invite.EdgeCampaign)
	}
	if m.clearedbills {
		edges = append(edges, invite.EdgeBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteMutation) EdgeCleared(name string) bool {
	switch name {
	case invite.EdgeUser:
		return m.cleareduser
	case invite.EdgeCampaign:
		return m.clearedcampaign
	case invite.EdgeBills:
		return m.clearedbills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteMutation) ClearEdge(name string) error {
	switch name {
	case invite.EdgeUser:
		m.ClearUser()
		return nil
	case invite.EdgeCampaign:
		m.ClearCampaign()
		return nil
	}
	return fmt.Errorf("unknown Invite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteMutation) ResetEdge(name string) error {
	switch name {
	case invite.EdgeUser:
		m.ResetUser()
		return nil
	case invite.EdgeCampaign:
		m.ResetCampaign()
		return nil
	case invite.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown Invite edge %s", name)
}

// InvokeModelOrderMutation represents an operation that mutates the InvokeModelOrder nodes in the graph.
type InvokeModelOrderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_by           *int64
	addcreated_by        *int64
	updated_by           *int64
	addupdated_by        *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	invoke_type          *enums.InvokeType
	record_time          *time.Time
	invoke_times         *int
	addinvoke_times      *int
	input_token_cost     *int64
	addinput_token_cost  *int64
	output_token_cost    *int64
	addoutput_token_cost *int64
	input_cep_cost       *int64
	addinput_cep_cost    *int64
	output_cep_cost      *int64
	addoutput_cep_cost   *int64
	clearedFields        map[string]struct{}
	bills                map[int64]struct{}
	removedbills         map[int64]struct{}
	clearedbills         bool
	user                 *int64
	cleareduser          bool
	model                *int64
	clearedmodel         bool
	api_token            *int64
	clearedapi_token     bool
	done                 bool
	oldValue             func(context.Context) (*InvokeModelOrder, error)
	predicates           []predicate.InvokeModelOrder
}

var _ ent.Mutation = (*InvokeModelOrderMutation)(nil)

// invokemodelorderOption allows management of the mutation configuration using functional options.
type invokemodelorderOption func(*InvokeModelOrderMutation)

// newInvokeModelOrderMutation creates new mutation for the InvokeModelOrder entity.
func newInvokeModelOrderMutation(c config, op Op, opts ...invokemodelorderOption) *InvokeModelOrderMutation {
	m := &InvokeModelOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeInvokeModelOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvokeModelOrderID sets the ID field of the mutation.
func withInvokeModelOrderID(id int64) invokemodelorderOption {
	return func(m *InvokeModelOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *InvokeModelOrder
		)
		m.oldValue = func(ctx context.Context) (*InvokeModelOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvokeModelOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvokeModelOrder sets the old InvokeModelOrder of the mutation.
func withInvokeModelOrder(node *InvokeModelOrder) invokemodelorderOption {
	return func(m *InvokeModelOrderMutation) {
		m.oldValue = func(context.Context) (*InvokeModelOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvokeModelOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvokeModelOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvokeModelOrder entities.
func (m *InvokeModelOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvokeModelOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvokeModelOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvokeModelOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *InvokeModelOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InvokeModelOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *InvokeModelOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *InvokeModelOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InvokeModelOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InvokeModelOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InvokeModelOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *InvokeModelOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *InvokeModelOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InvokeModelOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvokeModelOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvokeModelOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvokeModelOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvokeModelOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvokeModelOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvokeModelOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InvokeModelOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InvokeModelOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InvokeModelOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *InvokeModelOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvokeModelOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvokeModelOrderMutation) ResetUserID() {
	m.user = nil
}

// SetModelID sets the "model_id" field.
func (m *InvokeModelOrderMutation) SetModelID(i int64) {
	m.model = &i
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *InvokeModelOrderMutation) ModelID() (r int64, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldModelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *InvokeModelOrderMutation) ResetModelID() {
	m.model = nil
}

// SetAPITokenID sets the "api_token_id" field.
func (m *InvokeModelOrderMutation) SetAPITokenID(i int64) {
	m.api_token = &i
}

// APITokenID returns the value of the "api_token_id" field in the mutation.
func (m *InvokeModelOrderMutation) APITokenID() (r int64, exists bool) {
	v := m.api_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAPITokenID returns the old "api_token_id" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldAPITokenID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPITokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPITokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPITokenID: %w", err)
	}
	return oldValue.APITokenID, nil
}

// ResetAPITokenID resets all changes to the "api_token_id" field.
func (m *InvokeModelOrderMutation) ResetAPITokenID() {
	m.api_token = nil
}

// SetInvokeType sets the "invoke_type" field.
func (m *InvokeModelOrderMutation) SetInvokeType(et enums.InvokeType) {
	m.invoke_type = &et
}

// InvokeType returns the value of the "invoke_type" field in the mutation.
func (m *InvokeModelOrderMutation) InvokeType() (r enums.InvokeType, exists bool) {
	v := m.invoke_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInvokeType returns the old "invoke_type" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldInvokeType(ctx context.Context) (v enums.InvokeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvokeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvokeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvokeType: %w", err)
	}
	return oldValue.InvokeType, nil
}

// ResetInvokeType resets all changes to the "invoke_type" field.
func (m *InvokeModelOrderMutation) ResetInvokeType() {
	m.invoke_type = nil
}

// SetRecordTime sets the "record_time" field.
func (m *InvokeModelOrderMutation) SetRecordTime(t time.Time) {
	m.record_time = &t
}

// RecordTime returns the value of the "record_time" field in the mutation.
func (m *InvokeModelOrderMutation) RecordTime() (r time.Time, exists bool) {
	v := m.record_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordTime returns the old "record_time" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldRecordTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordTime: %w", err)
	}
	return oldValue.RecordTime, nil
}

// ResetRecordTime resets all changes to the "record_time" field.
func (m *InvokeModelOrderMutation) ResetRecordTime() {
	m.record_time = nil
}

// SetInvokeTimes sets the "invoke_times" field.
func (m *InvokeModelOrderMutation) SetInvokeTimes(i int) {
	m.invoke_times = &i
	m.addinvoke_times = nil
}

// InvokeTimes returns the value of the "invoke_times" field in the mutation.
func (m *InvokeModelOrderMutation) InvokeTimes() (r int, exists bool) {
	v := m.invoke_times
	if v == nil {
		return
	}
	return *v, true
}

// OldInvokeTimes returns the old "invoke_times" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldInvokeTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvokeTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvokeTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvokeTimes: %w", err)
	}
	return oldValue.InvokeTimes, nil
}

// AddInvokeTimes adds i to the "invoke_times" field.
func (m *InvokeModelOrderMutation) AddInvokeTimes(i int) {
	if m.addinvoke_times != nil {
		*m.addinvoke_times += i
	} else {
		m.addinvoke_times = &i
	}
}

// AddedInvokeTimes returns the value that was added to the "invoke_times" field in this mutation.
func (m *InvokeModelOrderMutation) AddedInvokeTimes() (r int, exists bool) {
	v := m.addinvoke_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvokeTimes resets all changes to the "invoke_times" field.
func (m *InvokeModelOrderMutation) ResetInvokeTimes() {
	m.invoke_times = nil
	m.addinvoke_times = nil
}

// SetInputTokenCost sets the "input_token_cost" field.
func (m *InvokeModelOrderMutation) SetInputTokenCost(i int64) {
	m.input_token_cost = &i
	m.addinput_token_cost = nil
}

// InputTokenCost returns the value of the "input_token_cost" field in the mutation.
func (m *InvokeModelOrderMutation) InputTokenCost() (r int64, exists bool) {
	v := m.input_token_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldInputTokenCost returns the old "input_token_cost" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldInputTokenCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputTokenCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputTokenCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputTokenCost: %w", err)
	}
	return oldValue.InputTokenCost, nil
}

// AddInputTokenCost adds i to the "input_token_cost" field.
func (m *InvokeModelOrderMutation) AddInputTokenCost(i int64) {
	if m.addinput_token_cost != nil {
		*m.addinput_token_cost += i
	} else {
		m.addinput_token_cost = &i
	}
}

// AddedInputTokenCost returns the value that was added to the "input_token_cost" field in this mutation.
func (m *InvokeModelOrderMutation) AddedInputTokenCost() (r int64, exists bool) {
	v := m.addinput_token_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetInputTokenCost resets all changes to the "input_token_cost" field.
func (m *InvokeModelOrderMutation) ResetInputTokenCost() {
	m.input_token_cost = nil
	m.addinput_token_cost = nil
}

// SetOutputTokenCost sets the "output_token_cost" field.
func (m *InvokeModelOrderMutation) SetOutputTokenCost(i int64) {
	m.output_token_cost = &i
	m.addoutput_token_cost = nil
}

// OutputTokenCost returns the value of the "output_token_cost" field in the mutation.
func (m *InvokeModelOrderMutation) OutputTokenCost() (r int64, exists bool) {
	v := m.output_token_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputTokenCost returns the old "output_token_cost" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldOutputTokenCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputTokenCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputTokenCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputTokenCost: %w", err)
	}
	return oldValue.OutputTokenCost, nil
}

// AddOutputTokenCost adds i to the "output_token_cost" field.
func (m *InvokeModelOrderMutation) AddOutputTokenCost(i int64) {
	if m.addoutput_token_cost != nil {
		*m.addoutput_token_cost += i
	} else {
		m.addoutput_token_cost = &i
	}
}

// AddedOutputTokenCost returns the value that was added to the "output_token_cost" field in this mutation.
func (m *InvokeModelOrderMutation) AddedOutputTokenCost() (r int64, exists bool) {
	v := m.addoutput_token_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutputTokenCost resets all changes to the "output_token_cost" field.
func (m *InvokeModelOrderMutation) ResetOutputTokenCost() {
	m.output_token_cost = nil
	m.addoutput_token_cost = nil
}

// SetInputCepCost sets the "input_cep_cost" field.
func (m *InvokeModelOrderMutation) SetInputCepCost(i int64) {
	m.input_cep_cost = &i
	m.addinput_cep_cost = nil
}

// InputCepCost returns the value of the "input_cep_cost" field in the mutation.
func (m *InvokeModelOrderMutation) InputCepCost() (r int64, exists bool) {
	v := m.input_cep_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldInputCepCost returns the old "input_cep_cost" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldInputCepCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputCepCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputCepCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputCepCost: %w", err)
	}
	return oldValue.InputCepCost, nil
}

// AddInputCepCost adds i to the "input_cep_cost" field.
func (m *InvokeModelOrderMutation) AddInputCepCost(i int64) {
	if m.addinput_cep_cost != nil {
		*m.addinput_cep_cost += i
	} else {
		m.addinput_cep_cost = &i
	}
}

// AddedInputCepCost returns the value that was added to the "input_cep_cost" field in this mutation.
func (m *InvokeModelOrderMutation) AddedInputCepCost() (r int64, exists bool) {
	v := m.addinput_cep_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetInputCepCost resets all changes to the "input_cep_cost" field.
func (m *InvokeModelOrderMutation) ResetInputCepCost() {
	m.input_cep_cost = nil
	m.addinput_cep_cost = nil
}

// SetOutputCepCost sets the "output_cep_cost" field.
func (m *InvokeModelOrderMutation) SetOutputCepCost(i int64) {
	m.output_cep_cost = &i
	m.addoutput_cep_cost = nil
}

// OutputCepCost returns the value of the "output_cep_cost" field in the mutation.
func (m *InvokeModelOrderMutation) OutputCepCost() (r int64, exists bool) {
	v := m.output_cep_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputCepCost returns the old "output_cep_cost" field's value of the InvokeModelOrder entity.
// If the InvokeModelOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvokeModelOrderMutation) OldOutputCepCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputCepCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputCepCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputCepCost: %w", err)
	}
	return oldValue.OutputCepCost, nil
}

// AddOutputCepCost adds i to the "output_cep_cost" field.
func (m *InvokeModelOrderMutation) AddOutputCepCost(i int64) {
	if m.addoutput_cep_cost != nil {
		*m.addoutput_cep_cost += i
	} else {
		m.addoutput_cep_cost = &i
	}
}

// AddedOutputCepCost returns the value that was added to the "output_cep_cost" field in this mutation.
func (m *InvokeModelOrderMutation) AddedOutputCepCost() (r int64, exists bool) {
	v := m.addoutput_cep_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutputCepCost resets all changes to the "output_cep_cost" field.
func (m *InvokeModelOrderMutation) ResetOutputCepCost() {
	m.output_cep_cost = nil
	m.addoutput_cep_cost = nil
}

// AddBillIDs adds the "bills" edge to the Bill entity by ids.
func (m *InvokeModelOrderMutation) AddBillIDs(ids ...int64) {
	if m.bills == nil {
		m.bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the Bill entity.
func (m *InvokeModelOrderMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the Bill entity was cleared.
func (m *InvokeModelOrderMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the Bill entity by IDs.
func (m *InvokeModelOrderMutation) RemoveBillIDs(ids ...int64) {
	if m.removedbills == nil {
		m.removedbills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the Bill entity.
func (m *InvokeModelOrderMutation) RemovedBillsIDs() (ids []int64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *InvokeModelOrderMutation) BillsIDs() (ids []int64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *InvokeModelOrderMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InvokeModelOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[invokemodelorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InvokeModelOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InvokeModelOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InvokeModelOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearModel clears the "model" edge to the Model entity.
func (m *InvokeModelOrderMutation) ClearModel() {
	m.clearedmodel = true
	m.clearedFields[invokemodelorder.FieldModelID] = struct{}{}
}

// ModelCleared reports if the "model" edge to the Model entity was cleared.
func (m *InvokeModelOrderMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *InvokeModelOrderMutation) ModelIDs() (ids []int64) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *InvokeModelOrderMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// ClearAPIToken clears the "api_token" edge to the ApiToken entity.
func (m *InvokeModelOrderMutation) ClearAPIToken() {
	m.clearedapi_token = true
	m.clearedFields[invokemodelorder.FieldAPITokenID] = struct{}{}
}

// APITokenCleared reports if the "api_token" edge to the ApiToken entity was cleared.
func (m *InvokeModelOrderMutation) APITokenCleared() bool {
	return m.clearedapi_token
}

// APITokenIDs returns the "api_token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APITokenID instead. It exists only for internal usage by the builders.
func (m *InvokeModelOrderMutation) APITokenIDs() (ids []int64) {
	if id := m.api_token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPIToken resets all changes to the "api_token" edge.
func (m *InvokeModelOrderMutation) ResetAPIToken() {
	m.api_token = nil
	m.clearedapi_token = false
}

// Where appends a list predicates to the InvokeModelOrderMutation builder.
func (m *InvokeModelOrderMutation) Where(ps ...predicate.InvokeModelOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvokeModelOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvokeModelOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvokeModelOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvokeModelOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvokeModelOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvokeModelOrder).
func (m *InvokeModelOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvokeModelOrderMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, invokemodelorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, invokemodelorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, invokemodelorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invokemodelorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, invokemodelorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, invokemodelorder.FieldUserID)
	}
	if m.model != nil {
		fields = append(fields, invokemodelorder.FieldModelID)
	}
	if m.api_token != nil {
		fields = append(fields, invokemodelorder.FieldAPITokenID)
	}
	if m.invoke_type != nil {
		fields = append(fields, invokemodelorder.FieldInvokeType)
	}
	if m.record_time != nil {
		fields = append(fields, invokemodelorder.FieldRecordTime)
	}
	if m.invoke_times != nil {
		fields = append(fields, invokemodelorder.FieldInvokeTimes)
	}
	if m.input_token_cost != nil {
		fields = append(fields, invokemodelorder.FieldInputTokenCost)
	}
	if m.output_token_cost != nil {
		fields = append(fields, invokemodelorder.FieldOutputTokenCost)
	}
	if m.input_cep_cost != nil {
		fields = append(fields, invokemodelorder.FieldInputCepCost)
	}
	if m.output_cep_cost != nil {
		fields = append(fields, invokemodelorder.FieldOutputCepCost)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvokeModelOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invokemodelorder.FieldCreatedBy:
		return m.CreatedBy()
	case invokemodelorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case invokemodelorder.FieldCreatedAt:
		return m.CreatedAt()
	case invokemodelorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case invokemodelorder.FieldDeletedAt:
		return m.DeletedAt()
	case invokemodelorder.FieldUserID:
		return m.UserID()
	case invokemodelorder.FieldModelID:
		return m.ModelID()
	case invokemodelorder.FieldAPITokenID:
		return m.APITokenID()
	case invokemodelorder.FieldInvokeType:
		return m.InvokeType()
	case invokemodelorder.FieldRecordTime:
		return m.RecordTime()
	case invokemodelorder.FieldInvokeTimes:
		return m.InvokeTimes()
	case invokemodelorder.FieldInputTokenCost:
		return m.InputTokenCost()
	case invokemodelorder.FieldOutputTokenCost:
		return m.OutputTokenCost()
	case invokemodelorder.FieldInputCepCost:
		return m.InputCepCost()
	case invokemodelorder.FieldOutputCepCost:
		return m.OutputCepCost()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvokeModelOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invokemodelorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case invokemodelorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case invokemodelorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invokemodelorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invokemodelorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invokemodelorder.FieldUserID:
		return m.OldUserID(ctx)
	case invokemodelorder.FieldModelID:
		return m.OldModelID(ctx)
	case invokemodelorder.FieldAPITokenID:
		return m.OldAPITokenID(ctx)
	case invokemodelorder.FieldInvokeType:
		return m.OldInvokeType(ctx)
	case invokemodelorder.FieldRecordTime:
		return m.OldRecordTime(ctx)
	case invokemodelorder.FieldInvokeTimes:
		return m.OldInvokeTimes(ctx)
	case invokemodelorder.FieldInputTokenCost:
		return m.OldInputTokenCost(ctx)
	case invokemodelorder.FieldOutputTokenCost:
		return m.OldOutputTokenCost(ctx)
	case invokemodelorder.FieldInputCepCost:
		return m.OldInputCepCost(ctx)
	case invokemodelorder.FieldOutputCepCost:
		return m.OldOutputCepCost(ctx)
	}
	return nil, fmt.Errorf("unknown InvokeModelOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvokeModelOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invokemodelorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case invokemodelorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case invokemodelorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invokemodelorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invokemodelorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invokemodelorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invokemodelorder.FieldModelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case invokemodelorder.FieldAPITokenID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPITokenID(v)
		return nil
	case invokemodelorder.FieldInvokeType:
		v, ok := value.(enums.InvokeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvokeType(v)
		return nil
	case invokemodelorder.FieldRecordTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordTime(v)
		return nil
	case invokemodelorder.FieldInvokeTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvokeTimes(v)
		return nil
	case invokemodelorder.FieldInputTokenCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputTokenCost(v)
		return nil
	case invokemodelorder.FieldOutputTokenCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputTokenCost(v)
		return nil
	case invokemodelorder.FieldInputCepCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputCepCost(v)
		return nil
	case invokemodelorder.FieldOutputCepCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputCepCost(v)
		return nil
	}
	return fmt.Errorf("unknown InvokeModelOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvokeModelOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, invokemodelorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, invokemodelorder.FieldUpdatedBy)
	}
	if m.addinvoke_times != nil {
		fields = append(fields, invokemodelorder.FieldInvokeTimes)
	}
	if m.addinput_token_cost != nil {
		fields = append(fields, invokemodelorder.FieldInputTokenCost)
	}
	if m.addoutput_token_cost != nil {
		fields = append(fields, invokemodelorder.FieldOutputTokenCost)
	}
	if m.addinput_cep_cost != nil {
		fields = append(fields, invokemodelorder.FieldInputCepCost)
	}
	if m.addoutput_cep_cost != nil {
		fields = append(fields, invokemodelorder.FieldOutputCepCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvokeModelOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invokemodelorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case invokemodelorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case invokemodelorder.FieldInvokeTimes:
		return m.AddedInvokeTimes()
	case invokemodelorder.FieldInputTokenCost:
		return m.AddedInputTokenCost()
	case invokemodelorder.FieldOutputTokenCost:
		return m.AddedOutputTokenCost()
	case invokemodelorder.FieldInputCepCost:
		return m.AddedInputCepCost()
	case invokemodelorder.FieldOutputCepCost:
		return m.AddedOutputCepCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvokeModelOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invokemodelorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case invokemodelorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case invokemodelorder.FieldInvokeTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvokeTimes(v)
		return nil
	case invokemodelorder.FieldInputTokenCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputTokenCost(v)
		return nil
	case invokemodelorder.FieldOutputTokenCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputTokenCost(v)
		return nil
	case invokemodelorder.FieldInputCepCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputCepCost(v)
		return nil
	case invokemodelorder.FieldOutputCepCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputCepCost(v)
		return nil
	}
	return fmt.Errorf("unknown InvokeModelOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvokeModelOrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvokeModelOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvokeModelOrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvokeModelOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvokeModelOrderMutation) ResetField(name string) error {
	switch name {
	case invokemodelorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case invokemodelorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case invokemodelorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invokemodelorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invokemodelorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invokemodelorder.FieldUserID:
		m.ResetUserID()
		return nil
	case invokemodelorder.FieldModelID:
		m.ResetModelID()
		return nil
	case invokemodelorder.FieldAPITokenID:
		m.ResetAPITokenID()
		return nil
	case invokemodelorder.FieldInvokeType:
		m.ResetInvokeType()
		return nil
	case invokemodelorder.FieldRecordTime:
		m.ResetRecordTime()
		return nil
	case invokemodelorder.FieldInvokeTimes:
		m.ResetInvokeTimes()
		return nil
	case invokemodelorder.FieldInputTokenCost:
		m.ResetInputTokenCost()
		return nil
	case invokemodelorder.FieldOutputTokenCost:
		m.ResetOutputTokenCost()
		return nil
	case invokemodelorder.FieldInputCepCost:
		m.ResetInputCepCost()
		return nil
	case invokemodelorder.FieldOutputCepCost:
		m.ResetOutputCepCost()
		return nil
	}
	return fmt.Errorf("unknown InvokeModelOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvokeModelOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.bills != nil {
		edges = append(edges, invokemodelorder.EdgeBills)
	}
	if m.user != nil {
		edges = append(edges, invokemodelorder.EdgeUser)
	}
	if m.model != nil {
		edges = append(edges, invokemodelorder.EdgeModel)
	}
	if m.api_token != nil {
		edges = append(edges, invokemodelorder.EdgeAPIToken)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvokeModelOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invokemodelorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case invokemodelorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case invokemodelorder.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	case invokemodelorder.EdgeAPIToken:
		if id := m.api_token; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvokeModelOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbills != nil {
		edges = append(edges, invokemodelorder.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvokeModelOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invokemodelorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvokeModelOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbills {
		edges = append(edges, invokemodelorder.EdgeBills)
	}
	if m.cleareduser {
		edges = append(edges, invokemodelorder.EdgeUser)
	}
	if m.clearedmodel {
		edges = append(edges, invokemodelorder.EdgeModel)
	}
	if m.clearedapi_token {
		edges = append(edges, invokemodelorder.EdgeAPIToken)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvokeModelOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case invokemodelorder.EdgeBills:
		return m.clearedbills
	case invokemodelorder.EdgeUser:
		return m.cleareduser
	case invokemodelorder.EdgeModel:
		return m.clearedmodel
	case invokemodelorder.EdgeAPIToken:
		return m.clearedapi_token
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvokeModelOrderMutation) ClearEdge(name string) error {
	switch name {
	case invokemodelorder.EdgeUser:
		m.ClearUser()
		return nil
	case invokemodelorder.EdgeModel:
		m.ClearModel()
		return nil
	case invokemodelorder.EdgeAPIToken:
		m.ClearAPIToken()
		return nil
	}
	return fmt.Errorf("unknown InvokeModelOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvokeModelOrderMutation) ResetEdge(name string) error {
	switch name {
	case invokemodelorder.EdgeBills:
		m.ResetBills()
		return nil
	case invokemodelorder.EdgeUser:
		m.ResetUser()
		return nil
	case invokemodelorder.EdgeModel:
		m.ResetModel()
		return nil
	case invokemodelorder.EdgeAPIToken:
		m.ResetAPIToken()
		return nil
	}
	return fmt.Errorf("unknown InvokeModelOrder edge %s", name)
}

// LoginRecordMutation represents an operation that mutates the LoginRecord nodes in the graph.
type LoginRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	ua            *string
	ip            *string
	way           *string
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*LoginRecord, error)
	predicates    []predicate.LoginRecord
}

var _ ent.Mutation = (*LoginRecordMutation)(nil)

// loginrecordOption allows management of the mutation configuration using functional options.
type loginrecordOption func(*LoginRecordMutation)

// newLoginRecordMutation creates new mutation for the LoginRecord entity.
func newLoginRecordMutation(c config, op Op, opts ...loginrecordOption) *LoginRecordMutation {
	m := &LoginRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginRecordID sets the ID field of the mutation.
func withLoginRecordID(id int64) loginrecordOption {
	return func(m *LoginRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginRecord
		)
		m.oldValue = func(ctx context.Context) (*LoginRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginRecord sets the old LoginRecord of the mutation.
func withLoginRecord(node *LoginRecord) loginrecordOption {
	return func(m *LoginRecordMutation) {
		m.oldValue = func(context.Context) (*LoginRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginRecord entities.
func (m *LoginRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *LoginRecordMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LoginRecordMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *LoginRecordMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LoginRecordMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LoginRecordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LoginRecordMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LoginRecordMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *LoginRecordMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LoginRecordMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LoginRecordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LoginRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoginRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoginRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoginRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoginRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoginRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LoginRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LoginRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LoginRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUa sets the "ua" field.
func (m *LoginRecordMutation) SetUa(s string) {
	m.ua = &s
}

// Ua returns the value of the "ua" field in the mutation.
func (m *LoginRecordMutation) Ua() (r string, exists bool) {
	v := m.ua
	if v == nil {
		return
	}
	return *v, true
}

// OldUa returns the old "ua" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldUa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUa: %w", err)
	}
	return oldValue.Ua, nil
}

// ResetUa resets all changes to the "ua" field.
func (m *LoginRecordMutation) ResetUa() {
	m.ua = nil
}

// SetIP sets the "ip" field.
func (m *LoginRecordMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LoginRecordMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *LoginRecordMutation) ResetIP() {
	m.ip = nil
}

// SetWay sets the "way" field.
func (m *LoginRecordMutation) SetWay(s string) {
	m.way = &s
}

// Way returns the value of the "way" field in the mutation.
func (m *LoginRecordMutation) Way() (r string, exists bool) {
	v := m.way
	if v == nil {
		return
	}
	return *v, true
}

// OldWay returns the old "way" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldWay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWay: %w", err)
	}
	return oldValue.Way, nil
}

// ResetWay resets all changes to the "way" field.
func (m *LoginRecordMutation) ResetWay() {
	m.way = nil
}

// SetUserID sets the "user_id" field.
func (m *LoginRecordMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LoginRecordMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LoginRecordMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *LoginRecordMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[loginrecord.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LoginRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LoginRecordMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LoginRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the LoginRecordMutation builder.
func (m *LoginRecordMutation) Where(ps ...predicate.LoginRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginRecord).
func (m *LoginRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginRecordMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, loginrecord.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, loginrecord.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, loginrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, loginrecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, loginrecord.FieldDeletedAt)
	}
	if m.ua != nil {
		fields = append(fields, loginrecord.FieldUa)
	}
	if m.ip != nil {
		fields = append(fields, loginrecord.FieldIP)
	}
	if m.way != nil {
		fields = append(fields, loginrecord.FieldWay)
	}
	if m.user != nil {
		fields = append(fields, loginrecord.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginrecord.FieldCreatedBy:
		return m.CreatedBy()
	case loginrecord.FieldUpdatedBy:
		return m.UpdatedBy()
	case loginrecord.FieldCreatedAt:
		return m.CreatedAt()
	case loginrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case loginrecord.FieldDeletedAt:
		return m.DeletedAt()
	case loginrecord.FieldUa:
		return m.Ua()
	case loginrecord.FieldIP:
		return m.IP()
	case loginrecord.FieldWay:
		return m.Way()
	case loginrecord.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginrecord.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case loginrecord.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case loginrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loginrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case loginrecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case loginrecord.FieldUa:
		return m.OldUa(ctx)
	case loginrecord.FieldIP:
		return m.OldIP(ctx)
	case loginrecord.FieldWay:
		return m.OldWay(ctx)
	case loginrecord.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown LoginRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginrecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case loginrecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case loginrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loginrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case loginrecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case loginrecord.FieldUa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUa(v)
		return nil
	case loginrecord.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case loginrecord.FieldWay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWay(v)
		return nil
	case loginrecord.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown LoginRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, loginrecord.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, loginrecord.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loginrecord.FieldCreatedBy:
		return m.AddedCreatedBy()
	case loginrecord.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loginrecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case loginrecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown LoginRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LoginRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginRecordMutation) ResetField(name string) error {
	switch name {
	case loginrecord.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case loginrecord.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case loginrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loginrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case loginrecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case loginrecord.FieldUa:
		m.ResetUa()
		return nil
	case loginrecord.FieldIP:
		m.ResetIP()
		return nil
	case loginrecord.FieldWay:
		m.ResetWay()
		return nil
	case loginrecord.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown LoginRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, loginrecord.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case loginrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, loginrecord.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case loginrecord.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginRecordMutation) ClearEdge(name string) error {
	switch name {
	case loginrecord.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown LoginRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginRecordMutation) ResetEdge(name string) error {
	switch name {
	case loginrecord.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown LoginRecord edge %s", name)
}

// LottoMutation represents an operation that mutates the Lotto nodes in the graph.
type LottoMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int64
	created_by                     *int64
	addcreated_by                  *int64
	updated_by                     *int64
	addupdated_by                  *int64
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	name                           *string
	total_weight                   *int64
	addtotal_weight                *int64
	started_at                     *time.Time
	ended_at                       *time.Time
	status                         *enums.LottoStatus
	clearedFields                  map[string]struct{}
	lotto_prizes                   map[int64]struct{}
	removedlotto_prizes            map[int64]struct{}
	clearedlotto_prizes            bool
	lotto_records                  map[int64]struct{}
	removedlotto_records           map[int64]struct{}
	clearedlotto_records           bool
	lotto_user_counts              map[int64]struct{}
	removedlotto_user_counts       map[int64]struct{}
	clearedlotto_user_counts       bool
	lotto_get_count_records        map[int64]struct{}
	removedlotto_get_count_records map[int64]struct{}
	clearedlotto_get_count_records bool
	lotto_Change_rules             map[int64]struct{}
	removedlotto_Change_rules      map[int64]struct{}
	clearedlotto_Change_rules      bool
	done                           bool
	oldValue                       func(context.Context) (*Lotto, error)
	predicates                     []predicate.Lotto
}

var _ ent.Mutation = (*LottoMutation)(nil)

// lottoOption allows management of the mutation configuration using functional options.
type lottoOption func(*LottoMutation)

// newLottoMutation creates new mutation for the Lotto entity.
func newLottoMutation(c config, op Op, opts ...lottoOption) *LottoMutation {
	m := &LottoMutation{
		config:        c,
		op:            op,
		typ:           TypeLotto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLottoID sets the ID field of the mutation.
func withLottoID(id int64) lottoOption {
	return func(m *LottoMutation) {
		var (
			err   error
			once  sync.Once
			value *Lotto
		)
		m.oldValue = func(ctx context.Context) (*Lotto, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lotto.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLotto sets the old Lotto of the mutation.
func withLotto(node *Lotto) lottoOption {
	return func(m *LottoMutation) {
		m.oldValue = func(context.Context) (*Lotto, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LottoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LottoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Lotto entities.
func (m *LottoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LottoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LottoMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lotto.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *LottoMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LottoMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *LottoMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LottoMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LottoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LottoMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LottoMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *LottoMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LottoMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LottoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LottoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LottoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LottoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LottoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LottoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LottoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LottoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LottoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LottoMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *LottoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LottoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LottoMutation) ResetName() {
	m.name = nil
}

// SetTotalWeight sets the "total_weight" field.
func (m *LottoMutation) SetTotalWeight(i int64) {
	m.total_weight = &i
	m.addtotal_weight = nil
}

// TotalWeight returns the value of the "total_weight" field in the mutation.
func (m *LottoMutation) TotalWeight() (r int64, exists bool) {
	v := m.total_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalWeight returns the old "total_weight" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldTotalWeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalWeight: %w", err)
	}
	return oldValue.TotalWeight, nil
}

// AddTotalWeight adds i to the "total_weight" field.
func (m *LottoMutation) AddTotalWeight(i int64) {
	if m.addtotal_weight != nil {
		*m.addtotal_weight += i
	} else {
		m.addtotal_weight = &i
	}
}

// AddedTotalWeight returns the value that was added to the "total_weight" field in this mutation.
func (m *LottoMutation) AddedTotalWeight() (r int64, exists bool) {
	v := m.addtotal_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalWeight resets all changes to the "total_weight" field.
func (m *LottoMutation) ResetTotalWeight() {
	m.total_weight = nil
	m.addtotal_weight = nil
}

// SetStartedAt sets the "started_at" field.
func (m *LottoMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *LottoMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *LottoMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *LottoMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *LottoMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *LottoMutation) ResetEndedAt() {
	m.ended_at = nil
}

// SetStatus sets the "status" field.
func (m *LottoMutation) SetStatus(es enums.LottoStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *LottoMutation) Status() (r enums.LottoStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Lotto entity.
// If the Lotto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoMutation) OldStatus(ctx context.Context) (v enums.LottoStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LottoMutation) ResetStatus() {
	m.status = nil
}

// AddLottoPrizeIDs adds the "lotto_prizes" edge to the LottoPrize entity by ids.
func (m *LottoMutation) AddLottoPrizeIDs(ids ...int64) {
	if m.lotto_prizes == nil {
		m.lotto_prizes = make(map[int64]struct{})
	}
	for i := range ids {
		m.lotto_prizes[ids[i]] = struct{}{}
	}
}

// ClearLottoPrizes clears the "lotto_prizes" edge to the LottoPrize entity.
func (m *LottoMutation) ClearLottoPrizes() {
	m.clearedlotto_prizes = true
}

// LottoPrizesCleared reports if the "lotto_prizes" edge to the LottoPrize entity was cleared.
func (m *LottoMutation) LottoPrizesCleared() bool {
	return m.clearedlotto_prizes
}

// RemoveLottoPrizeIDs removes the "lotto_prizes" edge to the LottoPrize entity by IDs.
func (m *LottoMutation) RemoveLottoPrizeIDs(ids ...int64) {
	if m.removedlotto_prizes == nil {
		m.removedlotto_prizes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lotto_prizes, ids[i])
		m.removedlotto_prizes[ids[i]] = struct{}{}
	}
}

// RemovedLottoPrizes returns the removed IDs of the "lotto_prizes" edge to the LottoPrize entity.
func (m *LottoMutation) RemovedLottoPrizesIDs() (ids []int64) {
	for id := range m.removedlotto_prizes {
		ids = append(ids, id)
	}
	return
}

// LottoPrizesIDs returns the "lotto_prizes" edge IDs in the mutation.
func (m *LottoMutation) LottoPrizesIDs() (ids []int64) {
	for id := range m.lotto_prizes {
		ids = append(ids, id)
	}
	return
}

// ResetLottoPrizes resets all changes to the "lotto_prizes" edge.
func (m *LottoMutation) ResetLottoPrizes() {
	m.lotto_prizes = nil
	m.clearedlotto_prizes = false
	m.removedlotto_prizes = nil
}

// AddLottoRecordIDs adds the "lotto_records" edge to the LottoRecord entity by ids.
func (m *LottoMutation) AddLottoRecordIDs(ids ...int64) {
	if m.lotto_records == nil {
		m.lotto_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.lotto_records[ids[i]] = struct{}{}
	}
}

// ClearLottoRecords clears the "lotto_records" edge to the LottoRecord entity.
func (m *LottoMutation) ClearLottoRecords() {
	m.clearedlotto_records = true
}

// LottoRecordsCleared reports if the "lotto_records" edge to the LottoRecord entity was cleared.
func (m *LottoMutation) LottoRecordsCleared() bool {
	return m.clearedlotto_records
}

// RemoveLottoRecordIDs removes the "lotto_records" edge to the LottoRecord entity by IDs.
func (m *LottoMutation) RemoveLottoRecordIDs(ids ...int64) {
	if m.removedlotto_records == nil {
		m.removedlotto_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lotto_records, ids[i])
		m.removedlotto_records[ids[i]] = struct{}{}
	}
}

// RemovedLottoRecords returns the removed IDs of the "lotto_records" edge to the LottoRecord entity.
func (m *LottoMutation) RemovedLottoRecordsIDs() (ids []int64) {
	for id := range m.removedlotto_records {
		ids = append(ids, id)
	}
	return
}

// LottoRecordsIDs returns the "lotto_records" edge IDs in the mutation.
func (m *LottoMutation) LottoRecordsIDs() (ids []int64) {
	for id := range m.lotto_records {
		ids = append(ids, id)
	}
	return
}

// ResetLottoRecords resets all changes to the "lotto_records" edge.
func (m *LottoMutation) ResetLottoRecords() {
	m.lotto_records = nil
	m.clearedlotto_records = false
	m.removedlotto_records = nil
}

// AddLottoUserCountIDs adds the "lotto_user_counts" edge to the LottoUserCount entity by ids.
func (m *LottoMutation) AddLottoUserCountIDs(ids ...int64) {
	if m.lotto_user_counts == nil {
		m.lotto_user_counts = make(map[int64]struct{})
	}
	for i := range ids {
		m.lotto_user_counts[ids[i]] = struct{}{}
	}
}

// ClearLottoUserCounts clears the "lotto_user_counts" edge to the LottoUserCount entity.
func (m *LottoMutation) ClearLottoUserCounts() {
	m.clearedlotto_user_counts = true
}

// LottoUserCountsCleared reports if the "lotto_user_counts" edge to the LottoUserCount entity was cleared.
func (m *LottoMutation) LottoUserCountsCleared() bool {
	return m.clearedlotto_user_counts
}

// RemoveLottoUserCountIDs removes the "lotto_user_counts" edge to the LottoUserCount entity by IDs.
func (m *LottoMutation) RemoveLottoUserCountIDs(ids ...int64) {
	if m.removedlotto_user_counts == nil {
		m.removedlotto_user_counts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lotto_user_counts, ids[i])
		m.removedlotto_user_counts[ids[i]] = struct{}{}
	}
}

// RemovedLottoUserCounts returns the removed IDs of the "lotto_user_counts" edge to the LottoUserCount entity.
func (m *LottoMutation) RemovedLottoUserCountsIDs() (ids []int64) {
	for id := range m.removedlotto_user_counts {
		ids = append(ids, id)
	}
	return
}

// LottoUserCountsIDs returns the "lotto_user_counts" edge IDs in the mutation.
func (m *LottoMutation) LottoUserCountsIDs() (ids []int64) {
	for id := range m.lotto_user_counts {
		ids = append(ids, id)
	}
	return
}

// ResetLottoUserCounts resets all changes to the "lotto_user_counts" edge.
func (m *LottoMutation) ResetLottoUserCounts() {
	m.lotto_user_counts = nil
	m.clearedlotto_user_counts = false
	m.removedlotto_user_counts = nil
}

// AddLottoGetCountRecordIDs adds the "lotto_get_count_records" edge to the LottoGetCountRecord entity by ids.
func (m *LottoMutation) AddLottoGetCountRecordIDs(ids ...int64) {
	if m.lotto_get_count_records == nil {
		m.lotto_get_count_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.lotto_get_count_records[ids[i]] = struct{}{}
	}
}

// ClearLottoGetCountRecords clears the "lotto_get_count_records" edge to the LottoGetCountRecord entity.
func (m *LottoMutation) ClearLottoGetCountRecords() {
	m.clearedlotto_get_count_records = true
}

// LottoGetCountRecordsCleared reports if the "lotto_get_count_records" edge to the LottoGetCountRecord entity was cleared.
func (m *LottoMutation) LottoGetCountRecordsCleared() bool {
	return m.clearedlotto_get_count_records
}

// RemoveLottoGetCountRecordIDs removes the "lotto_get_count_records" edge to the LottoGetCountRecord entity by IDs.
func (m *LottoMutation) RemoveLottoGetCountRecordIDs(ids ...int64) {
	if m.removedlotto_get_count_records == nil {
		m.removedlotto_get_count_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lotto_get_count_records, ids[i])
		m.removedlotto_get_count_records[ids[i]] = struct{}{}
	}
}

// RemovedLottoGetCountRecords returns the removed IDs of the "lotto_get_count_records" edge to the LottoGetCountRecord entity.
func (m *LottoMutation) RemovedLottoGetCountRecordsIDs() (ids []int64) {
	for id := range m.removedlotto_get_count_records {
		ids = append(ids, id)
	}
	return
}

// LottoGetCountRecordsIDs returns the "lotto_get_count_records" edge IDs in the mutation.
func (m *LottoMutation) LottoGetCountRecordsIDs() (ids []int64) {
	for id := range m.lotto_get_count_records {
		ids = append(ids, id)
	}
	return
}

// ResetLottoGetCountRecords resets all changes to the "lotto_get_count_records" edge.
func (m *LottoMutation) ResetLottoGetCountRecords() {
	m.lotto_get_count_records = nil
	m.clearedlotto_get_count_records = false
	m.removedlotto_get_count_records = nil
}

// AddLottoChangeRuleIDs adds the "lotto_Change_rules" edge to the LottoChanceRule entity by ids.
func (m *LottoMutation) AddLottoChangeRuleIDs(ids ...int64) {
	if m.lotto_Change_rules == nil {
		m.lotto_Change_rules = make(map[int64]struct{})
	}
	for i := range ids {
		m.lotto_Change_rules[ids[i]] = struct{}{}
	}
}

// ClearLottoChangeRules clears the "lotto_Change_rules" edge to the LottoChanceRule entity.
func (m *LottoMutation) ClearLottoChangeRules() {
	m.clearedlotto_Change_rules = true
}

// LottoChangeRulesCleared reports if the "lotto_Change_rules" edge to the LottoChanceRule entity was cleared.
func (m *LottoMutation) LottoChangeRulesCleared() bool {
	return m.clearedlotto_Change_rules
}

// RemoveLottoChangeRuleIDs removes the "lotto_Change_rules" edge to the LottoChanceRule entity by IDs.
func (m *LottoMutation) RemoveLottoChangeRuleIDs(ids ...int64) {
	if m.removedlotto_Change_rules == nil {
		m.removedlotto_Change_rules = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lotto_Change_rules, ids[i])
		m.removedlotto_Change_rules[ids[i]] = struct{}{}
	}
}

// RemovedLottoChangeRules returns the removed IDs of the "lotto_Change_rules" edge to the LottoChanceRule entity.
func (m *LottoMutation) RemovedLottoChangeRulesIDs() (ids []int64) {
	for id := range m.removedlotto_Change_rules {
		ids = append(ids, id)
	}
	return
}

// LottoChangeRulesIDs returns the "lotto_Change_rules" edge IDs in the mutation.
func (m *LottoMutation) LottoChangeRulesIDs() (ids []int64) {
	for id := range m.lotto_Change_rules {
		ids = append(ids, id)
	}
	return
}

// ResetLottoChangeRules resets all changes to the "lotto_Change_rules" edge.
func (m *LottoMutation) ResetLottoChangeRules() {
	m.lotto_Change_rules = nil
	m.clearedlotto_Change_rules = false
	m.removedlotto_Change_rules = nil
}

// Where appends a list predicates to the LottoMutation builder.
func (m *LottoMutation) Where(ps ...predicate.Lotto) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LottoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LottoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lotto, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LottoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LottoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lotto).
func (m *LottoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LottoMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, lotto.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, lotto.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, lotto.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lotto.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, lotto.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, lotto.FieldName)
	}
	if m.total_weight != nil {
		fields = append(fields, lotto.FieldTotalWeight)
	}
	if m.started_at != nil {
		fields = append(fields, lotto.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, lotto.FieldEndedAt)
	}
	if m.status != nil {
		fields = append(fields, lotto.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LottoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lotto.FieldCreatedBy:
		return m.CreatedBy()
	case lotto.FieldUpdatedBy:
		return m.UpdatedBy()
	case lotto.FieldCreatedAt:
		return m.CreatedAt()
	case lotto.FieldUpdatedAt:
		return m.UpdatedAt()
	case lotto.FieldDeletedAt:
		return m.DeletedAt()
	case lotto.FieldName:
		return m.Name()
	case lotto.FieldTotalWeight:
		return m.TotalWeight()
	case lotto.FieldStartedAt:
		return m.StartedAt()
	case lotto.FieldEndedAt:
		return m.EndedAt()
	case lotto.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LottoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lotto.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case lotto.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case lotto.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lotto.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lotto.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case lotto.FieldName:
		return m.OldName(ctx)
	case lotto.FieldTotalWeight:
		return m.OldTotalWeight(ctx)
	case lotto.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case lotto.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case lotto.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Lotto field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lotto.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case lotto.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case lotto.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lotto.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lotto.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case lotto.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case lotto.FieldTotalWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalWeight(v)
		return nil
	case lotto.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case lotto.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case lotto.FieldStatus:
		v, ok := value.(enums.LottoStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Lotto field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LottoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, lotto.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, lotto.FieldUpdatedBy)
	}
	if m.addtotal_weight != nil {
		fields = append(fields, lotto.FieldTotalWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LottoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lotto.FieldCreatedBy:
		return m.AddedCreatedBy()
	case lotto.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case lotto.FieldTotalWeight:
		return m.AddedTotalWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lotto.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case lotto.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case lotto.FieldTotalWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Lotto numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LottoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LottoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LottoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Lotto nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LottoMutation) ResetField(name string) error {
	switch name {
	case lotto.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case lotto.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case lotto.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lotto.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lotto.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case lotto.FieldName:
		m.ResetName()
		return nil
	case lotto.FieldTotalWeight:
		m.ResetTotalWeight()
		return nil
	case lotto.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case lotto.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case lotto.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Lotto field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LottoMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.lotto_prizes != nil {
		edges = append(edges, lotto.EdgeLottoPrizes)
	}
	if m.lotto_records != nil {
		edges = append(edges, lotto.EdgeLottoRecords)
	}
	if m.lotto_user_counts != nil {
		edges = append(edges, lotto.EdgeLottoUserCounts)
	}
	if m.lotto_get_count_records != nil {
		edges = append(edges, lotto.EdgeLottoGetCountRecords)
	}
	if m.lotto_Change_rules != nil {
		edges = append(edges, lotto.EdgeLottoChangeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LottoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lotto.EdgeLottoPrizes:
		ids := make([]ent.Value, 0, len(m.lotto_prizes))
		for id := range m.lotto_prizes {
			ids = append(ids, id)
		}
		return ids
	case lotto.EdgeLottoRecords:
		ids := make([]ent.Value, 0, len(m.lotto_records))
		for id := range m.lotto_records {
			ids = append(ids, id)
		}
		return ids
	case lotto.EdgeLottoUserCounts:
		ids := make([]ent.Value, 0, len(m.lotto_user_counts))
		for id := range m.lotto_user_counts {
			ids = append(ids, id)
		}
		return ids
	case lotto.EdgeLottoGetCountRecords:
		ids := make([]ent.Value, 0, len(m.lotto_get_count_records))
		for id := range m.lotto_get_count_records {
			ids = append(ids, id)
		}
		return ids
	case lotto.EdgeLottoChangeRules:
		ids := make([]ent.Value, 0, len(m.lotto_Change_rules))
		for id := range m.lotto_Change_rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LottoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedlotto_prizes != nil {
		edges = append(edges, lotto.EdgeLottoPrizes)
	}
	if m.removedlotto_records != nil {
		edges = append(edges, lotto.EdgeLottoRecords)
	}
	if m.removedlotto_user_counts != nil {
		edges = append(edges, lotto.EdgeLottoUserCounts)
	}
	if m.removedlotto_get_count_records != nil {
		edges = append(edges, lotto.EdgeLottoGetCountRecords)
	}
	if m.removedlotto_Change_rules != nil {
		edges = append(edges, lotto.EdgeLottoChangeRules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LottoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lotto.EdgeLottoPrizes:
		ids := make([]ent.Value, 0, len(m.removedlotto_prizes))
		for id := range m.removedlotto_prizes {
			ids = append(ids, id)
		}
		return ids
	case lotto.EdgeLottoRecords:
		ids := make([]ent.Value, 0, len(m.removedlotto_records))
		for id := range m.removedlotto_records {
			ids = append(ids, id)
		}
		return ids
	case lotto.EdgeLottoUserCounts:
		ids := make([]ent.Value, 0, len(m.removedlotto_user_counts))
		for id := range m.removedlotto_user_counts {
			ids = append(ids, id)
		}
		return ids
	case lotto.EdgeLottoGetCountRecords:
		ids := make([]ent.Value, 0, len(m.removedlotto_get_count_records))
		for id := range m.removedlotto_get_count_records {
			ids = append(ids, id)
		}
		return ids
	case lotto.EdgeLottoChangeRules:
		ids := make([]ent.Value, 0, len(m.removedlotto_Change_rules))
		for id := range m.removedlotto_Change_rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LottoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedlotto_prizes {
		edges = append(edges, lotto.EdgeLottoPrizes)
	}
	if m.clearedlotto_records {
		edges = append(edges, lotto.EdgeLottoRecords)
	}
	if m.clearedlotto_user_counts {
		edges = append(edges, lotto.EdgeLottoUserCounts)
	}
	if m.clearedlotto_get_count_records {
		edges = append(edges, lotto.EdgeLottoGetCountRecords)
	}
	if m.clearedlotto_Change_rules {
		edges = append(edges, lotto.EdgeLottoChangeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LottoMutation) EdgeCleared(name string) bool {
	switch name {
	case lotto.EdgeLottoPrizes:
		return m.clearedlotto_prizes
	case lotto.EdgeLottoRecords:
		return m.clearedlotto_records
	case lotto.EdgeLottoUserCounts:
		return m.clearedlotto_user_counts
	case lotto.EdgeLottoGetCountRecords:
		return m.clearedlotto_get_count_records
	case lotto.EdgeLottoChangeRules:
		return m.clearedlotto_Change_rules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LottoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Lotto unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LottoMutation) ResetEdge(name string) error {
	switch name {
	case lotto.EdgeLottoPrizes:
		m.ResetLottoPrizes()
		return nil
	case lotto.EdgeLottoRecords:
		m.ResetLottoRecords()
		return nil
	case lotto.EdgeLottoUserCounts:
		m.ResetLottoUserCounts()
		return nil
	case lotto.EdgeLottoGetCountRecords:
		m.ResetLottoGetCountRecords()
		return nil
	case lotto.EdgeLottoChangeRules:
		m.ResetLottoChangeRules()
		return nil
	}
	return fmt.Errorf("unknown Lotto edge %s", name)
}

// LottoChanceRuleMutation represents an operation that mutates the LottoChanceRule nodes in the graph.
type LottoChanceRuleMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_by         *int64
	addcreated_by      *int64
	updated_by         *int64
	addupdated_by      *int64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	condition          *enums.LottoCondition
	award_count        *int64
	addaward_count     *int64
	recharge_amount    *int64
	addrecharge_amount *int64
	clearedFields      map[string]struct{}
	lotto              *int64
	clearedlotto       bool
	done               bool
	oldValue           func(context.Context) (*LottoChanceRule, error)
	predicates         []predicate.LottoChanceRule
}

var _ ent.Mutation = (*LottoChanceRuleMutation)(nil)

// lottochanceruleOption allows management of the mutation configuration using functional options.
type lottochanceruleOption func(*LottoChanceRuleMutation)

// newLottoChanceRuleMutation creates new mutation for the LottoChanceRule entity.
func newLottoChanceRuleMutation(c config, op Op, opts ...lottochanceruleOption) *LottoChanceRuleMutation {
	m := &LottoChanceRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeLottoChanceRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLottoChanceRuleID sets the ID field of the mutation.
func withLottoChanceRuleID(id int64) lottochanceruleOption {
	return func(m *LottoChanceRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *LottoChanceRule
		)
		m.oldValue = func(ctx context.Context) (*LottoChanceRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LottoChanceRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLottoChanceRule sets the old LottoChanceRule of the mutation.
func withLottoChanceRule(node *LottoChanceRule) lottochanceruleOption {
	return func(m *LottoChanceRuleMutation) {
		m.oldValue = func(context.Context) (*LottoChanceRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LottoChanceRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LottoChanceRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LottoChanceRule entities.
func (m *LottoChanceRuleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LottoChanceRuleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LottoChanceRuleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LottoChanceRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *LottoChanceRuleMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LottoChanceRuleMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LottoChanceRule entity.
// If the LottoChanceRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoChanceRuleMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *LottoChanceRuleMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LottoChanceRuleMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LottoChanceRuleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LottoChanceRuleMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LottoChanceRuleMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LottoChanceRule entity.
// If the LottoChanceRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoChanceRuleMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *LottoChanceRuleMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LottoChanceRuleMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LottoChanceRuleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LottoChanceRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LottoChanceRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LottoChanceRule entity.
// If the LottoChanceRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoChanceRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LottoChanceRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LottoChanceRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LottoChanceRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LottoChanceRule entity.
// If the LottoChanceRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoChanceRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LottoChanceRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LottoChanceRuleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LottoChanceRuleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LottoChanceRule entity.
// If the LottoChanceRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoChanceRuleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LottoChanceRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetLottoID sets the "lotto_id" field.
func (m *LottoChanceRuleMutation) SetLottoID(i int64) {
	m.lotto = &i
}

// LottoID returns the value of the "lotto_id" field in the mutation.
func (m *LottoChanceRuleMutation) LottoID() (r int64, exists bool) {
	v := m.lotto
	if v == nil {
		return
	}
	return *v, true
}

// OldLottoID returns the old "lotto_id" field's value of the LottoChanceRule entity.
// If the LottoChanceRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoChanceRuleMutation) OldLottoID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLottoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLottoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLottoID: %w", err)
	}
	return oldValue.LottoID, nil
}

// ResetLottoID resets all changes to the "lotto_id" field.
func (m *LottoChanceRuleMutation) ResetLottoID() {
	m.lotto = nil
}

// SetCondition sets the "condition" field.
func (m *LottoChanceRuleMutation) SetCondition(ec enums.LottoCondition) {
	m.condition = &ec
}

// Condition returns the value of the "condition" field in the mutation.
func (m *LottoChanceRuleMutation) Condition() (r enums.LottoCondition, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the LottoChanceRule entity.
// If the LottoChanceRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoChanceRuleMutation) OldCondition(ctx context.Context) (v enums.LottoCondition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// ResetCondition resets all changes to the "condition" field.
func (m *LottoChanceRuleMutation) ResetCondition() {
	m.condition = nil
}

// SetAwardCount sets the "award_count" field.
func (m *LottoChanceRuleMutation) SetAwardCount(i int64) {
	m.award_count = &i
	m.addaward_count = nil
}

// AwardCount returns the value of the "award_count" field in the mutation.
func (m *LottoChanceRuleMutation) AwardCount() (r int64, exists bool) {
	v := m.award_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardCount returns the old "award_count" field's value of the LottoChanceRule entity.
// If the LottoChanceRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoChanceRuleMutation) OldAwardCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardCount: %w", err)
	}
	return oldValue.AwardCount, nil
}

// AddAwardCount adds i to the "award_count" field.
func (m *LottoChanceRuleMutation) AddAwardCount(i int64) {
	if m.addaward_count != nil {
		*m.addaward_count += i
	} else {
		m.addaward_count = &i
	}
}

// AddedAwardCount returns the value that was added to the "award_count" field in this mutation.
func (m *LottoChanceRuleMutation) AddedAwardCount() (r int64, exists bool) {
	v := m.addaward_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwardCount resets all changes to the "award_count" field.
func (m *LottoChanceRuleMutation) ResetAwardCount() {
	m.award_count = nil
	m.addaward_count = nil
}

// SetRechargeAmount sets the "recharge_amount" field.
func (m *LottoChanceRuleMutation) SetRechargeAmount(i int64) {
	m.recharge_amount = &i
	m.addrecharge_amount = nil
}

// RechargeAmount returns the value of the "recharge_amount" field in the mutation.
func (m *LottoChanceRuleMutation) RechargeAmount() (r int64, exists bool) {
	v := m.recharge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRechargeAmount returns the old "recharge_amount" field's value of the LottoChanceRule entity.
// If the LottoChanceRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoChanceRuleMutation) OldRechargeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRechargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRechargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRechargeAmount: %w", err)
	}
	return oldValue.RechargeAmount, nil
}

// AddRechargeAmount adds i to the "recharge_amount" field.
func (m *LottoChanceRuleMutation) AddRechargeAmount(i int64) {
	if m.addrecharge_amount != nil {
		*m.addrecharge_amount += i
	} else {
		m.addrecharge_amount = &i
	}
}

// AddedRechargeAmount returns the value that was added to the "recharge_amount" field in this mutation.
func (m *LottoChanceRuleMutation) AddedRechargeAmount() (r int64, exists bool) {
	v := m.addrecharge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRechargeAmount resets all changes to the "recharge_amount" field.
func (m *LottoChanceRuleMutation) ResetRechargeAmount() {
	m.recharge_amount = nil
	m.addrecharge_amount = nil
}

// ClearLotto clears the "lotto" edge to the Lotto entity.
func (m *LottoChanceRuleMutation) ClearLotto() {
	m.clearedlotto = true
	m.clearedFields[lottochancerule.FieldLottoID] = struct{}{}
}

// LottoCleared reports if the "lotto" edge to the Lotto entity was cleared.
func (m *LottoChanceRuleMutation) LottoCleared() bool {
	return m.clearedlotto
}

// LottoIDs returns the "lotto" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LottoID instead. It exists only for internal usage by the builders.
func (m *LottoChanceRuleMutation) LottoIDs() (ids []int64) {
	if id := m.lotto; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLotto resets all changes to the "lotto" edge.
func (m *LottoChanceRuleMutation) ResetLotto() {
	m.lotto = nil
	m.clearedlotto = false
}

// Where appends a list predicates to the LottoChanceRuleMutation builder.
func (m *LottoChanceRuleMutation) Where(ps ...predicate.LottoChanceRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LottoChanceRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LottoChanceRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LottoChanceRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LottoChanceRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LottoChanceRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LottoChanceRule).
func (m *LottoChanceRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LottoChanceRuleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, lottochancerule.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, lottochancerule.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, lottochancerule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lottochancerule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, lottochancerule.FieldDeletedAt)
	}
	if m.lotto != nil {
		fields = append(fields, lottochancerule.FieldLottoID)
	}
	if m.condition != nil {
		fields = append(fields, lottochancerule.FieldCondition)
	}
	if m.award_count != nil {
		fields = append(fields, lottochancerule.FieldAwardCount)
	}
	if m.recharge_amount != nil {
		fields = append(fields, lottochancerule.FieldRechargeAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LottoChanceRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lottochancerule.FieldCreatedBy:
		return m.CreatedBy()
	case lottochancerule.FieldUpdatedBy:
		return m.UpdatedBy()
	case lottochancerule.FieldCreatedAt:
		return m.CreatedAt()
	case lottochancerule.FieldUpdatedAt:
		return m.UpdatedAt()
	case lottochancerule.FieldDeletedAt:
		return m.DeletedAt()
	case lottochancerule.FieldLottoID:
		return m.LottoID()
	case lottochancerule.FieldCondition:
		return m.Condition()
	case lottochancerule.FieldAwardCount:
		return m.AwardCount()
	case lottochancerule.FieldRechargeAmount:
		return m.RechargeAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LottoChanceRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lottochancerule.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case lottochancerule.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case lottochancerule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lottochancerule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lottochancerule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case lottochancerule.FieldLottoID:
		return m.OldLottoID(ctx)
	case lottochancerule.FieldCondition:
		return m.OldCondition(ctx)
	case lottochancerule.FieldAwardCount:
		return m.OldAwardCount(ctx)
	case lottochancerule.FieldRechargeAmount:
		return m.OldRechargeAmount(ctx)
	}
	return nil, fmt.Errorf("unknown LottoChanceRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoChanceRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lottochancerule.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case lottochancerule.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case lottochancerule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lottochancerule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lottochancerule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case lottochancerule.FieldLottoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLottoID(v)
		return nil
	case lottochancerule.FieldCondition:
		v, ok := value.(enums.LottoCondition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case lottochancerule.FieldAwardCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardCount(v)
		return nil
	case lottochancerule.FieldRechargeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRechargeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoChanceRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LottoChanceRuleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, lottochancerule.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, lottochancerule.FieldUpdatedBy)
	}
	if m.addaward_count != nil {
		fields = append(fields, lottochancerule.FieldAwardCount)
	}
	if m.addrecharge_amount != nil {
		fields = append(fields, lottochancerule.FieldRechargeAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LottoChanceRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lottochancerule.FieldCreatedBy:
		return m.AddedCreatedBy()
	case lottochancerule.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case lottochancerule.FieldAwardCount:
		return m.AddedAwardCount()
	case lottochancerule.FieldRechargeAmount:
		return m.AddedRechargeAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoChanceRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lottochancerule.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case lottochancerule.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case lottochancerule.FieldAwardCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwardCount(v)
		return nil
	case lottochancerule.FieldRechargeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRechargeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoChanceRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LottoChanceRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LottoChanceRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LottoChanceRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LottoChanceRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LottoChanceRuleMutation) ResetField(name string) error {
	switch name {
	case lottochancerule.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case lottochancerule.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case lottochancerule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lottochancerule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lottochancerule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case lottochancerule.FieldLottoID:
		m.ResetLottoID()
		return nil
	case lottochancerule.FieldCondition:
		m.ResetCondition()
		return nil
	case lottochancerule.FieldAwardCount:
		m.ResetAwardCount()
		return nil
	case lottochancerule.FieldRechargeAmount:
		m.ResetRechargeAmount()
		return nil
	}
	return fmt.Errorf("unknown LottoChanceRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LottoChanceRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lotto != nil {
		edges = append(edges, lottochancerule.EdgeLotto)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LottoChanceRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lottochancerule.EdgeLotto:
		if id := m.lotto; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LottoChanceRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LottoChanceRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LottoChanceRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlotto {
		edges = append(edges, lottochancerule.EdgeLotto)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LottoChanceRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case lottochancerule.EdgeLotto:
		return m.clearedlotto
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LottoChanceRuleMutation) ClearEdge(name string) error {
	switch name {
	case lottochancerule.EdgeLotto:
		m.ClearLotto()
		return nil
	}
	return fmt.Errorf("unknown LottoChanceRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LottoChanceRuleMutation) ResetEdge(name string) error {
	switch name {
	case lottochancerule.EdgeLotto:
		m.ResetLotto()
		return nil
	}
	return fmt.Errorf("unknown LottoChanceRule edge %s", name)
}

// LottoGetCountRecordMutation represents an operation that mutates the LottoGetCountRecord nodes in the graph.
type LottoGetCountRecordMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_by         *int64
	addcreated_by      *int64
	updated_by         *int64
	addupdated_by      *int64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	count              *int64
	addcount           *int64
	_type              *enums.LottoCondition
	recharge_amount    *int64
	addrecharge_amount *int64
	clearedFields      map[string]struct{}
	user               *int64
	cleareduser        bool
	lotto              *int64
	clearedlotto       bool
	done               bool
	oldValue           func(context.Context) (*LottoGetCountRecord, error)
	predicates         []predicate.LottoGetCountRecord
}

var _ ent.Mutation = (*LottoGetCountRecordMutation)(nil)

// lottogetcountrecordOption allows management of the mutation configuration using functional options.
type lottogetcountrecordOption func(*LottoGetCountRecordMutation)

// newLottoGetCountRecordMutation creates new mutation for the LottoGetCountRecord entity.
func newLottoGetCountRecordMutation(c config, op Op, opts ...lottogetcountrecordOption) *LottoGetCountRecordMutation {
	m := &LottoGetCountRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeLottoGetCountRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLottoGetCountRecordID sets the ID field of the mutation.
func withLottoGetCountRecordID(id int64) lottogetcountrecordOption {
	return func(m *LottoGetCountRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *LottoGetCountRecord
		)
		m.oldValue = func(ctx context.Context) (*LottoGetCountRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LottoGetCountRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLottoGetCountRecord sets the old LottoGetCountRecord of the mutation.
func withLottoGetCountRecord(node *LottoGetCountRecord) lottogetcountrecordOption {
	return func(m *LottoGetCountRecordMutation) {
		m.oldValue = func(context.Context) (*LottoGetCountRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LottoGetCountRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LottoGetCountRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LottoGetCountRecord entities.
func (m *LottoGetCountRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LottoGetCountRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LottoGetCountRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LottoGetCountRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *LottoGetCountRecordMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LottoGetCountRecordMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *LottoGetCountRecordMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LottoGetCountRecordMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LottoGetCountRecordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LottoGetCountRecordMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LottoGetCountRecordMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *LottoGetCountRecordMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LottoGetCountRecordMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LottoGetCountRecordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LottoGetCountRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LottoGetCountRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LottoGetCountRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LottoGetCountRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LottoGetCountRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LottoGetCountRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LottoGetCountRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LottoGetCountRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LottoGetCountRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *LottoGetCountRecordMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LottoGetCountRecordMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LottoGetCountRecordMutation) ResetUserID() {
	m.user = nil
}

// SetLottoID sets the "lotto_id" field.
func (m *LottoGetCountRecordMutation) SetLottoID(i int64) {
	m.lotto = &i
}

// LottoID returns the value of the "lotto_id" field in the mutation.
func (m *LottoGetCountRecordMutation) LottoID() (r int64, exists bool) {
	v := m.lotto
	if v == nil {
		return
	}
	return *v, true
}

// OldLottoID returns the old "lotto_id" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldLottoID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLottoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLottoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLottoID: %w", err)
	}
	return oldValue.LottoID, nil
}

// ResetLottoID resets all changes to the "lotto_id" field.
func (m *LottoGetCountRecordMutation) ResetLottoID() {
	m.lotto = nil
}

// SetCount sets the "count" field.
func (m *LottoGetCountRecordMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *LottoGetCountRecordMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *LottoGetCountRecordMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *LottoGetCountRecordMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *LottoGetCountRecordMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetType sets the "type" field.
func (m *LottoGetCountRecordMutation) SetType(ec enums.LottoCondition) {
	m._type = &ec
}

// GetType returns the value of the "type" field in the mutation.
func (m *LottoGetCountRecordMutation) GetType() (r enums.LottoCondition, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldType(ctx context.Context) (v enums.LottoCondition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LottoGetCountRecordMutation) ResetType() {
	m._type = nil
}

// SetRechargeAmount sets the "recharge_amount" field.
func (m *LottoGetCountRecordMutation) SetRechargeAmount(i int64) {
	m.recharge_amount = &i
	m.addrecharge_amount = nil
}

// RechargeAmount returns the value of the "recharge_amount" field in the mutation.
func (m *LottoGetCountRecordMutation) RechargeAmount() (r int64, exists bool) {
	v := m.recharge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRechargeAmount returns the old "recharge_amount" field's value of the LottoGetCountRecord entity.
// If the LottoGetCountRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoGetCountRecordMutation) OldRechargeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRechargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRechargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRechargeAmount: %w", err)
	}
	return oldValue.RechargeAmount, nil
}

// AddRechargeAmount adds i to the "recharge_amount" field.
func (m *LottoGetCountRecordMutation) AddRechargeAmount(i int64) {
	if m.addrecharge_amount != nil {
		*m.addrecharge_amount += i
	} else {
		m.addrecharge_amount = &i
	}
}

// AddedRechargeAmount returns the value that was added to the "recharge_amount" field in this mutation.
func (m *LottoGetCountRecordMutation) AddedRechargeAmount() (r int64, exists bool) {
	v := m.addrecharge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRechargeAmount resets all changes to the "recharge_amount" field.
func (m *LottoGetCountRecordMutation) ResetRechargeAmount() {
	m.recharge_amount = nil
	m.addrecharge_amount = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *LottoGetCountRecordMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[lottogetcountrecord.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LottoGetCountRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LottoGetCountRecordMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LottoGetCountRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearLotto clears the "lotto" edge to the Lotto entity.
func (m *LottoGetCountRecordMutation) ClearLotto() {
	m.clearedlotto = true
	m.clearedFields[lottogetcountrecord.FieldLottoID] = struct{}{}
}

// LottoCleared reports if the "lotto" edge to the Lotto entity was cleared.
func (m *LottoGetCountRecordMutation) LottoCleared() bool {
	return m.clearedlotto
}

// LottoIDs returns the "lotto" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LottoID instead. It exists only for internal usage by the builders.
func (m *LottoGetCountRecordMutation) LottoIDs() (ids []int64) {
	if id := m.lotto; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLotto resets all changes to the "lotto" edge.
func (m *LottoGetCountRecordMutation) ResetLotto() {
	m.lotto = nil
	m.clearedlotto = false
}

// Where appends a list predicates to the LottoGetCountRecordMutation builder.
func (m *LottoGetCountRecordMutation) Where(ps ...predicate.LottoGetCountRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LottoGetCountRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LottoGetCountRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LottoGetCountRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LottoGetCountRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LottoGetCountRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LottoGetCountRecord).
func (m *LottoGetCountRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LottoGetCountRecordMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, lottogetcountrecord.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, lottogetcountrecord.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, lottogetcountrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lottogetcountrecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, lottogetcountrecord.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, lottogetcountrecord.FieldUserID)
	}
	if m.lotto != nil {
		fields = append(fields, lottogetcountrecord.FieldLottoID)
	}
	if m.count != nil {
		fields = append(fields, lottogetcountrecord.FieldCount)
	}
	if m._type != nil {
		fields = append(fields, lottogetcountrecord.FieldType)
	}
	if m.recharge_amount != nil {
		fields = append(fields, lottogetcountrecord.FieldRechargeAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LottoGetCountRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lottogetcountrecord.FieldCreatedBy:
		return m.CreatedBy()
	case lottogetcountrecord.FieldUpdatedBy:
		return m.UpdatedBy()
	case lottogetcountrecord.FieldCreatedAt:
		return m.CreatedAt()
	case lottogetcountrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case lottogetcountrecord.FieldDeletedAt:
		return m.DeletedAt()
	case lottogetcountrecord.FieldUserID:
		return m.UserID()
	case lottogetcountrecord.FieldLottoID:
		return m.LottoID()
	case lottogetcountrecord.FieldCount:
		return m.Count()
	case lottogetcountrecord.FieldType:
		return m.GetType()
	case lottogetcountrecord.FieldRechargeAmount:
		return m.RechargeAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LottoGetCountRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lottogetcountrecord.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case lottogetcountrecord.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case lottogetcountrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lottogetcountrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lottogetcountrecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case lottogetcountrecord.FieldUserID:
		return m.OldUserID(ctx)
	case lottogetcountrecord.FieldLottoID:
		return m.OldLottoID(ctx)
	case lottogetcountrecord.FieldCount:
		return m.OldCount(ctx)
	case lottogetcountrecord.FieldType:
		return m.OldType(ctx)
	case lottogetcountrecord.FieldRechargeAmount:
		return m.OldRechargeAmount(ctx)
	}
	return nil, fmt.Errorf("unknown LottoGetCountRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoGetCountRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lottogetcountrecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case lottogetcountrecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case lottogetcountrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lottogetcountrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lottogetcountrecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case lottogetcountrecord.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case lottogetcountrecord.FieldLottoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLottoID(v)
		return nil
	case lottogetcountrecord.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case lottogetcountrecord.FieldType:
		v, ok := value.(enums.LottoCondition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case lottogetcountrecord.FieldRechargeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRechargeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoGetCountRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LottoGetCountRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, lottogetcountrecord.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, lottogetcountrecord.FieldUpdatedBy)
	}
	if m.addcount != nil {
		fields = append(fields, lottogetcountrecord.FieldCount)
	}
	if m.addrecharge_amount != nil {
		fields = append(fields, lottogetcountrecord.FieldRechargeAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LottoGetCountRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lottogetcountrecord.FieldCreatedBy:
		return m.AddedCreatedBy()
	case lottogetcountrecord.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case lottogetcountrecord.FieldCount:
		return m.AddedCount()
	case lottogetcountrecord.FieldRechargeAmount:
		return m.AddedRechargeAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoGetCountRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lottogetcountrecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case lottogetcountrecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case lottogetcountrecord.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case lottogetcountrecord.FieldRechargeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRechargeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoGetCountRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LottoGetCountRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LottoGetCountRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LottoGetCountRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LottoGetCountRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LottoGetCountRecordMutation) ResetField(name string) error {
	switch name {
	case lottogetcountrecord.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case lottogetcountrecord.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case lottogetcountrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lottogetcountrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lottogetcountrecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case lottogetcountrecord.FieldUserID:
		m.ResetUserID()
		return nil
	case lottogetcountrecord.FieldLottoID:
		m.ResetLottoID()
		return nil
	case lottogetcountrecord.FieldCount:
		m.ResetCount()
		return nil
	case lottogetcountrecord.FieldType:
		m.ResetType()
		return nil
	case lottogetcountrecord.FieldRechargeAmount:
		m.ResetRechargeAmount()
		return nil
	}
	return fmt.Errorf("unknown LottoGetCountRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LottoGetCountRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, lottogetcountrecord.EdgeUser)
	}
	if m.lotto != nil {
		edges = append(edges, lottogetcountrecord.EdgeLotto)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LottoGetCountRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lottogetcountrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case lottogetcountrecord.EdgeLotto:
		if id := m.lotto; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LottoGetCountRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LottoGetCountRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LottoGetCountRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, lottogetcountrecord.EdgeUser)
	}
	if m.clearedlotto {
		edges = append(edges, lottogetcountrecord.EdgeLotto)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LottoGetCountRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case lottogetcountrecord.EdgeUser:
		return m.cleareduser
	case lottogetcountrecord.EdgeLotto:
		return m.clearedlotto
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LottoGetCountRecordMutation) ClearEdge(name string) error {
	switch name {
	case lottogetcountrecord.EdgeUser:
		m.ClearUser()
		return nil
	case lottogetcountrecord.EdgeLotto:
		m.ClearLotto()
		return nil
	}
	return fmt.Errorf("unknown LottoGetCountRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LottoGetCountRecordMutation) ResetEdge(name string) error {
	switch name {
	case lottogetcountrecord.EdgeUser:
		m.ResetUser()
		return nil
	case lottogetcountrecord.EdgeLotto:
		m.ResetLotto()
		return nil
	}
	return fmt.Errorf("unknown LottoGetCountRecord edge %s", name)
}

// LottoPrizeMutation represents an operation that mutates the LottoPrize nodes in the graph.
type LottoPrizeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_by           *int64
	addcreated_by        *int64
	updated_by           *int64
	addupdated_by        *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	level_name           *string
	weight               *int64
	addweight            *int64
	name                 *string
	status               *lottoprize.Status
	_type                *lottoprize.Type
	cep_amount           *int64
	addcep_amount        *int64
	clearedFields        map[string]struct{}
	lotto                *int64
	clearedlotto         bool
	lotto_records        map[int64]struct{}
	removedlotto_records map[int64]struct{}
	clearedlotto_records bool
	done                 bool
	oldValue             func(context.Context) (*LottoPrize, error)
	predicates           []predicate.LottoPrize
}

var _ ent.Mutation = (*LottoPrizeMutation)(nil)

// lottoprizeOption allows management of the mutation configuration using functional options.
type lottoprizeOption func(*LottoPrizeMutation)

// newLottoPrizeMutation creates new mutation for the LottoPrize entity.
func newLottoPrizeMutation(c config, op Op, opts ...lottoprizeOption) *LottoPrizeMutation {
	m := &LottoPrizeMutation{
		config:        c,
		op:            op,
		typ:           TypeLottoPrize,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLottoPrizeID sets the ID field of the mutation.
func withLottoPrizeID(id int64) lottoprizeOption {
	return func(m *LottoPrizeMutation) {
		var (
			err   error
			once  sync.Once
			value *LottoPrize
		)
		m.oldValue = func(ctx context.Context) (*LottoPrize, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LottoPrize.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLottoPrize sets the old LottoPrize of the mutation.
func withLottoPrize(node *LottoPrize) lottoprizeOption {
	return func(m *LottoPrizeMutation) {
		m.oldValue = func(context.Context) (*LottoPrize, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LottoPrizeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LottoPrizeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LottoPrize entities.
func (m *LottoPrizeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LottoPrizeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LottoPrizeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LottoPrize.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *LottoPrizeMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LottoPrizeMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *LottoPrizeMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LottoPrizeMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LottoPrizeMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LottoPrizeMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LottoPrizeMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *LottoPrizeMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LottoPrizeMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LottoPrizeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LottoPrizeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LottoPrizeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LottoPrizeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LottoPrizeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LottoPrizeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LottoPrizeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LottoPrizeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LottoPrizeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LottoPrizeMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetLottoID sets the "lotto_id" field.
func (m *LottoPrizeMutation) SetLottoID(i int64) {
	m.lotto = &i
}

// LottoID returns the value of the "lotto_id" field in the mutation.
func (m *LottoPrizeMutation) LottoID() (r int64, exists bool) {
	v := m.lotto
	if v == nil {
		return
	}
	return *v, true
}

// OldLottoID returns the old "lotto_id" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldLottoID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLottoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLottoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLottoID: %w", err)
	}
	return oldValue.LottoID, nil
}

// ResetLottoID resets all changes to the "lotto_id" field.
func (m *LottoPrizeMutation) ResetLottoID() {
	m.lotto = nil
}

// SetLevelName sets the "level_name" field.
func (m *LottoPrizeMutation) SetLevelName(s string) {
	m.level_name = &s
}

// LevelName returns the value of the "level_name" field in the mutation.
func (m *LottoPrizeMutation) LevelName() (r string, exists bool) {
	v := m.level_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelName returns the old "level_name" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldLevelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelName: %w", err)
	}
	return oldValue.LevelName, nil
}

// ResetLevelName resets all changes to the "level_name" field.
func (m *LottoPrizeMutation) ResetLevelName() {
	m.level_name = nil
}

// SetWeight sets the "weight" field.
func (m *LottoPrizeMutation) SetWeight(i int64) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *LottoPrizeMutation) Weight() (r int64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldWeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *LottoPrizeMutation) AddWeight(i int64) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *LottoPrizeMutation) AddedWeight() (r int64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *LottoPrizeMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetName sets the "name" field.
func (m *LottoPrizeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LottoPrizeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LottoPrizeMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *LottoPrizeMutation) SetStatus(l lottoprize.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LottoPrizeMutation) Status() (r lottoprize.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldStatus(ctx context.Context) (v lottoprize.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LottoPrizeMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *LottoPrizeMutation) SetType(l lottoprize.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LottoPrizeMutation) GetType() (r lottoprize.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldType(ctx context.Context) (v lottoprize.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LottoPrizeMutation) ResetType() {
	m._type = nil
}

// SetCepAmount sets the "cep_amount" field.
func (m *LottoPrizeMutation) SetCepAmount(i int64) {
	m.cep_amount = &i
	m.addcep_amount = nil
}

// CepAmount returns the value of the "cep_amount" field in the mutation.
func (m *LottoPrizeMutation) CepAmount() (r int64, exists bool) {
	v := m.cep_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCepAmount returns the old "cep_amount" field's value of the LottoPrize entity.
// If the LottoPrize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoPrizeMutation) OldCepAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCepAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCepAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCepAmount: %w", err)
	}
	return oldValue.CepAmount, nil
}

// AddCepAmount adds i to the "cep_amount" field.
func (m *LottoPrizeMutation) AddCepAmount(i int64) {
	if m.addcep_amount != nil {
		*m.addcep_amount += i
	} else {
		m.addcep_amount = &i
	}
}

// AddedCepAmount returns the value that was added to the "cep_amount" field in this mutation.
func (m *LottoPrizeMutation) AddedCepAmount() (r int64, exists bool) {
	v := m.addcep_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCepAmount resets all changes to the "cep_amount" field.
func (m *LottoPrizeMutation) ResetCepAmount() {
	m.cep_amount = nil
	m.addcep_amount = nil
}

// ClearLotto clears the "lotto" edge to the Lotto entity.
func (m *LottoPrizeMutation) ClearLotto() {
	m.clearedlotto = true
	m.clearedFields[lottoprize.FieldLottoID] = struct{}{}
}

// LottoCleared reports if the "lotto" edge to the Lotto entity was cleared.
func (m *LottoPrizeMutation) LottoCleared() bool {
	return m.clearedlotto
}

// LottoIDs returns the "lotto" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LottoID instead. It exists only for internal usage by the builders.
func (m *LottoPrizeMutation) LottoIDs() (ids []int64) {
	if id := m.lotto; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLotto resets all changes to the "lotto" edge.
func (m *LottoPrizeMutation) ResetLotto() {
	m.lotto = nil
	m.clearedlotto = false
}

// AddLottoRecordIDs adds the "lotto_records" edge to the LottoRecord entity by ids.
func (m *LottoPrizeMutation) AddLottoRecordIDs(ids ...int64) {
	if m.lotto_records == nil {
		m.lotto_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.lotto_records[ids[i]] = struct{}{}
	}
}

// ClearLottoRecords clears the "lotto_records" edge to the LottoRecord entity.
func (m *LottoPrizeMutation) ClearLottoRecords() {
	m.clearedlotto_records = true
}

// LottoRecordsCleared reports if the "lotto_records" edge to the LottoRecord entity was cleared.
func (m *LottoPrizeMutation) LottoRecordsCleared() bool {
	return m.clearedlotto_records
}

// RemoveLottoRecordIDs removes the "lotto_records" edge to the LottoRecord entity by IDs.
func (m *LottoPrizeMutation) RemoveLottoRecordIDs(ids ...int64) {
	if m.removedlotto_records == nil {
		m.removedlotto_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lotto_records, ids[i])
		m.removedlotto_records[ids[i]] = struct{}{}
	}
}

// RemovedLottoRecords returns the removed IDs of the "lotto_records" edge to the LottoRecord entity.
func (m *LottoPrizeMutation) RemovedLottoRecordsIDs() (ids []int64) {
	for id := range m.removedlotto_records {
		ids = append(ids, id)
	}
	return
}

// LottoRecordsIDs returns the "lotto_records" edge IDs in the mutation.
func (m *LottoPrizeMutation) LottoRecordsIDs() (ids []int64) {
	for id := range m.lotto_records {
		ids = append(ids, id)
	}
	return
}

// ResetLottoRecords resets all changes to the "lotto_records" edge.
func (m *LottoPrizeMutation) ResetLottoRecords() {
	m.lotto_records = nil
	m.clearedlotto_records = false
	m.removedlotto_records = nil
}

// Where appends a list predicates to the LottoPrizeMutation builder.
func (m *LottoPrizeMutation) Where(ps ...predicate.LottoPrize) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LottoPrizeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LottoPrizeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LottoPrize, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LottoPrizeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LottoPrizeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LottoPrize).
func (m *LottoPrizeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LottoPrizeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, lottoprize.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, lottoprize.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, lottoprize.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lottoprize.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, lottoprize.FieldDeletedAt)
	}
	if m.lotto != nil {
		fields = append(fields, lottoprize.FieldLottoID)
	}
	if m.level_name != nil {
		fields = append(fields, lottoprize.FieldLevelName)
	}
	if m.weight != nil {
		fields = append(fields, lottoprize.FieldWeight)
	}
	if m.name != nil {
		fields = append(fields, lottoprize.FieldName)
	}
	if m.status != nil {
		fields = append(fields, lottoprize.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, lottoprize.FieldType)
	}
	if m.cep_amount != nil {
		fields = append(fields, lottoprize.FieldCepAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LottoPrizeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lottoprize.FieldCreatedBy:
		return m.CreatedBy()
	case lottoprize.FieldUpdatedBy:
		return m.UpdatedBy()
	case lottoprize.FieldCreatedAt:
		return m.CreatedAt()
	case lottoprize.FieldUpdatedAt:
		return m.UpdatedAt()
	case lottoprize.FieldDeletedAt:
		return m.DeletedAt()
	case lottoprize.FieldLottoID:
		return m.LottoID()
	case lottoprize.FieldLevelName:
		return m.LevelName()
	case lottoprize.FieldWeight:
		return m.Weight()
	case lottoprize.FieldName:
		return m.Name()
	case lottoprize.FieldStatus:
		return m.Status()
	case lottoprize.FieldType:
		return m.GetType()
	case lottoprize.FieldCepAmount:
		return m.CepAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LottoPrizeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lottoprize.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case lottoprize.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case lottoprize.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lottoprize.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lottoprize.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case lottoprize.FieldLottoID:
		return m.OldLottoID(ctx)
	case lottoprize.FieldLevelName:
		return m.OldLevelName(ctx)
	case lottoprize.FieldWeight:
		return m.OldWeight(ctx)
	case lottoprize.FieldName:
		return m.OldName(ctx)
	case lottoprize.FieldStatus:
		return m.OldStatus(ctx)
	case lottoprize.FieldType:
		return m.OldType(ctx)
	case lottoprize.FieldCepAmount:
		return m.OldCepAmount(ctx)
	}
	return nil, fmt.Errorf("unknown LottoPrize field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoPrizeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lottoprize.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case lottoprize.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case lottoprize.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lottoprize.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lottoprize.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case lottoprize.FieldLottoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLottoID(v)
		return nil
	case lottoprize.FieldLevelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelName(v)
		return nil
	case lottoprize.FieldWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case lottoprize.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case lottoprize.FieldStatus:
		v, ok := value.(lottoprize.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case lottoprize.FieldType:
		v, ok := value.(lottoprize.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case lottoprize.FieldCepAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCepAmount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoPrize field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LottoPrizeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, lottoprize.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, lottoprize.FieldUpdatedBy)
	}
	if m.addweight != nil {
		fields = append(fields, lottoprize.FieldWeight)
	}
	if m.addcep_amount != nil {
		fields = append(fields, lottoprize.FieldCepAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LottoPrizeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lottoprize.FieldCreatedBy:
		return m.AddedCreatedBy()
	case lottoprize.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case lottoprize.FieldWeight:
		return m.AddedWeight()
	case lottoprize.FieldCepAmount:
		return m.AddedCepAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoPrizeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lottoprize.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case lottoprize.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case lottoprize.FieldWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case lottoprize.FieldCepAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCepAmount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoPrize numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LottoPrizeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LottoPrizeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LottoPrizeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LottoPrize nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LottoPrizeMutation) ResetField(name string) error {
	switch name {
	case lottoprize.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case lottoprize.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case lottoprize.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lottoprize.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lottoprize.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case lottoprize.FieldLottoID:
		m.ResetLottoID()
		return nil
	case lottoprize.FieldLevelName:
		m.ResetLevelName()
		return nil
	case lottoprize.FieldWeight:
		m.ResetWeight()
		return nil
	case lottoprize.FieldName:
		m.ResetName()
		return nil
	case lottoprize.FieldStatus:
		m.ResetStatus()
		return nil
	case lottoprize.FieldType:
		m.ResetType()
		return nil
	case lottoprize.FieldCepAmount:
		m.ResetCepAmount()
		return nil
	}
	return fmt.Errorf("unknown LottoPrize field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LottoPrizeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lotto != nil {
		edges = append(edges, lottoprize.EdgeLotto)
	}
	if m.lotto_records != nil {
		edges = append(edges, lottoprize.EdgeLottoRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LottoPrizeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lottoprize.EdgeLotto:
		if id := m.lotto; id != nil {
			return []ent.Value{*id}
		}
	case lottoprize.EdgeLottoRecords:
		ids := make([]ent.Value, 0, len(m.lotto_records))
		for id := range m.lotto_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LottoPrizeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlotto_records != nil {
		edges = append(edges, lottoprize.EdgeLottoRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LottoPrizeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lottoprize.EdgeLottoRecords:
		ids := make([]ent.Value, 0, len(m.removedlotto_records))
		for id := range m.removedlotto_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LottoPrizeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlotto {
		edges = append(edges, lottoprize.EdgeLotto)
	}
	if m.clearedlotto_records {
		edges = append(edges, lottoprize.EdgeLottoRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LottoPrizeMutation) EdgeCleared(name string) bool {
	switch name {
	case lottoprize.EdgeLotto:
		return m.clearedlotto
	case lottoprize.EdgeLottoRecords:
		return m.clearedlotto_records
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LottoPrizeMutation) ClearEdge(name string) error {
	switch name {
	case lottoprize.EdgeLotto:
		m.ClearLotto()
		return nil
	}
	return fmt.Errorf("unknown LottoPrize unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LottoPrizeMutation) ResetEdge(name string) error {
	switch name {
	case lottoprize.EdgeLotto:
		m.ResetLotto()
		return nil
	case lottoprize.EdgeLottoRecords:
		m.ResetLottoRecords()
		return nil
	}
	return fmt.Errorf("unknown LottoPrize edge %s", name)
}

// LottoRecordMutation represents an operation that mutates the LottoRecord nodes in the graph.
type LottoRecordMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	result                *lottorecord.Result
	status                *lottorecord.Status
	remain_lotto_count    *int64
	addremain_lotto_count *int64
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	lotto                 *int64
	clearedlotto          bool
	lotto_prize           *int64
	clearedlotto_prize    bool
	done                  bool
	oldValue              func(context.Context) (*LottoRecord, error)
	predicates            []predicate.LottoRecord
}

var _ ent.Mutation = (*LottoRecordMutation)(nil)

// lottorecordOption allows management of the mutation configuration using functional options.
type lottorecordOption func(*LottoRecordMutation)

// newLottoRecordMutation creates new mutation for the LottoRecord entity.
func newLottoRecordMutation(c config, op Op, opts ...lottorecordOption) *LottoRecordMutation {
	m := &LottoRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeLottoRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLottoRecordID sets the ID field of the mutation.
func withLottoRecordID(id int64) lottorecordOption {
	return func(m *LottoRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *LottoRecord
		)
		m.oldValue = func(ctx context.Context) (*LottoRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LottoRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLottoRecord sets the old LottoRecord of the mutation.
func withLottoRecord(node *LottoRecord) lottorecordOption {
	return func(m *LottoRecordMutation) {
		m.oldValue = func(context.Context) (*LottoRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LottoRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LottoRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LottoRecord entities.
func (m *LottoRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LottoRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LottoRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LottoRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *LottoRecordMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LottoRecordMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *LottoRecordMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LottoRecordMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LottoRecordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LottoRecordMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LottoRecordMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *LottoRecordMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LottoRecordMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LottoRecordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LottoRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LottoRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LottoRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LottoRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LottoRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LottoRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LottoRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LottoRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LottoRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *LottoRecordMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LottoRecordMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LottoRecordMutation) ResetUserID() {
	m.user = nil
}

// SetLottoID sets the "lotto_id" field.
func (m *LottoRecordMutation) SetLottoID(i int64) {
	m.lotto = &i
}

// LottoID returns the value of the "lotto_id" field in the mutation.
func (m *LottoRecordMutation) LottoID() (r int64, exists bool) {
	v := m.lotto
	if v == nil {
		return
	}
	return *v, true
}

// OldLottoID returns the old "lotto_id" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldLottoID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLottoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLottoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLottoID: %w", err)
	}
	return oldValue.LottoID, nil
}

// ResetLottoID resets all changes to the "lotto_id" field.
func (m *LottoRecordMutation) ResetLottoID() {
	m.lotto = nil
}

// SetResult sets the "result" field.
func (m *LottoRecordMutation) SetResult(l lottorecord.Result) {
	m.result = &l
}

// Result returns the value of the "result" field in the mutation.
func (m *LottoRecordMutation) Result() (r lottorecord.Result, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldResult(ctx context.Context) (v lottorecord.Result, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *LottoRecordMutation) ResetResult() {
	m.result = nil
}

// SetLottoPrizeID sets the "lotto_prize_id" field.
func (m *LottoRecordMutation) SetLottoPrizeID(i int64) {
	m.lotto_prize = &i
}

// LottoPrizeID returns the value of the "lotto_prize_id" field in the mutation.
func (m *LottoRecordMutation) LottoPrizeID() (r int64, exists bool) {
	v := m.lotto_prize
	if v == nil {
		return
	}
	return *v, true
}

// OldLottoPrizeID returns the old "lotto_prize_id" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldLottoPrizeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLottoPrizeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLottoPrizeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLottoPrizeID: %w", err)
	}
	return oldValue.LottoPrizeID, nil
}

// ResetLottoPrizeID resets all changes to the "lotto_prize_id" field.
func (m *LottoRecordMutation) ResetLottoPrizeID() {
	m.lotto_prize = nil
}

// SetStatus sets the "status" field.
func (m *LottoRecordMutation) SetStatus(l lottorecord.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LottoRecordMutation) Status() (r lottorecord.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldStatus(ctx context.Context) (v lottorecord.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LottoRecordMutation) ResetStatus() {
	m.status = nil
}

// SetRemainLottoCount sets the "remain_lotto_count" field.
func (m *LottoRecordMutation) SetRemainLottoCount(i int64) {
	m.remain_lotto_count = &i
	m.addremain_lotto_count = nil
}

// RemainLottoCount returns the value of the "remain_lotto_count" field in the mutation.
func (m *LottoRecordMutation) RemainLottoCount() (r int64, exists bool) {
	v := m.remain_lotto_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainLottoCount returns the old "remain_lotto_count" field's value of the LottoRecord entity.
// If the LottoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoRecordMutation) OldRemainLottoCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainLottoCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainLottoCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainLottoCount: %w", err)
	}
	return oldValue.RemainLottoCount, nil
}

// AddRemainLottoCount adds i to the "remain_lotto_count" field.
func (m *LottoRecordMutation) AddRemainLottoCount(i int64) {
	if m.addremain_lotto_count != nil {
		*m.addremain_lotto_count += i
	} else {
		m.addremain_lotto_count = &i
	}
}

// AddedRemainLottoCount returns the value that was added to the "remain_lotto_count" field in this mutation.
func (m *LottoRecordMutation) AddedRemainLottoCount() (r int64, exists bool) {
	v := m.addremain_lotto_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainLottoCount resets all changes to the "remain_lotto_count" field.
func (m *LottoRecordMutation) ResetRemainLottoCount() {
	m.remain_lotto_count = nil
	m.addremain_lotto_count = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *LottoRecordMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[lottorecord.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LottoRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LottoRecordMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LottoRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearLotto clears the "lotto" edge to the Lotto entity.
func (m *LottoRecordMutation) ClearLotto() {
	m.clearedlotto = true
	m.clearedFields[lottorecord.FieldLottoID] = struct{}{}
}

// LottoCleared reports if the "lotto" edge to the Lotto entity was cleared.
func (m *LottoRecordMutation) LottoCleared() bool {
	return m.clearedlotto
}

// LottoIDs returns the "lotto" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LottoID instead. It exists only for internal usage by the builders.
func (m *LottoRecordMutation) LottoIDs() (ids []int64) {
	if id := m.lotto; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLotto resets all changes to the "lotto" edge.
func (m *LottoRecordMutation) ResetLotto() {
	m.lotto = nil
	m.clearedlotto = false
}

// ClearLottoPrize clears the "lotto_prize" edge to the LottoPrize entity.
func (m *LottoRecordMutation) ClearLottoPrize() {
	m.clearedlotto_prize = true
	m.clearedFields[lottorecord.FieldLottoPrizeID] = struct{}{}
}

// LottoPrizeCleared reports if the "lotto_prize" edge to the LottoPrize entity was cleared.
func (m *LottoRecordMutation) LottoPrizeCleared() bool {
	return m.clearedlotto_prize
}

// LottoPrizeIDs returns the "lotto_prize" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LottoPrizeID instead. It exists only for internal usage by the builders.
func (m *LottoRecordMutation) LottoPrizeIDs() (ids []int64) {
	if id := m.lotto_prize; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLottoPrize resets all changes to the "lotto_prize" edge.
func (m *LottoRecordMutation) ResetLottoPrize() {
	m.lotto_prize = nil
	m.clearedlotto_prize = false
}

// Where appends a list predicates to the LottoRecordMutation builder.
func (m *LottoRecordMutation) Where(ps ...predicate.LottoRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LottoRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LottoRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LottoRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LottoRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LottoRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LottoRecord).
func (m *LottoRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LottoRecordMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, lottorecord.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, lottorecord.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, lottorecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lottorecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, lottorecord.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, lottorecord.FieldUserID)
	}
	if m.lotto != nil {
		fields = append(fields, lottorecord.FieldLottoID)
	}
	if m.result != nil {
		fields = append(fields, lottorecord.FieldResult)
	}
	if m.lotto_prize != nil {
		fields = append(fields, lottorecord.FieldLottoPrizeID)
	}
	if m.status != nil {
		fields = append(fields, lottorecord.FieldStatus)
	}
	if m.remain_lotto_count != nil {
		fields = append(fields, lottorecord.FieldRemainLottoCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LottoRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lottorecord.FieldCreatedBy:
		return m.CreatedBy()
	case lottorecord.FieldUpdatedBy:
		return m.UpdatedBy()
	case lottorecord.FieldCreatedAt:
		return m.CreatedAt()
	case lottorecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case lottorecord.FieldDeletedAt:
		return m.DeletedAt()
	case lottorecord.FieldUserID:
		return m.UserID()
	case lottorecord.FieldLottoID:
		return m.LottoID()
	case lottorecord.FieldResult:
		return m.Result()
	case lottorecord.FieldLottoPrizeID:
		return m.LottoPrizeID()
	case lottorecord.FieldStatus:
		return m.Status()
	case lottorecord.FieldRemainLottoCount:
		return m.RemainLottoCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LottoRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lottorecord.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case lottorecord.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case lottorecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lottorecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lottorecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case lottorecord.FieldUserID:
		return m.OldUserID(ctx)
	case lottorecord.FieldLottoID:
		return m.OldLottoID(ctx)
	case lottorecord.FieldResult:
		return m.OldResult(ctx)
	case lottorecord.FieldLottoPrizeID:
		return m.OldLottoPrizeID(ctx)
	case lottorecord.FieldStatus:
		return m.OldStatus(ctx)
	case lottorecord.FieldRemainLottoCount:
		return m.OldRemainLottoCount(ctx)
	}
	return nil, fmt.Errorf("unknown LottoRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lottorecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case lottorecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case lottorecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lottorecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lottorecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case lottorecord.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case lottorecord.FieldLottoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLottoID(v)
		return nil
	case lottorecord.FieldResult:
		v, ok := value.(lottorecord.Result)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case lottorecord.FieldLottoPrizeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLottoPrizeID(v)
		return nil
	case lottorecord.FieldStatus:
		v, ok := value.(lottorecord.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case lottorecord.FieldRemainLottoCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainLottoCount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LottoRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, lottorecord.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, lottorecord.FieldUpdatedBy)
	}
	if m.addremain_lotto_count != nil {
		fields = append(fields, lottorecord.FieldRemainLottoCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LottoRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lottorecord.FieldCreatedBy:
		return m.AddedCreatedBy()
	case lottorecord.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case lottorecord.FieldRemainLottoCount:
		return m.AddedRemainLottoCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lottorecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case lottorecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case lottorecord.FieldRemainLottoCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainLottoCount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LottoRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LottoRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LottoRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LottoRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LottoRecordMutation) ResetField(name string) error {
	switch name {
	case lottorecord.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case lottorecord.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case lottorecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lottorecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lottorecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case lottorecord.FieldUserID:
		m.ResetUserID()
		return nil
	case lottorecord.FieldLottoID:
		m.ResetLottoID()
		return nil
	case lottorecord.FieldResult:
		m.ResetResult()
		return nil
	case lottorecord.FieldLottoPrizeID:
		m.ResetLottoPrizeID()
		return nil
	case lottorecord.FieldStatus:
		m.ResetStatus()
		return nil
	case lottorecord.FieldRemainLottoCount:
		m.ResetRemainLottoCount()
		return nil
	}
	return fmt.Errorf("unknown LottoRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LottoRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, lottorecord.EdgeUser)
	}
	if m.lotto != nil {
		edges = append(edges, lottorecord.EdgeLotto)
	}
	if m.lotto_prize != nil {
		edges = append(edges, lottorecord.EdgeLottoPrize)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LottoRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lottorecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case lottorecord.EdgeLotto:
		if id := m.lotto; id != nil {
			return []ent.Value{*id}
		}
	case lottorecord.EdgeLottoPrize:
		if id := m.lotto_prize; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LottoRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LottoRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LottoRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, lottorecord.EdgeUser)
	}
	if m.clearedlotto {
		edges = append(edges, lottorecord.EdgeLotto)
	}
	if m.clearedlotto_prize {
		edges = append(edges, lottorecord.EdgeLottoPrize)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LottoRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case lottorecord.EdgeUser:
		return m.cleareduser
	case lottorecord.EdgeLotto:
		return m.clearedlotto
	case lottorecord.EdgeLottoPrize:
		return m.clearedlotto_prize
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LottoRecordMutation) ClearEdge(name string) error {
	switch name {
	case lottorecord.EdgeUser:
		m.ClearUser()
		return nil
	case lottorecord.EdgeLotto:
		m.ClearLotto()
		return nil
	case lottorecord.EdgeLottoPrize:
		m.ClearLottoPrize()
		return nil
	}
	return fmt.Errorf("unknown LottoRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LottoRecordMutation) ResetEdge(name string) error {
	switch name {
	case lottorecord.EdgeUser:
		m.ResetUser()
		return nil
	case lottorecord.EdgeLotto:
		m.ResetLotto()
		return nil
	case lottorecord.EdgeLottoPrize:
		m.ResetLottoPrize()
		return nil
	}
	return fmt.Errorf("unknown LottoRecord edge %s", name)
}

// LottoUserCountMutation represents an operation that mutates the LottoUserCount nodes in the graph.
type LottoUserCountMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	remain_lotto_count    *int64
	addremain_lotto_count *int64
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	lotto                 *int64
	clearedlotto          bool
	done                  bool
	oldValue              func(context.Context) (*LottoUserCount, error)
	predicates            []predicate.LottoUserCount
}

var _ ent.Mutation = (*LottoUserCountMutation)(nil)

// lottousercountOption allows management of the mutation configuration using functional options.
type lottousercountOption func(*LottoUserCountMutation)

// newLottoUserCountMutation creates new mutation for the LottoUserCount entity.
func newLottoUserCountMutation(c config, op Op, opts ...lottousercountOption) *LottoUserCountMutation {
	m := &LottoUserCountMutation{
		config:        c,
		op:            op,
		typ:           TypeLottoUserCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLottoUserCountID sets the ID field of the mutation.
func withLottoUserCountID(id int64) lottousercountOption {
	return func(m *LottoUserCountMutation) {
		var (
			err   error
			once  sync.Once
			value *LottoUserCount
		)
		m.oldValue = func(ctx context.Context) (*LottoUserCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LottoUserCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLottoUserCount sets the old LottoUserCount of the mutation.
func withLottoUserCount(node *LottoUserCount) lottousercountOption {
	return func(m *LottoUserCountMutation) {
		m.oldValue = func(context.Context) (*LottoUserCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LottoUserCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LottoUserCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LottoUserCount entities.
func (m *LottoUserCountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LottoUserCountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LottoUserCountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LottoUserCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *LottoUserCountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LottoUserCountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LottoUserCount entity.
// If the LottoUserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoUserCountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *LottoUserCountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LottoUserCountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LottoUserCountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LottoUserCountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LottoUserCountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LottoUserCount entity.
// If the LottoUserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoUserCountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *LottoUserCountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LottoUserCountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LottoUserCountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LottoUserCountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LottoUserCountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LottoUserCount entity.
// If the LottoUserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoUserCountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LottoUserCountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LottoUserCountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LottoUserCountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LottoUserCount entity.
// If the LottoUserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoUserCountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LottoUserCountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LottoUserCountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LottoUserCountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LottoUserCount entity.
// If the LottoUserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoUserCountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LottoUserCountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *LottoUserCountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LottoUserCountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LottoUserCount entity.
// If the LottoUserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoUserCountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LottoUserCountMutation) ResetUserID() {
	m.user = nil
}

// SetLottoID sets the "lotto_id" field.
func (m *LottoUserCountMutation) SetLottoID(i int64) {
	m.lotto = &i
}

// LottoID returns the value of the "lotto_id" field in the mutation.
func (m *LottoUserCountMutation) LottoID() (r int64, exists bool) {
	v := m.lotto
	if v == nil {
		return
	}
	return *v, true
}

// OldLottoID returns the old "lotto_id" field's value of the LottoUserCount entity.
// If the LottoUserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoUserCountMutation) OldLottoID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLottoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLottoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLottoID: %w", err)
	}
	return oldValue.LottoID, nil
}

// ResetLottoID resets all changes to the "lotto_id" field.
func (m *LottoUserCountMutation) ResetLottoID() {
	m.lotto = nil
}

// SetRemainLottoCount sets the "remain_lotto_count" field.
func (m *LottoUserCountMutation) SetRemainLottoCount(i int64) {
	m.remain_lotto_count = &i
	m.addremain_lotto_count = nil
}

// RemainLottoCount returns the value of the "remain_lotto_count" field in the mutation.
func (m *LottoUserCountMutation) RemainLottoCount() (r int64, exists bool) {
	v := m.remain_lotto_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainLottoCount returns the old "remain_lotto_count" field's value of the LottoUserCount entity.
// If the LottoUserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LottoUserCountMutation) OldRemainLottoCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainLottoCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainLottoCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainLottoCount: %w", err)
	}
	return oldValue.RemainLottoCount, nil
}

// AddRemainLottoCount adds i to the "remain_lotto_count" field.
func (m *LottoUserCountMutation) AddRemainLottoCount(i int64) {
	if m.addremain_lotto_count != nil {
		*m.addremain_lotto_count += i
	} else {
		m.addremain_lotto_count = &i
	}
}

// AddedRemainLottoCount returns the value that was added to the "remain_lotto_count" field in this mutation.
func (m *LottoUserCountMutation) AddedRemainLottoCount() (r int64, exists bool) {
	v := m.addremain_lotto_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainLottoCount resets all changes to the "remain_lotto_count" field.
func (m *LottoUserCountMutation) ResetRemainLottoCount() {
	m.remain_lotto_count = nil
	m.addremain_lotto_count = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *LottoUserCountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[lottousercount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LottoUserCountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LottoUserCountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LottoUserCountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearLotto clears the "lotto" edge to the Lotto entity.
func (m *LottoUserCountMutation) ClearLotto() {
	m.clearedlotto = true
	m.clearedFields[lottousercount.FieldLottoID] = struct{}{}
}

// LottoCleared reports if the "lotto" edge to the Lotto entity was cleared.
func (m *LottoUserCountMutation) LottoCleared() bool {
	return m.clearedlotto
}

// LottoIDs returns the "lotto" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LottoID instead. It exists only for internal usage by the builders.
func (m *LottoUserCountMutation) LottoIDs() (ids []int64) {
	if id := m.lotto; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLotto resets all changes to the "lotto" edge.
func (m *LottoUserCountMutation) ResetLotto() {
	m.lotto = nil
	m.clearedlotto = false
}

// Where appends a list predicates to the LottoUserCountMutation builder.
func (m *LottoUserCountMutation) Where(ps ...predicate.LottoUserCount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LottoUserCountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LottoUserCountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LottoUserCount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LottoUserCountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LottoUserCountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LottoUserCount).
func (m *LottoUserCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LottoUserCountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, lottousercount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, lottousercount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, lottousercount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lottousercount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, lottousercount.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, lottousercount.FieldUserID)
	}
	if m.lotto != nil {
		fields = append(fields, lottousercount.FieldLottoID)
	}
	if m.remain_lotto_count != nil {
		fields = append(fields, lottousercount.FieldRemainLottoCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LottoUserCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lottousercount.FieldCreatedBy:
		return m.CreatedBy()
	case lottousercount.FieldUpdatedBy:
		return m.UpdatedBy()
	case lottousercount.FieldCreatedAt:
		return m.CreatedAt()
	case lottousercount.FieldUpdatedAt:
		return m.UpdatedAt()
	case lottousercount.FieldDeletedAt:
		return m.DeletedAt()
	case lottousercount.FieldUserID:
		return m.UserID()
	case lottousercount.FieldLottoID:
		return m.LottoID()
	case lottousercount.FieldRemainLottoCount:
		return m.RemainLottoCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LottoUserCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lottousercount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case lottousercount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case lottousercount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lottousercount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lottousercount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case lottousercount.FieldUserID:
		return m.OldUserID(ctx)
	case lottousercount.FieldLottoID:
		return m.OldLottoID(ctx)
	case lottousercount.FieldRemainLottoCount:
		return m.OldRemainLottoCount(ctx)
	}
	return nil, fmt.Errorf("unknown LottoUserCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoUserCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lottousercount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case lottousercount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case lottousercount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lottousercount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lottousercount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case lottousercount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case lottousercount.FieldLottoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLottoID(v)
		return nil
	case lottousercount.FieldRemainLottoCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainLottoCount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoUserCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LottoUserCountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, lottousercount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, lottousercount.FieldUpdatedBy)
	}
	if m.addremain_lotto_count != nil {
		fields = append(fields, lottousercount.FieldRemainLottoCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LottoUserCountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lottousercount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case lottousercount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case lottousercount.FieldRemainLottoCount:
		return m.AddedRemainLottoCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LottoUserCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lottousercount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case lottousercount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case lottousercount.FieldRemainLottoCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainLottoCount(v)
		return nil
	}
	return fmt.Errorf("unknown LottoUserCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LottoUserCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LottoUserCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LottoUserCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LottoUserCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LottoUserCountMutation) ResetField(name string) error {
	switch name {
	case lottousercount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case lottousercount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case lottousercount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lottousercount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lottousercount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case lottousercount.FieldUserID:
		m.ResetUserID()
		return nil
	case lottousercount.FieldLottoID:
		m.ResetLottoID()
		return nil
	case lottousercount.FieldRemainLottoCount:
		m.ResetRemainLottoCount()
		return nil
	}
	return fmt.Errorf("unknown LottoUserCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LottoUserCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, lottousercount.EdgeUser)
	}
	if m.lotto != nil {
		edges = append(edges, lottousercount.EdgeLotto)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LottoUserCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lottousercount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case lottousercount.EdgeLotto:
		if id := m.lotto; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LottoUserCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LottoUserCountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LottoUserCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, lottousercount.EdgeUser)
	}
	if m.clearedlotto {
		edges = append(edges, lottousercount.EdgeLotto)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LottoUserCountMutation) EdgeCleared(name string) bool {
	switch name {
	case lottousercount.EdgeUser:
		return m.cleareduser
	case lottousercount.EdgeLotto:
		return m.clearedlotto
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LottoUserCountMutation) ClearEdge(name string) error {
	switch name {
	case lottousercount.EdgeUser:
		m.ClearUser()
		return nil
	case lottousercount.EdgeLotto:
		m.ClearLotto()
		return nil
	}
	return fmt.Errorf("unknown LottoUserCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LottoUserCountMutation) ResetEdge(name string) error {
	switch name {
	case lottousercount.EdgeUser:
		m.ResetUser()
		return nil
	case lottousercount.EdgeLotto:
		m.ResetLotto()
		return nil
	}
	return fmt.Errorf("unknown LottoUserCount edge %s", name)
}

// MissionMutation represents an operation that mutates the Mission nodes in the graph.
type MissionMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int64
	created_by                     *int64
	addcreated_by                  *int64
	updated_by                     *int64
	addupdated_by                  *int64
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	_type                          *enums.MissionType
	body                           *string
	call_back_url                  *string
	call_back_info                 *string
	call_back_data                 *[]byte
	status                         *enums.MissionStatus
	result                         *enums.MissionResult
	state                          *enums.MissionState
	result_urls                    *[]string
	appendresult_urls              []string
	urls                           *string
	mission_batch_number           *string
	gpu_version                    *enums.GpuVersion
	unit_cep                       *int64
	addunit_cep                    *int64
	resp_status_code               *int32
	addresp_status_code            *int32
	resp_body                      *string
	inner_uri                      *string
	inner_method                   *enums.InnerMethod
	temp_hmac_key                  *string
	temp_hmac_secret               *string
	second_hmac_key                *string
	username                       *string
	password                       *string
	white_device_ids               *[]string
	black_device_ids               *[]string
	started_at                     *time.Time
	finished_at                    *time.Time
	expired_at                     *time.Time
	free_at                        *time.Time
	close_way                      *enums.CloseWay
	closed_at                      *time.Time
	warning_times                  *int64
	addwarning_times               *int64
	remark                         *string
	use_auth                       *bool
	timed_shutdown                 *time.Time
	gpu_num                        *int
	addgpu_num                     *int
	clearedFields                  map[string]struct{}
	mission_kind                   *int64
	clearedmission_kind            bool
	user                           *int64
	cleareduser                    bool
	key_pair                       *int64
	clearedkey_pair                bool
	mission_batch                  *int64
	clearedmission_batch           bool
	old_mission                    *int64
	clearedold_mission             bool
	mission_key_pairs              map[int64]struct{}
	removedmission_key_pairs       map[int64]struct{}
	clearedmission_key_pairs       bool
	mission_consume_order          *int64
	clearedmission_consume_order   bool
	mission_produce_orders         map[int64]struct{}
	removedmission_produce_orders  map[int64]struct{}
	clearedmission_produce_orders  bool
	mission_productions            map[int64]struct{}
	removedmission_productions     map[int64]struct{}
	clearedmission_productions     bool
	mission_orders                 map[int64]struct{}
	removedmission_orders          map[int64]struct{}
	clearedmission_orders          bool
	renewal_agreements             map[int64]struct{}
	removedrenewal_agreements      map[int64]struct{}
	clearedrenewal_agreements      bool
	mission_extra_services         map[int64]struct{}
	removedmission_extra_services  map[int64]struct{}
	clearedmission_extra_services  bool
	extra_services                 map[int64]struct{}
	removedextra_services          map[int64]struct{}
	clearedextra_services          bool
	extra_service_orders           map[int64]struct{}
	removedextra_service_orders    map[int64]struct{}
	clearedextra_service_orders    bool
	reboot_missions                map[int64]struct{}
	removedreboot_missions         map[int64]struct{}
	clearedreboot_missions         bool
	mission_failed_feedback        *int64
	clearedmission_failed_feedback bool
	done                           bool
	oldValue                       func(context.Context) (*Mission, error)
	predicates                     []predicate.Mission
}

var _ ent.Mutation = (*MissionMutation)(nil)

// missionOption allows management of the mutation configuration using functional options.
type missionOption func(*MissionMutation)

// newMissionMutation creates new mutation for the Mission entity.
func newMissionMutation(c config, op Op, opts ...missionOption) *MissionMutation {
	m := &MissionMutation{
		config:        c,
		op:            op,
		typ:           TypeMission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionID sets the ID field of the mutation.
func withMissionID(id int64) missionOption {
	return func(m *MissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Mission
		)
		m.oldValue = func(ctx context.Context) (*Mission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMission sets the old Mission of the mutation.
func withMission(node *Mission) missionOption {
	return func(m *MissionMutation) {
		m.oldValue = func(context.Context) (*Mission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mission entities.
func (m *MissionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *MissionMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionMutation) ResetType() {
	m._type = nil
}

// SetMissionKindID sets the "mission_kind_id" field.
func (m *MissionMutation) SetMissionKindID(i int64) {
	m.mission_kind = &i
}

// MissionKindID returns the value of the "mission_kind_id" field in the mutation.
func (m *MissionMutation) MissionKindID() (r int64, exists bool) {
	v := m.mission_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionKindID returns the old "mission_kind_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldMissionKindID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionKindID: %w", err)
	}
	return oldValue.MissionKindID, nil
}

// ResetMissionKindID resets all changes to the "mission_kind_id" field.
func (m *MissionMutation) ResetMissionKindID() {
	m.mission_kind = nil
}

// SetBody sets the "body" field.
func (m *MissionMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *MissionMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *MissionMutation) ResetBody() {
	m.body = nil
}

// SetCallBackURL sets the "call_back_url" field.
func (m *MissionMutation) SetCallBackURL(s string) {
	m.call_back_url = &s
}

// CallBackURL returns the value of the "call_back_url" field in the mutation.
func (m *MissionMutation) CallBackURL() (r string, exists bool) {
	v := m.call_back_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCallBackURL returns the old "call_back_url" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCallBackURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallBackURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallBackURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallBackURL: %w", err)
	}
	return oldValue.CallBackURL, nil
}

// ResetCallBackURL resets all changes to the "call_back_url" field.
func (m *MissionMutation) ResetCallBackURL() {
	m.call_back_url = nil
}

// SetCallBackInfo sets the "call_back_info" field.
func (m *MissionMutation) SetCallBackInfo(s string) {
	m.call_back_info = &s
}

// CallBackInfo returns the value of the "call_back_info" field in the mutation.
func (m *MissionMutation) CallBackInfo() (r string, exists bool) {
	v := m.call_back_info
	if v == nil {
		return
	}
	return *v, true
}

// OldCallBackInfo returns the old "call_back_info" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCallBackInfo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallBackInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallBackInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallBackInfo: %w", err)
	}
	return oldValue.CallBackInfo, nil
}

// ClearCallBackInfo clears the value of the "call_back_info" field.
func (m *MissionMutation) ClearCallBackInfo() {
	m.call_back_info = nil
	m.clearedFields[mission.FieldCallBackInfo] = struct{}{}
}

// CallBackInfoCleared returns if the "call_back_info" field was cleared in this mutation.
func (m *MissionMutation) CallBackInfoCleared() bool {
	_, ok := m.clearedFields[mission.FieldCallBackInfo]
	return ok
}

// ResetCallBackInfo resets all changes to the "call_back_info" field.
func (m *MissionMutation) ResetCallBackInfo() {
	m.call_back_info = nil
	delete(m.clearedFields, mission.FieldCallBackInfo)
}

// SetCallBackData sets the "call_back_data" field.
func (m *MissionMutation) SetCallBackData(b []byte) {
	m.call_back_data = &b
}

// CallBackData returns the value of the "call_back_data" field in the mutation.
func (m *MissionMutation) CallBackData() (r []byte, exists bool) {
	v := m.call_back_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCallBackData returns the old "call_back_data" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCallBackData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallBackData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallBackData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallBackData: %w", err)
	}
	return oldValue.CallBackData, nil
}

// ClearCallBackData clears the value of the "call_back_data" field.
func (m *MissionMutation) ClearCallBackData() {
	m.call_back_data = nil
	m.clearedFields[mission.FieldCallBackData] = struct{}{}
}

// CallBackDataCleared returns if the "call_back_data" field was cleared in this mutation.
func (m *MissionMutation) CallBackDataCleared() bool {
	_, ok := m.clearedFields[mission.FieldCallBackData]
	return ok
}

// ResetCallBackData resets all changes to the "call_back_data" field.
func (m *MissionMutation) ResetCallBackData() {
	m.call_back_data = nil
	delete(m.clearedFields, mission.FieldCallBackData)
}

// SetStatus sets the "status" field.
func (m *MissionMutation) SetStatus(es enums.MissionStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionMutation) Status() (r enums.MissionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldStatus(ctx context.Context) (v enums.MissionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionMutation) ResetStatus() {
	m.status = nil
}

// SetResult sets the "result" field.
func (m *MissionMutation) SetResult(er enums.MissionResult) {
	m.result = &er
}

// Result returns the value of the "result" field in the mutation.
func (m *MissionMutation) Result() (r enums.MissionResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldResult(ctx context.Context) (v enums.MissionResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *MissionMutation) ResetResult() {
	m.result = nil
}

// SetState sets the "state" field.
func (m *MissionMutation) SetState(es enums.MissionState) {
	m.state = &es
}

// State returns the value of the "state" field in the mutation.
func (m *MissionMutation) State() (r enums.MissionState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldState(ctx context.Context) (v enums.MissionState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *MissionMutation) ResetState() {
	m.state = nil
}

// SetResultUrls sets the "result_urls" field.
func (m *MissionMutation) SetResultUrls(s []string) {
	m.result_urls = &s
	m.appendresult_urls = nil
}

// ResultUrls returns the value of the "result_urls" field in the mutation.
func (m *MissionMutation) ResultUrls() (r []string, exists bool) {
	v := m.result_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldResultUrls returns the old "result_urls" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldResultUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultUrls: %w", err)
	}
	return oldValue.ResultUrls, nil
}

// AppendResultUrls adds s to the "result_urls" field.
func (m *MissionMutation) AppendResultUrls(s []string) {
	m.appendresult_urls = append(m.appendresult_urls, s...)
}

// AppendedResultUrls returns the list of values that were appended to the "result_urls" field in this mutation.
func (m *MissionMutation) AppendedResultUrls() ([]string, bool) {
	if len(m.appendresult_urls) == 0 {
		return nil, false
	}
	return m.appendresult_urls, true
}

// ClearResultUrls clears the value of the "result_urls" field.
func (m *MissionMutation) ClearResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	m.clearedFields[mission.FieldResultUrls] = struct{}{}
}

// ResultUrlsCleared returns if the "result_urls" field was cleared in this mutation.
func (m *MissionMutation) ResultUrlsCleared() bool {
	_, ok := m.clearedFields[mission.FieldResultUrls]
	return ok
}

// ResetResultUrls resets all changes to the "result_urls" field.
func (m *MissionMutation) ResetResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	delete(m.clearedFields, mission.FieldResultUrls)
}

// SetUrls sets the "urls" field.
func (m *MissionMutation) SetUrls(s string) {
	m.urls = &s
}

// Urls returns the value of the "urls" field in the mutation.
func (m *MissionMutation) Urls() (r string, exists bool) {
	v := m.urls
	if v == nil {
		return
	}
	return *v, true
}

// OldUrls returns the old "urls" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUrls(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrls: %w", err)
	}
	return oldValue.Urls, nil
}

// ResetUrls resets all changes to the "urls" field.
func (m *MissionMutation) ResetUrls() {
	m.urls = nil
}

// SetKeyPairID sets the "key_pair_id" field.
func (m *MissionMutation) SetKeyPairID(i int64) {
	m.key_pair = &i
}

// KeyPairID returns the value of the "key_pair_id" field in the mutation.
func (m *MissionMutation) KeyPairID() (r int64, exists bool) {
	v := m.key_pair
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPairID returns the old "key_pair_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldKeyPairID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPairID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPairID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPairID: %w", err)
	}
	return oldValue.KeyPairID, nil
}

// ResetKeyPairID resets all changes to the "key_pair_id" field.
func (m *MissionMutation) ResetKeyPairID() {
	m.key_pair = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionMutation) ResetUserID() {
	m.user = nil
}

// SetMissionBatchID sets the "mission_batch_id" field.
func (m *MissionMutation) SetMissionBatchID(i int64) {
	m.mission_batch = &i
}

// MissionBatchID returns the value of the "mission_batch_id" field in the mutation.
func (m *MissionMutation) MissionBatchID() (r int64, exists bool) {
	v := m.mission_batch
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchID returns the old "mission_batch_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldMissionBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchID: %w", err)
	}
	return oldValue.MissionBatchID, nil
}

// ResetMissionBatchID resets all changes to the "mission_batch_id" field.
func (m *MissionMutation) ResetMissionBatchID() {
	m.mission_batch = nil
}

// SetMissionBatchNumber sets the "mission_batch_number" field.
func (m *MissionMutation) SetMissionBatchNumber(s string) {
	m.mission_batch_number = &s
}

// MissionBatchNumber returns the value of the "mission_batch_number" field in the mutation.
func (m *MissionMutation) MissionBatchNumber() (r string, exists bool) {
	v := m.mission_batch_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchNumber returns the old "mission_batch_number" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldMissionBatchNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchNumber: %w", err)
	}
	return oldValue.MissionBatchNumber, nil
}

// ResetMissionBatchNumber resets all changes to the "mission_batch_number" field.
func (m *MissionMutation) ResetMissionBatchNumber() {
	m.mission_batch_number = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *MissionMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *MissionMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *MissionMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetUnitCep sets the "unit_cep" field.
func (m *MissionMutation) SetUnitCep(i int64) {
	m.unit_cep = &i
	m.addunit_cep = nil
}

// UnitCep returns the value of the "unit_cep" field in the mutation.
func (m *MissionMutation) UnitCep() (r int64, exists bool) {
	v := m.unit_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCep returns the old "unit_cep" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUnitCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCep: %w", err)
	}
	return oldValue.UnitCep, nil
}

// AddUnitCep adds i to the "unit_cep" field.
func (m *MissionMutation) AddUnitCep(i int64) {
	if m.addunit_cep != nil {
		*m.addunit_cep += i
	} else {
		m.addunit_cep = &i
	}
}

// AddedUnitCep returns the value that was added to the "unit_cep" field in this mutation.
func (m *MissionMutation) AddedUnitCep() (r int64, exists bool) {
	v := m.addunit_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitCep resets all changes to the "unit_cep" field.
func (m *MissionMutation) ResetUnitCep() {
	m.unit_cep = nil
	m.addunit_cep = nil
}

// SetRespStatusCode sets the "resp_status_code" field.
func (m *MissionMutation) SetRespStatusCode(i int32) {
	m.resp_status_code = &i
	m.addresp_status_code = nil
}

// RespStatusCode returns the value of the "resp_status_code" field in the mutation.
func (m *MissionMutation) RespStatusCode() (r int32, exists bool) {
	v := m.resp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRespStatusCode returns the old "resp_status_code" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldRespStatusCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespStatusCode: %w", err)
	}
	return oldValue.RespStatusCode, nil
}

// AddRespStatusCode adds i to the "resp_status_code" field.
func (m *MissionMutation) AddRespStatusCode(i int32) {
	if m.addresp_status_code != nil {
		*m.addresp_status_code += i
	} else {
		m.addresp_status_code = &i
	}
}

// AddedRespStatusCode returns the value that was added to the "resp_status_code" field in this mutation.
func (m *MissionMutation) AddedRespStatusCode() (r int32, exists bool) {
	v := m.addresp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetRespStatusCode resets all changes to the "resp_status_code" field.
func (m *MissionMutation) ResetRespStatusCode() {
	m.resp_status_code = nil
	m.addresp_status_code = nil
}

// SetRespBody sets the "resp_body" field.
func (m *MissionMutation) SetRespBody(s string) {
	m.resp_body = &s
}

// RespBody returns the value of the "resp_body" field in the mutation.
func (m *MissionMutation) RespBody() (r string, exists bool) {
	v := m.resp_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRespBody returns the old "resp_body" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldRespBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespBody: %w", err)
	}
	return oldValue.RespBody, nil
}

// ResetRespBody resets all changes to the "resp_body" field.
func (m *MissionMutation) ResetRespBody() {
	m.resp_body = nil
}

// SetInnerURI sets the "inner_uri" field.
func (m *MissionMutation) SetInnerURI(s string) {
	m.inner_uri = &s
}

// InnerURI returns the value of the "inner_uri" field in the mutation.
func (m *MissionMutation) InnerURI() (r string, exists bool) {
	v := m.inner_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldInnerURI returns the old "inner_uri" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldInnerURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnerURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnerURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnerURI: %w", err)
	}
	return oldValue.InnerURI, nil
}

// ResetInnerURI resets all changes to the "inner_uri" field.
func (m *MissionMutation) ResetInnerURI() {
	m.inner_uri = nil
}

// SetInnerMethod sets the "inner_method" field.
func (m *MissionMutation) SetInnerMethod(em enums.InnerMethod) {
	m.inner_method = &em
}

// InnerMethod returns the value of the "inner_method" field in the mutation.
func (m *MissionMutation) InnerMethod() (r enums.InnerMethod, exists bool) {
	v := m.inner_method
	if v == nil {
		return
	}
	return *v, true
}

// OldInnerMethod returns the old "inner_method" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldInnerMethod(ctx context.Context) (v enums.InnerMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnerMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnerMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnerMethod: %w", err)
	}
	return oldValue.InnerMethod, nil
}

// ResetInnerMethod resets all changes to the "inner_method" field.
func (m *MissionMutation) ResetInnerMethod() {
	m.inner_method = nil
}

// SetTempHmacKey sets the "temp_hmac_key" field.
func (m *MissionMutation) SetTempHmacKey(s string) {
	m.temp_hmac_key = &s
}

// TempHmacKey returns the value of the "temp_hmac_key" field in the mutation.
func (m *MissionMutation) TempHmacKey() (r string, exists bool) {
	v := m.temp_hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTempHmacKey returns the old "temp_hmac_key" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldTempHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTempHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTempHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTempHmacKey: %w", err)
	}
	return oldValue.TempHmacKey, nil
}

// ResetTempHmacKey resets all changes to the "temp_hmac_key" field.
func (m *MissionMutation) ResetTempHmacKey() {
	m.temp_hmac_key = nil
}

// SetTempHmacSecret sets the "temp_hmac_secret" field.
func (m *MissionMutation) SetTempHmacSecret(s string) {
	m.temp_hmac_secret = &s
}

// TempHmacSecret returns the value of the "temp_hmac_secret" field in the mutation.
func (m *MissionMutation) TempHmacSecret() (r string, exists bool) {
	v := m.temp_hmac_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTempHmacSecret returns the old "temp_hmac_secret" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldTempHmacSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTempHmacSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTempHmacSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTempHmacSecret: %w", err)
	}
	return oldValue.TempHmacSecret, nil
}

// ResetTempHmacSecret resets all changes to the "temp_hmac_secret" field.
func (m *MissionMutation) ResetTempHmacSecret() {
	m.temp_hmac_secret = nil
}

// SetSecondHmacKey sets the "second_hmac_key" field.
func (m *MissionMutation) SetSecondHmacKey(s string) {
	m.second_hmac_key = &s
}

// SecondHmacKey returns the value of the "second_hmac_key" field in the mutation.
func (m *MissionMutation) SecondHmacKey() (r string, exists bool) {
	v := m.second_hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondHmacKey returns the old "second_hmac_key" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldSecondHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondHmacKey: %w", err)
	}
	return oldValue.SecondHmacKey, nil
}

// ResetSecondHmacKey resets all changes to the "second_hmac_key" field.
func (m *MissionMutation) ResetSecondHmacKey() {
	m.second_hmac_key = nil
}

// SetUsername sets the "username" field.
func (m *MissionMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *MissionMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *MissionMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *MissionMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MissionMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MissionMutation) ResetPassword() {
	m.password = nil
}

// SetWhiteDeviceIds sets the "white_device_ids" field.
func (m *MissionMutation) SetWhiteDeviceIds(s []string) {
	m.white_device_ids = &s
}

// WhiteDeviceIds returns the value of the "white_device_ids" field in the mutation.
func (m *MissionMutation) WhiteDeviceIds() (r []string, exists bool) {
	v := m.white_device_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldWhiteDeviceIds returns the old "white_device_ids" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldWhiteDeviceIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhiteDeviceIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhiteDeviceIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhiteDeviceIds: %w", err)
	}
	return oldValue.WhiteDeviceIds, nil
}

// ClearWhiteDeviceIds clears the value of the "white_device_ids" field.
func (m *MissionMutation) ClearWhiteDeviceIds() {
	m.white_device_ids = nil
	m.clearedFields[mission.FieldWhiteDeviceIds] = struct{}{}
}

// WhiteDeviceIdsCleared returns if the "white_device_ids" field was cleared in this mutation.
func (m *MissionMutation) WhiteDeviceIdsCleared() bool {
	_, ok := m.clearedFields[mission.FieldWhiteDeviceIds]
	return ok
}

// ResetWhiteDeviceIds resets all changes to the "white_device_ids" field.
func (m *MissionMutation) ResetWhiteDeviceIds() {
	m.white_device_ids = nil
	delete(m.clearedFields, mission.FieldWhiteDeviceIds)
}

// SetBlackDeviceIds sets the "black_device_ids" field.
func (m *MissionMutation) SetBlackDeviceIds(s []string) {
	m.black_device_ids = &s
}

// BlackDeviceIds returns the value of the "black_device_ids" field in the mutation.
func (m *MissionMutation) BlackDeviceIds() (r []string, exists bool) {
	v := m.black_device_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldBlackDeviceIds returns the old "black_device_ids" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldBlackDeviceIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlackDeviceIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlackDeviceIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlackDeviceIds: %w", err)
	}
	return oldValue.BlackDeviceIds, nil
}

// ClearBlackDeviceIds clears the value of the "black_device_ids" field.
func (m *MissionMutation) ClearBlackDeviceIds() {
	m.black_device_ids = nil
	m.clearedFields[mission.FieldBlackDeviceIds] = struct{}{}
}

// BlackDeviceIdsCleared returns if the "black_device_ids" field was cleared in this mutation.
func (m *MissionMutation) BlackDeviceIdsCleared() bool {
	_, ok := m.clearedFields[mission.FieldBlackDeviceIds]
	return ok
}

// ResetBlackDeviceIds resets all changes to the "black_device_ids" field.
func (m *MissionMutation) ResetBlackDeviceIds() {
	m.black_device_ids = nil
	delete(m.clearedFields, mission.FieldBlackDeviceIds)
}

// SetStartedAt sets the "started_at" field.
func (m *MissionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *MissionMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[mission.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *MissionMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[mission.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, mission.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *MissionMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[mission.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *MissionMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[mission.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, mission.FieldFinishedAt)
}

// SetExpiredAt sets the "expired_at" field.
func (m *MissionMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *MissionMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *MissionMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[mission.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *MissionMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[mission.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *MissionMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, mission.FieldExpiredAt)
}

// SetFreeAt sets the "free_at" field.
func (m *MissionMutation) SetFreeAt(t time.Time) {
	m.free_at = &t
}

// FreeAt returns the value of the "free_at" field in the mutation.
func (m *MissionMutation) FreeAt() (r time.Time, exists bool) {
	v := m.free_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeAt returns the old "free_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldFreeAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeAt: %w", err)
	}
	return oldValue.FreeAt, nil
}

// ResetFreeAt resets all changes to the "free_at" field.
func (m *MissionMutation) ResetFreeAt() {
	m.free_at = nil
}

// SetCloseWay sets the "close_way" field.
func (m *MissionMutation) SetCloseWay(ew enums.CloseWay) {
	m.close_way = &ew
}

// CloseWay returns the value of the "close_way" field in the mutation.
func (m *MissionMutation) CloseWay() (r enums.CloseWay, exists bool) {
	v := m.close_way
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseWay returns the old "close_way" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCloseWay(ctx context.Context) (v enums.CloseWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseWay: %w", err)
	}
	return oldValue.CloseWay, nil
}

// ResetCloseWay resets all changes to the "close_way" field.
func (m *MissionMutation) ResetCloseWay() {
	m.close_way = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *MissionMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *MissionMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldClosedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ClearClosedAt clears the value of the "closed_at" field.
func (m *MissionMutation) ClearClosedAt() {
	m.closed_at = nil
	m.clearedFields[mission.FieldClosedAt] = struct{}{}
}

// ClosedAtCleared returns if the "closed_at" field was cleared in this mutation.
func (m *MissionMutation) ClosedAtCleared() bool {
	_, ok := m.clearedFields[mission.FieldClosedAt]
	return ok
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *MissionMutation) ResetClosedAt() {
	m.closed_at = nil
	delete(m.clearedFields, mission.FieldClosedAt)
}

// SetWarningTimes sets the "warning_times" field.
func (m *MissionMutation) SetWarningTimes(i int64) {
	m.warning_times = &i
	m.addwarning_times = nil
}

// WarningTimes returns the value of the "warning_times" field in the mutation.
func (m *MissionMutation) WarningTimes() (r int64, exists bool) {
	v := m.warning_times
	if v == nil {
		return
	}
	return *v, true
}

// OldWarningTimes returns the old "warning_times" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldWarningTimes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarningTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarningTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarningTimes: %w", err)
	}
	return oldValue.WarningTimes, nil
}

// AddWarningTimes adds i to the "warning_times" field.
func (m *MissionMutation) AddWarningTimes(i int64) {
	if m.addwarning_times != nil {
		*m.addwarning_times += i
	} else {
		m.addwarning_times = &i
	}
}

// AddedWarningTimes returns the value that was added to the "warning_times" field in this mutation.
func (m *MissionMutation) AddedWarningTimes() (r int64, exists bool) {
	v := m.addwarning_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetWarningTimes resets all changes to the "warning_times" field.
func (m *MissionMutation) ResetWarningTimes() {
	m.warning_times = nil
	m.addwarning_times = nil
}

// SetRemark sets the "remark" field.
func (m *MissionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MissionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *MissionMutation) ResetRemark() {
	m.remark = nil
}

// SetUseAuth sets the "use_auth" field.
func (m *MissionMutation) SetUseAuth(b bool) {
	m.use_auth = &b
}

// UseAuth returns the value of the "use_auth" field in the mutation.
func (m *MissionMutation) UseAuth() (r bool, exists bool) {
	v := m.use_auth
	if v == nil {
		return
	}
	return *v, true
}

// OldUseAuth returns the old "use_auth" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUseAuth(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseAuth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseAuth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseAuth: %w", err)
	}
	return oldValue.UseAuth, nil
}

// ResetUseAuth resets all changes to the "use_auth" field.
func (m *MissionMutation) ResetUseAuth() {
	m.use_auth = nil
}

// SetOldMissionID sets the "old_mission_id" field.
func (m *MissionMutation) SetOldMissionID(i int64) {
	m.old_mission = &i
}

// OldMissionID returns the value of the "old_mission_id" field in the mutation.
func (m *MissionMutation) OldMissionID() (r int64, exists bool) {
	v := m.old_mission
	if v == nil {
		return
	}
	return *v, true
}

// OldOldMissionID returns the old "old_mission_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldOldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldMissionID: %w", err)
	}
	return oldValue.OldMissionID, nil
}

// ResetOldMissionID resets all changes to the "old_mission_id" field.
func (m *MissionMutation) ResetOldMissionID() {
	m.old_mission = nil
}

// SetTimedShutdown sets the "timed_shutdown" field.
func (m *MissionMutation) SetTimedShutdown(t time.Time) {
	m.timed_shutdown = &t
}

// TimedShutdown returns the value of the "timed_shutdown" field in the mutation.
func (m *MissionMutation) TimedShutdown() (r time.Time, exists bool) {
	v := m.timed_shutdown
	if v == nil {
		return
	}
	return *v, true
}

// OldTimedShutdown returns the old "timed_shutdown" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldTimedShutdown(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimedShutdown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimedShutdown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimedShutdown: %w", err)
	}
	return oldValue.TimedShutdown, nil
}

// ClearTimedShutdown clears the value of the "timed_shutdown" field.
func (m *MissionMutation) ClearTimedShutdown() {
	m.timed_shutdown = nil
	m.clearedFields[mission.FieldTimedShutdown] = struct{}{}
}

// TimedShutdownCleared returns if the "timed_shutdown" field was cleared in this mutation.
func (m *MissionMutation) TimedShutdownCleared() bool {
	_, ok := m.clearedFields[mission.FieldTimedShutdown]
	return ok
}

// ResetTimedShutdown resets all changes to the "timed_shutdown" field.
func (m *MissionMutation) ResetTimedShutdown() {
	m.timed_shutdown = nil
	delete(m.clearedFields, mission.FieldTimedShutdown)
}

// SetGpuNum sets the "gpu_num" field.
func (m *MissionMutation) SetGpuNum(i int) {
	m.gpu_num = &i
	m.addgpu_num = nil
}

// GpuNum returns the value of the "gpu_num" field in the mutation.
func (m *MissionMutation) GpuNum() (r int, exists bool) {
	v := m.gpu_num
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuNum returns the old "gpu_num" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldGpuNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuNum: %w", err)
	}
	return oldValue.GpuNum, nil
}

// AddGpuNum adds i to the "gpu_num" field.
func (m *MissionMutation) AddGpuNum(i int) {
	if m.addgpu_num != nil {
		*m.addgpu_num += i
	} else {
		m.addgpu_num = &i
	}
}

// AddedGpuNum returns the value that was added to the "gpu_num" field in this mutation.
func (m *MissionMutation) AddedGpuNum() (r int, exists bool) {
	v := m.addgpu_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetGpuNum resets all changes to the "gpu_num" field.
func (m *MissionMutation) ResetGpuNum() {
	m.gpu_num = nil
	m.addgpu_num = nil
}

// ClearMissionKind clears the "mission_kind" edge to the MissionKind entity.
func (m *MissionMutation) ClearMissionKind() {
	m.clearedmission_kind = true
	m.clearedFields[mission.FieldMissionKindID] = struct{}{}
}

// MissionKindCleared reports if the "mission_kind" edge to the MissionKind entity was cleared.
func (m *MissionMutation) MissionKindCleared() bool {
	return m.clearedmission_kind
}

// MissionKindIDs returns the "mission_kind" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionKindID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) MissionKindIDs() (ids []int64) {
	if id := m.mission_kind; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionKind resets all changes to the "mission_kind" edge.
func (m *MissionMutation) ResetMissionKind() {
	m.mission_kind = nil
	m.clearedmission_kind = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[mission.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearKeyPair clears the "key_pair" edge to the HmacKeyPair entity.
func (m *MissionMutation) ClearKeyPair() {
	m.clearedkey_pair = true
	m.clearedFields[mission.FieldKeyPairID] = struct{}{}
}

// KeyPairCleared reports if the "key_pair" edge to the HmacKeyPair entity was cleared.
func (m *MissionMutation) KeyPairCleared() bool {
	return m.clearedkey_pair
}

// KeyPairIDs returns the "key_pair" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeyPairID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) KeyPairIDs() (ids []int64) {
	if id := m.key_pair; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeyPair resets all changes to the "key_pair" edge.
func (m *MissionMutation) ResetKeyPair() {
	m.key_pair = nil
	m.clearedkey_pair = false
}

// ClearMissionBatch clears the "mission_batch" edge to the MissionBatch entity.
func (m *MissionMutation) ClearMissionBatch() {
	m.clearedmission_batch = true
	m.clearedFields[mission.FieldMissionBatchID] = struct{}{}
}

// MissionBatchCleared reports if the "mission_batch" edge to the MissionBatch entity was cleared.
func (m *MissionMutation) MissionBatchCleared() bool {
	return m.clearedmission_batch
}

// MissionBatchIDs returns the "mission_batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionBatchID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) MissionBatchIDs() (ids []int64) {
	if id := m.mission_batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionBatch resets all changes to the "mission_batch" edge.
func (m *MissionMutation) ResetMissionBatch() {
	m.mission_batch = nil
	m.clearedmission_batch = false
}

// ClearOldMission clears the "old_mission" edge to the Mission entity.
func (m *MissionMutation) ClearOldMission() {
	m.clearedold_mission = true
	m.clearedFields[mission.FieldOldMissionID] = struct{}{}
}

// OldMissionCleared reports if the "old_mission" edge to the Mission entity was cleared.
func (m *MissionMutation) OldMissionCleared() bool {
	return m.clearedold_mission
}

// OldMissionIDs returns the "old_mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OldMissionID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) OldMissionIDs() (ids []int64) {
	if id := m.old_mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOldMission resets all changes to the "old_mission" edge.
func (m *MissionMutation) ResetOldMission() {
	m.old_mission = nil
	m.clearedold_mission = false
}

// AddMissionKeyPairIDs adds the "mission_key_pairs" edge to the MissionKeyPair entity by ids.
func (m *MissionMutation) AddMissionKeyPairIDs(ids ...int64) {
	if m.mission_key_pairs == nil {
		m.mission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_key_pairs[ids[i]] = struct{}{}
	}
}

// ClearMissionKeyPairs clears the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *MissionMutation) ClearMissionKeyPairs() {
	m.clearedmission_key_pairs = true
}

// MissionKeyPairsCleared reports if the "mission_key_pairs" edge to the MissionKeyPair entity was cleared.
func (m *MissionMutation) MissionKeyPairsCleared() bool {
	return m.clearedmission_key_pairs
}

// RemoveMissionKeyPairIDs removes the "mission_key_pairs" edge to the MissionKeyPair entity by IDs.
func (m *MissionMutation) RemoveMissionKeyPairIDs(ids ...int64) {
	if m.removedmission_key_pairs == nil {
		m.removedmission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_key_pairs, ids[i])
		m.removedmission_key_pairs[ids[i]] = struct{}{}
	}
}

// RemovedMissionKeyPairs returns the removed IDs of the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *MissionMutation) RemovedMissionKeyPairsIDs() (ids []int64) {
	for id := range m.removedmission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// MissionKeyPairsIDs returns the "mission_key_pairs" edge IDs in the mutation.
func (m *MissionMutation) MissionKeyPairsIDs() (ids []int64) {
	for id := range m.mission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// ResetMissionKeyPairs resets all changes to the "mission_key_pairs" edge.
func (m *MissionMutation) ResetMissionKeyPairs() {
	m.mission_key_pairs = nil
	m.clearedmission_key_pairs = false
	m.removedmission_key_pairs = nil
}

// SetMissionConsumeOrderID sets the "mission_consume_order" edge to the MissionConsumeOrder entity by id.
func (m *MissionMutation) SetMissionConsumeOrderID(id int64) {
	m.mission_consume_order = &id
}

// ClearMissionConsumeOrder clears the "mission_consume_order" edge to the MissionConsumeOrder entity.
func (m *MissionMutation) ClearMissionConsumeOrder() {
	m.clearedmission_consume_order = true
}

// MissionConsumeOrderCleared reports if the "mission_consume_order" edge to the MissionConsumeOrder entity was cleared.
func (m *MissionMutation) MissionConsumeOrderCleared() bool {
	return m.clearedmission_consume_order
}

// MissionConsumeOrderID returns the "mission_consume_order" edge ID in the mutation.
func (m *MissionMutation) MissionConsumeOrderID() (id int64, exists bool) {
	if m.mission_consume_order != nil {
		return *m.mission_consume_order, true
	}
	return
}

// MissionConsumeOrderIDs returns the "mission_consume_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionConsumeOrderID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) MissionConsumeOrderIDs() (ids []int64) {
	if id := m.mission_consume_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionConsumeOrder resets all changes to the "mission_consume_order" edge.
func (m *MissionMutation) ResetMissionConsumeOrder() {
	m.mission_consume_order = nil
	m.clearedmission_consume_order = false
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *MissionMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *MissionMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *MissionMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *MissionMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *MissionMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// AddMissionProductionIDs adds the "mission_productions" edge to the MissionProduction entity by ids.
func (m *MissionMutation) AddMissionProductionIDs(ids ...int64) {
	if m.mission_productions == nil {
		m.mission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_productions[ids[i]] = struct{}{}
	}
}

// ClearMissionProductions clears the "mission_productions" edge to the MissionProduction entity.
func (m *MissionMutation) ClearMissionProductions() {
	m.clearedmission_productions = true
}

// MissionProductionsCleared reports if the "mission_productions" edge to the MissionProduction entity was cleared.
func (m *MissionMutation) MissionProductionsCleared() bool {
	return m.clearedmission_productions
}

// RemoveMissionProductionIDs removes the "mission_productions" edge to the MissionProduction entity by IDs.
func (m *MissionMutation) RemoveMissionProductionIDs(ids ...int64) {
	if m.removedmission_productions == nil {
		m.removedmission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_productions, ids[i])
		m.removedmission_productions[ids[i]] = struct{}{}
	}
}

// RemovedMissionProductions returns the removed IDs of the "mission_productions" edge to the MissionProduction entity.
func (m *MissionMutation) RemovedMissionProductionsIDs() (ids []int64) {
	for id := range m.removedmission_productions {
		ids = append(ids, id)
	}
	return
}

// MissionProductionsIDs returns the "mission_productions" edge IDs in the mutation.
func (m *MissionMutation) MissionProductionsIDs() (ids []int64) {
	for id := range m.mission_productions {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProductions resets all changes to the "mission_productions" edge.
func (m *MissionMutation) ResetMissionProductions() {
	m.mission_productions = nil
	m.clearedmission_productions = false
	m.removedmission_productions = nil
}

// AddMissionOrderIDs adds the "mission_orders" edge to the MissionOrder entity by ids.
func (m *MissionMutation) AddMissionOrderIDs(ids ...int64) {
	if m.mission_orders == nil {
		m.mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionOrders clears the "mission_orders" edge to the MissionOrder entity.
func (m *MissionMutation) ClearMissionOrders() {
	m.clearedmission_orders = true
}

// MissionOrdersCleared reports if the "mission_orders" edge to the MissionOrder entity was cleared.
func (m *MissionMutation) MissionOrdersCleared() bool {
	return m.clearedmission_orders
}

// RemoveMissionOrderIDs removes the "mission_orders" edge to the MissionOrder entity by IDs.
func (m *MissionMutation) RemoveMissionOrderIDs(ids ...int64) {
	if m.removedmission_orders == nil {
		m.removedmission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_orders, ids[i])
		m.removedmission_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionOrders returns the removed IDs of the "mission_orders" edge to the MissionOrder entity.
func (m *MissionMutation) RemovedMissionOrdersIDs() (ids []int64) {
	for id := range m.removedmission_orders {
		ids = append(ids, id)
	}
	return
}

// MissionOrdersIDs returns the "mission_orders" edge IDs in the mutation.
func (m *MissionMutation) MissionOrdersIDs() (ids []int64) {
	for id := range m.mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionOrders resets all changes to the "mission_orders" edge.
func (m *MissionMutation) ResetMissionOrders() {
	m.mission_orders = nil
	m.clearedmission_orders = false
	m.removedmission_orders = nil
}

// AddRenewalAgreementIDs adds the "renewal_agreements" edge to the RenewalAgreement entity by ids.
func (m *MissionMutation) AddRenewalAgreementIDs(ids ...int64) {
	if m.renewal_agreements == nil {
		m.renewal_agreements = make(map[int64]struct{})
	}
	for i := range ids {
		m.renewal_agreements[ids[i]] = struct{}{}
	}
}

// ClearRenewalAgreements clears the "renewal_agreements" edge to the RenewalAgreement entity.
func (m *MissionMutation) ClearRenewalAgreements() {
	m.clearedrenewal_agreements = true
}

// RenewalAgreementsCleared reports if the "renewal_agreements" edge to the RenewalAgreement entity was cleared.
func (m *MissionMutation) RenewalAgreementsCleared() bool {
	return m.clearedrenewal_agreements
}

// RemoveRenewalAgreementIDs removes the "renewal_agreements" edge to the RenewalAgreement entity by IDs.
func (m *MissionMutation) RemoveRenewalAgreementIDs(ids ...int64) {
	if m.removedrenewal_agreements == nil {
		m.removedrenewal_agreements = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.renewal_agreements, ids[i])
		m.removedrenewal_agreements[ids[i]] = struct{}{}
	}
}

// RemovedRenewalAgreements returns the removed IDs of the "renewal_agreements" edge to the RenewalAgreement entity.
func (m *MissionMutation) RemovedRenewalAgreementsIDs() (ids []int64) {
	for id := range m.removedrenewal_agreements {
		ids = append(ids, id)
	}
	return
}

// RenewalAgreementsIDs returns the "renewal_agreements" edge IDs in the mutation.
func (m *MissionMutation) RenewalAgreementsIDs() (ids []int64) {
	for id := range m.renewal_agreements {
		ids = append(ids, id)
	}
	return
}

// ResetRenewalAgreements resets all changes to the "renewal_agreements" edge.
func (m *MissionMutation) ResetRenewalAgreements() {
	m.renewal_agreements = nil
	m.clearedrenewal_agreements = false
	m.removedrenewal_agreements = nil
}

// AddMissionExtraServiceIDs adds the "mission_extra_services" edge to the MissionExtraService entity by ids.
func (m *MissionMutation) AddMissionExtraServiceIDs(ids ...int64) {
	if m.mission_extra_services == nil {
		m.mission_extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_extra_services[ids[i]] = struct{}{}
	}
}

// ClearMissionExtraServices clears the "mission_extra_services" edge to the MissionExtraService entity.
func (m *MissionMutation) ClearMissionExtraServices() {
	m.clearedmission_extra_services = true
}

// MissionExtraServicesCleared reports if the "mission_extra_services" edge to the MissionExtraService entity was cleared.
func (m *MissionMutation) MissionExtraServicesCleared() bool {
	return m.clearedmission_extra_services
}

// RemoveMissionExtraServiceIDs removes the "mission_extra_services" edge to the MissionExtraService entity by IDs.
func (m *MissionMutation) RemoveMissionExtraServiceIDs(ids ...int64) {
	if m.removedmission_extra_services == nil {
		m.removedmission_extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_extra_services, ids[i])
		m.removedmission_extra_services[ids[i]] = struct{}{}
	}
}

// RemovedMissionExtraServices returns the removed IDs of the "mission_extra_services" edge to the MissionExtraService entity.
func (m *MissionMutation) RemovedMissionExtraServicesIDs() (ids []int64) {
	for id := range m.removedmission_extra_services {
		ids = append(ids, id)
	}
	return
}

// MissionExtraServicesIDs returns the "mission_extra_services" edge IDs in the mutation.
func (m *MissionMutation) MissionExtraServicesIDs() (ids []int64) {
	for id := range m.mission_extra_services {
		ids = append(ids, id)
	}
	return
}

// ResetMissionExtraServices resets all changes to the "mission_extra_services" edge.
func (m *MissionMutation) ResetMissionExtraServices() {
	m.mission_extra_services = nil
	m.clearedmission_extra_services = false
	m.removedmission_extra_services = nil
}

// AddExtraServiceIDs adds the "extra_services" edge to the ExtraService entity by ids.
func (m *MissionMutation) AddExtraServiceIDs(ids ...int64) {
	if m.extra_services == nil {
		m.extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_services[ids[i]] = struct{}{}
	}
}

// ClearExtraServices clears the "extra_services" edge to the ExtraService entity.
func (m *MissionMutation) ClearExtraServices() {
	m.clearedextra_services = true
}

// ExtraServicesCleared reports if the "extra_services" edge to the ExtraService entity was cleared.
func (m *MissionMutation) ExtraServicesCleared() bool {
	return m.clearedextra_services
}

// RemoveExtraServiceIDs removes the "extra_services" edge to the ExtraService entity by IDs.
func (m *MissionMutation) RemoveExtraServiceIDs(ids ...int64) {
	if m.removedextra_services == nil {
		m.removedextra_services = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_services, ids[i])
		m.removedextra_services[ids[i]] = struct{}{}
	}
}

// RemovedExtraServices returns the removed IDs of the "extra_services" edge to the ExtraService entity.
func (m *MissionMutation) RemovedExtraServicesIDs() (ids []int64) {
	for id := range m.removedextra_services {
		ids = append(ids, id)
	}
	return
}

// ExtraServicesIDs returns the "extra_services" edge IDs in the mutation.
func (m *MissionMutation) ExtraServicesIDs() (ids []int64) {
	for id := range m.extra_services {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServices resets all changes to the "extra_services" edge.
func (m *MissionMutation) ResetExtraServices() {
	m.extra_services = nil
	m.clearedextra_services = false
	m.removedextra_services = nil
}

// AddExtraServiceOrderIDs adds the "extra_service_orders" edge to the ExtraServiceOrder entity by ids.
func (m *MissionMutation) AddExtraServiceOrderIDs(ids ...int64) {
	if m.extra_service_orders == nil {
		m.extra_service_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_orders[ids[i]] = struct{}{}
	}
}

// ClearExtraServiceOrders clears the "extra_service_orders" edge to the ExtraServiceOrder entity.
func (m *MissionMutation) ClearExtraServiceOrders() {
	m.clearedextra_service_orders = true
}

// ExtraServiceOrdersCleared reports if the "extra_service_orders" edge to the ExtraServiceOrder entity was cleared.
func (m *MissionMutation) ExtraServiceOrdersCleared() bool {
	return m.clearedextra_service_orders
}

// RemoveExtraServiceOrderIDs removes the "extra_service_orders" edge to the ExtraServiceOrder entity by IDs.
func (m *MissionMutation) RemoveExtraServiceOrderIDs(ids ...int64) {
	if m.removedextra_service_orders == nil {
		m.removedextra_service_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_orders, ids[i])
		m.removedextra_service_orders[ids[i]] = struct{}{}
	}
}

// RemovedExtraServiceOrders returns the removed IDs of the "extra_service_orders" edge to the ExtraServiceOrder entity.
func (m *MissionMutation) RemovedExtraServiceOrdersIDs() (ids []int64) {
	for id := range m.removedextra_service_orders {
		ids = append(ids, id)
	}
	return
}

// ExtraServiceOrdersIDs returns the "extra_service_orders" edge IDs in the mutation.
func (m *MissionMutation) ExtraServiceOrdersIDs() (ids []int64) {
	for id := range m.extra_service_orders {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServiceOrders resets all changes to the "extra_service_orders" edge.
func (m *MissionMutation) ResetExtraServiceOrders() {
	m.extra_service_orders = nil
	m.clearedextra_service_orders = false
	m.removedextra_service_orders = nil
}

// AddRebootMissionIDs adds the "reboot_missions" edge to the Mission entity by ids.
func (m *MissionMutation) AddRebootMissionIDs(ids ...int64) {
	if m.reboot_missions == nil {
		m.reboot_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.reboot_missions[ids[i]] = struct{}{}
	}
}

// ClearRebootMissions clears the "reboot_missions" edge to the Mission entity.
func (m *MissionMutation) ClearRebootMissions() {
	m.clearedreboot_missions = true
}

// RebootMissionsCleared reports if the "reboot_missions" edge to the Mission entity was cleared.
func (m *MissionMutation) RebootMissionsCleared() bool {
	return m.clearedreboot_missions
}

// RemoveRebootMissionIDs removes the "reboot_missions" edge to the Mission entity by IDs.
func (m *MissionMutation) RemoveRebootMissionIDs(ids ...int64) {
	if m.removedreboot_missions == nil {
		m.removedreboot_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.reboot_missions, ids[i])
		m.removedreboot_missions[ids[i]] = struct{}{}
	}
}

// RemovedRebootMissions returns the removed IDs of the "reboot_missions" edge to the Mission entity.
func (m *MissionMutation) RemovedRebootMissionsIDs() (ids []int64) {
	for id := range m.removedreboot_missions {
		ids = append(ids, id)
	}
	return
}

// RebootMissionsIDs returns the "reboot_missions" edge IDs in the mutation.
func (m *MissionMutation) RebootMissionsIDs() (ids []int64) {
	for id := range m.reboot_missions {
		ids = append(ids, id)
	}
	return
}

// ResetRebootMissions resets all changes to the "reboot_missions" edge.
func (m *MissionMutation) ResetRebootMissions() {
	m.reboot_missions = nil
	m.clearedreboot_missions = false
	m.removedreboot_missions = nil
}

// SetMissionFailedFeedbackID sets the "mission_failed_feedback" edge to the MissionFailedFeedback entity by id.
func (m *MissionMutation) SetMissionFailedFeedbackID(id int64) {
	m.mission_failed_feedback = &id
}

// ClearMissionFailedFeedback clears the "mission_failed_feedback" edge to the MissionFailedFeedback entity.
func (m *MissionMutation) ClearMissionFailedFeedback() {
	m.clearedmission_failed_feedback = true
}

// MissionFailedFeedbackCleared reports if the "mission_failed_feedback" edge to the MissionFailedFeedback entity was cleared.
func (m *MissionMutation) MissionFailedFeedbackCleared() bool {
	return m.clearedmission_failed_feedback
}

// MissionFailedFeedbackID returns the "mission_failed_feedback" edge ID in the mutation.
func (m *MissionMutation) MissionFailedFeedbackID() (id int64, exists bool) {
	if m.mission_failed_feedback != nil {
		return *m.mission_failed_feedback, true
	}
	return
}

// MissionFailedFeedbackIDs returns the "mission_failed_feedback" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionFailedFeedbackID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) MissionFailedFeedbackIDs() (ids []int64) {
	if id := m.mission_failed_feedback; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionFailedFeedback resets all changes to the "mission_failed_feedback" edge.
func (m *MissionMutation) ResetMissionFailedFeedback() {
	m.mission_failed_feedback = nil
	m.clearedmission_failed_feedback = false
}

// Where appends a list predicates to the MissionMutation builder.
func (m *MissionMutation) Where(ps ...predicate.Mission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mission).
func (m *MissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionMutation) Fields() []string {
	fields := make([]string, 0, 45)
	if m.created_by != nil {
		fields = append(fields, mission.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, mission.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, mission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, mission.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, mission.FieldType)
	}
	if m.mission_kind != nil {
		fields = append(fields, mission.FieldMissionKindID)
	}
	if m.body != nil {
		fields = append(fields, mission.FieldBody)
	}
	if m.call_back_url != nil {
		fields = append(fields, mission.FieldCallBackURL)
	}
	if m.call_back_info != nil {
		fields = append(fields, mission.FieldCallBackInfo)
	}
	if m.call_back_data != nil {
		fields = append(fields, mission.FieldCallBackData)
	}
	if m.status != nil {
		fields = append(fields, mission.FieldStatus)
	}
	if m.result != nil {
		fields = append(fields, mission.FieldResult)
	}
	if m.state != nil {
		fields = append(fields, mission.FieldState)
	}
	if m.result_urls != nil {
		fields = append(fields, mission.FieldResultUrls)
	}
	if m.urls != nil {
		fields = append(fields, mission.FieldUrls)
	}
	if m.key_pair != nil {
		fields = append(fields, mission.FieldKeyPairID)
	}
	if m.user != nil {
		fields = append(fields, mission.FieldUserID)
	}
	if m.mission_batch != nil {
		fields = append(fields, mission.FieldMissionBatchID)
	}
	if m.mission_batch_number != nil {
		fields = append(fields, mission.FieldMissionBatchNumber)
	}
	if m.gpu_version != nil {
		fields = append(fields, mission.FieldGpuVersion)
	}
	if m.unit_cep != nil {
		fields = append(fields, mission.FieldUnitCep)
	}
	if m.resp_status_code != nil {
		fields = append(fields, mission.FieldRespStatusCode)
	}
	if m.resp_body != nil {
		fields = append(fields, mission.FieldRespBody)
	}
	if m.inner_uri != nil {
		fields = append(fields, mission.FieldInnerURI)
	}
	if m.inner_method != nil {
		fields = append(fields, mission.FieldInnerMethod)
	}
	if m.temp_hmac_key != nil {
		fields = append(fields, mission.FieldTempHmacKey)
	}
	if m.temp_hmac_secret != nil {
		fields = append(fields, mission.FieldTempHmacSecret)
	}
	if m.second_hmac_key != nil {
		fields = append(fields, mission.FieldSecondHmacKey)
	}
	if m.username != nil {
		fields = append(fields, mission.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, mission.FieldPassword)
	}
	if m.white_device_ids != nil {
		fields = append(fields, mission.FieldWhiteDeviceIds)
	}
	if m.black_device_ids != nil {
		fields = append(fields, mission.FieldBlackDeviceIds)
	}
	if m.started_at != nil {
		fields = append(fields, mission.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, mission.FieldFinishedAt)
	}
	if m.expired_at != nil {
		fields = append(fields, mission.FieldExpiredAt)
	}
	if m.free_at != nil {
		fields = append(fields, mission.FieldFreeAt)
	}
	if m.close_way != nil {
		fields = append(fields, mission.FieldCloseWay)
	}
	if m.closed_at != nil {
		fields = append(fields, mission.FieldClosedAt)
	}
	if m.warning_times != nil {
		fields = append(fields, mission.FieldWarningTimes)
	}
	if m.remark != nil {
		fields = append(fields, mission.FieldRemark)
	}
	if m.use_auth != nil {
		fields = append(fields, mission.FieldUseAuth)
	}
	if m.old_mission != nil {
		fields = append(fields, mission.FieldOldMissionID)
	}
	if m.timed_shutdown != nil {
		fields = append(fields, mission.FieldTimedShutdown)
	}
	if m.gpu_num != nil {
		fields = append(fields, mission.FieldGpuNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mission.FieldCreatedBy:
		return m.CreatedBy()
	case mission.FieldUpdatedBy:
		return m.UpdatedBy()
	case mission.FieldCreatedAt:
		return m.CreatedAt()
	case mission.FieldUpdatedAt:
		return m.UpdatedAt()
	case mission.FieldDeletedAt:
		return m.DeletedAt()
	case mission.FieldType:
		return m.GetType()
	case mission.FieldMissionKindID:
		return m.MissionKindID()
	case mission.FieldBody:
		return m.Body()
	case mission.FieldCallBackURL:
		return m.CallBackURL()
	case mission.FieldCallBackInfo:
		return m.CallBackInfo()
	case mission.FieldCallBackData:
		return m.CallBackData()
	case mission.FieldStatus:
		return m.Status()
	case mission.FieldResult:
		return m.Result()
	case mission.FieldState:
		return m.State()
	case mission.FieldResultUrls:
		return m.ResultUrls()
	case mission.FieldUrls:
		return m.Urls()
	case mission.FieldKeyPairID:
		return m.KeyPairID()
	case mission.FieldUserID:
		return m.UserID()
	case mission.FieldMissionBatchID:
		return m.MissionBatchID()
	case mission.FieldMissionBatchNumber:
		return m.MissionBatchNumber()
	case mission.FieldGpuVersion:
		return m.GpuVersion()
	case mission.FieldUnitCep:
		return m.UnitCep()
	case mission.FieldRespStatusCode:
		return m.RespStatusCode()
	case mission.FieldRespBody:
		return m.RespBody()
	case mission.FieldInnerURI:
		return m.InnerURI()
	case mission.FieldInnerMethod:
		return m.InnerMethod()
	case mission.FieldTempHmacKey:
		return m.TempHmacKey()
	case mission.FieldTempHmacSecret:
		return m.TempHmacSecret()
	case mission.FieldSecondHmacKey:
		return m.SecondHmacKey()
	case mission.FieldUsername:
		return m.Username()
	case mission.FieldPassword:
		return m.Password()
	case mission.FieldWhiteDeviceIds:
		return m.WhiteDeviceIds()
	case mission.FieldBlackDeviceIds:
		return m.BlackDeviceIds()
	case mission.FieldStartedAt:
		return m.StartedAt()
	case mission.FieldFinishedAt:
		return m.FinishedAt()
	case mission.FieldExpiredAt:
		return m.ExpiredAt()
	case mission.FieldFreeAt:
		return m.FreeAt()
	case mission.FieldCloseWay:
		return m.CloseWay()
	case mission.FieldClosedAt:
		return m.ClosedAt()
	case mission.FieldWarningTimes:
		return m.WarningTimes()
	case mission.FieldRemark:
		return m.Remark()
	case mission.FieldUseAuth:
		return m.UseAuth()
	case mission.FieldOldMissionID:
		return m.OldMissionID()
	case mission.FieldTimedShutdown:
		return m.TimedShutdown()
	case mission.FieldGpuNum:
		return m.GpuNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case mission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case mission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mission.FieldType:
		return m.OldType(ctx)
	case mission.FieldMissionKindID:
		return m.OldMissionKindID(ctx)
	case mission.FieldBody:
		return m.OldBody(ctx)
	case mission.FieldCallBackURL:
		return m.OldCallBackURL(ctx)
	case mission.FieldCallBackInfo:
		return m.OldCallBackInfo(ctx)
	case mission.FieldCallBackData:
		return m.OldCallBackData(ctx)
	case mission.FieldStatus:
		return m.OldStatus(ctx)
	case mission.FieldResult:
		return m.OldResult(ctx)
	case mission.FieldState:
		return m.OldState(ctx)
	case mission.FieldResultUrls:
		return m.OldResultUrls(ctx)
	case mission.FieldUrls:
		return m.OldUrls(ctx)
	case mission.FieldKeyPairID:
		return m.OldKeyPairID(ctx)
	case mission.FieldUserID:
		return m.OldUserID(ctx)
	case mission.FieldMissionBatchID:
		return m.OldMissionBatchID(ctx)
	case mission.FieldMissionBatchNumber:
		return m.OldMissionBatchNumber(ctx)
	case mission.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case mission.FieldUnitCep:
		return m.OldUnitCep(ctx)
	case mission.FieldRespStatusCode:
		return m.OldRespStatusCode(ctx)
	case mission.FieldRespBody:
		return m.OldRespBody(ctx)
	case mission.FieldInnerURI:
		return m.OldInnerURI(ctx)
	case mission.FieldInnerMethod:
		return m.OldInnerMethod(ctx)
	case mission.FieldTempHmacKey:
		return m.OldTempHmacKey(ctx)
	case mission.FieldTempHmacSecret:
		return m.OldTempHmacSecret(ctx)
	case mission.FieldSecondHmacKey:
		return m.OldSecondHmacKey(ctx)
	case mission.FieldUsername:
		return m.OldUsername(ctx)
	case mission.FieldPassword:
		return m.OldPassword(ctx)
	case mission.FieldWhiteDeviceIds:
		return m.OldWhiteDeviceIds(ctx)
	case mission.FieldBlackDeviceIds:
		return m.OldBlackDeviceIds(ctx)
	case mission.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case mission.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case mission.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case mission.FieldFreeAt:
		return m.OldFreeAt(ctx)
	case mission.FieldCloseWay:
		return m.OldCloseWay(ctx)
	case mission.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case mission.FieldWarningTimes:
		return m.OldWarningTimes(ctx)
	case mission.FieldRemark:
		return m.OldRemark(ctx)
	case mission.FieldUseAuth:
		return m.OldUseAuth(ctx)
	case mission.FieldOldMissionID:
		return m.OldOldMissionID(ctx)
	case mission.FieldTimedShutdown:
		return m.OldTimedShutdown(ctx)
	case mission.FieldGpuNum:
		return m.OldGpuNum(ctx)
	}
	return nil, fmt.Errorf("unknown Mission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case mission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case mission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mission.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case mission.FieldMissionKindID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionKindID(v)
		return nil
	case mission.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case mission.FieldCallBackURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallBackURL(v)
		return nil
	case mission.FieldCallBackInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallBackInfo(v)
		return nil
	case mission.FieldCallBackData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallBackData(v)
		return nil
	case mission.FieldStatus:
		v, ok := value.(enums.MissionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mission.FieldResult:
		v, ok := value.(enums.MissionResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case mission.FieldState:
		v, ok := value.(enums.MissionState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case mission.FieldResultUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultUrls(v)
		return nil
	case mission.FieldUrls:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrls(v)
		return nil
	case mission.FieldKeyPairID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPairID(v)
		return nil
	case mission.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case mission.FieldMissionBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchID(v)
		return nil
	case mission.FieldMissionBatchNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchNumber(v)
		return nil
	case mission.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case mission.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCep(v)
		return nil
	case mission.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespStatusCode(v)
		return nil
	case mission.FieldRespBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespBody(v)
		return nil
	case mission.FieldInnerURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnerURI(v)
		return nil
	case mission.FieldInnerMethod:
		v, ok := value.(enums.InnerMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnerMethod(v)
		return nil
	case mission.FieldTempHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTempHmacKey(v)
		return nil
	case mission.FieldTempHmacSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTempHmacSecret(v)
		return nil
	case mission.FieldSecondHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondHmacKey(v)
		return nil
	case mission.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case mission.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case mission.FieldWhiteDeviceIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhiteDeviceIds(v)
		return nil
	case mission.FieldBlackDeviceIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlackDeviceIds(v)
		return nil
	case mission.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case mission.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case mission.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case mission.FieldFreeAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeAt(v)
		return nil
	case mission.FieldCloseWay:
		v, ok := value.(enums.CloseWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseWay(v)
		return nil
	case mission.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case mission.FieldWarningTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarningTimes(v)
		return nil
	case mission.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case mission.FieldUseAuth:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseAuth(v)
		return nil
	case mission.FieldOldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldMissionID(v)
		return nil
	case mission.FieldTimedShutdown:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimedShutdown(v)
		return nil
	case mission.FieldGpuNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuNum(v)
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, mission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, mission.FieldUpdatedBy)
	}
	if m.addunit_cep != nil {
		fields = append(fields, mission.FieldUnitCep)
	}
	if m.addresp_status_code != nil {
		fields = append(fields, mission.FieldRespStatusCode)
	}
	if m.addwarning_times != nil {
		fields = append(fields, mission.FieldWarningTimes)
	}
	if m.addgpu_num != nil {
		fields = append(fields, mission.FieldGpuNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case mission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case mission.FieldUnitCep:
		return m.AddedUnitCep()
	case mission.FieldRespStatusCode:
		return m.AddedRespStatusCode()
	case mission.FieldWarningTimes:
		return m.AddedWarningTimes()
	case mission.FieldGpuNum:
		return m.AddedGpuNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case mission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case mission.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCep(v)
		return nil
	case mission.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRespStatusCode(v)
		return nil
	case mission.FieldWarningTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarningTimes(v)
		return nil
	case mission.FieldGpuNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGpuNum(v)
		return nil
	}
	return fmt.Errorf("unknown Mission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mission.FieldCallBackInfo) {
		fields = append(fields, mission.FieldCallBackInfo)
	}
	if m.FieldCleared(mission.FieldCallBackData) {
		fields = append(fields, mission.FieldCallBackData)
	}
	if m.FieldCleared(mission.FieldResultUrls) {
		fields = append(fields, mission.FieldResultUrls)
	}
	if m.FieldCleared(mission.FieldWhiteDeviceIds) {
		fields = append(fields, mission.FieldWhiteDeviceIds)
	}
	if m.FieldCleared(mission.FieldBlackDeviceIds) {
		fields = append(fields, mission.FieldBlackDeviceIds)
	}
	if m.FieldCleared(mission.FieldStartedAt) {
		fields = append(fields, mission.FieldStartedAt)
	}
	if m.FieldCleared(mission.FieldFinishedAt) {
		fields = append(fields, mission.FieldFinishedAt)
	}
	if m.FieldCleared(mission.FieldExpiredAt) {
		fields = append(fields, mission.FieldExpiredAt)
	}
	if m.FieldCleared(mission.FieldClosedAt) {
		fields = append(fields, mission.FieldClosedAt)
	}
	if m.FieldCleared(mission.FieldTimedShutdown) {
		fields = append(fields, mission.FieldTimedShutdown)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionMutation) ClearField(name string) error {
	switch name {
	case mission.FieldCallBackInfo:
		m.ClearCallBackInfo()
		return nil
	case mission.FieldCallBackData:
		m.ClearCallBackData()
		return nil
	case mission.FieldResultUrls:
		m.ClearResultUrls()
		return nil
	case mission.FieldWhiteDeviceIds:
		m.ClearWhiteDeviceIds()
		return nil
	case mission.FieldBlackDeviceIds:
		m.ClearBlackDeviceIds()
		return nil
	case mission.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case mission.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case mission.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	case mission.FieldClosedAt:
		m.ClearClosedAt()
		return nil
	case mission.FieldTimedShutdown:
		m.ClearTimedShutdown()
		return nil
	}
	return fmt.Errorf("unknown Mission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionMutation) ResetField(name string) error {
	switch name {
	case mission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case mission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case mission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mission.FieldType:
		m.ResetType()
		return nil
	case mission.FieldMissionKindID:
		m.ResetMissionKindID()
		return nil
	case mission.FieldBody:
		m.ResetBody()
		return nil
	case mission.FieldCallBackURL:
		m.ResetCallBackURL()
		return nil
	case mission.FieldCallBackInfo:
		m.ResetCallBackInfo()
		return nil
	case mission.FieldCallBackData:
		m.ResetCallBackData()
		return nil
	case mission.FieldStatus:
		m.ResetStatus()
		return nil
	case mission.FieldResult:
		m.ResetResult()
		return nil
	case mission.FieldState:
		m.ResetState()
		return nil
	case mission.FieldResultUrls:
		m.ResetResultUrls()
		return nil
	case mission.FieldUrls:
		m.ResetUrls()
		return nil
	case mission.FieldKeyPairID:
		m.ResetKeyPairID()
		return nil
	case mission.FieldUserID:
		m.ResetUserID()
		return nil
	case mission.FieldMissionBatchID:
		m.ResetMissionBatchID()
		return nil
	case mission.FieldMissionBatchNumber:
		m.ResetMissionBatchNumber()
		return nil
	case mission.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case mission.FieldUnitCep:
		m.ResetUnitCep()
		return nil
	case mission.FieldRespStatusCode:
		m.ResetRespStatusCode()
		return nil
	case mission.FieldRespBody:
		m.ResetRespBody()
		return nil
	case mission.FieldInnerURI:
		m.ResetInnerURI()
		return nil
	case mission.FieldInnerMethod:
		m.ResetInnerMethod()
		return nil
	case mission.FieldTempHmacKey:
		m.ResetTempHmacKey()
		return nil
	case mission.FieldTempHmacSecret:
		m.ResetTempHmacSecret()
		return nil
	case mission.FieldSecondHmacKey:
		m.ResetSecondHmacKey()
		return nil
	case mission.FieldUsername:
		m.ResetUsername()
		return nil
	case mission.FieldPassword:
		m.ResetPassword()
		return nil
	case mission.FieldWhiteDeviceIds:
		m.ResetWhiteDeviceIds()
		return nil
	case mission.FieldBlackDeviceIds:
		m.ResetBlackDeviceIds()
		return nil
	case mission.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case mission.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case mission.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case mission.FieldFreeAt:
		m.ResetFreeAt()
		return nil
	case mission.FieldCloseWay:
		m.ResetCloseWay()
		return nil
	case mission.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case mission.FieldWarningTimes:
		m.ResetWarningTimes()
		return nil
	case mission.FieldRemark:
		m.ResetRemark()
		return nil
	case mission.FieldUseAuth:
		m.ResetUseAuth()
		return nil
	case mission.FieldOldMissionID:
		m.ResetOldMissionID()
		return nil
	case mission.FieldTimedShutdown:
		m.ResetTimedShutdown()
		return nil
	case mission.FieldGpuNum:
		m.ResetGpuNum()
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.mission_kind != nil {
		edges = append(edges, mission.EdgeMissionKind)
	}
	if m.user != nil {
		edges = append(edges, mission.EdgeUser)
	}
	if m.key_pair != nil {
		edges = append(edges, mission.EdgeKeyPair)
	}
	if m.mission_batch != nil {
		edges = append(edges, mission.EdgeMissionBatch)
	}
	if m.old_mission != nil {
		edges = append(edges, mission.EdgeOldMission)
	}
	if m.mission_key_pairs != nil {
		edges = append(edges, mission.EdgeMissionKeyPairs)
	}
	if m.mission_consume_order != nil {
		edges = append(edges, mission.EdgeMissionConsumeOrder)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, mission.EdgeMissionProduceOrders)
	}
	if m.mission_productions != nil {
		edges = append(edges, mission.EdgeMissionProductions)
	}
	if m.mission_orders != nil {
		edges = append(edges, mission.EdgeMissionOrders)
	}
	if m.renewal_agreements != nil {
		edges = append(edges, mission.EdgeRenewalAgreements)
	}
	if m.mission_extra_services != nil {
		edges = append(edges, mission.EdgeMissionExtraServices)
	}
	if m.extra_services != nil {
		edges = append(edges, mission.EdgeExtraServices)
	}
	if m.extra_service_orders != nil {
		edges = append(edges, mission.EdgeExtraServiceOrders)
	}
	if m.reboot_missions != nil {
		edges = append(edges, mission.EdgeRebootMissions)
	}
	if m.mission_failed_feedback != nil {
		edges = append(edges, mission.EdgeMissionFailedFeedback)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeMissionKind:
		if id := m.mission_kind; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeKeyPair:
		if id := m.key_pair; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeMissionBatch:
		if id := m.mission_batch; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeOldMission:
		if id := m.old_mission; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.mission_key_pairs))
		for id := range m.mission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionConsumeOrder:
		if id := m.mission_consume_order; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.mission_productions))
		for id := range m.mission_productions {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.mission_orders))
		for id := range m.mission_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeRenewalAgreements:
		ids := make([]ent.Value, 0, len(m.renewal_agreements))
		for id := range m.renewal_agreements {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionExtraServices:
		ids := make([]ent.Value, 0, len(m.mission_extra_services))
		for id := range m.mission_extra_services {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeExtraServices:
		ids := make([]ent.Value, 0, len(m.extra_services))
		for id := range m.extra_services {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeExtraServiceOrders:
		ids := make([]ent.Value, 0, len(m.extra_service_orders))
		for id := range m.extra_service_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeRebootMissions:
		ids := make([]ent.Value, 0, len(m.reboot_missions))
		for id := range m.reboot_missions {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionFailedFeedback:
		if id := m.mission_failed_feedback; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedmission_key_pairs != nil {
		edges = append(edges, mission.EdgeMissionKeyPairs)
	}
	if m.removedmission_produce_orders != nil {
		edges = append(edges, mission.EdgeMissionProduceOrders)
	}
	if m.removedmission_productions != nil {
		edges = append(edges, mission.EdgeMissionProductions)
	}
	if m.removedmission_orders != nil {
		edges = append(edges, mission.EdgeMissionOrders)
	}
	if m.removedrenewal_agreements != nil {
		edges = append(edges, mission.EdgeRenewalAgreements)
	}
	if m.removedmission_extra_services != nil {
		edges = append(edges, mission.EdgeMissionExtraServices)
	}
	if m.removedextra_services != nil {
		edges = append(edges, mission.EdgeExtraServices)
	}
	if m.removedextra_service_orders != nil {
		edges = append(edges, mission.EdgeExtraServiceOrders)
	}
	if m.removedreboot_missions != nil {
		edges = append(edges, mission.EdgeRebootMissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.removedmission_key_pairs))
		for id := range m.removedmission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.removedmission_productions))
		for id := range m.removedmission_productions {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_orders))
		for id := range m.removedmission_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeRenewalAgreements:
		ids := make([]ent.Value, 0, len(m.removedrenewal_agreements))
		for id := range m.removedrenewal_agreements {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionExtraServices:
		ids := make([]ent.Value, 0, len(m.removedmission_extra_services))
		for id := range m.removedmission_extra_services {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeExtraServices:
		ids := make([]ent.Value, 0, len(m.removedextra_services))
		for id := range m.removedextra_services {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeExtraServiceOrders:
		ids := make([]ent.Value, 0, len(m.removedextra_service_orders))
		for id := range m.removedextra_service_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeRebootMissions:
		ids := make([]ent.Value, 0, len(m.removedreboot_missions))
		for id := range m.removedreboot_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedmission_kind {
		edges = append(edges, mission.EdgeMissionKind)
	}
	if m.cleareduser {
		edges = append(edges, mission.EdgeUser)
	}
	if m.clearedkey_pair {
		edges = append(edges, mission.EdgeKeyPair)
	}
	if m.clearedmission_batch {
		edges = append(edges, mission.EdgeMissionBatch)
	}
	if m.clearedold_mission {
		edges = append(edges, mission.EdgeOldMission)
	}
	if m.clearedmission_key_pairs {
		edges = append(edges, mission.EdgeMissionKeyPairs)
	}
	if m.clearedmission_consume_order {
		edges = append(edges, mission.EdgeMissionConsumeOrder)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, mission.EdgeMissionProduceOrders)
	}
	if m.clearedmission_productions {
		edges = append(edges, mission.EdgeMissionProductions)
	}
	if m.clearedmission_orders {
		edges = append(edges, mission.EdgeMissionOrders)
	}
	if m.clearedrenewal_agreements {
		edges = append(edges, mission.EdgeRenewalAgreements)
	}
	if m.clearedmission_extra_services {
		edges = append(edges, mission.EdgeMissionExtraServices)
	}
	if m.clearedextra_services {
		edges = append(edges, mission.EdgeExtraServices)
	}
	if m.clearedextra_service_orders {
		edges = append(edges, mission.EdgeExtraServiceOrders)
	}
	if m.clearedreboot_missions {
		edges = append(edges, mission.EdgeRebootMissions)
	}
	if m.clearedmission_failed_feedback {
		edges = append(edges, mission.EdgeMissionFailedFeedback)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionMutation) EdgeCleared(name string) bool {
	switch name {
	case mission.EdgeMissionKind:
		return m.clearedmission_kind
	case mission.EdgeUser:
		return m.cleareduser
	case mission.EdgeKeyPair:
		return m.clearedkey_pair
	case mission.EdgeMissionBatch:
		return m.clearedmission_batch
	case mission.EdgeOldMission:
		return m.clearedold_mission
	case mission.EdgeMissionKeyPairs:
		return m.clearedmission_key_pairs
	case mission.EdgeMissionConsumeOrder:
		return m.clearedmission_consume_order
	case mission.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case mission.EdgeMissionProductions:
		return m.clearedmission_productions
	case mission.EdgeMissionOrders:
		return m.clearedmission_orders
	case mission.EdgeRenewalAgreements:
		return m.clearedrenewal_agreements
	case mission.EdgeMissionExtraServices:
		return m.clearedmission_extra_services
	case mission.EdgeExtraServices:
		return m.clearedextra_services
	case mission.EdgeExtraServiceOrders:
		return m.clearedextra_service_orders
	case mission.EdgeRebootMissions:
		return m.clearedreboot_missions
	case mission.EdgeMissionFailedFeedback:
		return m.clearedmission_failed_feedback
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionMutation) ClearEdge(name string) error {
	switch name {
	case mission.EdgeMissionKind:
		m.ClearMissionKind()
		return nil
	case mission.EdgeUser:
		m.ClearUser()
		return nil
	case mission.EdgeKeyPair:
		m.ClearKeyPair()
		return nil
	case mission.EdgeMissionBatch:
		m.ClearMissionBatch()
		return nil
	case mission.EdgeOldMission:
		m.ClearOldMission()
		return nil
	case mission.EdgeMissionConsumeOrder:
		m.ClearMissionConsumeOrder()
		return nil
	case mission.EdgeMissionFailedFeedback:
		m.ClearMissionFailedFeedback()
		return nil
	}
	return fmt.Errorf("unknown Mission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionMutation) ResetEdge(name string) error {
	switch name {
	case mission.EdgeMissionKind:
		m.ResetMissionKind()
		return nil
	case mission.EdgeUser:
		m.ResetUser()
		return nil
	case mission.EdgeKeyPair:
		m.ResetKeyPair()
		return nil
	case mission.EdgeMissionBatch:
		m.ResetMissionBatch()
		return nil
	case mission.EdgeOldMission:
		m.ResetOldMission()
		return nil
	case mission.EdgeMissionKeyPairs:
		m.ResetMissionKeyPairs()
		return nil
	case mission.EdgeMissionConsumeOrder:
		m.ResetMissionConsumeOrder()
		return nil
	case mission.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case mission.EdgeMissionProductions:
		m.ResetMissionProductions()
		return nil
	case mission.EdgeMissionOrders:
		m.ResetMissionOrders()
		return nil
	case mission.EdgeRenewalAgreements:
		m.ResetRenewalAgreements()
		return nil
	case mission.EdgeMissionExtraServices:
		m.ResetMissionExtraServices()
		return nil
	case mission.EdgeExtraServices:
		m.ResetExtraServices()
		return nil
	case mission.EdgeExtraServiceOrders:
		m.ResetExtraServiceOrders()
		return nil
	case mission.EdgeRebootMissions:
		m.ResetRebootMissions()
		return nil
	case mission.EdgeMissionFailedFeedback:
		m.ResetMissionFailedFeedback()
		return nil
	}
	return fmt.Errorf("unknown Mission edge %s", name)
}

// MissionBatchMutation represents an operation that mutates the MissionBatch nodes in the graph.
type MissionBatchMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	number                        *string
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	mission_consume_orders        map[int64]struct{}
	removedmission_consume_orders map[int64]struct{}
	clearedmission_consume_orders bool
	missions                      map[int64]struct{}
	removedmissions               map[int64]struct{}
	clearedmissions               bool
	mission_orders                map[int64]struct{}
	removedmission_orders         map[int64]struct{}
	clearedmission_orders         bool
	extra_service_order           map[int64]struct{}
	removedextra_service_order    map[int64]struct{}
	clearedextra_service_order    bool
	done                          bool
	oldValue                      func(context.Context) (*MissionBatch, error)
	predicates                    []predicate.MissionBatch
}

var _ ent.Mutation = (*MissionBatchMutation)(nil)

// missionbatchOption allows management of the mutation configuration using functional options.
type missionbatchOption func(*MissionBatchMutation)

// newMissionBatchMutation creates new mutation for the MissionBatch entity.
func newMissionBatchMutation(c config, op Op, opts ...missionbatchOption) *MissionBatchMutation {
	m := &MissionBatchMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionBatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionBatchID sets the ID field of the mutation.
func withMissionBatchID(id int64) missionbatchOption {
	return func(m *MissionBatchMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionBatch
		)
		m.oldValue = func(ctx context.Context) (*MissionBatch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionBatch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionBatch sets the old MissionBatch of the mutation.
func withMissionBatch(node *MissionBatch) missionbatchOption {
	return func(m *MissionBatchMutation) {
		m.oldValue = func(context.Context) (*MissionBatch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionBatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionBatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionBatch entities.
func (m *MissionBatchMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionBatchMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionBatchMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionBatch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionBatchMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionBatchMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionBatchMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionBatchMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionBatchMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionBatchMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionBatchMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionBatchMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionBatchMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionBatchMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionBatchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionBatchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionBatchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionBatchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionBatchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionBatchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionBatchMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionBatchMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionBatchMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetNumber sets the "number" field.
func (m *MissionBatchMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *MissionBatchMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *MissionBatchMutation) ResetNumber() {
	m.number = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionBatchMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionBatchMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionBatchMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionBatchMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionbatch.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionBatchMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionBatchMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionBatchMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMissionConsumeOrderIDs adds the "mission_consume_orders" edge to the MissionConsumeOrder entity by ids.
func (m *MissionBatchMutation) AddMissionConsumeOrderIDs(ids ...int64) {
	if m.mission_consume_orders == nil {
		m.mission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_consume_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionConsumeOrders clears the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *MissionBatchMutation) ClearMissionConsumeOrders() {
	m.clearedmission_consume_orders = true
}

// MissionConsumeOrdersCleared reports if the "mission_consume_orders" edge to the MissionConsumeOrder entity was cleared.
func (m *MissionBatchMutation) MissionConsumeOrdersCleared() bool {
	return m.clearedmission_consume_orders
}

// RemoveMissionConsumeOrderIDs removes the "mission_consume_orders" edge to the MissionConsumeOrder entity by IDs.
func (m *MissionBatchMutation) RemoveMissionConsumeOrderIDs(ids ...int64) {
	if m.removedmission_consume_orders == nil {
		m.removedmission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_consume_orders, ids[i])
		m.removedmission_consume_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionConsumeOrders returns the removed IDs of the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *MissionBatchMutation) RemovedMissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.removedmission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// MissionConsumeOrdersIDs returns the "mission_consume_orders" edge IDs in the mutation.
func (m *MissionBatchMutation) MissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.mission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionConsumeOrders resets all changes to the "mission_consume_orders" edge.
func (m *MissionBatchMutation) ResetMissionConsumeOrders() {
	m.mission_consume_orders = nil
	m.clearedmission_consume_orders = false
	m.removedmission_consume_orders = nil
}

// AddMissionIDs adds the "missions" edge to the Mission entity by ids.
func (m *MissionBatchMutation) AddMissionIDs(ids ...int64) {
	if m.missions == nil {
		m.missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.missions[ids[i]] = struct{}{}
	}
}

// ClearMissions clears the "missions" edge to the Mission entity.
func (m *MissionBatchMutation) ClearMissions() {
	m.clearedmissions = true
}

// MissionsCleared reports if the "missions" edge to the Mission entity was cleared.
func (m *MissionBatchMutation) MissionsCleared() bool {
	return m.clearedmissions
}

// RemoveMissionIDs removes the "missions" edge to the Mission entity by IDs.
func (m *MissionBatchMutation) RemoveMissionIDs(ids ...int64) {
	if m.removedmissions == nil {
		m.removedmissions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.missions, ids[i])
		m.removedmissions[ids[i]] = struct{}{}
	}
}

// RemovedMissions returns the removed IDs of the "missions" edge to the Mission entity.
func (m *MissionBatchMutation) RemovedMissionsIDs() (ids []int64) {
	for id := range m.removedmissions {
		ids = append(ids, id)
	}
	return
}

// MissionsIDs returns the "missions" edge IDs in the mutation.
func (m *MissionBatchMutation) MissionsIDs() (ids []int64) {
	for id := range m.missions {
		ids = append(ids, id)
	}
	return
}

// ResetMissions resets all changes to the "missions" edge.
func (m *MissionBatchMutation) ResetMissions() {
	m.missions = nil
	m.clearedmissions = false
	m.removedmissions = nil
}

// AddMissionOrderIDs adds the "mission_orders" edge to the MissionOrder entity by ids.
func (m *MissionBatchMutation) AddMissionOrderIDs(ids ...int64) {
	if m.mission_orders == nil {
		m.mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionOrders clears the "mission_orders" edge to the MissionOrder entity.
func (m *MissionBatchMutation) ClearMissionOrders() {
	m.clearedmission_orders = true
}

// MissionOrdersCleared reports if the "mission_orders" edge to the MissionOrder entity was cleared.
func (m *MissionBatchMutation) MissionOrdersCleared() bool {
	return m.clearedmission_orders
}

// RemoveMissionOrderIDs removes the "mission_orders" edge to the MissionOrder entity by IDs.
func (m *MissionBatchMutation) RemoveMissionOrderIDs(ids ...int64) {
	if m.removedmission_orders == nil {
		m.removedmission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_orders, ids[i])
		m.removedmission_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionOrders returns the removed IDs of the "mission_orders" edge to the MissionOrder entity.
func (m *MissionBatchMutation) RemovedMissionOrdersIDs() (ids []int64) {
	for id := range m.removedmission_orders {
		ids = append(ids, id)
	}
	return
}

// MissionOrdersIDs returns the "mission_orders" edge IDs in the mutation.
func (m *MissionBatchMutation) MissionOrdersIDs() (ids []int64) {
	for id := range m.mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionOrders resets all changes to the "mission_orders" edge.
func (m *MissionBatchMutation) ResetMissionOrders() {
	m.mission_orders = nil
	m.clearedmission_orders = false
	m.removedmission_orders = nil
}

// AddExtraServiceOrderIDs adds the "extra_service_order" edge to the ExtraServiceOrder entity by ids.
func (m *MissionBatchMutation) AddExtraServiceOrderIDs(ids ...int64) {
	if m.extra_service_order == nil {
		m.extra_service_order = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_order[ids[i]] = struct{}{}
	}
}

// ClearExtraServiceOrder clears the "extra_service_order" edge to the ExtraServiceOrder entity.
func (m *MissionBatchMutation) ClearExtraServiceOrder() {
	m.clearedextra_service_order = true
}

// ExtraServiceOrderCleared reports if the "extra_service_order" edge to the ExtraServiceOrder entity was cleared.
func (m *MissionBatchMutation) ExtraServiceOrderCleared() bool {
	return m.clearedextra_service_order
}

// RemoveExtraServiceOrderIDs removes the "extra_service_order" edge to the ExtraServiceOrder entity by IDs.
func (m *MissionBatchMutation) RemoveExtraServiceOrderIDs(ids ...int64) {
	if m.removedextra_service_order == nil {
		m.removedextra_service_order = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_order, ids[i])
		m.removedextra_service_order[ids[i]] = struct{}{}
	}
}

// RemovedExtraServiceOrder returns the removed IDs of the "extra_service_order" edge to the ExtraServiceOrder entity.
func (m *MissionBatchMutation) RemovedExtraServiceOrderIDs() (ids []int64) {
	for id := range m.removedextra_service_order {
		ids = append(ids, id)
	}
	return
}

// ExtraServiceOrderIDs returns the "extra_service_order" edge IDs in the mutation.
func (m *MissionBatchMutation) ExtraServiceOrderIDs() (ids []int64) {
	for id := range m.extra_service_order {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServiceOrder resets all changes to the "extra_service_order" edge.
func (m *MissionBatchMutation) ResetExtraServiceOrder() {
	m.extra_service_order = nil
	m.clearedextra_service_order = false
	m.removedextra_service_order = nil
}

// Where appends a list predicates to the MissionBatchMutation builder.
func (m *MissionBatchMutation) Where(ps ...predicate.MissionBatch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionBatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionBatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionBatch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionBatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionBatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionBatch).
func (m *MissionBatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionBatchMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, missionbatch.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionbatch.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionbatch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionbatch.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionbatch.FieldDeletedAt)
	}
	if m.number != nil {
		fields = append(fields, missionbatch.FieldNumber)
	}
	if m.user != nil {
		fields = append(fields, missionbatch.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionBatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionbatch.FieldCreatedBy:
		return m.CreatedBy()
	case missionbatch.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionbatch.FieldCreatedAt:
		return m.CreatedAt()
	case missionbatch.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionbatch.FieldDeletedAt:
		return m.DeletedAt()
	case missionbatch.FieldNumber:
		return m.Number()
	case missionbatch.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionBatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionbatch.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionbatch.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionbatch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionbatch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionbatch.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionbatch.FieldNumber:
		return m.OldNumber(ctx)
	case missionbatch.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown MissionBatch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionBatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionbatch.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionbatch.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionbatch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionbatch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionbatch.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionbatch.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case missionbatch.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionBatch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionBatchMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionbatch.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionbatch.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionBatchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionbatch.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionbatch.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionBatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionbatch.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionbatch.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MissionBatch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionBatchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionBatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionBatchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionBatch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionBatchMutation) ResetField(name string) error {
	switch name {
	case missionbatch.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionbatch.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionbatch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionbatch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionbatch.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionbatch.FieldNumber:
		m.ResetNumber()
		return nil
	case missionbatch.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown MissionBatch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionBatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, missionbatch.EdgeUser)
	}
	if m.mission_consume_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionConsumeOrders)
	}
	if m.missions != nil {
		edges = append(edges, missionbatch.EdgeMissions)
	}
	if m.mission_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionOrders)
	}
	if m.extra_service_order != nil {
		edges = append(edges, missionbatch.EdgeExtraServiceOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionBatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionbatch.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionbatch.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.mission_consume_orders))
		for id := range m.mission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.missions))
		for id := range m.missions {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.mission_orders))
		for id := range m.mission_orders {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeExtraServiceOrder:
		ids := make([]ent.Value, 0, len(m.extra_service_order))
		for id := range m.extra_service_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionBatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmission_consume_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionConsumeOrders)
	}
	if m.removedmissions != nil {
		edges = append(edges, missionbatch.EdgeMissions)
	}
	if m.removedmission_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionOrders)
	}
	if m.removedextra_service_order != nil {
		edges = append(edges, missionbatch.EdgeExtraServiceOrder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionBatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionbatch.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_consume_orders))
		for id := range m.removedmission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.removedmissions))
		for id := range m.removedmissions {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_orders))
		for id := range m.removedmission_orders {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeExtraServiceOrder:
		ids := make([]ent.Value, 0, len(m.removedextra_service_order))
		for id := range m.removedextra_service_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionBatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, missionbatch.EdgeUser)
	}
	if m.clearedmission_consume_orders {
		edges = append(edges, missionbatch.EdgeMissionConsumeOrders)
	}
	if m.clearedmissions {
		edges = append(edges, missionbatch.EdgeMissions)
	}
	if m.clearedmission_orders {
		edges = append(edges, missionbatch.EdgeMissionOrders)
	}
	if m.clearedextra_service_order {
		edges = append(edges, missionbatch.EdgeExtraServiceOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionBatchMutation) EdgeCleared(name string) bool {
	switch name {
	case missionbatch.EdgeUser:
		return m.cleareduser
	case missionbatch.EdgeMissionConsumeOrders:
		return m.clearedmission_consume_orders
	case missionbatch.EdgeMissions:
		return m.clearedmissions
	case missionbatch.EdgeMissionOrders:
		return m.clearedmission_orders
	case missionbatch.EdgeExtraServiceOrder:
		return m.clearedextra_service_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionBatchMutation) ClearEdge(name string) error {
	switch name {
	case missionbatch.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown MissionBatch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionBatchMutation) ResetEdge(name string) error {
	switch name {
	case missionbatch.EdgeUser:
		m.ResetUser()
		return nil
	case missionbatch.EdgeMissionConsumeOrders:
		m.ResetMissionConsumeOrders()
		return nil
	case missionbatch.EdgeMissions:
		m.ResetMissions()
		return nil
	case missionbatch.EdgeMissionOrders:
		m.ResetMissionOrders()
		return nil
	case missionbatch.EdgeExtraServiceOrder:
		m.ResetExtraServiceOrder()
		return nil
	}
	return fmt.Errorf("unknown MissionBatch edge %s", name)
}

// MissionCategoryMutation represents an operation that mutates the MissionCategory nodes in the graph.
type MissionCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	category      *string
	_type         *enums.CategoryType
	weight        *int
	addweight     *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MissionCategory, error)
	predicates    []predicate.MissionCategory
}

var _ ent.Mutation = (*MissionCategoryMutation)(nil)

// missioncategoryOption allows management of the mutation configuration using functional options.
type missioncategoryOption func(*MissionCategoryMutation)

// newMissionCategoryMutation creates new mutation for the MissionCategory entity.
func newMissionCategoryMutation(c config, op Op, opts ...missioncategoryOption) *MissionCategoryMutation {
	m := &MissionCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionCategoryID sets the ID field of the mutation.
func withMissionCategoryID(id int64) missioncategoryOption {
	return func(m *MissionCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionCategory
		)
		m.oldValue = func(ctx context.Context) (*MissionCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionCategory sets the old MissionCategory of the mutation.
func withMissionCategory(node *MissionCategory) missioncategoryOption {
	return func(m *MissionCategoryMutation) {
		m.oldValue = func(context.Context) (*MissionCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionCategory entities.
func (m *MissionCategoryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionCategoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionCategoryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionCategoryMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionCategoryMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionCategory entity.
// If the MissionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionCategoryMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionCategoryMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionCategoryMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionCategoryMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionCategoryMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionCategoryMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionCategory entity.
// If the MissionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionCategoryMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionCategoryMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionCategoryMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionCategoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionCategory entity.
// If the MissionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionCategory entity.
// If the MissionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionCategory entity.
// If the MissionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionCategoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetCategory sets the "category" field.
func (m *MissionCategoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *MissionCategoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the MissionCategory entity.
// If the MissionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionCategoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MissionCategoryMutation) ResetCategory() {
	m.category = nil
}

// SetType sets the "type" field.
func (m *MissionCategoryMutation) SetType(et enums.CategoryType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionCategoryMutation) GetType() (r enums.CategoryType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionCategory entity.
// If the MissionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionCategoryMutation) OldType(ctx context.Context) (v enums.CategoryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionCategoryMutation) ResetType() {
	m._type = nil
}

// SetWeight sets the "weight" field.
func (m *MissionCategoryMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *MissionCategoryMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the MissionCategory entity.
// If the MissionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionCategoryMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *MissionCategoryMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *MissionCategoryMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *MissionCategoryMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// Where appends a list predicates to the MissionCategoryMutation builder.
func (m *MissionCategoryMutation) Where(ps ...predicate.MissionCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionCategory).
func (m *MissionCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionCategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, missioncategory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missioncategory.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missioncategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missioncategory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missioncategory.FieldDeletedAt)
	}
	if m.category != nil {
		fields = append(fields, missioncategory.FieldCategory)
	}
	if m._type != nil {
		fields = append(fields, missioncategory.FieldType)
	}
	if m.weight != nil {
		fields = append(fields, missioncategory.FieldWeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missioncategory.FieldCreatedBy:
		return m.CreatedBy()
	case missioncategory.FieldUpdatedBy:
		return m.UpdatedBy()
	case missioncategory.FieldCreatedAt:
		return m.CreatedAt()
	case missioncategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case missioncategory.FieldDeletedAt:
		return m.DeletedAt()
	case missioncategory.FieldCategory:
		return m.Category()
	case missioncategory.FieldType:
		return m.GetType()
	case missioncategory.FieldWeight:
		return m.Weight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missioncategory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missioncategory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missioncategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missioncategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missioncategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missioncategory.FieldCategory:
		return m.OldCategory(ctx)
	case missioncategory.FieldType:
		return m.OldType(ctx)
	case missioncategory.FieldWeight:
		return m.OldWeight(ctx)
	}
	return nil, fmt.Errorf("unknown MissionCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missioncategory.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missioncategory.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missioncategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missioncategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missioncategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missioncategory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case missioncategory.FieldType:
		v, ok := value.(enums.CategoryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missioncategory.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	}
	return fmt.Errorf("unknown MissionCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missioncategory.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missioncategory.FieldUpdatedBy)
	}
	if m.addweight != nil {
		fields = append(fields, missioncategory.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missioncategory.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missioncategory.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missioncategory.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missioncategory.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missioncategory.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missioncategory.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown MissionCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionCategoryMutation) ResetField(name string) error {
	switch name {
	case missioncategory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missioncategory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missioncategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missioncategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missioncategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missioncategory.FieldCategory:
		m.ResetCategory()
		return nil
	case missioncategory.FieldType:
		m.ResetType()
		return nil
	case missioncategory.FieldWeight:
		m.ResetWeight()
		return nil
	}
	return fmt.Errorf("unknown MissionCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MissionCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MissionCategory edge %s", name)
}

// MissionConsumeOrderMutation represents an operation that mutates the MissionConsumeOrder nodes in the graph.
type MissionConsumeOrderMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	status                        *enums.MissionOrderStatus
	pure_cep                      *int64
	addpure_cep                   *int64
	gift_cep                      *int64
	addgift_cep                   *int64
	_type                         *enums.MissionType
	is_time                       *bool
	call_way                      *enums.MissionCallWay
	serial_number                 *string
	started_at                    *time.Time
	finished_at                   *time.Time
	mission_batch_number          *string
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	cost_bills                    map[int64]struct{}
	removedcost_bills             map[int64]struct{}
	clearedcost_bills             bool
	mission_produce_orders        map[int64]struct{}
	removedmission_produce_orders map[int64]struct{}
	clearedmission_produce_orders bool
	mission_batch                 *int64
	clearedmission_batch          bool
	mission                       *int64
	clearedmission                bool
	done                          bool
	oldValue                      func(context.Context) (*MissionConsumeOrder, error)
	predicates                    []predicate.MissionConsumeOrder
}

var _ ent.Mutation = (*MissionConsumeOrderMutation)(nil)

// missionconsumeorderOption allows management of the mutation configuration using functional options.
type missionconsumeorderOption func(*MissionConsumeOrderMutation)

// newMissionConsumeOrderMutation creates new mutation for the MissionConsumeOrder entity.
func newMissionConsumeOrderMutation(c config, op Op, opts ...missionconsumeorderOption) *MissionConsumeOrderMutation {
	m := &MissionConsumeOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionConsumeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionConsumeOrderID sets the ID field of the mutation.
func withMissionConsumeOrderID(id int64) missionconsumeorderOption {
	return func(m *MissionConsumeOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionConsumeOrder
		)
		m.oldValue = func(ctx context.Context) (*MissionConsumeOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionConsumeOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionConsumeOrder sets the old MissionConsumeOrder of the mutation.
func withMissionConsumeOrder(node *MissionConsumeOrder) missionconsumeorderOption {
	return func(m *MissionConsumeOrderMutation) {
		m.oldValue = func(context.Context) (*MissionConsumeOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionConsumeOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionConsumeOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionConsumeOrder entities.
func (m *MissionConsumeOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionConsumeOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionConsumeOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionConsumeOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionConsumeOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionConsumeOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionConsumeOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionConsumeOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionConsumeOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionConsumeOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionConsumeOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionConsumeOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionConsumeOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionConsumeOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionConsumeOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionConsumeOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionConsumeOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionConsumeOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionConsumeOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionConsumeOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionConsumeOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionConsumeOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionConsumeOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionConsumeOrderMutation) ResetUserID() {
	m.user = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionConsumeOrderMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionConsumeOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionConsumeOrderMutation) ResetMissionID() {
	m.mission = nil
}

// SetStatus sets the "status" field.
func (m *MissionConsumeOrderMutation) SetStatus(eos enums.MissionOrderStatus) {
	m.status = &eos
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionConsumeOrderMutation) Status() (r enums.MissionOrderStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldStatus(ctx context.Context) (v enums.MissionOrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionConsumeOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *MissionConsumeOrderMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *MissionConsumeOrderMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *MissionConsumeOrderMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *MissionConsumeOrderMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *MissionConsumeOrderMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *MissionConsumeOrderMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *MissionConsumeOrderMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *MissionConsumeOrderMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetType sets the "type" field.
func (m *MissionConsumeOrderMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionConsumeOrderMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionConsumeOrderMutation) ResetType() {
	m._type = nil
}

// SetIsTime sets the "is_time" field.
func (m *MissionConsumeOrderMutation) SetIsTime(b bool) {
	m.is_time = &b
}

// IsTime returns the value of the "is_time" field in the mutation.
func (m *MissionConsumeOrderMutation) IsTime() (r bool, exists bool) {
	v := m.is_time
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTime returns the old "is_time" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldIsTime(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTime: %w", err)
	}
	return oldValue.IsTime, nil
}

// ResetIsTime resets all changes to the "is_time" field.
func (m *MissionConsumeOrderMutation) ResetIsTime() {
	m.is_time = nil
}

// SetCallWay sets the "call_way" field.
func (m *MissionConsumeOrderMutation) SetCallWay(ecw enums.MissionCallWay) {
	m.call_way = &ecw
}

// CallWay returns the value of the "call_way" field in the mutation.
func (m *MissionConsumeOrderMutation) CallWay() (r enums.MissionCallWay, exists bool) {
	v := m.call_way
	if v == nil {
		return
	}
	return *v, true
}

// OldCallWay returns the old "call_way" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldCallWay(ctx context.Context) (v enums.MissionCallWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallWay: %w", err)
	}
	return oldValue.CallWay, nil
}

// ResetCallWay resets all changes to the "call_way" field.
func (m *MissionConsumeOrderMutation) ResetCallWay() {
	m.call_way = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *MissionConsumeOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MissionConsumeOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MissionConsumeOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionConsumeOrderMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionConsumeOrderMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionConsumeOrderMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionConsumeOrderMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionConsumeOrderMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionConsumeOrderMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetMissionBatchID sets the "mission_batch_id" field.
func (m *MissionConsumeOrderMutation) SetMissionBatchID(i int64) {
	m.mission_batch = &i
}

// MissionBatchID returns the value of the "mission_batch_id" field in the mutation.
func (m *MissionConsumeOrderMutation) MissionBatchID() (r int64, exists bool) {
	v := m.mission_batch
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchID returns the old "mission_batch_id" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldMissionBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchID: %w", err)
	}
	return oldValue.MissionBatchID, nil
}

// ResetMissionBatchID resets all changes to the "mission_batch_id" field.
func (m *MissionConsumeOrderMutation) ResetMissionBatchID() {
	m.mission_batch = nil
}

// SetMissionBatchNumber sets the "mission_batch_number" field.
func (m *MissionConsumeOrderMutation) SetMissionBatchNumber(s string) {
	m.mission_batch_number = &s
}

// MissionBatchNumber returns the value of the "mission_batch_number" field in the mutation.
func (m *MissionConsumeOrderMutation) MissionBatchNumber() (r string, exists bool) {
	v := m.mission_batch_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchNumber returns the old "mission_batch_number" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldMissionBatchNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchNumber: %w", err)
	}
	return oldValue.MissionBatchNumber, nil
}

// ResetMissionBatchNumber resets all changes to the "mission_batch_number" field.
func (m *MissionConsumeOrderMutation) ResetMissionBatchNumber() {
	m.mission_batch_number = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionConsumeOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionconsumeorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionConsumeOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionConsumeOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionConsumeOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *MissionConsumeOrderMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *MissionConsumeOrderMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *MissionConsumeOrderMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *MissionConsumeOrderMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *MissionConsumeOrderMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *MissionConsumeOrderMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *MissionConsumeOrderMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *MissionConsumeOrderMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionConsumeOrderMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *MissionConsumeOrderMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *MissionConsumeOrderMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionConsumeOrderMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *MissionConsumeOrderMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *MissionConsumeOrderMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// ClearMissionBatch clears the "mission_batch" edge to the MissionBatch entity.
func (m *MissionConsumeOrderMutation) ClearMissionBatch() {
	m.clearedmission_batch = true
	m.clearedFields[missionconsumeorder.FieldMissionBatchID] = struct{}{}
}

// MissionBatchCleared reports if the "mission_batch" edge to the MissionBatch entity was cleared.
func (m *MissionConsumeOrderMutation) MissionBatchCleared() bool {
	return m.clearedmission_batch
}

// MissionBatchIDs returns the "mission_batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionBatchID instead. It exists only for internal usage by the builders.
func (m *MissionConsumeOrderMutation) MissionBatchIDs() (ids []int64) {
	if id := m.mission_batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionBatch resets all changes to the "mission_batch" edge.
func (m *MissionConsumeOrderMutation) ResetMissionBatch() {
	m.mission_batch = nil
	m.clearedmission_batch = false
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionConsumeOrderMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionconsumeorder.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionConsumeOrderMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionConsumeOrderMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionConsumeOrderMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// Where appends a list predicates to the MissionConsumeOrderMutation builder.
func (m *MissionConsumeOrderMutation) Where(ps ...predicate.MissionConsumeOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionConsumeOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionConsumeOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionConsumeOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionConsumeOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionConsumeOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionConsumeOrder).
func (m *MissionConsumeOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionConsumeOrderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_by != nil {
		fields = append(fields, missionconsumeorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionconsumeorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionconsumeorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionconsumeorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionconsumeorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, missionconsumeorder.FieldUserID)
	}
	if m.mission != nil {
		fields = append(fields, missionconsumeorder.FieldMissionID)
	}
	if m.status != nil {
		fields = append(fields, missionconsumeorder.FieldStatus)
	}
	if m.pure_cep != nil {
		fields = append(fields, missionconsumeorder.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, missionconsumeorder.FieldGiftCep)
	}
	if m._type != nil {
		fields = append(fields, missionconsumeorder.FieldType)
	}
	if m.is_time != nil {
		fields = append(fields, missionconsumeorder.FieldIsTime)
	}
	if m.call_way != nil {
		fields = append(fields, missionconsumeorder.FieldCallWay)
	}
	if m.serial_number != nil {
		fields = append(fields, missionconsumeorder.FieldSerialNumber)
	}
	if m.started_at != nil {
		fields = append(fields, missionconsumeorder.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionconsumeorder.FieldFinishedAt)
	}
	if m.mission_batch != nil {
		fields = append(fields, missionconsumeorder.FieldMissionBatchID)
	}
	if m.mission_batch_number != nil {
		fields = append(fields, missionconsumeorder.FieldMissionBatchNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionConsumeOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		return m.CreatedBy()
	case missionconsumeorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionconsumeorder.FieldCreatedAt:
		return m.CreatedAt()
	case missionconsumeorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionconsumeorder.FieldDeletedAt:
		return m.DeletedAt()
	case missionconsumeorder.FieldUserID:
		return m.UserID()
	case missionconsumeorder.FieldMissionID:
		return m.MissionID()
	case missionconsumeorder.FieldStatus:
		return m.Status()
	case missionconsumeorder.FieldPureCep:
		return m.PureCep()
	case missionconsumeorder.FieldGiftCep:
		return m.GiftCep()
	case missionconsumeorder.FieldType:
		return m.GetType()
	case missionconsumeorder.FieldIsTime:
		return m.IsTime()
	case missionconsumeorder.FieldCallWay:
		return m.CallWay()
	case missionconsumeorder.FieldSerialNumber:
		return m.SerialNumber()
	case missionconsumeorder.FieldStartedAt:
		return m.StartedAt()
	case missionconsumeorder.FieldFinishedAt:
		return m.FinishedAt()
	case missionconsumeorder.FieldMissionBatchID:
		return m.MissionBatchID()
	case missionconsumeorder.FieldMissionBatchNumber:
		return m.MissionBatchNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionConsumeOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionconsumeorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionconsumeorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionconsumeorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionconsumeorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionconsumeorder.FieldUserID:
		return m.OldUserID(ctx)
	case missionconsumeorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionconsumeorder.FieldStatus:
		return m.OldStatus(ctx)
	case missionconsumeorder.FieldPureCep:
		return m.OldPureCep(ctx)
	case missionconsumeorder.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case missionconsumeorder.FieldType:
		return m.OldType(ctx)
	case missionconsumeorder.FieldIsTime:
		return m.OldIsTime(ctx)
	case missionconsumeorder.FieldCallWay:
		return m.OldCallWay(ctx)
	case missionconsumeorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case missionconsumeorder.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionconsumeorder.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionconsumeorder.FieldMissionBatchID:
		return m.OldMissionBatchID(ctx)
	case missionconsumeorder.FieldMissionBatchNumber:
		return m.OldMissionBatchNumber(ctx)
	}
	return nil, fmt.Errorf("unknown MissionConsumeOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionConsumeOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionconsumeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionconsumeorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionconsumeorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionconsumeorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionconsumeorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case missionconsumeorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionconsumeorder.FieldStatus:
		v, ok := value.(enums.MissionOrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case missionconsumeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case missionconsumeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case missionconsumeorder.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionconsumeorder.FieldIsTime:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTime(v)
		return nil
	case missionconsumeorder.FieldCallWay:
		v, ok := value.(enums.MissionCallWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallWay(v)
		return nil
	case missionconsumeorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case missionconsumeorder.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionconsumeorder.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionconsumeorder.FieldMissionBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchID(v)
		return nil
	case missionconsumeorder.FieldMissionBatchNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchNumber(v)
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionConsumeOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionconsumeorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionconsumeorder.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, missionconsumeorder.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, missionconsumeorder.FieldGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionConsumeOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionconsumeorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionconsumeorder.FieldPureCep:
		return m.AddedPureCep()
	case missionconsumeorder.FieldGiftCep:
		return m.AddedGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionConsumeOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionconsumeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionconsumeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case missionconsumeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionConsumeOrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionConsumeOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionConsumeOrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionConsumeOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionConsumeOrderMutation) ResetField(name string) error {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionconsumeorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionconsumeorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionconsumeorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionconsumeorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionconsumeorder.FieldUserID:
		m.ResetUserID()
		return nil
	case missionconsumeorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionconsumeorder.FieldStatus:
		m.ResetStatus()
		return nil
	case missionconsumeorder.FieldPureCep:
		m.ResetPureCep()
		return nil
	case missionconsumeorder.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case missionconsumeorder.FieldType:
		m.ResetType()
		return nil
	case missionconsumeorder.FieldIsTime:
		m.ResetIsTime()
		return nil
	case missionconsumeorder.FieldCallWay:
		m.ResetCallWay()
		return nil
	case missionconsumeorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case missionconsumeorder.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionconsumeorder.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionconsumeorder.FieldMissionBatchID:
		m.ResetMissionBatchID()
		return nil
	case missionconsumeorder.FieldMissionBatchNumber:
		m.ResetMissionBatchNumber()
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionConsumeOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, missionconsumeorder.EdgeUser)
	}
	if m.cost_bills != nil {
		edges = append(edges, missionconsumeorder.EdgeCostBills)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, missionconsumeorder.EdgeMissionProduceOrders)
	}
	if m.mission_batch != nil {
		edges = append(edges, missionconsumeorder.EdgeMissionBatch)
	}
	if m.mission != nil {
		edges = append(edges, missionconsumeorder.EdgeMission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionConsumeOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionconsumeorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionconsumeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case missionconsumeorder.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case missionconsumeorder.EdgeMissionBatch:
		if id := m.mission_batch; id != nil {
			return []ent.Value{*id}
		}
	case missionconsumeorder.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionConsumeOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcost_bills != nil {
		edges = append(edges, missionconsumeorder.EdgeCostBills)
	}
	if m.removedmission_produce_orders != nil {
		edges = append(edges, missionconsumeorder.EdgeMissionProduceOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionConsumeOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionconsumeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	case missionconsumeorder.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionConsumeOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, missionconsumeorder.EdgeUser)
	}
	if m.clearedcost_bills {
		edges = append(edges, missionconsumeorder.EdgeCostBills)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, missionconsumeorder.EdgeMissionProduceOrders)
	}
	if m.clearedmission_batch {
		edges = append(edges, missionconsumeorder.EdgeMissionBatch)
	}
	if m.clearedmission {
		edges = append(edges, missionconsumeorder.EdgeMission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionConsumeOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case missionconsumeorder.EdgeUser:
		return m.cleareduser
	case missionconsumeorder.EdgeCostBills:
		return m.clearedcost_bills
	case missionconsumeorder.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case missionconsumeorder.EdgeMissionBatch:
		return m.clearedmission_batch
	case missionconsumeorder.EdgeMission:
		return m.clearedmission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionConsumeOrderMutation) ClearEdge(name string) error {
	switch name {
	case missionconsumeorder.EdgeUser:
		m.ClearUser()
		return nil
	case missionconsumeorder.EdgeMissionBatch:
		m.ClearMissionBatch()
		return nil
	case missionconsumeorder.EdgeMission:
		m.ClearMission()
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionConsumeOrderMutation) ResetEdge(name string) error {
	switch name {
	case missionconsumeorder.EdgeUser:
		m.ResetUser()
		return nil
	case missionconsumeorder.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case missionconsumeorder.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case missionconsumeorder.EdgeMissionBatch:
		m.ResetMissionBatch()
		return nil
	case missionconsumeorder.EdgeMission:
		m.ResetMission()
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder edge %s", name)
}

// MissionExtraServiceMutation represents an operation that mutates the MissionExtraService nodes in the graph.
type MissionExtraServiceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_by           *int64
	addcreated_by        *int64
	updated_by           *int64
	addupdated_by        *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	clearedFields        map[string]struct{}
	mission              *int64
	clearedmission       bool
	extra_service        *int64
	clearedextra_service bool
	done                 bool
	oldValue             func(context.Context) (*MissionExtraService, error)
	predicates           []predicate.MissionExtraService
}

var _ ent.Mutation = (*MissionExtraServiceMutation)(nil)

// missionextraserviceOption allows management of the mutation configuration using functional options.
type missionextraserviceOption func(*MissionExtraServiceMutation)

// newMissionExtraServiceMutation creates new mutation for the MissionExtraService entity.
func newMissionExtraServiceMutation(c config, op Op, opts ...missionextraserviceOption) *MissionExtraServiceMutation {
	m := &MissionExtraServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionExtraService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionExtraServiceID sets the ID field of the mutation.
func withMissionExtraServiceID(id int64) missionextraserviceOption {
	return func(m *MissionExtraServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionExtraService
		)
		m.oldValue = func(ctx context.Context) (*MissionExtraService, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionExtraService.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionExtraService sets the old MissionExtraService of the mutation.
func withMissionExtraService(node *MissionExtraService) missionextraserviceOption {
	return func(m *MissionExtraServiceMutation) {
		m.oldValue = func(context.Context) (*MissionExtraService, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionExtraServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionExtraServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionExtraService entities.
func (m *MissionExtraServiceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionExtraServiceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionExtraServiceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionExtraService.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionExtraServiceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionExtraServiceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionExtraServiceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionExtraServiceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionExtraServiceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionExtraServiceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionExtraServiceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionExtraServiceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionExtraServiceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionExtraServiceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionExtraServiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionExtraServiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionExtraServiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionExtraServiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionExtraServiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionExtraServiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionExtraServiceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionExtraServiceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionExtraServiceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionExtraServiceMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionExtraServiceMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionExtraServiceMutation) ResetMissionID() {
	m.mission = nil
}

// SetExtraServiceID sets the "extra_service_id" field.
func (m *MissionExtraServiceMutation) SetExtraServiceID(i int64) {
	m.extra_service = &i
}

// ExtraServiceID returns the value of the "extra_service_id" field in the mutation.
func (m *MissionExtraServiceMutation) ExtraServiceID() (r int64, exists bool) {
	v := m.extra_service
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceID returns the old "extra_service_id" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldExtraServiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceID: %w", err)
	}
	return oldValue.ExtraServiceID, nil
}

// ResetExtraServiceID resets all changes to the "extra_service_id" field.
func (m *MissionExtraServiceMutation) ResetExtraServiceID() {
	m.extra_service = nil
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionExtraServiceMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionextraservice.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionExtraServiceMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionExtraServiceMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionExtraServiceMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearExtraService clears the "extra_service" edge to the ExtraService entity.
func (m *MissionExtraServiceMutation) ClearExtraService() {
	m.clearedextra_service = true
	m.clearedFields[missionextraservice.FieldExtraServiceID] = struct{}{}
}

// ExtraServiceCleared reports if the "extra_service" edge to the ExtraService entity was cleared.
func (m *MissionExtraServiceMutation) ExtraServiceCleared() bool {
	return m.clearedextra_service
}

// ExtraServiceIDs returns the "extra_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExtraServiceID instead. It exists only for internal usage by the builders.
func (m *MissionExtraServiceMutation) ExtraServiceIDs() (ids []int64) {
	if id := m.extra_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExtraService resets all changes to the "extra_service" edge.
func (m *MissionExtraServiceMutation) ResetExtraService() {
	m.extra_service = nil
	m.clearedextra_service = false
}

// Where appends a list predicates to the MissionExtraServiceMutation builder.
func (m *MissionExtraServiceMutation) Where(ps ...predicate.MissionExtraService) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionExtraServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionExtraServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionExtraService, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionExtraServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionExtraServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionExtraService).
func (m *MissionExtraServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionExtraServiceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, missionextraservice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionextraservice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionextraservice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionextraservice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionextraservice.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, missionextraservice.FieldMissionID)
	}
	if m.extra_service != nil {
		fields = append(fields, missionextraservice.FieldExtraServiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionExtraServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionextraservice.FieldCreatedBy:
		return m.CreatedBy()
	case missionextraservice.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionextraservice.FieldCreatedAt:
		return m.CreatedAt()
	case missionextraservice.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionextraservice.FieldDeletedAt:
		return m.DeletedAt()
	case missionextraservice.FieldMissionID:
		return m.MissionID()
	case missionextraservice.FieldExtraServiceID:
		return m.ExtraServiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionExtraServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionextraservice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionextraservice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionextraservice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionextraservice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionextraservice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionextraservice.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionextraservice.FieldExtraServiceID:
		return m.OldExtraServiceID(ctx)
	}
	return nil, fmt.Errorf("unknown MissionExtraService field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionExtraServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionextraservice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionextraservice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionextraservice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionextraservice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionextraservice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionextraservice.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionextraservice.FieldExtraServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionExtraServiceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionextraservice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionextraservice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionExtraServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionextraservice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionextraservice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionExtraServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionextraservice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionextraservice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionExtraServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionExtraServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionExtraServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionExtraService nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionExtraServiceMutation) ResetField(name string) error {
	switch name {
	case missionextraservice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionextraservice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionextraservice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionextraservice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionextraservice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionextraservice.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionextraservice.FieldExtraServiceID:
		m.ResetExtraServiceID()
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionExtraServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mission != nil {
		edges = append(edges, missionextraservice.EdgeMission)
	}
	if m.extra_service != nil {
		edges = append(edges, missionextraservice.EdgeExtraService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionExtraServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionextraservice.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case missionextraservice.EdgeExtraService:
		if id := m.extra_service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionExtraServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionExtraServiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionExtraServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmission {
		edges = append(edges, missionextraservice.EdgeMission)
	}
	if m.clearedextra_service {
		edges = append(edges, missionextraservice.EdgeExtraService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionExtraServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case missionextraservice.EdgeMission:
		return m.clearedmission
	case missionextraservice.EdgeExtraService:
		return m.clearedextra_service
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionExtraServiceMutation) ClearEdge(name string) error {
	switch name {
	case missionextraservice.EdgeMission:
		m.ClearMission()
		return nil
	case missionextraservice.EdgeExtraService:
		m.ClearExtraService()
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionExtraServiceMutation) ResetEdge(name string) error {
	switch name {
	case missionextraservice.EdgeMission:
		m.ResetMission()
		return nil
	case missionextraservice.EdgeExtraService:
		m.ResetExtraService()
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService edge %s", name)
}

// MissionFailedFeedbackMutation represents an operation that mutates the MissionFailedFeedback nodes in the graph.
type MissionFailedFeedbackMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_by     *int64
	addcreated_by  *int64
	updated_by     *int64
	addupdated_by  *int64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	_type          *enums.MissionFailedFeedbackType
	mission_name   *string
	status         *enums.MissionFailedFeedbackStatus
	reason         *string
	clearedFields  map[string]struct{}
	user           *int64
	cleareduser    bool
	device         *int64
	cleareddevice  bool
	mission        *int64
	clearedmission bool
	done           bool
	oldValue       func(context.Context) (*MissionFailedFeedback, error)
	predicates     []predicate.MissionFailedFeedback
}

var _ ent.Mutation = (*MissionFailedFeedbackMutation)(nil)

// missionfailedfeedbackOption allows management of the mutation configuration using functional options.
type missionfailedfeedbackOption func(*MissionFailedFeedbackMutation)

// newMissionFailedFeedbackMutation creates new mutation for the MissionFailedFeedback entity.
func newMissionFailedFeedbackMutation(c config, op Op, opts ...missionfailedfeedbackOption) *MissionFailedFeedbackMutation {
	m := &MissionFailedFeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionFailedFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionFailedFeedbackID sets the ID field of the mutation.
func withMissionFailedFeedbackID(id int64) missionfailedfeedbackOption {
	return func(m *MissionFailedFeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionFailedFeedback
		)
		m.oldValue = func(ctx context.Context) (*MissionFailedFeedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionFailedFeedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionFailedFeedback sets the old MissionFailedFeedback of the mutation.
func withMissionFailedFeedback(node *MissionFailedFeedback) missionfailedfeedbackOption {
	return func(m *MissionFailedFeedbackMutation) {
		m.oldValue = func(context.Context) (*MissionFailedFeedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionFailedFeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionFailedFeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionFailedFeedback entities.
func (m *MissionFailedFeedbackMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionFailedFeedbackMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionFailedFeedbackMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionFailedFeedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionFailedFeedbackMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionFailedFeedbackMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionFailedFeedbackMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionFailedFeedbackMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionFailedFeedbackMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionFailedFeedbackMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionFailedFeedbackMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionFailedFeedbackMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionFailedFeedbackMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionFailedFeedbackMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionFailedFeedbackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionFailedFeedbackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionFailedFeedbackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionFailedFeedbackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionFailedFeedbackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionFailedFeedbackMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionFailedFeedbackMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionFailedFeedbackMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionFailedFeedbackMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionFailedFeedbackMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionFailedFeedbackMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionFailedFeedbackMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionFailedFeedbackMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionFailedFeedbackMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionFailedFeedbackMutation) ResetDeviceID() {
	m.device = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionFailedFeedbackMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionFailedFeedbackMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionFailedFeedbackMutation) ResetMissionID() {
	m.mission = nil
}

// SetType sets the "type" field.
func (m *MissionFailedFeedbackMutation) SetType(efft enums.MissionFailedFeedbackType) {
	m._type = &efft
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionFailedFeedbackMutation) GetType() (r enums.MissionFailedFeedbackType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldType(ctx context.Context) (v enums.MissionFailedFeedbackType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionFailedFeedbackMutation) ResetType() {
	m._type = nil
}

// SetMissionName sets the "mission_name" field.
func (m *MissionFailedFeedbackMutation) SetMissionName(s string) {
	m.mission_name = &s
}

// MissionName returns the value of the "mission_name" field in the mutation.
func (m *MissionFailedFeedbackMutation) MissionName() (r string, exists bool) {
	v := m.mission_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionName returns the old "mission_name" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldMissionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionName: %w", err)
	}
	return oldValue.MissionName, nil
}

// ResetMissionName resets all changes to the "mission_name" field.
func (m *MissionFailedFeedbackMutation) ResetMissionName() {
	m.mission_name = nil
}

// SetStatus sets the "status" field.
func (m *MissionFailedFeedbackMutation) SetStatus(effs enums.MissionFailedFeedbackStatus) {
	m.status = &effs
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionFailedFeedbackMutation) Status() (r enums.MissionFailedFeedbackStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldStatus(ctx context.Context) (v enums.MissionFailedFeedbackStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionFailedFeedbackMutation) ResetStatus() {
	m.status = nil
}

// SetReason sets the "reason" field.
func (m *MissionFailedFeedbackMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *MissionFailedFeedbackMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the MissionFailedFeedback entity.
// If the MissionFailedFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionFailedFeedbackMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *MissionFailedFeedbackMutation) ResetReason() {
	m.reason = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionFailedFeedbackMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionfailedfeedback.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionFailedFeedbackMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionFailedFeedbackMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionFailedFeedbackMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *MissionFailedFeedbackMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[missionfailedfeedback.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *MissionFailedFeedbackMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *MissionFailedFeedbackMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *MissionFailedFeedbackMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionFailedFeedbackMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionfailedfeedback.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionFailedFeedbackMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionFailedFeedbackMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionFailedFeedbackMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// Where appends a list predicates to the MissionFailedFeedbackMutation builder.
func (m *MissionFailedFeedbackMutation) Where(ps ...predicate.MissionFailedFeedback) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionFailedFeedbackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionFailedFeedbackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionFailedFeedback, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionFailedFeedbackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionFailedFeedbackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionFailedFeedback).
func (m *MissionFailedFeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionFailedFeedbackMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, missionfailedfeedback.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionfailedfeedback.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionfailedfeedback.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionfailedfeedback.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionfailedfeedback.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, missionfailedfeedback.FieldUserID)
	}
	if m.device != nil {
		fields = append(fields, missionfailedfeedback.FieldDeviceID)
	}
	if m.mission != nil {
		fields = append(fields, missionfailedfeedback.FieldMissionID)
	}
	if m._type != nil {
		fields = append(fields, missionfailedfeedback.FieldType)
	}
	if m.mission_name != nil {
		fields = append(fields, missionfailedfeedback.FieldMissionName)
	}
	if m.status != nil {
		fields = append(fields, missionfailedfeedback.FieldStatus)
	}
	if m.reason != nil {
		fields = append(fields, missionfailedfeedback.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionFailedFeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionfailedfeedback.FieldCreatedBy:
		return m.CreatedBy()
	case missionfailedfeedback.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionfailedfeedback.FieldCreatedAt:
		return m.CreatedAt()
	case missionfailedfeedback.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionfailedfeedback.FieldDeletedAt:
		return m.DeletedAt()
	case missionfailedfeedback.FieldUserID:
		return m.UserID()
	case missionfailedfeedback.FieldDeviceID:
		return m.DeviceID()
	case missionfailedfeedback.FieldMissionID:
		return m.MissionID()
	case missionfailedfeedback.FieldType:
		return m.GetType()
	case missionfailedfeedback.FieldMissionName:
		return m.MissionName()
	case missionfailedfeedback.FieldStatus:
		return m.Status()
	case missionfailedfeedback.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionFailedFeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionfailedfeedback.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionfailedfeedback.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionfailedfeedback.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionfailedfeedback.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionfailedfeedback.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionfailedfeedback.FieldUserID:
		return m.OldUserID(ctx)
	case missionfailedfeedback.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionfailedfeedback.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionfailedfeedback.FieldType:
		return m.OldType(ctx)
	case missionfailedfeedback.FieldMissionName:
		return m.OldMissionName(ctx)
	case missionfailedfeedback.FieldStatus:
		return m.OldStatus(ctx)
	case missionfailedfeedback.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown MissionFailedFeedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionFailedFeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionfailedfeedback.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionfailedfeedback.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionfailedfeedback.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionfailedfeedback.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionfailedfeedback.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionfailedfeedback.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case missionfailedfeedback.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionfailedfeedback.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionfailedfeedback.FieldType:
		v, ok := value.(enums.MissionFailedFeedbackType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionfailedfeedback.FieldMissionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionName(v)
		return nil
	case missionfailedfeedback.FieldStatus:
		v, ok := value.(enums.MissionFailedFeedbackStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case missionfailedfeedback.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown MissionFailedFeedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionFailedFeedbackMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionfailedfeedback.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionfailedfeedback.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionFailedFeedbackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionfailedfeedback.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionfailedfeedback.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionFailedFeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionfailedfeedback.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionfailedfeedback.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MissionFailedFeedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionFailedFeedbackMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionFailedFeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionFailedFeedbackMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionFailedFeedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionFailedFeedbackMutation) ResetField(name string) error {
	switch name {
	case missionfailedfeedback.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionfailedfeedback.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionfailedfeedback.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionfailedfeedback.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionfailedfeedback.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionfailedfeedback.FieldUserID:
		m.ResetUserID()
		return nil
	case missionfailedfeedback.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionfailedfeedback.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionfailedfeedback.FieldType:
		m.ResetType()
		return nil
	case missionfailedfeedback.FieldMissionName:
		m.ResetMissionName()
		return nil
	case missionfailedfeedback.FieldStatus:
		m.ResetStatus()
		return nil
	case missionfailedfeedback.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown MissionFailedFeedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionFailedFeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, missionfailedfeedback.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, missionfailedfeedback.EdgeDevice)
	}
	if m.mission != nil {
		edges = append(edges, missionfailedfeedback.EdgeMission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionFailedFeedbackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionfailedfeedback.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionfailedfeedback.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case missionfailedfeedback.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionFailedFeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionFailedFeedbackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionFailedFeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, missionfailedfeedback.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, missionfailedfeedback.EdgeDevice)
	}
	if m.clearedmission {
		edges = append(edges, missionfailedfeedback.EdgeMission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionFailedFeedbackMutation) EdgeCleared(name string) bool {
	switch name {
	case missionfailedfeedback.EdgeUser:
		return m.cleareduser
	case missionfailedfeedback.EdgeDevice:
		return m.cleareddevice
	case missionfailedfeedback.EdgeMission:
		return m.clearedmission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionFailedFeedbackMutation) ClearEdge(name string) error {
	switch name {
	case missionfailedfeedback.EdgeUser:
		m.ClearUser()
		return nil
	case missionfailedfeedback.EdgeDevice:
		m.ClearDevice()
		return nil
	case missionfailedfeedback.EdgeMission:
		m.ClearMission()
		return nil
	}
	return fmt.Errorf("unknown MissionFailedFeedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionFailedFeedbackMutation) ResetEdge(name string) error {
	switch name {
	case missionfailedfeedback.EdgeUser:
		m.ResetUser()
		return nil
	case missionfailedfeedback.EdgeDevice:
		m.ResetDevice()
		return nil
	case missionfailedfeedback.EdgeMission:
		m.ResetMission()
		return nil
	}
	return fmt.Errorf("unknown MissionFailedFeedback edge %s", name)
}

// MissionKeyPairMutation represents an operation that mutates the MissionKeyPair nodes in the graph.
type MissionKeyPairMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	started_at        *time.Time
	finished_at       *time.Time
	result            *enums.MissionResult
	device_id         *int64
	adddevice_id      *int64
	result_urls       *[]string
	appendresult_urls []string
	clearedFields     map[string]struct{}
	mission           *int64
	clearedmission    bool
	key_pair          *int64
	clearedkey_pair   bool
	done              bool
	oldValue          func(context.Context) (*MissionKeyPair, error)
	predicates        []predicate.MissionKeyPair
}

var _ ent.Mutation = (*MissionKeyPairMutation)(nil)

// missionkeypairOption allows management of the mutation configuration using functional options.
type missionkeypairOption func(*MissionKeyPairMutation)

// newMissionKeyPairMutation creates new mutation for the MissionKeyPair entity.
func newMissionKeyPairMutation(c config, op Op, opts ...missionkeypairOption) *MissionKeyPairMutation {
	m := &MissionKeyPairMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionKeyPair,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionKeyPairID sets the ID field of the mutation.
func withMissionKeyPairID(id int64) missionkeypairOption {
	return func(m *MissionKeyPairMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionKeyPair
		)
		m.oldValue = func(ctx context.Context) (*MissionKeyPair, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionKeyPair.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionKeyPair sets the old MissionKeyPair of the mutation.
func withMissionKeyPair(node *MissionKeyPair) missionkeypairOption {
	return func(m *MissionKeyPairMutation) {
		m.oldValue = func(context.Context) (*MissionKeyPair, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionKeyPairMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionKeyPairMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionKeyPair entities.
func (m *MissionKeyPairMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionKeyPairMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionKeyPairMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionKeyPair.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionKeyPairMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionKeyPairMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionKeyPairMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionKeyPairMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionKeyPairMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionKeyPairMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionKeyPairMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionKeyPairMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionKeyPairMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionKeyPairMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionKeyPairMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionKeyPairMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionKeyPairMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionKeyPairMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionKeyPairMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionKeyPairMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionKeyPairMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionKeyPairMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionKeyPairMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionKeyPairMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionKeyPairMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionKeyPairMutation) ResetMissionID() {
	m.mission = nil
}

// SetKeyPairID sets the "key_pair_id" field.
func (m *MissionKeyPairMutation) SetKeyPairID(i int64) {
	m.key_pair = &i
}

// KeyPairID returns the value of the "key_pair_id" field in the mutation.
func (m *MissionKeyPairMutation) KeyPairID() (r int64, exists bool) {
	v := m.key_pair
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPairID returns the old "key_pair_id" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldKeyPairID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPairID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPairID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPairID: %w", err)
	}
	return oldValue.KeyPairID, nil
}

// ResetKeyPairID resets all changes to the "key_pair_id" field.
func (m *MissionKeyPairMutation) ResetKeyPairID() {
	m.key_pair = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionKeyPairMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionKeyPairMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionKeyPairMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionKeyPairMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionKeyPairMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionKeyPairMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetResult sets the "result" field.
func (m *MissionKeyPairMutation) SetResult(er enums.MissionResult) {
	m.result = &er
}

// Result returns the value of the "result" field in the mutation.
func (m *MissionKeyPairMutation) Result() (r enums.MissionResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldResult(ctx context.Context) (v enums.MissionResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *MissionKeyPairMutation) ResetResult() {
	m.result = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionKeyPairMutation) SetDeviceID(i int64) {
	m.device_id = &i
	m.adddevice_id = nil
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionKeyPairMutation) DeviceID() (r int64, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// AddDeviceID adds i to the "device_id" field.
func (m *MissionKeyPairMutation) AddDeviceID(i int64) {
	if m.adddevice_id != nil {
		*m.adddevice_id += i
	} else {
		m.adddevice_id = &i
	}
}

// AddedDeviceID returns the value that was added to the "device_id" field in this mutation.
func (m *MissionKeyPairMutation) AddedDeviceID() (r int64, exists bool) {
	v := m.adddevice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionKeyPairMutation) ResetDeviceID() {
	m.device_id = nil
	m.adddevice_id = nil
}

// SetResultUrls sets the "result_urls" field.
func (m *MissionKeyPairMutation) SetResultUrls(s []string) {
	m.result_urls = &s
	m.appendresult_urls = nil
}

// ResultUrls returns the value of the "result_urls" field in the mutation.
func (m *MissionKeyPairMutation) ResultUrls() (r []string, exists bool) {
	v := m.result_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldResultUrls returns the old "result_urls" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldResultUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultUrls: %w", err)
	}
	return oldValue.ResultUrls, nil
}

// AppendResultUrls adds s to the "result_urls" field.
func (m *MissionKeyPairMutation) AppendResultUrls(s []string) {
	m.appendresult_urls = append(m.appendresult_urls, s...)
}

// AppendedResultUrls returns the list of values that were appended to the "result_urls" field in this mutation.
func (m *MissionKeyPairMutation) AppendedResultUrls() ([]string, bool) {
	if len(m.appendresult_urls) == 0 {
		return nil, false
	}
	return m.appendresult_urls, true
}

// ClearResultUrls clears the value of the "result_urls" field.
func (m *MissionKeyPairMutation) ClearResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	m.clearedFields[missionkeypair.FieldResultUrls] = struct{}{}
}

// ResultUrlsCleared returns if the "result_urls" field was cleared in this mutation.
func (m *MissionKeyPairMutation) ResultUrlsCleared() bool {
	_, ok := m.clearedFields[missionkeypair.FieldResultUrls]
	return ok
}

// ResetResultUrls resets all changes to the "result_urls" field.
func (m *MissionKeyPairMutation) ResetResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	delete(m.clearedFields, missionkeypair.FieldResultUrls)
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionKeyPairMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionkeypair.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionKeyPairMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionKeyPairMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionKeyPairMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearKeyPair clears the "key_pair" edge to the HmacKeyPair entity.
func (m *MissionKeyPairMutation) ClearKeyPair() {
	m.clearedkey_pair = true
	m.clearedFields[missionkeypair.FieldKeyPairID] = struct{}{}
}

// KeyPairCleared reports if the "key_pair" edge to the HmacKeyPair entity was cleared.
func (m *MissionKeyPairMutation) KeyPairCleared() bool {
	return m.clearedkey_pair
}

// KeyPairIDs returns the "key_pair" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeyPairID instead. It exists only for internal usage by the builders.
func (m *MissionKeyPairMutation) KeyPairIDs() (ids []int64) {
	if id := m.key_pair; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeyPair resets all changes to the "key_pair" edge.
func (m *MissionKeyPairMutation) ResetKeyPair() {
	m.key_pair = nil
	m.clearedkey_pair = false
}

// Where appends a list predicates to the MissionKeyPairMutation builder.
func (m *MissionKeyPairMutation) Where(ps ...predicate.MissionKeyPair) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionKeyPairMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionKeyPairMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionKeyPair, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionKeyPairMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionKeyPairMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionKeyPair).
func (m *MissionKeyPairMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionKeyPairMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, missionkeypair.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionkeypair.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionkeypair.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionkeypair.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionkeypair.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, missionkeypair.FieldMissionID)
	}
	if m.key_pair != nil {
		fields = append(fields, missionkeypair.FieldKeyPairID)
	}
	if m.started_at != nil {
		fields = append(fields, missionkeypair.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionkeypair.FieldFinishedAt)
	}
	if m.result != nil {
		fields = append(fields, missionkeypair.FieldResult)
	}
	if m.device_id != nil {
		fields = append(fields, missionkeypair.FieldDeviceID)
	}
	if m.result_urls != nil {
		fields = append(fields, missionkeypair.FieldResultUrls)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionKeyPairMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionkeypair.FieldCreatedBy:
		return m.CreatedBy()
	case missionkeypair.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionkeypair.FieldCreatedAt:
		return m.CreatedAt()
	case missionkeypair.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionkeypair.FieldDeletedAt:
		return m.DeletedAt()
	case missionkeypair.FieldMissionID:
		return m.MissionID()
	case missionkeypair.FieldKeyPairID:
		return m.KeyPairID()
	case missionkeypair.FieldStartedAt:
		return m.StartedAt()
	case missionkeypair.FieldFinishedAt:
		return m.FinishedAt()
	case missionkeypair.FieldResult:
		return m.Result()
	case missionkeypair.FieldDeviceID:
		return m.DeviceID()
	case missionkeypair.FieldResultUrls:
		return m.ResultUrls()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionKeyPairMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionkeypair.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionkeypair.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionkeypair.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionkeypair.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionkeypair.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionkeypair.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionkeypair.FieldKeyPairID:
		return m.OldKeyPairID(ctx)
	case missionkeypair.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionkeypair.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionkeypair.FieldResult:
		return m.OldResult(ctx)
	case missionkeypair.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionkeypair.FieldResultUrls:
		return m.OldResultUrls(ctx)
	}
	return nil, fmt.Errorf("unknown MissionKeyPair field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKeyPairMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionkeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionkeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionkeypair.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionkeypair.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionkeypair.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionkeypair.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionkeypair.FieldKeyPairID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPairID(v)
		return nil
	case missionkeypair.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionkeypair.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionkeypair.FieldResult:
		v, ok := value.(enums.MissionResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case missionkeypair.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionkeypair.FieldResultUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultUrls(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionKeyPairMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionkeypair.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionkeypair.FieldUpdatedBy)
	}
	if m.adddevice_id != nil {
		fields = append(fields, missionkeypair.FieldDeviceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionKeyPairMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionkeypair.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionkeypair.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionkeypair.FieldDeviceID:
		return m.AddedDeviceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKeyPairMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionkeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionkeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionkeypair.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionKeyPairMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(missionkeypair.FieldResultUrls) {
		fields = append(fields, missionkeypair.FieldResultUrls)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionKeyPairMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionKeyPairMutation) ClearField(name string) error {
	switch name {
	case missionkeypair.FieldResultUrls:
		m.ClearResultUrls()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionKeyPairMutation) ResetField(name string) error {
	switch name {
	case missionkeypair.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionkeypair.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionkeypair.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionkeypair.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionkeypair.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionkeypair.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionkeypair.FieldKeyPairID:
		m.ResetKeyPairID()
		return nil
	case missionkeypair.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionkeypair.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionkeypair.FieldResult:
		m.ResetResult()
		return nil
	case missionkeypair.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionkeypair.FieldResultUrls:
		m.ResetResultUrls()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionKeyPairMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mission != nil {
		edges = append(edges, missionkeypair.EdgeMission)
	}
	if m.key_pair != nil {
		edges = append(edges, missionkeypair.EdgeKeyPair)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionKeyPairMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionkeypair.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case missionkeypair.EdgeKeyPair:
		if id := m.key_pair; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionKeyPairMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionKeyPairMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionKeyPairMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmission {
		edges = append(edges, missionkeypair.EdgeMission)
	}
	if m.clearedkey_pair {
		edges = append(edges, missionkeypair.EdgeKeyPair)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionKeyPairMutation) EdgeCleared(name string) bool {
	switch name {
	case missionkeypair.EdgeMission:
		return m.clearedmission
	case missionkeypair.EdgeKeyPair:
		return m.clearedkey_pair
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionKeyPairMutation) ClearEdge(name string) error {
	switch name {
	case missionkeypair.EdgeMission:
		m.ClearMission()
		return nil
	case missionkeypair.EdgeKeyPair:
		m.ClearKeyPair()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionKeyPairMutation) ResetEdge(name string) error {
	switch name {
	case missionkeypair.EdgeMission:
		m.ResetMission()
		return nil
	case missionkeypair.EdgeKeyPair:
		m.ResetKeyPair()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair edge %s", name)
}

// MissionKindMutation represents an operation that mutates the MissionKind nodes in the graph.
type MissionKindMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_by      *int64
	addcreated_by   *int64
	updated_by      *int64
	addupdated_by   *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	_type           *enums.MissionType
	category        *enums.MissionCategory
	billing_type    *enums.MissionBillingType
	clearedFields   map[string]struct{}
	missions        map[int64]struct{}
	removedmissions map[int64]struct{}
	clearedmissions bool
	done            bool
	oldValue        func(context.Context) (*MissionKind, error)
	predicates      []predicate.MissionKind
}

var _ ent.Mutation = (*MissionKindMutation)(nil)

// missionkindOption allows management of the mutation configuration using functional options.
type missionkindOption func(*MissionKindMutation)

// newMissionKindMutation creates new mutation for the MissionKind entity.
func newMissionKindMutation(c config, op Op, opts ...missionkindOption) *MissionKindMutation {
	m := &MissionKindMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionKind,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionKindID sets the ID field of the mutation.
func withMissionKindID(id int64) missionkindOption {
	return func(m *MissionKindMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionKind
		)
		m.oldValue = func(ctx context.Context) (*MissionKind, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionKind.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionKind sets the old MissionKind of the mutation.
func withMissionKind(node *MissionKind) missionkindOption {
	return func(m *MissionKindMutation) {
		m.oldValue = func(context.Context) (*MissionKind, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionKindMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionKindMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionKind entities.
func (m *MissionKindMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionKindMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionKindMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionKind.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionKindMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionKindMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionKindMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionKindMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionKindMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionKindMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionKindMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionKindMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionKindMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionKindMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionKindMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionKindMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionKindMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionKindMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionKindMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionKindMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionKindMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionKindMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionKindMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *MissionKindMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionKindMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionKindMutation) ResetType() {
	m._type = nil
}

// SetCategory sets the "category" field.
func (m *MissionKindMutation) SetCategory(ec enums.MissionCategory) {
	m.category = &ec
}

// Category returns the value of the "category" field in the mutation.
func (m *MissionKindMutation) Category() (r enums.MissionCategory, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldCategory(ctx context.Context) (v enums.MissionCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MissionKindMutation) ResetCategory() {
	m.category = nil
}

// SetBillingType sets the "billing_type" field.
func (m *MissionKindMutation) SetBillingType(ebt enums.MissionBillingType) {
	m.billing_type = &ebt
}

// BillingType returns the value of the "billing_type" field in the mutation.
func (m *MissionKindMutation) BillingType() (r enums.MissionBillingType, exists bool) {
	v := m.billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingType returns the old "billing_type" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingType: %w", err)
	}
	return oldValue.BillingType, nil
}

// ResetBillingType resets all changes to the "billing_type" field.
func (m *MissionKindMutation) ResetBillingType() {
	m.billing_type = nil
}

// AddMissionIDs adds the "missions" edge to the Mission entity by ids.
func (m *MissionKindMutation) AddMissionIDs(ids ...int64) {
	if m.missions == nil {
		m.missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.missions[ids[i]] = struct{}{}
	}
}

// ClearMissions clears the "missions" edge to the Mission entity.
func (m *MissionKindMutation) ClearMissions() {
	m.clearedmissions = true
}

// MissionsCleared reports if the "missions" edge to the Mission entity was cleared.
func (m *MissionKindMutation) MissionsCleared() bool {
	return m.clearedmissions
}

// RemoveMissionIDs removes the "missions" edge to the Mission entity by IDs.
func (m *MissionKindMutation) RemoveMissionIDs(ids ...int64) {
	if m.removedmissions == nil {
		m.removedmissions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.missions, ids[i])
		m.removedmissions[ids[i]] = struct{}{}
	}
}

// RemovedMissions returns the removed IDs of the "missions" edge to the Mission entity.
func (m *MissionKindMutation) RemovedMissionsIDs() (ids []int64) {
	for id := range m.removedmissions {
		ids = append(ids, id)
	}
	return
}

// MissionsIDs returns the "missions" edge IDs in the mutation.
func (m *MissionKindMutation) MissionsIDs() (ids []int64) {
	for id := range m.missions {
		ids = append(ids, id)
	}
	return
}

// ResetMissions resets all changes to the "missions" edge.
func (m *MissionKindMutation) ResetMissions() {
	m.missions = nil
	m.clearedmissions = false
	m.removedmissions = nil
}

// Where appends a list predicates to the MissionKindMutation builder.
func (m *MissionKindMutation) Where(ps ...predicate.MissionKind) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionKindMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionKindMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionKind, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionKindMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionKindMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionKind).
func (m *MissionKindMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionKindMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, missionkind.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionkind.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionkind.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionkind.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionkind.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, missionkind.FieldType)
	}
	if m.category != nil {
		fields = append(fields, missionkind.FieldCategory)
	}
	if m.billing_type != nil {
		fields = append(fields, missionkind.FieldBillingType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionKindMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionkind.FieldCreatedBy:
		return m.CreatedBy()
	case missionkind.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionkind.FieldCreatedAt:
		return m.CreatedAt()
	case missionkind.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionkind.FieldDeletedAt:
		return m.DeletedAt()
	case missionkind.FieldType:
		return m.GetType()
	case missionkind.FieldCategory:
		return m.Category()
	case missionkind.FieldBillingType:
		return m.BillingType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionKindMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionkind.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionkind.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionkind.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionkind.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionkind.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionkind.FieldType:
		return m.OldType(ctx)
	case missionkind.FieldCategory:
		return m.OldCategory(ctx)
	case missionkind.FieldBillingType:
		return m.OldBillingType(ctx)
	}
	return nil, fmt.Errorf("unknown MissionKind field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKindMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionkind.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionkind.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionkind.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionkind.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionkind.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionkind.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionkind.FieldCategory:
		v, ok := value.(enums.MissionCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case missionkind.FieldBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingType(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKind field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionKindMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionkind.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionkind.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionKindMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionkind.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionkind.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKindMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionkind.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionkind.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKind numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionKindMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionKindMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionKindMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionKind nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionKindMutation) ResetField(name string) error {
	switch name {
	case missionkind.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionkind.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionkind.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionkind.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionkind.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionkind.FieldType:
		m.ResetType()
		return nil
	case missionkind.FieldCategory:
		m.ResetCategory()
		return nil
	case missionkind.FieldBillingType:
		m.ResetBillingType()
		return nil
	}
	return fmt.Errorf("unknown MissionKind field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionKindMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.missions != nil {
		edges = append(edges, missionkind.EdgeMissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionKindMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionkind.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.missions))
		for id := range m.missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionKindMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmissions != nil {
		edges = append(edges, missionkind.EdgeMissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionKindMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionkind.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.removedmissions))
		for id := range m.removedmissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionKindMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmissions {
		edges = append(edges, missionkind.EdgeMissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionKindMutation) EdgeCleared(name string) bool {
	switch name {
	case missionkind.EdgeMissions:
		return m.clearedmissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionKindMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MissionKind unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionKindMutation) ResetEdge(name string) error {
	switch name {
	case missionkind.EdgeMissions:
		m.ResetMissions()
		return nil
	}
	return fmt.Errorf("unknown MissionKind edge %s", name)
}

// MissionOrderMutation represents an operation that mutates the MissionOrder nodes in the graph.
type MissionOrderMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	created_by                  *int64
	addcreated_by               *int64
	updated_by                  *int64
	addupdated_by               *int64
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	status                      *enums.MissionOrderStatus
	consume_amount              *int64
	addconsume_amount           *int64
	produce_amount              *int64
	addproduce_amount           *int64
	gas_amount                  *int64
	addgas_amount               *int64
	mission_type                *enums.MissionType
	mission_billing_type        *enums.MissionBillingType
	call_way                    *enums.MissionCallWay
	serial_number               *string
	started_at                  *time.Time
	finished_at                 *time.Time
	buy_duration                *int64
	addbuy_duration             *int64
	plan_started_at             *time.Time
	plan_finished_at            *time.Time
	expired_warning_time        *time.Time
	mission_batch_number        *string
	total_amount                *int64
	addtotal_amount             *int64
	settled_amount              *int64
	addsettled_amount           *int64
	settled_count               *int64
	addsettled_count            *int64
	total_settle_count          *int64
	addtotal_settle_count       *int64
	lately_settled_at           *time.Time
	clearedFields               map[string]struct{}
	consume_user                *int64
	clearedconsume_user         bool
	produce_user                *int64
	clearedproduce_user         bool
	symbol                      *int64
	clearedsymbol               bool
	bills                       map[int64]struct{}
	removedbills                map[int64]struct{}
	clearedbills                bool
	mission_batch               *int64
	clearedmission_batch        bool
	mission                     *int64
	clearedmission              bool
	device                      *int64
	cleareddevice               bool
	extra_service_orders        map[int64]struct{}
	removedextra_service_orders map[int64]struct{}
	clearedextra_service_orders bool
	done                        bool
	oldValue                    func(context.Context) (*MissionOrder, error)
	predicates                  []predicate.MissionOrder
}

var _ ent.Mutation = (*MissionOrderMutation)(nil)

// missionorderOption allows management of the mutation configuration using functional options.
type missionorderOption func(*MissionOrderMutation)

// newMissionOrderMutation creates new mutation for the MissionOrder entity.
func newMissionOrderMutation(c config, op Op, opts ...missionorderOption) *MissionOrderMutation {
	m := &MissionOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionOrderID sets the ID field of the mutation.
func withMissionOrderID(id int64) missionorderOption {
	return func(m *MissionOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionOrder
		)
		m.oldValue = func(ctx context.Context) (*MissionOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionOrder sets the old MissionOrder of the mutation.
func withMissionOrder(node *MissionOrder) missionorderOption {
	return func(m *MissionOrderMutation) {
		m.oldValue = func(context.Context) (*MissionOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionOrder entities.
func (m *MissionOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionOrderMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionOrderMutation) ResetMissionID() {
	m.mission = nil
}

// SetStatus sets the "status" field.
func (m *MissionOrderMutation) SetStatus(eos enums.MissionOrderStatus) {
	m.status = &eos
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionOrderMutation) Status() (r enums.MissionOrderStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldStatus(ctx context.Context) (v enums.MissionOrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionOrderMutation) ResetStatus() {
	m.status = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *MissionOrderMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *MissionOrderMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *MissionOrderMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetConsumeUserID sets the "consume_user_id" field.
func (m *MissionOrderMutation) SetConsumeUserID(i int64) {
	m.consume_user = &i
}

// ConsumeUserID returns the value of the "consume_user_id" field in the mutation.
func (m *MissionOrderMutation) ConsumeUserID() (r int64, exists bool) {
	v := m.consume_user
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumeUserID returns the old "consume_user_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldConsumeUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumeUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumeUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumeUserID: %w", err)
	}
	return oldValue.ConsumeUserID, nil
}

// ResetConsumeUserID resets all changes to the "consume_user_id" field.
func (m *MissionOrderMutation) ResetConsumeUserID() {
	m.consume_user = nil
}

// SetConsumeAmount sets the "consume_amount" field.
func (m *MissionOrderMutation) SetConsumeAmount(i int64) {
	m.consume_amount = &i
	m.addconsume_amount = nil
}

// ConsumeAmount returns the value of the "consume_amount" field in the mutation.
func (m *MissionOrderMutation) ConsumeAmount() (r int64, exists bool) {
	v := m.consume_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumeAmount returns the old "consume_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldConsumeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumeAmount: %w", err)
	}
	return oldValue.ConsumeAmount, nil
}

// AddConsumeAmount adds i to the "consume_amount" field.
func (m *MissionOrderMutation) AddConsumeAmount(i int64) {
	if m.addconsume_amount != nil {
		*m.addconsume_amount += i
	} else {
		m.addconsume_amount = &i
	}
}

// AddedConsumeAmount returns the value that was added to the "consume_amount" field in this mutation.
func (m *MissionOrderMutation) AddedConsumeAmount() (r int64, exists bool) {
	v := m.addconsume_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetConsumeAmount resets all changes to the "consume_amount" field.
func (m *MissionOrderMutation) ResetConsumeAmount() {
	m.consume_amount = nil
	m.addconsume_amount = nil
}

// SetProduceUserID sets the "produce_user_id" field.
func (m *MissionOrderMutation) SetProduceUserID(i int64) {
	m.produce_user = &i
}

// ProduceUserID returns the value of the "produce_user_id" field in the mutation.
func (m *MissionOrderMutation) ProduceUserID() (r int64, exists bool) {
	v := m.produce_user
	if v == nil {
		return
	}
	return *v, true
}

// OldProduceUserID returns the old "produce_user_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldProduceUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProduceUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProduceUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduceUserID: %w", err)
	}
	return oldValue.ProduceUserID, nil
}

// ResetProduceUserID resets all changes to the "produce_user_id" field.
func (m *MissionOrderMutation) ResetProduceUserID() {
	m.produce_user = nil
}

// SetProduceAmount sets the "produce_amount" field.
func (m *MissionOrderMutation) SetProduceAmount(i int64) {
	m.produce_amount = &i
	m.addproduce_amount = nil
}

// ProduceAmount returns the value of the "produce_amount" field in the mutation.
func (m *MissionOrderMutation) ProduceAmount() (r int64, exists bool) {
	v := m.produce_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldProduceAmount returns the old "produce_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldProduceAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProduceAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProduceAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduceAmount: %w", err)
	}
	return oldValue.ProduceAmount, nil
}

// AddProduceAmount adds i to the "produce_amount" field.
func (m *MissionOrderMutation) AddProduceAmount(i int64) {
	if m.addproduce_amount != nil {
		*m.addproduce_amount += i
	} else {
		m.addproduce_amount = &i
	}
}

// AddedProduceAmount returns the value that was added to the "produce_amount" field in this mutation.
func (m *MissionOrderMutation) AddedProduceAmount() (r int64, exists bool) {
	v := m.addproduce_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetProduceAmount resets all changes to the "produce_amount" field.
func (m *MissionOrderMutation) ResetProduceAmount() {
	m.produce_amount = nil
	m.addproduce_amount = nil
}

// SetGasAmount sets the "gas_amount" field.
func (m *MissionOrderMutation) SetGasAmount(i int64) {
	m.gas_amount = &i
	m.addgas_amount = nil
}

// GasAmount returns the value of the "gas_amount" field in the mutation.
func (m *MissionOrderMutation) GasAmount() (r int64, exists bool) {
	v := m.gas_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldGasAmount returns the old "gas_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldGasAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGasAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGasAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGasAmount: %w", err)
	}
	return oldValue.GasAmount, nil
}

// AddGasAmount adds i to the "gas_amount" field.
func (m *MissionOrderMutation) AddGasAmount(i int64) {
	if m.addgas_amount != nil {
		*m.addgas_amount += i
	} else {
		m.addgas_amount = &i
	}
}

// AddedGasAmount returns the value that was added to the "gas_amount" field in this mutation.
func (m *MissionOrderMutation) AddedGasAmount() (r int64, exists bool) {
	v := m.addgas_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetGasAmount resets all changes to the "gas_amount" field.
func (m *MissionOrderMutation) ResetGasAmount() {
	m.gas_amount = nil
	m.addgas_amount = nil
}

// SetMissionType sets the "mission_type" field.
func (m *MissionOrderMutation) SetMissionType(et enums.MissionType) {
	m.mission_type = &et
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *MissionOrderMutation) MissionType() (r enums.MissionType, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *MissionOrderMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionBillingType sets the "mission_billing_type" field.
func (m *MissionOrderMutation) SetMissionBillingType(ebt enums.MissionBillingType) {
	m.mission_billing_type = &ebt
}

// MissionBillingType returns the value of the "mission_billing_type" field in the mutation.
func (m *MissionOrderMutation) MissionBillingType() (r enums.MissionBillingType, exists bool) {
	v := m.mission_billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBillingType returns the old "mission_billing_type" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBillingType: %w", err)
	}
	return oldValue.MissionBillingType, nil
}

// ResetMissionBillingType resets all changes to the "mission_billing_type" field.
func (m *MissionOrderMutation) ResetMissionBillingType() {
	m.mission_billing_type = nil
}

// SetCallWay sets the "call_way" field.
func (m *MissionOrderMutation) SetCallWay(ecw enums.MissionCallWay) {
	m.call_way = &ecw
}

// CallWay returns the value of the "call_way" field in the mutation.
func (m *MissionOrderMutation) CallWay() (r enums.MissionCallWay, exists bool) {
	v := m.call_way
	if v == nil {
		return
	}
	return *v, true
}

// OldCallWay returns the old "call_way" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldCallWay(ctx context.Context) (v enums.MissionCallWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallWay: %w", err)
	}
	return oldValue.CallWay, nil
}

// ResetCallWay resets all changes to the "call_way" field.
func (m *MissionOrderMutation) ResetCallWay() {
	m.call_way = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *MissionOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MissionOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MissionOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionOrderMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionOrderMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionOrderMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionOrderMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionOrderMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionOrderMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetBuyDuration sets the "buy_duration" field.
func (m *MissionOrderMutation) SetBuyDuration(i int64) {
	m.buy_duration = &i
	m.addbuy_duration = nil
}

// BuyDuration returns the value of the "buy_duration" field in the mutation.
func (m *MissionOrderMutation) BuyDuration() (r int64, exists bool) {
	v := m.buy_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyDuration returns the old "buy_duration" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldBuyDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyDuration: %w", err)
	}
	return oldValue.BuyDuration, nil
}

// AddBuyDuration adds i to the "buy_duration" field.
func (m *MissionOrderMutation) AddBuyDuration(i int64) {
	if m.addbuy_duration != nil {
		*m.addbuy_duration += i
	} else {
		m.addbuy_duration = &i
	}
}

// AddedBuyDuration returns the value that was added to the "buy_duration" field in this mutation.
func (m *MissionOrderMutation) AddedBuyDuration() (r int64, exists bool) {
	v := m.addbuy_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetBuyDuration resets all changes to the "buy_duration" field.
func (m *MissionOrderMutation) ResetBuyDuration() {
	m.buy_duration = nil
	m.addbuy_duration = nil
}

// SetPlanStartedAt sets the "plan_started_at" field.
func (m *MissionOrderMutation) SetPlanStartedAt(t time.Time) {
	m.plan_started_at = &t
}

// PlanStartedAt returns the value of the "plan_started_at" field in the mutation.
func (m *MissionOrderMutation) PlanStartedAt() (r time.Time, exists bool) {
	v := m.plan_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanStartedAt returns the old "plan_started_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldPlanStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanStartedAt: %w", err)
	}
	return oldValue.PlanStartedAt, nil
}

// ClearPlanStartedAt clears the value of the "plan_started_at" field.
func (m *MissionOrderMutation) ClearPlanStartedAt() {
	m.plan_started_at = nil
	m.clearedFields[missionorder.FieldPlanStartedAt] = struct{}{}
}

// PlanStartedAtCleared returns if the "plan_started_at" field was cleared in this mutation.
func (m *MissionOrderMutation) PlanStartedAtCleared() bool {
	_, ok := m.clearedFields[missionorder.FieldPlanStartedAt]
	return ok
}

// ResetPlanStartedAt resets all changes to the "plan_started_at" field.
func (m *MissionOrderMutation) ResetPlanStartedAt() {
	m.plan_started_at = nil
	delete(m.clearedFields, missionorder.FieldPlanStartedAt)
}

// SetPlanFinishedAt sets the "plan_finished_at" field.
func (m *MissionOrderMutation) SetPlanFinishedAt(t time.Time) {
	m.plan_finished_at = &t
}

// PlanFinishedAt returns the value of the "plan_finished_at" field in the mutation.
func (m *MissionOrderMutation) PlanFinishedAt() (r time.Time, exists bool) {
	v := m.plan_finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanFinishedAt returns the old "plan_finished_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldPlanFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanFinishedAt: %w", err)
	}
	return oldValue.PlanFinishedAt, nil
}

// ClearPlanFinishedAt clears the value of the "plan_finished_at" field.
func (m *MissionOrderMutation) ClearPlanFinishedAt() {
	m.plan_finished_at = nil
	m.clearedFields[missionorder.FieldPlanFinishedAt] = struct{}{}
}

// PlanFinishedAtCleared returns if the "plan_finished_at" field was cleared in this mutation.
func (m *MissionOrderMutation) PlanFinishedAtCleared() bool {
	_, ok := m.clearedFields[missionorder.FieldPlanFinishedAt]
	return ok
}

// ResetPlanFinishedAt resets all changes to the "plan_finished_at" field.
func (m *MissionOrderMutation) ResetPlanFinishedAt() {
	m.plan_finished_at = nil
	delete(m.clearedFields, missionorder.FieldPlanFinishedAt)
}

// SetExpiredWarningTime sets the "expired_warning_time" field.
func (m *MissionOrderMutation) SetExpiredWarningTime(t time.Time) {
	m.expired_warning_time = &t
}

// ExpiredWarningTime returns the value of the "expired_warning_time" field in the mutation.
func (m *MissionOrderMutation) ExpiredWarningTime() (r time.Time, exists bool) {
	v := m.expired_warning_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredWarningTime returns the old "expired_warning_time" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldExpiredWarningTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredWarningTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredWarningTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredWarningTime: %w", err)
	}
	return oldValue.ExpiredWarningTime, nil
}

// ClearExpiredWarningTime clears the value of the "expired_warning_time" field.
func (m *MissionOrderMutation) ClearExpiredWarningTime() {
	m.expired_warning_time = nil
	m.clearedFields[missionorder.FieldExpiredWarningTime] = struct{}{}
}

// ExpiredWarningTimeCleared returns if the "expired_warning_time" field was cleared in this mutation.
func (m *MissionOrderMutation) ExpiredWarningTimeCleared() bool {
	_, ok := m.clearedFields[missionorder.FieldExpiredWarningTime]
	return ok
}

// ResetExpiredWarningTime resets all changes to the "expired_warning_time" field.
func (m *MissionOrderMutation) ResetExpiredWarningTime() {
	m.expired_warning_time = nil
	delete(m.clearedFields, missionorder.FieldExpiredWarningTime)
}

// SetMissionBatchID sets the "mission_batch_id" field.
func (m *MissionOrderMutation) SetMissionBatchID(i int64) {
	m.mission_batch = &i
}

// MissionBatchID returns the value of the "mission_batch_id" field in the mutation.
func (m *MissionOrderMutation) MissionBatchID() (r int64, exists bool) {
	v := m.mission_batch
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchID returns the old "mission_batch_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchID: %w", err)
	}
	return oldValue.MissionBatchID, nil
}

// ResetMissionBatchID resets all changes to the "mission_batch_id" field.
func (m *MissionOrderMutation) ResetMissionBatchID() {
	m.mission_batch = nil
}

// SetMissionBatchNumber sets the "mission_batch_number" field.
func (m *MissionOrderMutation) SetMissionBatchNumber(s string) {
	m.mission_batch_number = &s
}

// MissionBatchNumber returns the value of the "mission_batch_number" field in the mutation.
func (m *MissionOrderMutation) MissionBatchNumber() (r string, exists bool) {
	v := m.mission_batch_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchNumber returns the old "mission_batch_number" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionBatchNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchNumber: %w", err)
	}
	return oldValue.MissionBatchNumber, nil
}

// ResetMissionBatchNumber resets all changes to the "mission_batch_number" field.
func (m *MissionOrderMutation) ResetMissionBatchNumber() {
	m.mission_batch_number = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionOrderMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionOrderMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionOrderMutation) ResetDeviceID() {
	m.device = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *MissionOrderMutation) SetTotalAmount(i int64) {
	m.total_amount = &i
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *MissionOrderMutation) TotalAmount() (r int64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldTotalAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds i to the "total_amount" field.
func (m *MissionOrderMutation) AddTotalAmount(i int64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += i
	} else {
		m.addtotal_amount = &i
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *MissionOrderMutation) AddedTotalAmount() (r int64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *MissionOrderMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetSettledAmount sets the "settled_amount" field.
func (m *MissionOrderMutation) SetSettledAmount(i int64) {
	m.settled_amount = &i
	m.addsettled_amount = nil
}

// SettledAmount returns the value of the "settled_amount" field in the mutation.
func (m *MissionOrderMutation) SettledAmount() (r int64, exists bool) {
	v := m.settled_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledAmount returns the old "settled_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldSettledAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledAmount: %w", err)
	}
	return oldValue.SettledAmount, nil
}

// AddSettledAmount adds i to the "settled_amount" field.
func (m *MissionOrderMutation) AddSettledAmount(i int64) {
	if m.addsettled_amount != nil {
		*m.addsettled_amount += i
	} else {
		m.addsettled_amount = &i
	}
}

// AddedSettledAmount returns the value that was added to the "settled_amount" field in this mutation.
func (m *MissionOrderMutation) AddedSettledAmount() (r int64, exists bool) {
	v := m.addsettled_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettledAmount resets all changes to the "settled_amount" field.
func (m *MissionOrderMutation) ResetSettledAmount() {
	m.settled_amount = nil
	m.addsettled_amount = nil
}

// SetSettledCount sets the "settled_count" field.
func (m *MissionOrderMutation) SetSettledCount(i int64) {
	m.settled_count = &i
	m.addsettled_count = nil
}

// SettledCount returns the value of the "settled_count" field in the mutation.
func (m *MissionOrderMutation) SettledCount() (r int64, exists bool) {
	v := m.settled_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledCount returns the old "settled_count" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldSettledCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledCount: %w", err)
	}
	return oldValue.SettledCount, nil
}

// AddSettledCount adds i to the "settled_count" field.
func (m *MissionOrderMutation) AddSettledCount(i int64) {
	if m.addsettled_count != nil {
		*m.addsettled_count += i
	} else {
		m.addsettled_count = &i
	}
}

// AddedSettledCount returns the value that was added to the "settled_count" field in this mutation.
func (m *MissionOrderMutation) AddedSettledCount() (r int64, exists bool) {
	v := m.addsettled_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettledCount resets all changes to the "settled_count" field.
func (m *MissionOrderMutation) ResetSettledCount() {
	m.settled_count = nil
	m.addsettled_count = nil
}

// SetTotalSettleCount sets the "total_settle_count" field.
func (m *MissionOrderMutation) SetTotalSettleCount(i int64) {
	m.total_settle_count = &i
	m.addtotal_settle_count = nil
}

// TotalSettleCount returns the value of the "total_settle_count" field in the mutation.
func (m *MissionOrderMutation) TotalSettleCount() (r int64, exists bool) {
	v := m.total_settle_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSettleCount returns the old "total_settle_count" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldTotalSettleCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSettleCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSettleCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSettleCount: %w", err)
	}
	return oldValue.TotalSettleCount, nil
}

// AddTotalSettleCount adds i to the "total_settle_count" field.
func (m *MissionOrderMutation) AddTotalSettleCount(i int64) {
	if m.addtotal_settle_count != nil {
		*m.addtotal_settle_count += i
	} else {
		m.addtotal_settle_count = &i
	}
}

// AddedTotalSettleCount returns the value that was added to the "total_settle_count" field in this mutation.
func (m *MissionOrderMutation) AddedTotalSettleCount() (r int64, exists bool) {
	v := m.addtotal_settle_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSettleCount resets all changes to the "total_settle_count" field.
func (m *MissionOrderMutation) ResetTotalSettleCount() {
	m.total_settle_count = nil
	m.addtotal_settle_count = nil
}

// SetLatelySettledAt sets the "lately_settled_at" field.
func (m *MissionOrderMutation) SetLatelySettledAt(t time.Time) {
	m.lately_settled_at = &t
}

// LatelySettledAt returns the value of the "lately_settled_at" field in the mutation.
func (m *MissionOrderMutation) LatelySettledAt() (r time.Time, exists bool) {
	v := m.lately_settled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLatelySettledAt returns the old "lately_settled_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldLatelySettledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatelySettledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatelySettledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatelySettledAt: %w", err)
	}
	return oldValue.LatelySettledAt, nil
}

// ResetLatelySettledAt resets all changes to the "lately_settled_at" field.
func (m *MissionOrderMutation) ResetLatelySettledAt() {
	m.lately_settled_at = nil
}

// ClearConsumeUser clears the "consume_user" edge to the User entity.
func (m *MissionOrderMutation) ClearConsumeUser() {
	m.clearedconsume_user = true
	m.clearedFields[missionorder.FieldConsumeUserID] = struct{}{}
}

// ConsumeUserCleared reports if the "consume_user" edge to the User entity was cleared.
func (m *MissionOrderMutation) ConsumeUserCleared() bool {
	return m.clearedconsume_user
}

// ConsumeUserIDs returns the "consume_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConsumeUserID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) ConsumeUserIDs() (ids []int64) {
	if id := m.consume_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConsumeUser resets all changes to the "consume_user" edge.
func (m *MissionOrderMutation) ResetConsumeUser() {
	m.consume_user = nil
	m.clearedconsume_user = false
}

// ClearProduceUser clears the "produce_user" edge to the User entity.
func (m *MissionOrderMutation) ClearProduceUser() {
	m.clearedproduce_user = true
	m.clearedFields[missionorder.FieldProduceUserID] = struct{}{}
}

// ProduceUserCleared reports if the "produce_user" edge to the User entity was cleared.
func (m *MissionOrderMutation) ProduceUserCleared() bool {
	return m.clearedproduce_user
}

// ProduceUserIDs returns the "produce_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProduceUserID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) ProduceUserIDs() (ids []int64) {
	if id := m.produce_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduceUser resets all changes to the "produce_user" edge.
func (m *MissionOrderMutation) ResetProduceUser() {
	m.produce_user = nil
	m.clearedproduce_user = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *MissionOrderMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[missionorder.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *MissionOrderMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *MissionOrderMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// AddBillIDs adds the "bills" edge to the Bill entity by ids.
func (m *MissionOrderMutation) AddBillIDs(ids ...int64) {
	if m.bills == nil {
		m.bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the Bill entity.
func (m *MissionOrderMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the Bill entity was cleared.
func (m *MissionOrderMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the Bill entity by IDs.
func (m *MissionOrderMutation) RemoveBillIDs(ids ...int64) {
	if m.removedbills == nil {
		m.removedbills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the Bill entity.
func (m *MissionOrderMutation) RemovedBillsIDs() (ids []int64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *MissionOrderMutation) BillsIDs() (ids []int64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *MissionOrderMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// ClearMissionBatch clears the "mission_batch" edge to the MissionBatch entity.
func (m *MissionOrderMutation) ClearMissionBatch() {
	m.clearedmission_batch = true
	m.clearedFields[missionorder.FieldMissionBatchID] = struct{}{}
}

// MissionBatchCleared reports if the "mission_batch" edge to the MissionBatch entity was cleared.
func (m *MissionOrderMutation) MissionBatchCleared() bool {
	return m.clearedmission_batch
}

// MissionBatchIDs returns the "mission_batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionBatchID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) MissionBatchIDs() (ids []int64) {
	if id := m.mission_batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionBatch resets all changes to the "mission_batch" edge.
func (m *MissionOrderMutation) ResetMissionBatch() {
	m.mission_batch = nil
	m.clearedmission_batch = false
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionOrderMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionorder.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionOrderMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionOrderMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *MissionOrderMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[missionorder.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *MissionOrderMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *MissionOrderMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddExtraServiceOrderIDs adds the "extra_service_orders" edge to the ExtraServiceOrder entity by ids.
func (m *MissionOrderMutation) AddExtraServiceOrderIDs(ids ...int64) {
	if m.extra_service_orders == nil {
		m.extra_service_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_orders[ids[i]] = struct{}{}
	}
}

// ClearExtraServiceOrders clears the "extra_service_orders" edge to the ExtraServiceOrder entity.
func (m *MissionOrderMutation) ClearExtraServiceOrders() {
	m.clearedextra_service_orders = true
}

// ExtraServiceOrdersCleared reports if the "extra_service_orders" edge to the ExtraServiceOrder entity was cleared.
func (m *MissionOrderMutation) ExtraServiceOrdersCleared() bool {
	return m.clearedextra_service_orders
}

// RemoveExtraServiceOrderIDs removes the "extra_service_orders" edge to the ExtraServiceOrder entity by IDs.
func (m *MissionOrderMutation) RemoveExtraServiceOrderIDs(ids ...int64) {
	if m.removedextra_service_orders == nil {
		m.removedextra_service_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_orders, ids[i])
		m.removedextra_service_orders[ids[i]] = struct{}{}
	}
}

// RemovedExtraServiceOrders returns the removed IDs of the "extra_service_orders" edge to the ExtraServiceOrder entity.
func (m *MissionOrderMutation) RemovedExtraServiceOrdersIDs() (ids []int64) {
	for id := range m.removedextra_service_orders {
		ids = append(ids, id)
	}
	return
}

// ExtraServiceOrdersIDs returns the "extra_service_orders" edge IDs in the mutation.
func (m *MissionOrderMutation) ExtraServiceOrdersIDs() (ids []int64) {
	for id := range m.extra_service_orders {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServiceOrders resets all changes to the "extra_service_orders" edge.
func (m *MissionOrderMutation) ResetExtraServiceOrders() {
	m.extra_service_orders = nil
	m.clearedextra_service_orders = false
	m.removedextra_service_orders = nil
}

// Where appends a list predicates to the MissionOrderMutation builder.
func (m *MissionOrderMutation) Where(ps ...predicate.MissionOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionOrder).
func (m *MissionOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionOrderMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.created_by != nil {
		fields = append(fields, missionorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionorder.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, missionorder.FieldMissionID)
	}
	if m.status != nil {
		fields = append(fields, missionorder.FieldStatus)
	}
	if m.symbol != nil {
		fields = append(fields, missionorder.FieldSymbolID)
	}
	if m.consume_user != nil {
		fields = append(fields, missionorder.FieldConsumeUserID)
	}
	if m.consume_amount != nil {
		fields = append(fields, missionorder.FieldConsumeAmount)
	}
	if m.produce_user != nil {
		fields = append(fields, missionorder.FieldProduceUserID)
	}
	if m.produce_amount != nil {
		fields = append(fields, missionorder.FieldProduceAmount)
	}
	if m.gas_amount != nil {
		fields = append(fields, missionorder.FieldGasAmount)
	}
	if m.mission_type != nil {
		fields = append(fields, missionorder.FieldMissionType)
	}
	if m.mission_billing_type != nil {
		fields = append(fields, missionorder.FieldMissionBillingType)
	}
	if m.call_way != nil {
		fields = append(fields, missionorder.FieldCallWay)
	}
	if m.serial_number != nil {
		fields = append(fields, missionorder.FieldSerialNumber)
	}
	if m.started_at != nil {
		fields = append(fields, missionorder.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionorder.FieldFinishedAt)
	}
	if m.buy_duration != nil {
		fields = append(fields, missionorder.FieldBuyDuration)
	}
	if m.plan_started_at != nil {
		fields = append(fields, missionorder.FieldPlanStartedAt)
	}
	if m.plan_finished_at != nil {
		fields = append(fields, missionorder.FieldPlanFinishedAt)
	}
	if m.expired_warning_time != nil {
		fields = append(fields, missionorder.FieldExpiredWarningTime)
	}
	if m.mission_batch != nil {
		fields = append(fields, missionorder.FieldMissionBatchID)
	}
	if m.mission_batch_number != nil {
		fields = append(fields, missionorder.FieldMissionBatchNumber)
	}
	if m.device != nil {
		fields = append(fields, missionorder.FieldDeviceID)
	}
	if m.total_amount != nil {
		fields = append(fields, missionorder.FieldTotalAmount)
	}
	if m.settled_amount != nil {
		fields = append(fields, missionorder.FieldSettledAmount)
	}
	if m.settled_count != nil {
		fields = append(fields, missionorder.FieldSettledCount)
	}
	if m.total_settle_count != nil {
		fields = append(fields, missionorder.FieldTotalSettleCount)
	}
	if m.lately_settled_at != nil {
		fields = append(fields, missionorder.FieldLatelySettledAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionorder.FieldCreatedBy:
		return m.CreatedBy()
	case missionorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionorder.FieldCreatedAt:
		return m.CreatedAt()
	case missionorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionorder.FieldDeletedAt:
		return m.DeletedAt()
	case missionorder.FieldMissionID:
		return m.MissionID()
	case missionorder.FieldStatus:
		return m.Status()
	case missionorder.FieldSymbolID:
		return m.SymbolID()
	case missionorder.FieldConsumeUserID:
		return m.ConsumeUserID()
	case missionorder.FieldConsumeAmount:
		return m.ConsumeAmount()
	case missionorder.FieldProduceUserID:
		return m.ProduceUserID()
	case missionorder.FieldProduceAmount:
		return m.ProduceAmount()
	case missionorder.FieldGasAmount:
		return m.GasAmount()
	case missionorder.FieldMissionType:
		return m.MissionType()
	case missionorder.FieldMissionBillingType:
		return m.MissionBillingType()
	case missionorder.FieldCallWay:
		return m.CallWay()
	case missionorder.FieldSerialNumber:
		return m.SerialNumber()
	case missionorder.FieldStartedAt:
		return m.StartedAt()
	case missionorder.FieldFinishedAt:
		return m.FinishedAt()
	case missionorder.FieldBuyDuration:
		return m.BuyDuration()
	case missionorder.FieldPlanStartedAt:
		return m.PlanStartedAt()
	case missionorder.FieldPlanFinishedAt:
		return m.PlanFinishedAt()
	case missionorder.FieldExpiredWarningTime:
		return m.ExpiredWarningTime()
	case missionorder.FieldMissionBatchID:
		return m.MissionBatchID()
	case missionorder.FieldMissionBatchNumber:
		return m.MissionBatchNumber()
	case missionorder.FieldDeviceID:
		return m.DeviceID()
	case missionorder.FieldTotalAmount:
		return m.TotalAmount()
	case missionorder.FieldSettledAmount:
		return m.SettledAmount()
	case missionorder.FieldSettledCount:
		return m.SettledCount()
	case missionorder.FieldTotalSettleCount:
		return m.TotalSettleCount()
	case missionorder.FieldLatelySettledAt:
		return m.LatelySettledAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionorder.FieldStatus:
		return m.OldStatus(ctx)
	case missionorder.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case missionorder.FieldConsumeUserID:
		return m.OldConsumeUserID(ctx)
	case missionorder.FieldConsumeAmount:
		return m.OldConsumeAmount(ctx)
	case missionorder.FieldProduceUserID:
		return m.OldProduceUserID(ctx)
	case missionorder.FieldProduceAmount:
		return m.OldProduceAmount(ctx)
	case missionorder.FieldGasAmount:
		return m.OldGasAmount(ctx)
	case missionorder.FieldMissionType:
		return m.OldMissionType(ctx)
	case missionorder.FieldMissionBillingType:
		return m.OldMissionBillingType(ctx)
	case missionorder.FieldCallWay:
		return m.OldCallWay(ctx)
	case missionorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case missionorder.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionorder.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionorder.FieldBuyDuration:
		return m.OldBuyDuration(ctx)
	case missionorder.FieldPlanStartedAt:
		return m.OldPlanStartedAt(ctx)
	case missionorder.FieldPlanFinishedAt:
		return m.OldPlanFinishedAt(ctx)
	case missionorder.FieldExpiredWarningTime:
		return m.OldExpiredWarningTime(ctx)
	case missionorder.FieldMissionBatchID:
		return m.OldMissionBatchID(ctx)
	case missionorder.FieldMissionBatchNumber:
		return m.OldMissionBatchNumber(ctx)
	case missionorder.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionorder.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case missionorder.FieldSettledAmount:
		return m.OldSettledAmount(ctx)
	case missionorder.FieldSettledCount:
		return m.OldSettledCount(ctx)
	case missionorder.FieldTotalSettleCount:
		return m.OldTotalSettleCount(ctx)
	case missionorder.FieldLatelySettledAt:
		return m.OldLatelySettledAt(ctx)
	}
	return nil, fmt.Errorf("unknown MissionOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionorder.FieldStatus:
		v, ok := value.(enums.MissionOrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case missionorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case missionorder.FieldConsumeUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumeUserID(v)
		return nil
	case missionorder.FieldConsumeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumeAmount(v)
		return nil
	case missionorder.FieldProduceUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduceUserID(v)
		return nil
	case missionorder.FieldProduceAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduceAmount(v)
		return nil
	case missionorder.FieldGasAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGasAmount(v)
		return nil
	case missionorder.FieldMissionType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case missionorder.FieldMissionBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBillingType(v)
		return nil
	case missionorder.FieldCallWay:
		v, ok := value.(enums.MissionCallWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallWay(v)
		return nil
	case missionorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case missionorder.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionorder.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionorder.FieldBuyDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyDuration(v)
		return nil
	case missionorder.FieldPlanStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanStartedAt(v)
		return nil
	case missionorder.FieldPlanFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanFinishedAt(v)
		return nil
	case missionorder.FieldExpiredWarningTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredWarningTime(v)
		return nil
	case missionorder.FieldMissionBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchID(v)
		return nil
	case missionorder.FieldMissionBatchNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchNumber(v)
		return nil
	case missionorder.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionorder.FieldTotalAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case missionorder.FieldSettledAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledAmount(v)
		return nil
	case missionorder.FieldSettledCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledCount(v)
		return nil
	case missionorder.FieldTotalSettleCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSettleCount(v)
		return nil
	case missionorder.FieldLatelySettledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatelySettledAt(v)
		return nil
	}
	return fmt.Errorf("unknown MissionOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionorder.FieldUpdatedBy)
	}
	if m.addconsume_amount != nil {
		fields = append(fields, missionorder.FieldConsumeAmount)
	}
	if m.addproduce_amount != nil {
		fields = append(fields, missionorder.FieldProduceAmount)
	}
	if m.addgas_amount != nil {
		fields = append(fields, missionorder.FieldGasAmount)
	}
	if m.addbuy_duration != nil {
		fields = append(fields, missionorder.FieldBuyDuration)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, missionorder.FieldTotalAmount)
	}
	if m.addsettled_amount != nil {
		fields = append(fields, missionorder.FieldSettledAmount)
	}
	if m.addsettled_count != nil {
		fields = append(fields, missionorder.FieldSettledCount)
	}
	if m.addtotal_settle_count != nil {
		fields = append(fields, missionorder.FieldTotalSettleCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionorder.FieldConsumeAmount:
		return m.AddedConsumeAmount()
	case missionorder.FieldProduceAmount:
		return m.AddedProduceAmount()
	case missionorder.FieldGasAmount:
		return m.AddedGasAmount()
	case missionorder.FieldBuyDuration:
		return m.AddedBuyDuration()
	case missionorder.FieldTotalAmount:
		return m.AddedTotalAmount()
	case missionorder.FieldSettledAmount:
		return m.AddedSettledAmount()
	case missionorder.FieldSettledCount:
		return m.AddedSettledCount()
	case missionorder.FieldTotalSettleCount:
		return m.AddedTotalSettleCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionorder.FieldConsumeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConsumeAmount(v)
		return nil
	case missionorder.FieldProduceAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProduceAmount(v)
		return nil
	case missionorder.FieldGasAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGasAmount(v)
		return nil
	case missionorder.FieldBuyDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuyDuration(v)
		return nil
	case missionorder.FieldTotalAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case missionorder.FieldSettledAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettledAmount(v)
		return nil
	case missionorder.FieldSettledCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettledCount(v)
		return nil
	case missionorder.FieldTotalSettleCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSettleCount(v)
		return nil
	}
	return fmt.Errorf("unknown MissionOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(missionorder.FieldPlanStartedAt) {
		fields = append(fields, missionorder.FieldPlanStartedAt)
	}
	if m.FieldCleared(missionorder.FieldPlanFinishedAt) {
		fields = append(fields, missionorder.FieldPlanFinishedAt)
	}
	if m.FieldCleared(missionorder.FieldExpiredWarningTime) {
		fields = append(fields, missionorder.FieldExpiredWarningTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionOrderMutation) ClearField(name string) error {
	switch name {
	case missionorder.FieldPlanStartedAt:
		m.ClearPlanStartedAt()
		return nil
	case missionorder.FieldPlanFinishedAt:
		m.ClearPlanFinishedAt()
		return nil
	case missionorder.FieldExpiredWarningTime:
		m.ClearExpiredWarningTime()
		return nil
	}
	return fmt.Errorf("unknown MissionOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionOrderMutation) ResetField(name string) error {
	switch name {
	case missionorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionorder.FieldStatus:
		m.ResetStatus()
		return nil
	case missionorder.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case missionorder.FieldConsumeUserID:
		m.ResetConsumeUserID()
		return nil
	case missionorder.FieldConsumeAmount:
		m.ResetConsumeAmount()
		return nil
	case missionorder.FieldProduceUserID:
		m.ResetProduceUserID()
		return nil
	case missionorder.FieldProduceAmount:
		m.ResetProduceAmount()
		return nil
	case missionorder.FieldGasAmount:
		m.ResetGasAmount()
		return nil
	case missionorder.FieldMissionType:
		m.ResetMissionType()
		return nil
	case missionorder.FieldMissionBillingType:
		m.ResetMissionBillingType()
		return nil
	case missionorder.FieldCallWay:
		m.ResetCallWay()
		return nil
	case missionorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case missionorder.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionorder.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionorder.FieldBuyDuration:
		m.ResetBuyDuration()
		return nil
	case missionorder.FieldPlanStartedAt:
		m.ResetPlanStartedAt()
		return nil
	case missionorder.FieldPlanFinishedAt:
		m.ResetPlanFinishedAt()
		return nil
	case missionorder.FieldExpiredWarningTime:
		m.ResetExpiredWarningTime()
		return nil
	case missionorder.FieldMissionBatchID:
		m.ResetMissionBatchID()
		return nil
	case missionorder.FieldMissionBatchNumber:
		m.ResetMissionBatchNumber()
		return nil
	case missionorder.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionorder.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case missionorder.FieldSettledAmount:
		m.ResetSettledAmount()
		return nil
	case missionorder.FieldSettledCount:
		m.ResetSettledCount()
		return nil
	case missionorder.FieldTotalSettleCount:
		m.ResetTotalSettleCount()
		return nil
	case missionorder.FieldLatelySettledAt:
		m.ResetLatelySettledAt()
		return nil
	}
	return fmt.Errorf("unknown MissionOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.consume_user != nil {
		edges = append(edges, missionorder.EdgeConsumeUser)
	}
	if m.produce_user != nil {
		edges = append(edges, missionorder.EdgeProduceUser)
	}
	if m.symbol != nil {
		edges = append(edges, missionorder.EdgeSymbol)
	}
	if m.bills != nil {
		edges = append(edges, missionorder.EdgeBills)
	}
	if m.mission_batch != nil {
		edges = append(edges, missionorder.EdgeMissionBatch)
	}
	if m.mission != nil {
		edges = append(edges, missionorder.EdgeMission)
	}
	if m.device != nil {
		edges = append(edges, missionorder.EdgeDevice)
	}
	if m.extra_service_orders != nil {
		edges = append(edges, missionorder.EdgeExtraServiceOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionorder.EdgeConsumeUser:
		if id := m.consume_user; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeProduceUser:
		if id := m.produce_user; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case missionorder.EdgeMissionBatch:
		if id := m.mission_batch; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeExtraServiceOrders:
		ids := make([]ent.Value, 0, len(m.extra_service_orders))
		for id := range m.extra_service_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedbills != nil {
		edges = append(edges, missionorder.EdgeBills)
	}
	if m.removedextra_service_orders != nil {
		edges = append(edges, missionorder.EdgeExtraServiceOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	case missionorder.EdgeExtraServiceOrders:
		ids := make([]ent.Value, 0, len(m.removedextra_service_orders))
		for id := range m.removedextra_service_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedconsume_user {
		edges = append(edges, missionorder.EdgeConsumeUser)
	}
	if m.clearedproduce_user {
		edges = append(edges, missionorder.EdgeProduceUser)
	}
	if m.clearedsymbol {
		edges = append(edges, missionorder.EdgeSymbol)
	}
	if m.clearedbills {
		edges = append(edges, missionorder.EdgeBills)
	}
	if m.clearedmission_batch {
		edges = append(edges, missionorder.EdgeMissionBatch)
	}
	if m.clearedmission {
		edges = append(edges, missionorder.EdgeMission)
	}
	if m.cleareddevice {
		edges = append(edges, missionorder.EdgeDevice)
	}
	if m.clearedextra_service_orders {
		edges = append(edges, missionorder.EdgeExtraServiceOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case missionorder.EdgeConsumeUser:
		return m.clearedconsume_user
	case missionorder.EdgeProduceUser:
		return m.clearedproduce_user
	case missionorder.EdgeSymbol:
		return m.clearedsymbol
	case missionorder.EdgeBills:
		return m.clearedbills
	case missionorder.EdgeMissionBatch:
		return m.clearedmission_batch
	case missionorder.EdgeMission:
		return m.clearedmission
	case missionorder.EdgeDevice:
		return m.cleareddevice
	case missionorder.EdgeExtraServiceOrders:
		return m.clearedextra_service_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionOrderMutation) ClearEdge(name string) error {
	switch name {
	case missionorder.EdgeConsumeUser:
		m.ClearConsumeUser()
		return nil
	case missionorder.EdgeProduceUser:
		m.ClearProduceUser()
		return nil
	case missionorder.EdgeSymbol:
		m.ClearSymbol()
		return nil
	case missionorder.EdgeMissionBatch:
		m.ClearMissionBatch()
		return nil
	case missionorder.EdgeMission:
		m.ClearMission()
		return nil
	case missionorder.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown MissionOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionOrderMutation) ResetEdge(name string) error {
	switch name {
	case missionorder.EdgeConsumeUser:
		m.ResetConsumeUser()
		return nil
	case missionorder.EdgeProduceUser:
		m.ResetProduceUser()
		return nil
	case missionorder.EdgeSymbol:
		m.ResetSymbol()
		return nil
	case missionorder.EdgeBills:
		m.ResetBills()
		return nil
	case missionorder.EdgeMissionBatch:
		m.ResetMissionBatch()
		return nil
	case missionorder.EdgeMission:
		m.ResetMission()
		return nil
	case missionorder.EdgeDevice:
		m.ResetDevice()
		return nil
	case missionorder.EdgeExtraServiceOrders:
		m.ResetExtraServiceOrders()
		return nil
	}
	return fmt.Errorf("unknown MissionOrder edge %s", name)
}

// MissionProduceOrderMutation represents an operation that mutates the MissionProduceOrder nodes in the graph.
type MissionProduceOrderMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_by                   *int64
	addcreated_by                *int64
	updated_by                   *int64
	addupdated_by                *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	mission_id                   *int64
	addmission_id                *int64
	status                       *enums.MissionOrderStatus
	pure_cep                     *int64
	addpure_cep                  *int64
	gift_cep                     *int64
	addgift_cep                  *int64
	symbol_id                    *int64
	addsymbol_id                 *int64
	amount                       *int64
	addamount                    *int64
	_type                        *enums.MissionType
	is_time                      *bool
	serial_number                *string
	clearedFields                map[string]struct{}
	user                         *int64
	cleareduser                  bool
	earn_bills                   map[int64]struct{}
	removedearn_bills            map[int64]struct{}
	clearedearn_bills            bool
	device                       *int64
	cleareddevice                bool
	mission_consume_order        *int64
	clearedmission_consume_order bool
	mission_production           *int64
	clearedmission_production    bool
	done                         bool
	oldValue                     func(context.Context) (*MissionProduceOrder, error)
	predicates                   []predicate.MissionProduceOrder
}

var _ ent.Mutation = (*MissionProduceOrderMutation)(nil)

// missionproduceorderOption allows management of the mutation configuration using functional options.
type missionproduceorderOption func(*MissionProduceOrderMutation)

// newMissionProduceOrderMutation creates new mutation for the MissionProduceOrder entity.
func newMissionProduceOrderMutation(c config, op Op, opts ...missionproduceorderOption) *MissionProduceOrderMutation {
	m := &MissionProduceOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionProduceOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionProduceOrderID sets the ID field of the mutation.
func withMissionProduceOrderID(id int64) missionproduceorderOption {
	return func(m *MissionProduceOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionProduceOrder
		)
		m.oldValue = func(ctx context.Context) (*MissionProduceOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionProduceOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionProduceOrder sets the old MissionProduceOrder of the mutation.
func withMissionProduceOrder(node *MissionProduceOrder) missionproduceorderOption {
	return func(m *MissionProduceOrderMutation) {
		m.oldValue = func(context.Context) (*MissionProduceOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionProduceOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionProduceOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionProduceOrder entities.
func (m *MissionProduceOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionProduceOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionProduceOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionProduceOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionProduceOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionProduceOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionProduceOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionProduceOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionProduceOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionProduceOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionProduceOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionProduceOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionProduceOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionProduceOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionProduceOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionProduceOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionProduceOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionProduceOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionProduceOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionProduceOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionProduceOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionProduceOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionProduceOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionProduceOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionProduceOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionProduceOrderMutation) ResetUserID() {
	m.user = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionProduceOrderMutation) SetMissionID(i int64) {
	m.mission_id = &i
	m.addmission_id = nil
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionProduceOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// AddMissionID adds i to the "mission_id" field.
func (m *MissionProduceOrderMutation) AddMissionID(i int64) {
	if m.addmission_id != nil {
		*m.addmission_id += i
	} else {
		m.addmission_id = &i
	}
}

// AddedMissionID returns the value that was added to the "mission_id" field in this mutation.
func (m *MissionProduceOrderMutation) AddedMissionID() (r int64, exists bool) {
	v := m.addmission_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionProduceOrderMutation) ResetMissionID() {
	m.mission_id = nil
	m.addmission_id = nil
}

// SetMissionProductionID sets the "mission_production_id" field.
func (m *MissionProduceOrderMutation) SetMissionProductionID(i int64) {
	m.mission_production = &i
}

// MissionProductionID returns the value of the "mission_production_id" field in the mutation.
func (m *MissionProduceOrderMutation) MissionProductionID() (r int64, exists bool) {
	v := m.mission_production
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionProductionID returns the old "mission_production_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldMissionProductionID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionProductionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionProductionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionProductionID: %w", err)
	}
	return oldValue.MissionProductionID, nil
}

// ClearMissionProductionID clears the value of the "mission_production_id" field.
func (m *MissionProduceOrderMutation) ClearMissionProductionID() {
	m.mission_production = nil
	m.clearedFields[missionproduceorder.FieldMissionProductionID] = struct{}{}
}

// MissionProductionIDCleared returns if the "mission_production_id" field was cleared in this mutation.
func (m *MissionProduceOrderMutation) MissionProductionIDCleared() bool {
	_, ok := m.clearedFields[missionproduceorder.FieldMissionProductionID]
	return ok
}

// ResetMissionProductionID resets all changes to the "mission_production_id" field.
func (m *MissionProduceOrderMutation) ResetMissionProductionID() {
	m.mission_production = nil
	delete(m.clearedFields, missionproduceorder.FieldMissionProductionID)
}

// SetStatus sets the "status" field.
func (m *MissionProduceOrderMutation) SetStatus(eos enums.MissionOrderStatus) {
	m.status = &eos
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionProduceOrderMutation) Status() (r enums.MissionOrderStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldStatus(ctx context.Context) (v enums.MissionOrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionProduceOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *MissionProduceOrderMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *MissionProduceOrderMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *MissionProduceOrderMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *MissionProduceOrderMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *MissionProduceOrderMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *MissionProduceOrderMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *MissionProduceOrderMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *MissionProduceOrderMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *MissionProduceOrderMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *MissionProduceOrderMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *MissionProduceOrderMutation) SetSymbolID(i int64) {
	m.symbol_id = &i
	m.addsymbol_id = nil
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *MissionProduceOrderMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// AddSymbolID adds i to the "symbol_id" field.
func (m *MissionProduceOrderMutation) AddSymbolID(i int64) {
	if m.addsymbol_id != nil {
		*m.addsymbol_id += i
	} else {
		m.addsymbol_id = &i
	}
}

// AddedSymbolID returns the value that was added to the "symbol_id" field in this mutation.
func (m *MissionProduceOrderMutation) AddedSymbolID() (r int64, exists bool) {
	v := m.addsymbol_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *MissionProduceOrderMutation) ResetSymbolID() {
	m.symbol_id = nil
	m.addsymbol_id = nil
}

// SetAmount sets the "amount" field.
func (m *MissionProduceOrderMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *MissionProduceOrderMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *MissionProduceOrderMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *MissionProduceOrderMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *MissionProduceOrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetType sets the "type" field.
func (m *MissionProduceOrderMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionProduceOrderMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionProduceOrderMutation) ResetType() {
	m._type = nil
}

// SetIsTime sets the "is_time" field.
func (m *MissionProduceOrderMutation) SetIsTime(b bool) {
	m.is_time = &b
}

// IsTime returns the value of the "is_time" field in the mutation.
func (m *MissionProduceOrderMutation) IsTime() (r bool, exists bool) {
	v := m.is_time
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTime returns the old "is_time" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldIsTime(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTime: %w", err)
	}
	return oldValue.IsTime, nil
}

// ResetIsTime resets all changes to the "is_time" field.
func (m *MissionProduceOrderMutation) ResetIsTime() {
	m.is_time = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionProduceOrderMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionProduceOrderMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionProduceOrderMutation) ResetDeviceID() {
	m.device = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *MissionProduceOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MissionProduceOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MissionProduceOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetMissionConsumeOrderID sets the "mission_consume_order_id" field.
func (m *MissionProduceOrderMutation) SetMissionConsumeOrderID(i int64) {
	m.mission_consume_order = &i
}

// MissionConsumeOrderID returns the value of the "mission_consume_order_id" field in the mutation.
func (m *MissionProduceOrderMutation) MissionConsumeOrderID() (r int64, exists bool) {
	v := m.mission_consume_order
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionConsumeOrderID returns the old "mission_consume_order_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldMissionConsumeOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionConsumeOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionConsumeOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionConsumeOrderID: %w", err)
	}
	return oldValue.MissionConsumeOrderID, nil
}

// ResetMissionConsumeOrderID resets all changes to the "mission_consume_order_id" field.
func (m *MissionProduceOrderMutation) ResetMissionConsumeOrderID() {
	m.mission_consume_order = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionProduceOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionproduceorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionProduceOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionProduceOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *MissionProduceOrderMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *MissionProduceOrderMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *MissionProduceOrderMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *MissionProduceOrderMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *MissionProduceOrderMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *MissionProduceOrderMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *MissionProduceOrderMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *MissionProduceOrderMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[missionproduceorder.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *MissionProduceOrderMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *MissionProduceOrderMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// ClearMissionConsumeOrder clears the "mission_consume_order" edge to the MissionConsumeOrder entity.
func (m *MissionProduceOrderMutation) ClearMissionConsumeOrder() {
	m.clearedmission_consume_order = true
	m.clearedFields[missionproduceorder.FieldMissionConsumeOrderID] = struct{}{}
}

// MissionConsumeOrderCleared reports if the "mission_consume_order" edge to the MissionConsumeOrder entity was cleared.
func (m *MissionProduceOrderMutation) MissionConsumeOrderCleared() bool {
	return m.clearedmission_consume_order
}

// MissionConsumeOrderIDs returns the "mission_consume_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionConsumeOrderID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) MissionConsumeOrderIDs() (ids []int64) {
	if id := m.mission_consume_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionConsumeOrder resets all changes to the "mission_consume_order" edge.
func (m *MissionProduceOrderMutation) ResetMissionConsumeOrder() {
	m.mission_consume_order = nil
	m.clearedmission_consume_order = false
}

// ClearMissionProduction clears the "mission_production" edge to the MissionProduction entity.
func (m *MissionProduceOrderMutation) ClearMissionProduction() {
	m.clearedmission_production = true
	m.clearedFields[missionproduceorder.FieldMissionProductionID] = struct{}{}
}

// MissionProductionCleared reports if the "mission_production" edge to the MissionProduction entity was cleared.
func (m *MissionProduceOrderMutation) MissionProductionCleared() bool {
	return m.MissionProductionIDCleared() || m.clearedmission_production
}

// MissionProductionIDs returns the "mission_production" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionProductionID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) MissionProductionIDs() (ids []int64) {
	if id := m.mission_production; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionProduction resets all changes to the "mission_production" edge.
func (m *MissionProduceOrderMutation) ResetMissionProduction() {
	m.mission_production = nil
	m.clearedmission_production = false
}

// Where appends a list predicates to the MissionProduceOrderMutation builder.
func (m *MissionProduceOrderMutation) Where(ps ...predicate.MissionProduceOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionProduceOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionProduceOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionProduceOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionProduceOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionProduceOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionProduceOrder).
func (m *MissionProduceOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionProduceOrderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_by != nil {
		fields = append(fields, missionproduceorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionproduceorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionproduceorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionproduceorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionproduceorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, missionproduceorder.FieldUserID)
	}
	if m.mission_id != nil {
		fields = append(fields, missionproduceorder.FieldMissionID)
	}
	if m.mission_production != nil {
		fields = append(fields, missionproduceorder.FieldMissionProductionID)
	}
	if m.status != nil {
		fields = append(fields, missionproduceorder.FieldStatus)
	}
	if m.pure_cep != nil {
		fields = append(fields, missionproduceorder.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, missionproduceorder.FieldGiftCep)
	}
	if m.symbol_id != nil {
		fields = append(fields, missionproduceorder.FieldSymbolID)
	}
	if m.amount != nil {
		fields = append(fields, missionproduceorder.FieldAmount)
	}
	if m._type != nil {
		fields = append(fields, missionproduceorder.FieldType)
	}
	if m.is_time != nil {
		fields = append(fields, missionproduceorder.FieldIsTime)
	}
	if m.device != nil {
		fields = append(fields, missionproduceorder.FieldDeviceID)
	}
	if m.serial_number != nil {
		fields = append(fields, missionproduceorder.FieldSerialNumber)
	}
	if m.mission_consume_order != nil {
		fields = append(fields, missionproduceorder.FieldMissionConsumeOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionProduceOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		return m.CreatedBy()
	case missionproduceorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionproduceorder.FieldCreatedAt:
		return m.CreatedAt()
	case missionproduceorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionproduceorder.FieldDeletedAt:
		return m.DeletedAt()
	case missionproduceorder.FieldUserID:
		return m.UserID()
	case missionproduceorder.FieldMissionID:
		return m.MissionID()
	case missionproduceorder.FieldMissionProductionID:
		return m.MissionProductionID()
	case missionproduceorder.FieldStatus:
		return m.Status()
	case missionproduceorder.FieldPureCep:
		return m.PureCep()
	case missionproduceorder.FieldGiftCep:
		return m.GiftCep()
	case missionproduceorder.FieldSymbolID:
		return m.SymbolID()
	case missionproduceorder.FieldAmount:
		return m.Amount()
	case missionproduceorder.FieldType:
		return m.GetType()
	case missionproduceorder.FieldIsTime:
		return m.IsTime()
	case missionproduceorder.FieldDeviceID:
		return m.DeviceID()
	case missionproduceorder.FieldSerialNumber:
		return m.SerialNumber()
	case missionproduceorder.FieldMissionConsumeOrderID:
		return m.MissionConsumeOrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionProduceOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionproduceorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionproduceorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionproduceorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionproduceorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionproduceorder.FieldUserID:
		return m.OldUserID(ctx)
	case missionproduceorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionproduceorder.FieldMissionProductionID:
		return m.OldMissionProductionID(ctx)
	case missionproduceorder.FieldStatus:
		return m.OldStatus(ctx)
	case missionproduceorder.FieldPureCep:
		return m.OldPureCep(ctx)
	case missionproduceorder.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case missionproduceorder.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case missionproduceorder.FieldAmount:
		return m.OldAmount(ctx)
	case missionproduceorder.FieldType:
		return m.OldType(ctx)
	case missionproduceorder.FieldIsTime:
		return m.OldIsTime(ctx)
	case missionproduceorder.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionproduceorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case missionproduceorder.FieldMissionConsumeOrderID:
		return m.OldMissionConsumeOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown MissionProduceOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProduceOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionproduceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionproduceorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionproduceorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionproduceorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionproduceorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case missionproduceorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionproduceorder.FieldMissionProductionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionProductionID(v)
		return nil
	case missionproduceorder.FieldStatus:
		v, ok := value.(enums.MissionOrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case missionproduceorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case missionproduceorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case missionproduceorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case missionproduceorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case missionproduceorder.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionproduceorder.FieldIsTime:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTime(v)
		return nil
	case missionproduceorder.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionproduceorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case missionproduceorder.FieldMissionConsumeOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionConsumeOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionProduceOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionproduceorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionproduceorder.FieldUpdatedBy)
	}
	if m.addmission_id != nil {
		fields = append(fields, missionproduceorder.FieldMissionID)
	}
	if m.addpure_cep != nil {
		fields = append(fields, missionproduceorder.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, missionproduceorder.FieldGiftCep)
	}
	if m.addsymbol_id != nil {
		fields = append(fields, missionproduceorder.FieldSymbolID)
	}
	if m.addamount != nil {
		fields = append(fields, missionproduceorder.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionProduceOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionproduceorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionproduceorder.FieldMissionID:
		return m.AddedMissionID()
	case missionproduceorder.FieldPureCep:
		return m.AddedPureCep()
	case missionproduceorder.FieldGiftCep:
		return m.AddedGiftCep()
	case missionproduceorder.FieldSymbolID:
		return m.AddedSymbolID()
	case missionproduceorder.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProduceOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionproduceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionproduceorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMissionID(v)
		return nil
	case missionproduceorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case missionproduceorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case missionproduceorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSymbolID(v)
		return nil
	case missionproduceorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionProduceOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(missionproduceorder.FieldMissionProductionID) {
		fields = append(fields, missionproduceorder.FieldMissionProductionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionProduceOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionProduceOrderMutation) ClearField(name string) error {
	switch name {
	case missionproduceorder.FieldMissionProductionID:
		m.ClearMissionProductionID()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionProduceOrderMutation) ResetField(name string) error {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionproduceorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionproduceorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionproduceorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionproduceorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionproduceorder.FieldUserID:
		m.ResetUserID()
		return nil
	case missionproduceorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionproduceorder.FieldMissionProductionID:
		m.ResetMissionProductionID()
		return nil
	case missionproduceorder.FieldStatus:
		m.ResetStatus()
		return nil
	case missionproduceorder.FieldPureCep:
		m.ResetPureCep()
		return nil
	case missionproduceorder.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case missionproduceorder.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case missionproduceorder.FieldAmount:
		m.ResetAmount()
		return nil
	case missionproduceorder.FieldType:
		m.ResetType()
		return nil
	case missionproduceorder.FieldIsTime:
		m.ResetIsTime()
		return nil
	case missionproduceorder.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionproduceorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case missionproduceorder.FieldMissionConsumeOrderID:
		m.ResetMissionConsumeOrderID()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionProduceOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, missionproduceorder.EdgeUser)
	}
	if m.earn_bills != nil {
		edges = append(edges, missionproduceorder.EdgeEarnBills)
	}
	if m.device != nil {
		edges = append(edges, missionproduceorder.EdgeDevice)
	}
	if m.mission_consume_order != nil {
		edges = append(edges, missionproduceorder.EdgeMissionConsumeOrder)
	}
	if m.mission_production != nil {
		edges = append(edges, missionproduceorder.EdgeMissionProduction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionProduceOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionproduceorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionproduceorder.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	case missionproduceorder.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case missionproduceorder.EdgeMissionConsumeOrder:
		if id := m.mission_consume_order; id != nil {
			return []ent.Value{*id}
		}
	case missionproduceorder.EdgeMissionProduction:
		if id := m.mission_production; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionProduceOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedearn_bills != nil {
		edges = append(edges, missionproduceorder.EdgeEarnBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionProduceOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionproduceorder.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionProduceOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, missionproduceorder.EdgeUser)
	}
	if m.clearedearn_bills {
		edges = append(edges, missionproduceorder.EdgeEarnBills)
	}
	if m.cleareddevice {
		edges = append(edges, missionproduceorder.EdgeDevice)
	}
	if m.clearedmission_consume_order {
		edges = append(edges, missionproduceorder.EdgeMissionConsumeOrder)
	}
	if m.clearedmission_production {
		edges = append(edges, missionproduceorder.EdgeMissionProduction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionProduceOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case missionproduceorder.EdgeUser:
		return m.cleareduser
	case missionproduceorder.EdgeEarnBills:
		return m.clearedearn_bills
	case missionproduceorder.EdgeDevice:
		return m.cleareddevice
	case missionproduceorder.EdgeMissionConsumeOrder:
		return m.clearedmission_consume_order
	case missionproduceorder.EdgeMissionProduction:
		return m.clearedmission_production
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionProduceOrderMutation) ClearEdge(name string) error {
	switch name {
	case missionproduceorder.EdgeUser:
		m.ClearUser()
		return nil
	case missionproduceorder.EdgeDevice:
		m.ClearDevice()
		return nil
	case missionproduceorder.EdgeMissionConsumeOrder:
		m.ClearMissionConsumeOrder()
		return nil
	case missionproduceorder.EdgeMissionProduction:
		m.ClearMissionProduction()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionProduceOrderMutation) ResetEdge(name string) error {
	switch name {
	case missionproduceorder.EdgeUser:
		m.ResetUser()
		return nil
	case missionproduceorder.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	case missionproduceorder.EdgeDevice:
		m.ResetDevice()
		return nil
	case missionproduceorder.EdgeMissionConsumeOrder:
		m.ResetMissionConsumeOrder()
		return nil
	case missionproduceorder.EdgeMissionProduction:
		m.ResetMissionProduction()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder edge %s", name)
}

// MissionProductionMutation represents an operation that mutates the MissionProduction nodes in the graph.
type MissionProductionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_by                   *int64
	addcreated_by                *int64
	updated_by                   *int64
	addupdated_by                *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	started_at                   *time.Time
	finished_at                  *time.Time
	state                        *enums.MissionState
	gpu_version                  *enums.GpuVersion
	device_slot                  *int8
	adddevice_slot               *int8
	urls                         *string
	resp_status_code             *int32
	addresp_status_code          *int32
	resp_body                    *string
	device_slots                 *string
	gpu_num                      *int8
	addgpu_num                   *int8
	clearedFields                map[string]struct{}
	mission                      *int64
	clearedmission               bool
	user                         *int64
	cleareduser                  bool
	device                       *int64
	cleareddevice                bool
	mission_produce_order        *int64
	clearedmission_produce_order bool
	done                         bool
	oldValue                     func(context.Context) (*MissionProduction, error)
	predicates                   []predicate.MissionProduction
}

var _ ent.Mutation = (*MissionProductionMutation)(nil)

// missionproductionOption allows management of the mutation configuration using functional options.
type missionproductionOption func(*MissionProductionMutation)

// newMissionProductionMutation creates new mutation for the MissionProduction entity.
func newMissionProductionMutation(c config, op Op, opts ...missionproductionOption) *MissionProductionMutation {
	m := &MissionProductionMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionProduction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionProductionID sets the ID field of the mutation.
func withMissionProductionID(id int64) missionproductionOption {
	return func(m *MissionProductionMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionProduction
		)
		m.oldValue = func(ctx context.Context) (*MissionProduction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionProduction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionProduction sets the old MissionProduction of the mutation.
func withMissionProduction(node *MissionProduction) missionproductionOption {
	return func(m *MissionProductionMutation) {
		m.oldValue = func(context.Context) (*MissionProduction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionProductionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionProductionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionProduction entities.
func (m *MissionProductionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionProductionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionProductionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionProduction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionProductionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionProductionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionProductionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionProductionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionProductionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionProductionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionProductionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionProductionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionProductionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionProductionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionProductionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionProductionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionProductionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionProductionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionProductionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionProductionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionProductionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionProductionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionProductionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionProductionMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionProductionMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionProductionMutation) ResetMissionID() {
	m.mission = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionProductionMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionProductionMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionProductionMutation) ResetUserID() {
	m.user = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionProductionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionProductionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionProductionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionProductionMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionProductionMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionProductionMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetState sets the "state" field.
func (m *MissionProductionMutation) SetState(es enums.MissionState) {
	m.state = &es
}

// State returns the value of the "state" field in the mutation.
func (m *MissionProductionMutation) State() (r enums.MissionState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldState(ctx context.Context) (v enums.MissionState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *MissionProductionMutation) ResetState() {
	m.state = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionProductionMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionProductionMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionProductionMutation) ResetDeviceID() {
	m.device = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *MissionProductionMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *MissionProductionMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *MissionProductionMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetDeviceSlot sets the "device_slot" field.
func (m *MissionProductionMutation) SetDeviceSlot(i int8) {
	m.device_slot = &i
	m.adddevice_slot = nil
}

// DeviceSlot returns the value of the "device_slot" field in the mutation.
func (m *MissionProductionMutation) DeviceSlot() (r int8, exists bool) {
	v := m.device_slot
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceSlot returns the old "device_slot" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldDeviceSlot(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceSlot: %w", err)
	}
	return oldValue.DeviceSlot, nil
}

// AddDeviceSlot adds i to the "device_slot" field.
func (m *MissionProductionMutation) AddDeviceSlot(i int8) {
	if m.adddevice_slot != nil {
		*m.adddevice_slot += i
	} else {
		m.adddevice_slot = &i
	}
}

// AddedDeviceSlot returns the value that was added to the "device_slot" field in this mutation.
func (m *MissionProductionMutation) AddedDeviceSlot() (r int8, exists bool) {
	v := m.adddevice_slot
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceSlot resets all changes to the "device_slot" field.
func (m *MissionProductionMutation) ResetDeviceSlot() {
	m.device_slot = nil
	m.adddevice_slot = nil
}

// SetUrls sets the "urls" field.
func (m *MissionProductionMutation) SetUrls(s string) {
	m.urls = &s
}

// Urls returns the value of the "urls" field in the mutation.
func (m *MissionProductionMutation) Urls() (r string, exists bool) {
	v := m.urls
	if v == nil {
		return
	}
	return *v, true
}

// OldUrls returns the old "urls" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldUrls(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrls: %w", err)
	}
	return oldValue.Urls, nil
}

// ResetUrls resets all changes to the "urls" field.
func (m *MissionProductionMutation) ResetUrls() {
	m.urls = nil
}

// SetRespStatusCode sets the "resp_status_code" field.
func (m *MissionProductionMutation) SetRespStatusCode(i int32) {
	m.resp_status_code = &i
	m.addresp_status_code = nil
}

// RespStatusCode returns the value of the "resp_status_code" field in the mutation.
func (m *MissionProductionMutation) RespStatusCode() (r int32, exists bool) {
	v := m.resp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRespStatusCode returns the old "resp_status_code" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldRespStatusCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespStatusCode: %w", err)
	}
	return oldValue.RespStatusCode, nil
}

// AddRespStatusCode adds i to the "resp_status_code" field.
func (m *MissionProductionMutation) AddRespStatusCode(i int32) {
	if m.addresp_status_code != nil {
		*m.addresp_status_code += i
	} else {
		m.addresp_status_code = &i
	}
}

// AddedRespStatusCode returns the value that was added to the "resp_status_code" field in this mutation.
func (m *MissionProductionMutation) AddedRespStatusCode() (r int32, exists bool) {
	v := m.addresp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetRespStatusCode resets all changes to the "resp_status_code" field.
func (m *MissionProductionMutation) ResetRespStatusCode() {
	m.resp_status_code = nil
	m.addresp_status_code = nil
}

// SetRespBody sets the "resp_body" field.
func (m *MissionProductionMutation) SetRespBody(s string) {
	m.resp_body = &s
}

// RespBody returns the value of the "resp_body" field in the mutation.
func (m *MissionProductionMutation) RespBody() (r string, exists bool) {
	v := m.resp_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRespBody returns the old "resp_body" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldRespBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespBody: %w", err)
	}
	return oldValue.RespBody, nil
}

// ResetRespBody resets all changes to the "resp_body" field.
func (m *MissionProductionMutation) ResetRespBody() {
	m.resp_body = nil
}

// SetDeviceSlots sets the "device_slots" field.
func (m *MissionProductionMutation) SetDeviceSlots(s string) {
	m.device_slots = &s
}

// DeviceSlots returns the value of the "device_slots" field in the mutation.
func (m *MissionProductionMutation) DeviceSlots() (r string, exists bool) {
	v := m.device_slots
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceSlots returns the old "device_slots" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldDeviceSlots(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceSlots is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceSlots requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceSlots: %w", err)
	}
	return oldValue.DeviceSlots, nil
}

// ResetDeviceSlots resets all changes to the "device_slots" field.
func (m *MissionProductionMutation) ResetDeviceSlots() {
	m.device_slots = nil
}

// SetGpuNum sets the "gpu_num" field.
func (m *MissionProductionMutation) SetGpuNum(i int8) {
	m.gpu_num = &i
	m.addgpu_num = nil
}

// GpuNum returns the value of the "gpu_num" field in the mutation.
func (m *MissionProductionMutation) GpuNum() (r int8, exists bool) {
	v := m.gpu_num
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuNum returns the old "gpu_num" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldGpuNum(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuNum: %w", err)
	}
	return oldValue.GpuNum, nil
}

// AddGpuNum adds i to the "gpu_num" field.
func (m *MissionProductionMutation) AddGpuNum(i int8) {
	if m.addgpu_num != nil {
		*m.addgpu_num += i
	} else {
		m.addgpu_num = &i
	}
}

// AddedGpuNum returns the value that was added to the "gpu_num" field in this mutation.
func (m *MissionProductionMutation) AddedGpuNum() (r int8, exists bool) {
	v := m.addgpu_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetGpuNum resets all changes to the "gpu_num" field.
func (m *MissionProductionMutation) ResetGpuNum() {
	m.gpu_num = nil
	m.addgpu_num = nil
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionProductionMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionproduction.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionProductionMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionProductionMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionProductionMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionProductionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionproduction.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionProductionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionProductionMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionProductionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *MissionProductionMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[missionproduction.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *MissionProductionMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *MissionProductionMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *MissionProductionMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// SetMissionProduceOrderID sets the "mission_produce_order" edge to the MissionProduceOrder entity by id.
func (m *MissionProductionMutation) SetMissionProduceOrderID(id int64) {
	m.mission_produce_order = &id
}

// ClearMissionProduceOrder clears the "mission_produce_order" edge to the MissionProduceOrder entity.
func (m *MissionProductionMutation) ClearMissionProduceOrder() {
	m.clearedmission_produce_order = true
}

// MissionProduceOrderCleared reports if the "mission_produce_order" edge to the MissionProduceOrder entity was cleared.
func (m *MissionProductionMutation) MissionProduceOrderCleared() bool {
	return m.clearedmission_produce_order
}

// MissionProduceOrderID returns the "mission_produce_order" edge ID in the mutation.
func (m *MissionProductionMutation) MissionProduceOrderID() (id int64, exists bool) {
	if m.mission_produce_order != nil {
		return *m.mission_produce_order, true
	}
	return
}

// MissionProduceOrderIDs returns the "mission_produce_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionProduceOrderID instead. It exists only for internal usage by the builders.
func (m *MissionProductionMutation) MissionProduceOrderIDs() (ids []int64) {
	if id := m.mission_produce_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionProduceOrder resets all changes to the "mission_produce_order" edge.
func (m *MissionProductionMutation) ResetMissionProduceOrder() {
	m.mission_produce_order = nil
	m.clearedmission_produce_order = false
}

// Where appends a list predicates to the MissionProductionMutation builder.
func (m *MissionProductionMutation) Where(ps ...predicate.MissionProduction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionProductionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionProductionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionProduction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionProductionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionProductionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionProduction).
func (m *MissionProductionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionProductionMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_by != nil {
		fields = append(fields, missionproduction.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionproduction.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionproduction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionproduction.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionproduction.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, missionproduction.FieldMissionID)
	}
	if m.user != nil {
		fields = append(fields, missionproduction.FieldUserID)
	}
	if m.started_at != nil {
		fields = append(fields, missionproduction.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionproduction.FieldFinishedAt)
	}
	if m.state != nil {
		fields = append(fields, missionproduction.FieldState)
	}
	if m.device != nil {
		fields = append(fields, missionproduction.FieldDeviceID)
	}
	if m.gpu_version != nil {
		fields = append(fields, missionproduction.FieldGpuVersion)
	}
	if m.device_slot != nil {
		fields = append(fields, missionproduction.FieldDeviceSlot)
	}
	if m.urls != nil {
		fields = append(fields, missionproduction.FieldUrls)
	}
	if m.resp_status_code != nil {
		fields = append(fields, missionproduction.FieldRespStatusCode)
	}
	if m.resp_body != nil {
		fields = append(fields, missionproduction.FieldRespBody)
	}
	if m.device_slots != nil {
		fields = append(fields, missionproduction.FieldDeviceSlots)
	}
	if m.gpu_num != nil {
		fields = append(fields, missionproduction.FieldGpuNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionProductionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionproduction.FieldCreatedBy:
		return m.CreatedBy()
	case missionproduction.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionproduction.FieldCreatedAt:
		return m.CreatedAt()
	case missionproduction.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionproduction.FieldDeletedAt:
		return m.DeletedAt()
	case missionproduction.FieldMissionID:
		return m.MissionID()
	case missionproduction.FieldUserID:
		return m.UserID()
	case missionproduction.FieldStartedAt:
		return m.StartedAt()
	case missionproduction.FieldFinishedAt:
		return m.FinishedAt()
	case missionproduction.FieldState:
		return m.State()
	case missionproduction.FieldDeviceID:
		return m.DeviceID()
	case missionproduction.FieldGpuVersion:
		return m.GpuVersion()
	case missionproduction.FieldDeviceSlot:
		return m.DeviceSlot()
	case missionproduction.FieldUrls:
		return m.Urls()
	case missionproduction.FieldRespStatusCode:
		return m.RespStatusCode()
	case missionproduction.FieldRespBody:
		return m.RespBody()
	case missionproduction.FieldDeviceSlots:
		return m.DeviceSlots()
	case missionproduction.FieldGpuNum:
		return m.GpuNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionProductionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionproduction.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionproduction.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionproduction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionproduction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionproduction.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionproduction.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionproduction.FieldUserID:
		return m.OldUserID(ctx)
	case missionproduction.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionproduction.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionproduction.FieldState:
		return m.OldState(ctx)
	case missionproduction.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionproduction.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case missionproduction.FieldDeviceSlot:
		return m.OldDeviceSlot(ctx)
	case missionproduction.FieldUrls:
		return m.OldUrls(ctx)
	case missionproduction.FieldRespStatusCode:
		return m.OldRespStatusCode(ctx)
	case missionproduction.FieldRespBody:
		return m.OldRespBody(ctx)
	case missionproduction.FieldDeviceSlots:
		return m.OldDeviceSlots(ctx)
	case missionproduction.FieldGpuNum:
		return m.OldGpuNum(ctx)
	}
	return nil, fmt.Errorf("unknown MissionProduction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProductionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionproduction.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionproduction.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionproduction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionproduction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionproduction.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionproduction.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionproduction.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case missionproduction.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionproduction.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionproduction.FieldState:
		v, ok := value.(enums.MissionState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case missionproduction.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionproduction.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case missionproduction.FieldDeviceSlot:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceSlot(v)
		return nil
	case missionproduction.FieldUrls:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrls(v)
		return nil
	case missionproduction.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespStatusCode(v)
		return nil
	case missionproduction.FieldRespBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespBody(v)
		return nil
	case missionproduction.FieldDeviceSlots:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceSlots(v)
		return nil
	case missionproduction.FieldGpuNum:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuNum(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionProductionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionproduction.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionproduction.FieldUpdatedBy)
	}
	if m.adddevice_slot != nil {
		fields = append(fields, missionproduction.FieldDeviceSlot)
	}
	if m.addresp_status_code != nil {
		fields = append(fields, missionproduction.FieldRespStatusCode)
	}
	if m.addgpu_num != nil {
		fields = append(fields, missionproduction.FieldGpuNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionProductionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionproduction.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionproduction.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionproduction.FieldDeviceSlot:
		return m.AddedDeviceSlot()
	case missionproduction.FieldRespStatusCode:
		return m.AddedRespStatusCode()
	case missionproduction.FieldGpuNum:
		return m.AddedGpuNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProductionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionproduction.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionproduction.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionproduction.FieldDeviceSlot:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceSlot(v)
		return nil
	case missionproduction.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRespStatusCode(v)
		return nil
	case missionproduction.FieldGpuNum:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGpuNum(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionProductionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionProductionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionProductionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionProduction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionProductionMutation) ResetField(name string) error {
	switch name {
	case missionproduction.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionproduction.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionproduction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionproduction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionproduction.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionproduction.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionproduction.FieldUserID:
		m.ResetUserID()
		return nil
	case missionproduction.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionproduction.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionproduction.FieldState:
		m.ResetState()
		return nil
	case missionproduction.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionproduction.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case missionproduction.FieldDeviceSlot:
		m.ResetDeviceSlot()
		return nil
	case missionproduction.FieldUrls:
		m.ResetUrls()
		return nil
	case missionproduction.FieldRespStatusCode:
		m.ResetRespStatusCode()
		return nil
	case missionproduction.FieldRespBody:
		m.ResetRespBody()
		return nil
	case missionproduction.FieldDeviceSlots:
		m.ResetDeviceSlots()
		return nil
	case missionproduction.FieldGpuNum:
		m.ResetGpuNum()
		return nil
	}
	return fmt.Errorf("unknown MissionProduction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionProductionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.mission != nil {
		edges = append(edges, missionproduction.EdgeMission)
	}
	if m.user != nil {
		edges = append(edges, missionproduction.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, missionproduction.EdgeDevice)
	}
	if m.mission_produce_order != nil {
		edges = append(edges, missionproduction.EdgeMissionProduceOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionProductionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionproduction.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case missionproduction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionproduction.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case missionproduction.EdgeMissionProduceOrder:
		if id := m.mission_produce_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionProductionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionProductionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionProductionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmission {
		edges = append(edges, missionproduction.EdgeMission)
	}
	if m.cleareduser {
		edges = append(edges, missionproduction.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, missionproduction.EdgeDevice)
	}
	if m.clearedmission_produce_order {
		edges = append(edges, missionproduction.EdgeMissionProduceOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionProductionMutation) EdgeCleared(name string) bool {
	switch name {
	case missionproduction.EdgeMission:
		return m.clearedmission
	case missionproduction.EdgeUser:
		return m.cleareduser
	case missionproduction.EdgeDevice:
		return m.cleareddevice
	case missionproduction.EdgeMissionProduceOrder:
		return m.clearedmission_produce_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionProductionMutation) ClearEdge(name string) error {
	switch name {
	case missionproduction.EdgeMission:
		m.ClearMission()
		return nil
	case missionproduction.EdgeUser:
		m.ClearUser()
		return nil
	case missionproduction.EdgeDevice:
		m.ClearDevice()
		return nil
	case missionproduction.EdgeMissionProduceOrder:
		m.ClearMissionProduceOrder()
		return nil
	}
	return fmt.Errorf("unknown MissionProduction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionProductionMutation) ResetEdge(name string) error {
	switch name {
	case missionproduction.EdgeMission:
		m.ResetMission()
		return nil
	case missionproduction.EdgeUser:
		m.ResetUser()
		return nil
	case missionproduction.EdgeDevice:
		m.ResetDevice()
		return nil
	case missionproduction.EdgeMissionProduceOrder:
		m.ResetMissionProduceOrder()
		return nil
	}
	return fmt.Errorf("unknown MissionProduction edge %s", name)
}

// ModelMutation represents an operation that mutates the Model nodes in the graph.
type ModelMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	name                       *string
	author                     *string
	description                *string
	model_type                 *enums.Model
	model_status               *enums.ModelStatus
	is_official                *bool
	total_usage                *int
	addtotal_usage             *int
	clearedFields              map[string]struct{}
	model_prices               map[int64]struct{}
	removedmodel_prices        map[int64]struct{}
	clearedmodel_prices        bool
	user_models                map[int64]struct{}
	removeduser_models         map[int64]struct{}
	cleareduser_models         bool
	invoke_model_orders        map[int64]struct{}
	removedinvoke_model_orders map[int64]struct{}
	clearedinvoke_model_orders bool
	done                       bool
	oldValue                   func(context.Context) (*Model, error)
	predicates                 []predicate.Model
}

var _ ent.Mutation = (*ModelMutation)(nil)

// modelOption allows management of the mutation configuration using functional options.
type modelOption func(*ModelMutation)

// newModelMutation creates new mutation for the Model entity.
func newModelMutation(c config, op Op, opts ...modelOption) *ModelMutation {
	m := &ModelMutation{
		config:        c,
		op:            op,
		typ:           TypeModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModelID sets the ID field of the mutation.
func withModelID(id int64) modelOption {
	return func(m *ModelMutation) {
		var (
			err   error
			once  sync.Once
			value *Model
		)
		m.oldValue = func(ctx context.Context) (*Model, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Model.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModel sets the old Model of the mutation.
func withModel(node *Model) modelOption {
	return func(m *ModelMutation) {
		m.oldValue = func(context.Context) (*Model, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Model entities.
func (m *ModelMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModelMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModelMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Model.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ModelMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ModelMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ModelMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ModelMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ModelMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ModelMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ModelMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ModelMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ModelMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ModelMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ModelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ModelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ModelMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *ModelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ModelMutation) ResetName() {
	m.name = nil
}

// SetAuthor sets the "author" field.
func (m *ModelMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *ModelMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *ModelMutation) ResetAuthor() {
	m.author = nil
}

// SetDescription sets the "description" field.
func (m *ModelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ModelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ModelMutation) ResetDescription() {
	m.description = nil
}

// SetModelType sets the "model_type" field.
func (m *ModelMutation) SetModelType(e enums.Model) {
	m.model_type = &e
}

// ModelType returns the value of the "model_type" field in the mutation.
func (m *ModelMutation) ModelType() (r enums.Model, exists bool) {
	v := m.model_type
	if v == nil {
		return
	}
	return *v, true
}

// OldModelType returns the old "model_type" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldModelType(ctx context.Context) (v enums.Model, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelType: %w", err)
	}
	return oldValue.ModelType, nil
}

// ResetModelType resets all changes to the "model_type" field.
func (m *ModelMutation) ResetModelType() {
	m.model_type = nil
}

// SetModelStatus sets the "model_status" field.
func (m *ModelMutation) SetModelStatus(es enums.ModelStatus) {
	m.model_status = &es
}

// ModelStatus returns the value of the "model_status" field in the mutation.
func (m *ModelMutation) ModelStatus() (r enums.ModelStatus, exists bool) {
	v := m.model_status
	if v == nil {
		return
	}
	return *v, true
}

// OldModelStatus returns the old "model_status" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldModelStatus(ctx context.Context) (v enums.ModelStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelStatus: %w", err)
	}
	return oldValue.ModelStatus, nil
}

// ResetModelStatus resets all changes to the "model_status" field.
func (m *ModelMutation) ResetModelStatus() {
	m.model_status = nil
}

// SetIsOfficial sets the "is_official" field.
func (m *ModelMutation) SetIsOfficial(b bool) {
	m.is_official = &b
}

// IsOfficial returns the value of the "is_official" field in the mutation.
func (m *ModelMutation) IsOfficial() (r bool, exists bool) {
	v := m.is_official
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOfficial returns the old "is_official" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldIsOfficial(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOfficial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOfficial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOfficial: %w", err)
	}
	return oldValue.IsOfficial, nil
}

// ResetIsOfficial resets all changes to the "is_official" field.
func (m *ModelMutation) ResetIsOfficial() {
	m.is_official = nil
}

// SetTotalUsage sets the "total_usage" field.
func (m *ModelMutation) SetTotalUsage(i int) {
	m.total_usage = &i
	m.addtotal_usage = nil
}

// TotalUsage returns the value of the "total_usage" field in the mutation.
func (m *ModelMutation) TotalUsage() (r int, exists bool) {
	v := m.total_usage
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUsage returns the old "total_usage" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldTotalUsage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUsage: %w", err)
	}
	return oldValue.TotalUsage, nil
}

// AddTotalUsage adds i to the "total_usage" field.
func (m *ModelMutation) AddTotalUsage(i int) {
	if m.addtotal_usage != nil {
		*m.addtotal_usage += i
	} else {
		m.addtotal_usage = &i
	}
}

// AddedTotalUsage returns the value that was added to the "total_usage" field in this mutation.
func (m *ModelMutation) AddedTotalUsage() (r int, exists bool) {
	v := m.addtotal_usage
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalUsage resets all changes to the "total_usage" field.
func (m *ModelMutation) ResetTotalUsage() {
	m.total_usage = nil
	m.addtotal_usage = nil
}

// AddModelPriceIDs adds the "model_prices" edge to the ModelPrice entity by ids.
func (m *ModelMutation) AddModelPriceIDs(ids ...int64) {
	if m.model_prices == nil {
		m.model_prices = make(map[int64]struct{})
	}
	for i := range ids {
		m.model_prices[ids[i]] = struct{}{}
	}
}

// ClearModelPrices clears the "model_prices" edge to the ModelPrice entity.
func (m *ModelMutation) ClearModelPrices() {
	m.clearedmodel_prices = true
}

// ModelPricesCleared reports if the "model_prices" edge to the ModelPrice entity was cleared.
func (m *ModelMutation) ModelPricesCleared() bool {
	return m.clearedmodel_prices
}

// RemoveModelPriceIDs removes the "model_prices" edge to the ModelPrice entity by IDs.
func (m *ModelMutation) RemoveModelPriceIDs(ids ...int64) {
	if m.removedmodel_prices == nil {
		m.removedmodel_prices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.model_prices, ids[i])
		m.removedmodel_prices[ids[i]] = struct{}{}
	}
}

// RemovedModelPrices returns the removed IDs of the "model_prices" edge to the ModelPrice entity.
func (m *ModelMutation) RemovedModelPricesIDs() (ids []int64) {
	for id := range m.removedmodel_prices {
		ids = append(ids, id)
	}
	return
}

// ModelPricesIDs returns the "model_prices" edge IDs in the mutation.
func (m *ModelMutation) ModelPricesIDs() (ids []int64) {
	for id := range m.model_prices {
		ids = append(ids, id)
	}
	return
}

// ResetModelPrices resets all changes to the "model_prices" edge.
func (m *ModelMutation) ResetModelPrices() {
	m.model_prices = nil
	m.clearedmodel_prices = false
	m.removedmodel_prices = nil
}

// AddUserModelIDs adds the "user_models" edge to the UserModel entity by ids.
func (m *ModelMutation) AddUserModelIDs(ids ...int64) {
	if m.user_models == nil {
		m.user_models = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_models[ids[i]] = struct{}{}
	}
}

// ClearUserModels clears the "user_models" edge to the UserModel entity.
func (m *ModelMutation) ClearUserModels() {
	m.cleareduser_models = true
}

// UserModelsCleared reports if the "user_models" edge to the UserModel entity was cleared.
func (m *ModelMutation) UserModelsCleared() bool {
	return m.cleareduser_models
}

// RemoveUserModelIDs removes the "user_models" edge to the UserModel entity by IDs.
func (m *ModelMutation) RemoveUserModelIDs(ids ...int64) {
	if m.removeduser_models == nil {
		m.removeduser_models = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_models, ids[i])
		m.removeduser_models[ids[i]] = struct{}{}
	}
}

// RemovedUserModels returns the removed IDs of the "user_models" edge to the UserModel entity.
func (m *ModelMutation) RemovedUserModelsIDs() (ids []int64) {
	for id := range m.removeduser_models {
		ids = append(ids, id)
	}
	return
}

// UserModelsIDs returns the "user_models" edge IDs in the mutation.
func (m *ModelMutation) UserModelsIDs() (ids []int64) {
	for id := range m.user_models {
		ids = append(ids, id)
	}
	return
}

// ResetUserModels resets all changes to the "user_models" edge.
func (m *ModelMutation) ResetUserModels() {
	m.user_models = nil
	m.cleareduser_models = false
	m.removeduser_models = nil
}

// AddInvokeModelOrderIDs adds the "invoke_model_orders" edge to the InvokeModelOrder entity by ids.
func (m *ModelMutation) AddInvokeModelOrderIDs(ids ...int64) {
	if m.invoke_model_orders == nil {
		m.invoke_model_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.invoke_model_orders[ids[i]] = struct{}{}
	}
}

// ClearInvokeModelOrders clears the "invoke_model_orders" edge to the InvokeModelOrder entity.
func (m *ModelMutation) ClearInvokeModelOrders() {
	m.clearedinvoke_model_orders = true
}

// InvokeModelOrdersCleared reports if the "invoke_model_orders" edge to the InvokeModelOrder entity was cleared.
func (m *ModelMutation) InvokeModelOrdersCleared() bool {
	return m.clearedinvoke_model_orders
}

// RemoveInvokeModelOrderIDs removes the "invoke_model_orders" edge to the InvokeModelOrder entity by IDs.
func (m *ModelMutation) RemoveInvokeModelOrderIDs(ids ...int64) {
	if m.removedinvoke_model_orders == nil {
		m.removedinvoke_model_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invoke_model_orders, ids[i])
		m.removedinvoke_model_orders[ids[i]] = struct{}{}
	}
}

// RemovedInvokeModelOrders returns the removed IDs of the "invoke_model_orders" edge to the InvokeModelOrder entity.
func (m *ModelMutation) RemovedInvokeModelOrdersIDs() (ids []int64) {
	for id := range m.removedinvoke_model_orders {
		ids = append(ids, id)
	}
	return
}

// InvokeModelOrdersIDs returns the "invoke_model_orders" edge IDs in the mutation.
func (m *ModelMutation) InvokeModelOrdersIDs() (ids []int64) {
	for id := range m.invoke_model_orders {
		ids = append(ids, id)
	}
	return
}

// ResetInvokeModelOrders resets all changes to the "invoke_model_orders" edge.
func (m *ModelMutation) ResetInvokeModelOrders() {
	m.invoke_model_orders = nil
	m.clearedinvoke_model_orders = false
	m.removedinvoke_model_orders = nil
}

// Where appends a list predicates to the ModelMutation builder.
func (m *ModelMutation) Where(ps ...predicate.Model) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Model, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Model).
func (m *ModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModelMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, model.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, model.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, model.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, model.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, model.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, model.FieldName)
	}
	if m.author != nil {
		fields = append(fields, model.FieldAuthor)
	}
	if m.description != nil {
		fields = append(fields, model.FieldDescription)
	}
	if m.model_type != nil {
		fields = append(fields, model.FieldModelType)
	}
	if m.model_status != nil {
		fields = append(fields, model.FieldModelStatus)
	}
	if m.is_official != nil {
		fields = append(fields, model.FieldIsOfficial)
	}
	if m.total_usage != nil {
		fields = append(fields, model.FieldTotalUsage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case model.FieldCreatedBy:
		return m.CreatedBy()
	case model.FieldUpdatedBy:
		return m.UpdatedBy()
	case model.FieldCreatedAt:
		return m.CreatedAt()
	case model.FieldUpdatedAt:
		return m.UpdatedAt()
	case model.FieldDeletedAt:
		return m.DeletedAt()
	case model.FieldName:
		return m.Name()
	case model.FieldAuthor:
		return m.Author()
	case model.FieldDescription:
		return m.Description()
	case model.FieldModelType:
		return m.ModelType()
	case model.FieldModelStatus:
		return m.ModelStatus()
	case model.FieldIsOfficial:
		return m.IsOfficial()
	case model.FieldTotalUsage:
		return m.TotalUsage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case model.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case model.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case model.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case model.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case model.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case model.FieldName:
		return m.OldName(ctx)
	case model.FieldAuthor:
		return m.OldAuthor(ctx)
	case model.FieldDescription:
		return m.OldDescription(ctx)
	case model.FieldModelType:
		return m.OldModelType(ctx)
	case model.FieldModelStatus:
		return m.OldModelStatus(ctx)
	case model.FieldIsOfficial:
		return m.OldIsOfficial(ctx)
	case model.FieldTotalUsage:
		return m.OldTotalUsage(ctx)
	}
	return nil, fmt.Errorf("unknown Model field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case model.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case model.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case model.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case model.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case model.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case model.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case model.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case model.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case model.FieldModelType:
		v, ok := value.(enums.Model)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelType(v)
		return nil
	case model.FieldModelStatus:
		v, ok := value.(enums.ModelStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelStatus(v)
		return nil
	case model.FieldIsOfficial:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOfficial(v)
		return nil
	case model.FieldTotalUsage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUsage(v)
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModelMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, model.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, model.FieldUpdatedBy)
	}
	if m.addtotal_usage != nil {
		fields = append(fields, model.FieldTotalUsage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case model.FieldCreatedBy:
		return m.AddedCreatedBy()
	case model.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case model.FieldTotalUsage:
		return m.AddedTotalUsage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case model.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case model.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case model.FieldTotalUsage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalUsage(v)
		return nil
	}
	return fmt.Errorf("unknown Model numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Model nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModelMutation) ResetField(name string) error {
	switch name {
	case model.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case model.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case model.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case model.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case model.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case model.FieldName:
		m.ResetName()
		return nil
	case model.FieldAuthor:
		m.ResetAuthor()
		return nil
	case model.FieldDescription:
		m.ResetDescription()
		return nil
	case model.FieldModelType:
		m.ResetModelType()
		return nil
	case model.FieldModelStatus:
		m.ResetModelStatus()
		return nil
	case model.FieldIsOfficial:
		m.ResetIsOfficial()
		return nil
	case model.FieldTotalUsage:
		m.ResetTotalUsage()
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.model_prices != nil {
		edges = append(edges, model.EdgeModelPrices)
	}
	if m.user_models != nil {
		edges = append(edges, model.EdgeUserModels)
	}
	if m.invoke_model_orders != nil {
		edges = append(edges, model.EdgeInvokeModelOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case model.EdgeModelPrices:
		ids := make([]ent.Value, 0, len(m.model_prices))
		for id := range m.model_prices {
			ids = append(ids, id)
		}
		return ids
	case model.EdgeUserModels:
		ids := make([]ent.Value, 0, len(m.user_models))
		for id := range m.user_models {
			ids = append(ids, id)
		}
		return ids
	case model.EdgeInvokeModelOrders:
		ids := make([]ent.Value, 0, len(m.invoke_model_orders))
		for id := range m.invoke_model_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmodel_prices != nil {
		edges = append(edges, model.EdgeModelPrices)
	}
	if m.removeduser_models != nil {
		edges = append(edges, model.EdgeUserModels)
	}
	if m.removedinvoke_model_orders != nil {
		edges = append(edges, model.EdgeInvokeModelOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case model.EdgeModelPrices:
		ids := make([]ent.Value, 0, len(m.removedmodel_prices))
		for id := range m.removedmodel_prices {
			ids = append(ids, id)
		}
		return ids
	case model.EdgeUserModels:
		ids := make([]ent.Value, 0, len(m.removeduser_models))
		for id := range m.removeduser_models {
			ids = append(ids, id)
		}
		return ids
	case model.EdgeInvokeModelOrders:
		ids := make([]ent.Value, 0, len(m.removedinvoke_model_orders))
		for id := range m.removedinvoke_model_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmodel_prices {
		edges = append(edges, model.EdgeModelPrices)
	}
	if m.cleareduser_models {
		edges = append(edges, model.EdgeUserModels)
	}
	if m.clearedinvoke_model_orders {
		edges = append(edges, model.EdgeInvokeModelOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModelMutation) EdgeCleared(name string) bool {
	switch name {
	case model.EdgeModelPrices:
		return m.clearedmodel_prices
	case model.EdgeUserModels:
		return m.cleareduser_models
	case model.EdgeInvokeModelOrders:
		return m.clearedinvoke_model_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Model unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModelMutation) ResetEdge(name string) error {
	switch name {
	case model.EdgeModelPrices:
		m.ResetModelPrices()
		return nil
	case model.EdgeUserModels:
		m.ResetUserModels()
		return nil
	case model.EdgeInvokeModelOrders:
		m.ResetInvokeModelOrders()
		return nil
	}
	return fmt.Errorf("unknown Model edge %s", name)
}

// ModelPriceMutation represents an operation that mutates the ModelPrice nodes in the graph.
type ModelPriceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	invoke_type           *enums.InvokeType
	gpu_version           *enums.GpuVersion
	input_gpu_price       *int
	addinput_gpu_price    *int
	output_gpu_price      *int
	addoutput_gpu_price   *int
	input_model_price     *int
	addinput_model_price  *int
	output_model_price    *int
	addoutput_model_price *int
	token_per_cep         *int64
	addtoken_per_cep      *int64
	clearedFields         map[string]struct{}
	model                 *int64
	clearedmodel          bool
	done                  bool
	oldValue              func(context.Context) (*ModelPrice, error)
	predicates            []predicate.ModelPrice
}

var _ ent.Mutation = (*ModelPriceMutation)(nil)

// modelpriceOption allows management of the mutation configuration using functional options.
type modelpriceOption func(*ModelPriceMutation)

// newModelPriceMutation creates new mutation for the ModelPrice entity.
func newModelPriceMutation(c config, op Op, opts ...modelpriceOption) *ModelPriceMutation {
	m := &ModelPriceMutation{
		config:        c,
		op:            op,
		typ:           TypeModelPrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModelPriceID sets the ID field of the mutation.
func withModelPriceID(id int64) modelpriceOption {
	return func(m *ModelPriceMutation) {
		var (
			err   error
			once  sync.Once
			value *ModelPrice
		)
		m.oldValue = func(ctx context.Context) (*ModelPrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ModelPrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModelPrice sets the old ModelPrice of the mutation.
func withModelPrice(node *ModelPrice) modelpriceOption {
	return func(m *ModelPriceMutation) {
		m.oldValue = func(context.Context) (*ModelPrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModelPriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModelPriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ModelPrice entities.
func (m *ModelPriceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModelPriceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModelPriceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ModelPrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ModelPriceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ModelPriceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ModelPriceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ModelPriceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ModelPriceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ModelPriceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ModelPriceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ModelPriceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ModelPriceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ModelPriceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ModelPriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModelPriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModelPriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModelPriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModelPriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModelPriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ModelPriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ModelPriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ModelPriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetModelID sets the "model_id" field.
func (m *ModelPriceMutation) SetModelID(i int64) {
	m.model = &i
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *ModelPriceMutation) ModelID() (r int64, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldModelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *ModelPriceMutation) ResetModelID() {
	m.model = nil
}

// SetInvokeType sets the "invoke_type" field.
func (m *ModelPriceMutation) SetInvokeType(et enums.InvokeType) {
	m.invoke_type = &et
}

// InvokeType returns the value of the "invoke_type" field in the mutation.
func (m *ModelPriceMutation) InvokeType() (r enums.InvokeType, exists bool) {
	v := m.invoke_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInvokeType returns the old "invoke_type" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldInvokeType(ctx context.Context) (v enums.InvokeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvokeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvokeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvokeType: %w", err)
	}
	return oldValue.InvokeType, nil
}

// ResetInvokeType resets all changes to the "invoke_type" field.
func (m *ModelPriceMutation) ResetInvokeType() {
	m.invoke_type = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *ModelPriceMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *ModelPriceMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *ModelPriceMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetInputGpuPrice sets the "input_gpu_price" field.
func (m *ModelPriceMutation) SetInputGpuPrice(i int) {
	m.input_gpu_price = &i
	m.addinput_gpu_price = nil
}

// InputGpuPrice returns the value of the "input_gpu_price" field in the mutation.
func (m *ModelPriceMutation) InputGpuPrice() (r int, exists bool) {
	v := m.input_gpu_price
	if v == nil {
		return
	}
	return *v, true
}

// OldInputGpuPrice returns the old "input_gpu_price" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldInputGpuPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputGpuPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputGpuPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputGpuPrice: %w", err)
	}
	return oldValue.InputGpuPrice, nil
}

// AddInputGpuPrice adds i to the "input_gpu_price" field.
func (m *ModelPriceMutation) AddInputGpuPrice(i int) {
	if m.addinput_gpu_price != nil {
		*m.addinput_gpu_price += i
	} else {
		m.addinput_gpu_price = &i
	}
}

// AddedInputGpuPrice returns the value that was added to the "input_gpu_price" field in this mutation.
func (m *ModelPriceMutation) AddedInputGpuPrice() (r int, exists bool) {
	v := m.addinput_gpu_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetInputGpuPrice resets all changes to the "input_gpu_price" field.
func (m *ModelPriceMutation) ResetInputGpuPrice() {
	m.input_gpu_price = nil
	m.addinput_gpu_price = nil
}

// SetOutputGpuPrice sets the "output_gpu_price" field.
func (m *ModelPriceMutation) SetOutputGpuPrice(i int) {
	m.output_gpu_price = &i
	m.addoutput_gpu_price = nil
}

// OutputGpuPrice returns the value of the "output_gpu_price" field in the mutation.
func (m *ModelPriceMutation) OutputGpuPrice() (r int, exists bool) {
	v := m.output_gpu_price
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputGpuPrice returns the old "output_gpu_price" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldOutputGpuPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputGpuPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputGpuPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputGpuPrice: %w", err)
	}
	return oldValue.OutputGpuPrice, nil
}

// AddOutputGpuPrice adds i to the "output_gpu_price" field.
func (m *ModelPriceMutation) AddOutputGpuPrice(i int) {
	if m.addoutput_gpu_price != nil {
		*m.addoutput_gpu_price += i
	} else {
		m.addoutput_gpu_price = &i
	}
}

// AddedOutputGpuPrice returns the value that was added to the "output_gpu_price" field in this mutation.
func (m *ModelPriceMutation) AddedOutputGpuPrice() (r int, exists bool) {
	v := m.addoutput_gpu_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutputGpuPrice resets all changes to the "output_gpu_price" field.
func (m *ModelPriceMutation) ResetOutputGpuPrice() {
	m.output_gpu_price = nil
	m.addoutput_gpu_price = nil
}

// SetInputModelPrice sets the "input_model_price" field.
func (m *ModelPriceMutation) SetInputModelPrice(i int) {
	m.input_model_price = &i
	m.addinput_model_price = nil
}

// InputModelPrice returns the value of the "input_model_price" field in the mutation.
func (m *ModelPriceMutation) InputModelPrice() (r int, exists bool) {
	v := m.input_model_price
	if v == nil {
		return
	}
	return *v, true
}

// OldInputModelPrice returns the old "input_model_price" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldInputModelPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputModelPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputModelPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputModelPrice: %w", err)
	}
	return oldValue.InputModelPrice, nil
}

// AddInputModelPrice adds i to the "input_model_price" field.
func (m *ModelPriceMutation) AddInputModelPrice(i int) {
	if m.addinput_model_price != nil {
		*m.addinput_model_price += i
	} else {
		m.addinput_model_price = &i
	}
}

// AddedInputModelPrice returns the value that was added to the "input_model_price" field in this mutation.
func (m *ModelPriceMutation) AddedInputModelPrice() (r int, exists bool) {
	v := m.addinput_model_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetInputModelPrice resets all changes to the "input_model_price" field.
func (m *ModelPriceMutation) ResetInputModelPrice() {
	m.input_model_price = nil
	m.addinput_model_price = nil
}

// SetOutputModelPrice sets the "output_model_price" field.
func (m *ModelPriceMutation) SetOutputModelPrice(i int) {
	m.output_model_price = &i
	m.addoutput_model_price = nil
}

// OutputModelPrice returns the value of the "output_model_price" field in the mutation.
func (m *ModelPriceMutation) OutputModelPrice() (r int, exists bool) {
	v := m.output_model_price
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputModelPrice returns the old "output_model_price" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldOutputModelPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputModelPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputModelPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputModelPrice: %w", err)
	}
	return oldValue.OutputModelPrice, nil
}

// AddOutputModelPrice adds i to the "output_model_price" field.
func (m *ModelPriceMutation) AddOutputModelPrice(i int) {
	if m.addoutput_model_price != nil {
		*m.addoutput_model_price += i
	} else {
		m.addoutput_model_price = &i
	}
}

// AddedOutputModelPrice returns the value that was added to the "output_model_price" field in this mutation.
func (m *ModelPriceMutation) AddedOutputModelPrice() (r int, exists bool) {
	v := m.addoutput_model_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutputModelPrice resets all changes to the "output_model_price" field.
func (m *ModelPriceMutation) ResetOutputModelPrice() {
	m.output_model_price = nil
	m.addoutput_model_price = nil
}

// SetTokenPerCep sets the "token_per_cep" field.
func (m *ModelPriceMutation) SetTokenPerCep(i int64) {
	m.token_per_cep = &i
	m.addtoken_per_cep = nil
}

// TokenPerCep returns the value of the "token_per_cep" field in the mutation.
func (m *ModelPriceMutation) TokenPerCep() (r int64, exists bool) {
	v := m.token_per_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenPerCep returns the old "token_per_cep" field's value of the ModelPrice entity.
// If the ModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelPriceMutation) OldTokenPerCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenPerCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenPerCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenPerCep: %w", err)
	}
	return oldValue.TokenPerCep, nil
}

// AddTokenPerCep adds i to the "token_per_cep" field.
func (m *ModelPriceMutation) AddTokenPerCep(i int64) {
	if m.addtoken_per_cep != nil {
		*m.addtoken_per_cep += i
	} else {
		m.addtoken_per_cep = &i
	}
}

// AddedTokenPerCep returns the value that was added to the "token_per_cep" field in this mutation.
func (m *ModelPriceMutation) AddedTokenPerCep() (r int64, exists bool) {
	v := m.addtoken_per_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenPerCep resets all changes to the "token_per_cep" field.
func (m *ModelPriceMutation) ResetTokenPerCep() {
	m.token_per_cep = nil
	m.addtoken_per_cep = nil
}

// ClearModel clears the "model" edge to the Model entity.
func (m *ModelPriceMutation) ClearModel() {
	m.clearedmodel = true
	m.clearedFields[modelprice.FieldModelID] = struct{}{}
}

// ModelCleared reports if the "model" edge to the Model entity was cleared.
func (m *ModelPriceMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *ModelPriceMutation) ModelIDs() (ids []int64) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *ModelPriceMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// Where appends a list predicates to the ModelPriceMutation builder.
func (m *ModelPriceMutation) Where(ps ...predicate.ModelPrice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModelPriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModelPriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ModelPrice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModelPriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModelPriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ModelPrice).
func (m *ModelPriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModelPriceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, modelprice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, modelprice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, modelprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, modelprice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, modelprice.FieldDeletedAt)
	}
	if m.model != nil {
		fields = append(fields, modelprice.FieldModelID)
	}
	if m.invoke_type != nil {
		fields = append(fields, modelprice.FieldInvokeType)
	}
	if m.gpu_version != nil {
		fields = append(fields, modelprice.FieldGpuVersion)
	}
	if m.input_gpu_price != nil {
		fields = append(fields, modelprice.FieldInputGpuPrice)
	}
	if m.output_gpu_price != nil {
		fields = append(fields, modelprice.FieldOutputGpuPrice)
	}
	if m.input_model_price != nil {
		fields = append(fields, modelprice.FieldInputModelPrice)
	}
	if m.output_model_price != nil {
		fields = append(fields, modelprice.FieldOutputModelPrice)
	}
	if m.token_per_cep != nil {
		fields = append(fields, modelprice.FieldTokenPerCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModelPriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case modelprice.FieldCreatedBy:
		return m.CreatedBy()
	case modelprice.FieldUpdatedBy:
		return m.UpdatedBy()
	case modelprice.FieldCreatedAt:
		return m.CreatedAt()
	case modelprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case modelprice.FieldDeletedAt:
		return m.DeletedAt()
	case modelprice.FieldModelID:
		return m.ModelID()
	case modelprice.FieldInvokeType:
		return m.InvokeType()
	case modelprice.FieldGpuVersion:
		return m.GpuVersion()
	case modelprice.FieldInputGpuPrice:
		return m.InputGpuPrice()
	case modelprice.FieldOutputGpuPrice:
		return m.OutputGpuPrice()
	case modelprice.FieldInputModelPrice:
		return m.InputModelPrice()
	case modelprice.FieldOutputModelPrice:
		return m.OutputModelPrice()
	case modelprice.FieldTokenPerCep:
		return m.TokenPerCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModelPriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case modelprice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case modelprice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case modelprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case modelprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case modelprice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case modelprice.FieldModelID:
		return m.OldModelID(ctx)
	case modelprice.FieldInvokeType:
		return m.OldInvokeType(ctx)
	case modelprice.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case modelprice.FieldInputGpuPrice:
		return m.OldInputGpuPrice(ctx)
	case modelprice.FieldOutputGpuPrice:
		return m.OldOutputGpuPrice(ctx)
	case modelprice.FieldInputModelPrice:
		return m.OldInputModelPrice(ctx)
	case modelprice.FieldOutputModelPrice:
		return m.OldOutputModelPrice(ctx)
	case modelprice.FieldTokenPerCep:
		return m.OldTokenPerCep(ctx)
	}
	return nil, fmt.Errorf("unknown ModelPrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelPriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case modelprice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case modelprice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case modelprice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case modelprice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case modelprice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case modelprice.FieldModelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case modelprice.FieldInvokeType:
		v, ok := value.(enums.InvokeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvokeType(v)
		return nil
	case modelprice.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case modelprice.FieldInputGpuPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputGpuPrice(v)
		return nil
	case modelprice.FieldOutputGpuPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputGpuPrice(v)
		return nil
	case modelprice.FieldInputModelPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputModelPrice(v)
		return nil
	case modelprice.FieldOutputModelPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputModelPrice(v)
		return nil
	case modelprice.FieldTokenPerCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenPerCep(v)
		return nil
	}
	return fmt.Errorf("unknown ModelPrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModelPriceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, modelprice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, modelprice.FieldUpdatedBy)
	}
	if m.addinput_gpu_price != nil {
		fields = append(fields, modelprice.FieldInputGpuPrice)
	}
	if m.addoutput_gpu_price != nil {
		fields = append(fields, modelprice.FieldOutputGpuPrice)
	}
	if m.addinput_model_price != nil {
		fields = append(fields, modelprice.FieldInputModelPrice)
	}
	if m.addoutput_model_price != nil {
		fields = append(fields, modelprice.FieldOutputModelPrice)
	}
	if m.addtoken_per_cep != nil {
		fields = append(fields, modelprice.FieldTokenPerCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModelPriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case modelprice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case modelprice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case modelprice.FieldInputGpuPrice:
		return m.AddedInputGpuPrice()
	case modelprice.FieldOutputGpuPrice:
		return m.AddedOutputGpuPrice()
	case modelprice.FieldInputModelPrice:
		return m.AddedInputModelPrice()
	case modelprice.FieldOutputModelPrice:
		return m.AddedOutputModelPrice()
	case modelprice.FieldTokenPerCep:
		return m.AddedTokenPerCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelPriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case modelprice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case modelprice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case modelprice.FieldInputGpuPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputGpuPrice(v)
		return nil
	case modelprice.FieldOutputGpuPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputGpuPrice(v)
		return nil
	case modelprice.FieldInputModelPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputModelPrice(v)
		return nil
	case modelprice.FieldOutputModelPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputModelPrice(v)
		return nil
	case modelprice.FieldTokenPerCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenPerCep(v)
		return nil
	}
	return fmt.Errorf("unknown ModelPrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModelPriceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModelPriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModelPriceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ModelPrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModelPriceMutation) ResetField(name string) error {
	switch name {
	case modelprice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case modelprice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case modelprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case modelprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case modelprice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case modelprice.FieldModelID:
		m.ResetModelID()
		return nil
	case modelprice.FieldInvokeType:
		m.ResetInvokeType()
		return nil
	case modelprice.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case modelprice.FieldInputGpuPrice:
		m.ResetInputGpuPrice()
		return nil
	case modelprice.FieldOutputGpuPrice:
		m.ResetOutputGpuPrice()
		return nil
	case modelprice.FieldInputModelPrice:
		m.ResetInputModelPrice()
		return nil
	case modelprice.FieldOutputModelPrice:
		m.ResetOutputModelPrice()
		return nil
	case modelprice.FieldTokenPerCep:
		m.ResetTokenPerCep()
		return nil
	}
	return fmt.Errorf("unknown ModelPrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModelPriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.model != nil {
		edges = append(edges, modelprice.EdgeModel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModelPriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case modelprice.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModelPriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModelPriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModelPriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmodel {
		edges = append(edges, modelprice.EdgeModel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModelPriceMutation) EdgeCleared(name string) bool {
	switch name {
	case modelprice.EdgeModel:
		return m.clearedmodel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModelPriceMutation) ClearEdge(name string) error {
	switch name {
	case modelprice.EdgeModel:
		m.ClearModel()
		return nil
	}
	return fmt.Errorf("unknown ModelPrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModelPriceMutation) ResetEdge(name string) error {
	switch name {
	case modelprice.EdgeModel:
		m.ResetModel()
		return nil
	}
	return fmt.Errorf("unknown ModelPrice edge %s", name)
}

// OutputLogMutation represents an operation that mutates the OutputLog nodes in the graph.
type OutputLogMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	trace_id      *int64
	addtrace_id   *int64
	headers       *string
	body          *string
	url           *string
	ip            *string
	caller        *string
	status        *int16
	addstatus     *int16
	hmac_key      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OutputLog, error)
	predicates    []predicate.OutputLog
}

var _ ent.Mutation = (*OutputLogMutation)(nil)

// outputlogOption allows management of the mutation configuration using functional options.
type outputlogOption func(*OutputLogMutation)

// newOutputLogMutation creates new mutation for the OutputLog entity.
func newOutputLogMutation(c config, op Op, opts ...outputlogOption) *OutputLogMutation {
	m := &OutputLogMutation{
		config:        c,
		op:            op,
		typ:           TypeOutputLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutputLogID sets the ID field of the mutation.
func withOutputLogID(id int64) outputlogOption {
	return func(m *OutputLogMutation) {
		var (
			err   error
			once  sync.Once
			value *OutputLog
		)
		m.oldValue = func(ctx context.Context) (*OutputLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutputLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutputLog sets the old OutputLog of the mutation.
func withOutputLog(node *OutputLog) outputlogOption {
	return func(m *OutputLogMutation) {
		m.oldValue = func(context.Context) (*OutputLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutputLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutputLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OutputLog entities.
func (m *OutputLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutputLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutputLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutputLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OutputLogMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OutputLogMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OutputLogMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OutputLogMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OutputLogMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OutputLogMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OutputLogMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OutputLogMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OutputLogMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OutputLogMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OutputLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OutputLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OutputLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OutputLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OutputLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OutputLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OutputLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OutputLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OutputLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTraceID sets the "trace_id" field.
func (m *OutputLogMutation) SetTraceID(i int64) {
	m.trace_id = &i
	m.addtrace_id = nil
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *OutputLogMutation) TraceID() (r int64, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldTraceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// AddTraceID adds i to the "trace_id" field.
func (m *OutputLogMutation) AddTraceID(i int64) {
	if m.addtrace_id != nil {
		*m.addtrace_id += i
	} else {
		m.addtrace_id = &i
	}
}

// AddedTraceID returns the value that was added to the "trace_id" field in this mutation.
func (m *OutputLogMutation) AddedTraceID() (r int64, exists bool) {
	v := m.addtrace_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *OutputLogMutation) ResetTraceID() {
	m.trace_id = nil
	m.addtrace_id = nil
}

// SetHeaders sets the "headers" field.
func (m *OutputLogMutation) SetHeaders(s string) {
	m.headers = &s
}

// Headers returns the value of the "headers" field in the mutation.
func (m *OutputLogMutation) Headers() (r string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldHeaders(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ResetHeaders resets all changes to the "headers" field.
func (m *OutputLogMutation) ResetHeaders() {
	m.headers = nil
}

// SetBody sets the "body" field.
func (m *OutputLogMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *OutputLogMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *OutputLogMutation) ClearBody() {
	m.body = nil
	m.clearedFields[outputlog.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *OutputLogMutation) BodyCleared() bool {
	_, ok := m.clearedFields[outputlog.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *OutputLogMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, outputlog.FieldBody)
}

// SetURL sets the "url" field.
func (m *OutputLogMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *OutputLogMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *OutputLogMutation) ResetURL() {
	m.url = nil
}

// SetIP sets the "ip" field.
func (m *OutputLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *OutputLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *OutputLogMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[outputlog.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *OutputLogMutation) IPCleared() bool {
	_, ok := m.clearedFields[outputlog.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *OutputLogMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, outputlog.FieldIP)
}

// SetCaller sets the "caller" field.
func (m *OutputLogMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *OutputLogMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *OutputLogMutation) ResetCaller() {
	m.caller = nil
}

// SetStatus sets the "status" field.
func (m *OutputLogMutation) SetStatus(i int16) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OutputLogMutation) Status() (r int16, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldStatus(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OutputLogMutation) AddStatus(i int16) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OutputLogMutation) AddedStatus() (r int16, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OutputLogMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[outputlog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OutputLogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[outputlog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OutputLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, outputlog.FieldStatus)
}

// SetHmacKey sets the "hmac_key" field.
func (m *OutputLogMutation) SetHmacKey(s string) {
	m.hmac_key = &s
}

// HmacKey returns the value of the "hmac_key" field in the mutation.
func (m *OutputLogMutation) HmacKey() (r string, exists bool) {
	v := m.hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHmacKey returns the old "hmac_key" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHmacKey: %w", err)
	}
	return oldValue.HmacKey, nil
}

// ResetHmacKey resets all changes to the "hmac_key" field.
func (m *OutputLogMutation) ResetHmacKey() {
	m.hmac_key = nil
}

// Where appends a list predicates to the OutputLogMutation builder.
func (m *OutputLogMutation) Where(ps ...predicate.OutputLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OutputLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OutputLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OutputLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OutputLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OutputLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OutputLog).
func (m *OutputLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutputLogMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, outputlog.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, outputlog.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, outputlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, outputlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, outputlog.FieldDeletedAt)
	}
	if m.trace_id != nil {
		fields = append(fields, outputlog.FieldTraceID)
	}
	if m.headers != nil {
		fields = append(fields, outputlog.FieldHeaders)
	}
	if m.body != nil {
		fields = append(fields, outputlog.FieldBody)
	}
	if m.url != nil {
		fields = append(fields, outputlog.FieldURL)
	}
	if m.ip != nil {
		fields = append(fields, outputlog.FieldIP)
	}
	if m.caller != nil {
		fields = append(fields, outputlog.FieldCaller)
	}
	if m.status != nil {
		fields = append(fields, outputlog.FieldStatus)
	}
	if m.hmac_key != nil {
		fields = append(fields, outputlog.FieldHmacKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutputLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outputlog.FieldCreatedBy:
		return m.CreatedBy()
	case outputlog.FieldUpdatedBy:
		return m.UpdatedBy()
	case outputlog.FieldCreatedAt:
		return m.CreatedAt()
	case outputlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case outputlog.FieldDeletedAt:
		return m.DeletedAt()
	case outputlog.FieldTraceID:
		return m.TraceID()
	case outputlog.FieldHeaders:
		return m.Headers()
	case outputlog.FieldBody:
		return m.Body()
	case outputlog.FieldURL:
		return m.URL()
	case outputlog.FieldIP:
		return m.IP()
	case outputlog.FieldCaller:
		return m.Caller()
	case outputlog.FieldStatus:
		return m.Status()
	case outputlog.FieldHmacKey:
		return m.HmacKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutputLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outputlog.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case outputlog.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case outputlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case outputlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case outputlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case outputlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case outputlog.FieldHeaders:
		return m.OldHeaders(ctx)
	case outputlog.FieldBody:
		return m.OldBody(ctx)
	case outputlog.FieldURL:
		return m.OldURL(ctx)
	case outputlog.FieldIP:
		return m.OldIP(ctx)
	case outputlog.FieldCaller:
		return m.OldCaller(ctx)
	case outputlog.FieldStatus:
		return m.OldStatus(ctx)
	case outputlog.FieldHmacKey:
		return m.OldHmacKey(ctx)
	}
	return nil, fmt.Errorf("unknown OutputLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutputLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case outputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case outputlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case outputlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case outputlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case outputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case outputlog.FieldHeaders:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case outputlog.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case outputlog.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case outputlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case outputlog.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case outputlog.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case outputlog.FieldHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHmacKey(v)
		return nil
	}
	return fmt.Errorf("unknown OutputLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutputLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, outputlog.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, outputlog.FieldUpdatedBy)
	}
	if m.addtrace_id != nil {
		fields = append(fields, outputlog.FieldTraceID)
	}
	if m.addstatus != nil {
		fields = append(fields, outputlog.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutputLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case outputlog.FieldCreatedBy:
		return m.AddedCreatedBy()
	case outputlog.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case outputlog.FieldTraceID:
		return m.AddedTraceID()
	case outputlog.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutputLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case outputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case outputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case outputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraceID(v)
		return nil
	case outputlog.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OutputLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutputLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(outputlog.FieldBody) {
		fields = append(fields, outputlog.FieldBody)
	}
	if m.FieldCleared(outputlog.FieldIP) {
		fields = append(fields, outputlog.FieldIP)
	}
	if m.FieldCleared(outputlog.FieldStatus) {
		fields = append(fields, outputlog.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutputLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutputLogMutation) ClearField(name string) error {
	switch name {
	case outputlog.FieldBody:
		m.ClearBody()
		return nil
	case outputlog.FieldIP:
		m.ClearIP()
		return nil
	case outputlog.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown OutputLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutputLogMutation) ResetField(name string) error {
	switch name {
	case outputlog.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case outputlog.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case outputlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case outputlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case outputlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case outputlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case outputlog.FieldHeaders:
		m.ResetHeaders()
		return nil
	case outputlog.FieldBody:
		m.ResetBody()
		return nil
	case outputlog.FieldURL:
		m.ResetURL()
		return nil
	case outputlog.FieldIP:
		m.ResetIP()
		return nil
	case outputlog.FieldCaller:
		m.ResetCaller()
		return nil
	case outputlog.FieldStatus:
		m.ResetStatus()
		return nil
	case outputlog.FieldHmacKey:
		m.ResetHmacKey()
		return nil
	}
	return fmt.Errorf("unknown OutputLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutputLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutputLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutputLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutputLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutputLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutputLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutputLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OutputLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutputLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OutputLog edge %s", name)
}

// PlatformAccountMutation represents an operation that mutates the PlatformAccount nodes in the graph.
type PlatformAccountMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	_type             *platformaccount.Type
	sum_total_cep     *int64
	addsum_total_cep  *int64
	total_cep         *int64
	addtotal_cep      *int64
	sum_pure_cep      *int64
	addsum_pure_cep   *int64
	pure_cep          *int64
	addpure_cep       *int64
	sum_gift_cep      *int64
	addsum_gift_cep   *int64
	gift_cep          *int64
	addgift_cep       *int64
	clearedFields     map[string]struct{}
	earn_bills        map[int64]struct{}
	removedearn_bills map[int64]struct{}
	clearedearn_bills bool
	cost_bills        map[int64]struct{}
	removedcost_bills map[int64]struct{}
	clearedcost_bills bool
	done              bool
	oldValue          func(context.Context) (*PlatformAccount, error)
	predicates        []predicate.PlatformAccount
}

var _ ent.Mutation = (*PlatformAccountMutation)(nil)

// platformaccountOption allows management of the mutation configuration using functional options.
type platformaccountOption func(*PlatformAccountMutation)

// newPlatformAccountMutation creates new mutation for the PlatformAccount entity.
func newPlatformAccountMutation(c config, op Op, opts ...platformaccountOption) *PlatformAccountMutation {
	m := &PlatformAccountMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformAccountID sets the ID field of the mutation.
func withPlatformAccountID(id int64) platformaccountOption {
	return func(m *PlatformAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformAccount
		)
		m.oldValue = func(ctx context.Context) (*PlatformAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformAccount sets the old PlatformAccount of the mutation.
func withPlatformAccount(node *PlatformAccount) platformaccountOption {
	return func(m *PlatformAccountMutation) {
		m.oldValue = func(context.Context) (*PlatformAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlatformAccount entities.
func (m *PlatformAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *PlatformAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PlatformAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PlatformAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PlatformAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PlatformAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PlatformAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PlatformAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PlatformAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PlatformAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PlatformAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlatformAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlatformAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlatformAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlatformAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlatformAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlatformAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlatformAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlatformAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlatformAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *PlatformAccountMutation) SetType(pl platformaccount.Type) {
	m._type = &pl
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlatformAccountMutation) GetType() (r platformaccount.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldType(ctx context.Context) (v platformaccount.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PlatformAccountMutation) ResetType() {
	m._type = nil
}

// SetSumTotalCep sets the "sum_total_cep" field.
func (m *PlatformAccountMutation) SetSumTotalCep(i int64) {
	m.sum_total_cep = &i
	m.addsum_total_cep = nil
}

// SumTotalCep returns the value of the "sum_total_cep" field in the mutation.
func (m *PlatformAccountMutation) SumTotalCep() (r int64, exists bool) {
	v := m.sum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumTotalCep returns the old "sum_total_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldSumTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumTotalCep: %w", err)
	}
	return oldValue.SumTotalCep, nil
}

// AddSumTotalCep adds i to the "sum_total_cep" field.
func (m *PlatformAccountMutation) AddSumTotalCep(i int64) {
	if m.addsum_total_cep != nil {
		*m.addsum_total_cep += i
	} else {
		m.addsum_total_cep = &i
	}
}

// AddedSumTotalCep returns the value that was added to the "sum_total_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedSumTotalCep() (r int64, exists bool) {
	v := m.addsum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumTotalCep resets all changes to the "sum_total_cep" field.
func (m *PlatformAccountMutation) ResetSumTotalCep() {
	m.sum_total_cep = nil
	m.addsum_total_cep = nil
}

// SetTotalCep sets the "total_cep" field.
func (m *PlatformAccountMutation) SetTotalCep(i int64) {
	m.total_cep = &i
	m.addtotal_cep = nil
}

// TotalCep returns the value of the "total_cep" field in the mutation.
func (m *PlatformAccountMutation) TotalCep() (r int64, exists bool) {
	v := m.total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCep returns the old "total_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCep: %w", err)
	}
	return oldValue.TotalCep, nil
}

// AddTotalCep adds i to the "total_cep" field.
func (m *PlatformAccountMutation) AddTotalCep(i int64) {
	if m.addtotal_cep != nil {
		*m.addtotal_cep += i
	} else {
		m.addtotal_cep = &i
	}
}

// AddedTotalCep returns the value that was added to the "total_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedTotalCep() (r int64, exists bool) {
	v := m.addtotal_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCep resets all changes to the "total_cep" field.
func (m *PlatformAccountMutation) ResetTotalCep() {
	m.total_cep = nil
	m.addtotal_cep = nil
}

// SetSumPureCep sets the "sum_pure_cep" field.
func (m *PlatformAccountMutation) SetSumPureCep(i int64) {
	m.sum_pure_cep = &i
	m.addsum_pure_cep = nil
}

// SumPureCep returns the value of the "sum_pure_cep" field in the mutation.
func (m *PlatformAccountMutation) SumPureCep() (r int64, exists bool) {
	v := m.sum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumPureCep returns the old "sum_pure_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldSumPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumPureCep: %w", err)
	}
	return oldValue.SumPureCep, nil
}

// AddSumPureCep adds i to the "sum_pure_cep" field.
func (m *PlatformAccountMutation) AddSumPureCep(i int64) {
	if m.addsum_pure_cep != nil {
		*m.addsum_pure_cep += i
	} else {
		m.addsum_pure_cep = &i
	}
}

// AddedSumPureCep returns the value that was added to the "sum_pure_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedSumPureCep() (r int64, exists bool) {
	v := m.addsum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumPureCep resets all changes to the "sum_pure_cep" field.
func (m *PlatformAccountMutation) ResetSumPureCep() {
	m.sum_pure_cep = nil
	m.addsum_pure_cep = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *PlatformAccountMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *PlatformAccountMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *PlatformAccountMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *PlatformAccountMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetSumGiftCep sets the "sum_gift_cep" field.
func (m *PlatformAccountMutation) SetSumGiftCep(i int64) {
	m.sum_gift_cep = &i
	m.addsum_gift_cep = nil
}

// SumGiftCep returns the value of the "sum_gift_cep" field in the mutation.
func (m *PlatformAccountMutation) SumGiftCep() (r int64, exists bool) {
	v := m.sum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumGiftCep returns the old "sum_gift_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldSumGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumGiftCep: %w", err)
	}
	return oldValue.SumGiftCep, nil
}

// AddSumGiftCep adds i to the "sum_gift_cep" field.
func (m *PlatformAccountMutation) AddSumGiftCep(i int64) {
	if m.addsum_gift_cep != nil {
		*m.addsum_gift_cep += i
	} else {
		m.addsum_gift_cep = &i
	}
}

// AddedSumGiftCep returns the value that was added to the "sum_gift_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedSumGiftCep() (r int64, exists bool) {
	v := m.addsum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumGiftCep resets all changes to the "sum_gift_cep" field.
func (m *PlatformAccountMutation) ResetSumGiftCep() {
	m.sum_gift_cep = nil
	m.addsum_gift_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *PlatformAccountMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *PlatformAccountMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *PlatformAccountMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *PlatformAccountMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *PlatformAccountMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *PlatformAccountMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *PlatformAccountMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *PlatformAccountMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *PlatformAccountMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *PlatformAccountMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *PlatformAccountMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *PlatformAccountMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *PlatformAccountMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *PlatformAccountMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *PlatformAccountMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *PlatformAccountMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *PlatformAccountMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *PlatformAccountMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// Where appends a list predicates to the PlatformAccountMutation builder.
func (m *PlatformAccountMutation) Where(ps ...predicate.PlatformAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlatformAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlatformAccount).
func (m *PlatformAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformAccountMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, platformaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, platformaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, platformaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, platformaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, platformaccount.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, platformaccount.FieldType)
	}
	if m.sum_total_cep != nil {
		fields = append(fields, platformaccount.FieldSumTotalCep)
	}
	if m.total_cep != nil {
		fields = append(fields, platformaccount.FieldTotalCep)
	}
	if m.sum_pure_cep != nil {
		fields = append(fields, platformaccount.FieldSumPureCep)
	}
	if m.pure_cep != nil {
		fields = append(fields, platformaccount.FieldPureCep)
	}
	if m.sum_gift_cep != nil {
		fields = append(fields, platformaccount.FieldSumGiftCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, platformaccount.FieldGiftCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformaccount.FieldCreatedBy:
		return m.CreatedBy()
	case platformaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case platformaccount.FieldCreatedAt:
		return m.CreatedAt()
	case platformaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case platformaccount.FieldDeletedAt:
		return m.DeletedAt()
	case platformaccount.FieldType:
		return m.GetType()
	case platformaccount.FieldSumTotalCep:
		return m.SumTotalCep()
	case platformaccount.FieldTotalCep:
		return m.TotalCep()
	case platformaccount.FieldSumPureCep:
		return m.SumPureCep()
	case platformaccount.FieldPureCep:
		return m.PureCep()
	case platformaccount.FieldSumGiftCep:
		return m.SumGiftCep()
	case platformaccount.FieldGiftCep:
		return m.GiftCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case platformaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case platformaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case platformaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case platformaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case platformaccount.FieldType:
		return m.OldType(ctx)
	case platformaccount.FieldSumTotalCep:
		return m.OldSumTotalCep(ctx)
	case platformaccount.FieldTotalCep:
		return m.OldTotalCep(ctx)
	case platformaccount.FieldSumPureCep:
		return m.OldSumPureCep(ctx)
	case platformaccount.FieldPureCep:
		return m.OldPureCep(ctx)
	case platformaccount.FieldSumGiftCep:
		return m.OldSumGiftCep(ctx)
	case platformaccount.FieldGiftCep:
		return m.OldGiftCep(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case platformaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case platformaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case platformaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case platformaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case platformaccount.FieldType:
		v, ok := value.(platformaccount.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case platformaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumTotalCep(v)
		return nil
	case platformaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCep(v)
		return nil
	case platformaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumPureCep(v)
		return nil
	case platformaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case platformaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumGiftCep(v)
		return nil
	case platformaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, platformaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, platformaccount.FieldUpdatedBy)
	}
	if m.addsum_total_cep != nil {
		fields = append(fields, platformaccount.FieldSumTotalCep)
	}
	if m.addtotal_cep != nil {
		fields = append(fields, platformaccount.FieldTotalCep)
	}
	if m.addsum_pure_cep != nil {
		fields = append(fields, platformaccount.FieldSumPureCep)
	}
	if m.addpure_cep != nil {
		fields = append(fields, platformaccount.FieldPureCep)
	}
	if m.addsum_gift_cep != nil {
		fields = append(fields, platformaccount.FieldSumGiftCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, platformaccount.FieldGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case platformaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case platformaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case platformaccount.FieldSumTotalCep:
		return m.AddedSumTotalCep()
	case platformaccount.FieldTotalCep:
		return m.AddedTotalCep()
	case platformaccount.FieldSumPureCep:
		return m.AddedSumPureCep()
	case platformaccount.FieldPureCep:
		return m.AddedPureCep()
	case platformaccount.FieldSumGiftCep:
		return m.AddedSumGiftCep()
	case platformaccount.FieldGiftCep:
		return m.AddedGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case platformaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case platformaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case platformaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumTotalCep(v)
		return nil
	case platformaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCep(v)
		return nil
	case platformaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumPureCep(v)
		return nil
	case platformaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case platformaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumGiftCep(v)
		return nil
	case platformaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlatformAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformAccountMutation) ResetField(name string) error {
	switch name {
	case platformaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case platformaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case platformaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case platformaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case platformaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case platformaccount.FieldType:
		m.ResetType()
		return nil
	case platformaccount.FieldSumTotalCep:
		m.ResetSumTotalCep()
		return nil
	case platformaccount.FieldTotalCep:
		m.ResetTotalCep()
		return nil
	case platformaccount.FieldSumPureCep:
		m.ResetSumPureCep()
		return nil
	case platformaccount.FieldPureCep:
		m.ResetPureCep()
		return nil
	case platformaccount.FieldSumGiftCep:
		m.ResetSumGiftCep()
		return nil
	case platformaccount.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.earn_bills != nil {
		edges = append(edges, platformaccount.EdgeEarnBills)
	}
	if m.cost_bills != nil {
		edges = append(edges, platformaccount.EdgeCostBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	case platformaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedearn_bills != nil {
		edges = append(edges, platformaccount.EdgeEarnBills)
	}
	if m.removedcost_bills != nil {
		edges = append(edges, platformaccount.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case platformaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	case platformaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedearn_bills {
		edges = append(edges, platformaccount.EdgeEarnBills)
	}
	if m.clearedcost_bills {
		edges = append(edges, platformaccount.EdgeCostBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case platformaccount.EdgeEarnBills:
		return m.clearedearn_bills
	case platformaccount.EdgeCostBills:
		return m.clearedcost_bills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformAccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformAccountMutation) ResetEdge(name string) error {
	switch name {
	case platformaccount.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	case platformaccount.EdgeCostBills:
		m.ResetCostBills()
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount edge %s", name)
}

// PriceMutation represents an operation that mutates the Price nodes in the graph.
type PriceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_by           *int64
	addcreated_by        *int64
	updated_by           *int64
	addupdated_by        *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	gpu_version          *enums.GpuVersion
	mission_type         *enums.MissionType
	mission_category     *enums.MissionCategory
	mission_billing_type *enums.MissionBillingType
	cep                  *int64
	addcep               *int64
	original_cep         *int64
	addoriginal_cep      *int64
	started_at           *time.Time
	finished_at          *time.Time
	is_deprecated        *bool
	is_sensitive         *bool
	is_hot_gpu           *bool
	clearedFields        map[string]struct{}
	gpu                  *int64
	clearedgpu           bool
	done                 bool
	oldValue             func(context.Context) (*Price, error)
	predicates           []predicate.Price
}

var _ ent.Mutation = (*PriceMutation)(nil)

// priceOption allows management of the mutation configuration using functional options.
type priceOption func(*PriceMutation)

// newPriceMutation creates new mutation for the Price entity.
func newPriceMutation(c config, op Op, opts ...priceOption) *PriceMutation {
	m := &PriceMutation{
		config:        c,
		op:            op,
		typ:           TypePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPriceID sets the ID field of the mutation.
func withPriceID(id int64) priceOption {
	return func(m *PriceMutation) {
		var (
			err   error
			once  sync.Once
			value *Price
		)
		m.oldValue = func(ctx context.Context) (*Price, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Price.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrice sets the old Price of the mutation.
func withPrice(node *Price) priceOption {
	return func(m *PriceMutation) {
		m.oldValue = func(context.Context) (*Price, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Price entities.
func (m *PriceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PriceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PriceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Price.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *PriceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PriceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PriceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PriceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PriceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PriceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PriceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PriceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PriceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PriceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetGpuID sets the "gpu_id" field.
func (m *PriceMutation) SetGpuID(i int64) {
	m.gpu = &i
}

// GpuID returns the value of the "gpu_id" field in the mutation.
func (m *PriceMutation) GpuID() (r int64, exists bool) {
	v := m.gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuID returns the old "gpu_id" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldGpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuID: %w", err)
	}
	return oldValue.GpuID, nil
}

// ResetGpuID resets all changes to the "gpu_id" field.
func (m *PriceMutation) ResetGpuID() {
	m.gpu = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *PriceMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *PriceMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *PriceMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetMissionType sets the "mission_type" field.
func (m *PriceMutation) SetMissionType(et enums.MissionType) {
	m.mission_type = &et
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *PriceMutation) MissionType() (r enums.MissionType, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldMissionType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *PriceMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionCategory sets the "mission_category" field.
func (m *PriceMutation) SetMissionCategory(ec enums.MissionCategory) {
	m.mission_category = &ec
}

// MissionCategory returns the value of the "mission_category" field in the mutation.
func (m *PriceMutation) MissionCategory() (r enums.MissionCategory, exists bool) {
	v := m.mission_category
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionCategory returns the old "mission_category" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldMissionCategory(ctx context.Context) (v enums.MissionCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionCategory: %w", err)
	}
	return oldValue.MissionCategory, nil
}

// ResetMissionCategory resets all changes to the "mission_category" field.
func (m *PriceMutation) ResetMissionCategory() {
	m.mission_category = nil
}

// SetMissionBillingType sets the "mission_billing_type" field.
func (m *PriceMutation) SetMissionBillingType(ebt enums.MissionBillingType) {
	m.mission_billing_type = &ebt
}

// MissionBillingType returns the value of the "mission_billing_type" field in the mutation.
func (m *PriceMutation) MissionBillingType() (r enums.MissionBillingType, exists bool) {
	v := m.mission_billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBillingType returns the old "mission_billing_type" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldMissionBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBillingType: %w", err)
	}
	return oldValue.MissionBillingType, nil
}

// ResetMissionBillingType resets all changes to the "mission_billing_type" field.
func (m *PriceMutation) ResetMissionBillingType() {
	m.mission_billing_type = nil
}

// SetCep sets the "cep" field.
func (m *PriceMutation) SetCep(i int64) {
	m.cep = &i
	m.addcep = nil
}

// Cep returns the value of the "cep" field in the mutation.
func (m *PriceMutation) Cep() (r int64, exists bool) {
	v := m.cep
	if v == nil {
		return
	}
	return *v, true
}

// OldCep returns the old "cep" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCep: %w", err)
	}
	return oldValue.Cep, nil
}

// AddCep adds i to the "cep" field.
func (m *PriceMutation) AddCep(i int64) {
	if m.addcep != nil {
		*m.addcep += i
	} else {
		m.addcep = &i
	}
}

// AddedCep returns the value that was added to the "cep" field in this mutation.
func (m *PriceMutation) AddedCep() (r int64, exists bool) {
	v := m.addcep
	if v == nil {
		return
	}
	return *v, true
}

// ResetCep resets all changes to the "cep" field.
func (m *PriceMutation) ResetCep() {
	m.cep = nil
	m.addcep = nil
}

// SetOriginalCep sets the "original_cep" field.
func (m *PriceMutation) SetOriginalCep(i int64) {
	m.original_cep = &i
	m.addoriginal_cep = nil
}

// OriginalCep returns the value of the "original_cep" field in the mutation.
func (m *PriceMutation) OriginalCep() (r int64, exists bool) {
	v := m.original_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalCep returns the old "original_cep" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldOriginalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalCep: %w", err)
	}
	return oldValue.OriginalCep, nil
}

// AddOriginalCep adds i to the "original_cep" field.
func (m *PriceMutation) AddOriginalCep(i int64) {
	if m.addoriginal_cep != nil {
		*m.addoriginal_cep += i
	} else {
		m.addoriginal_cep = &i
	}
}

// AddedOriginalCep returns the value that was added to the "original_cep" field in this mutation.
func (m *PriceMutation) AddedOriginalCep() (r int64, exists bool) {
	v := m.addoriginal_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetOriginalCep resets all changes to the "original_cep" field.
func (m *PriceMutation) ResetOriginalCep() {
	m.original_cep = nil
	m.addoriginal_cep = nil
}

// SetStartedAt sets the "started_at" field.
func (m *PriceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *PriceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *PriceMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[price.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *PriceMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[price.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *PriceMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, price.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *PriceMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *PriceMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *PriceMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[price.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *PriceMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[price.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *PriceMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, price.FieldFinishedAt)
}

// SetIsDeprecated sets the "is_deprecated" field.
func (m *PriceMutation) SetIsDeprecated(b bool) {
	m.is_deprecated = &b
}

// IsDeprecated returns the value of the "is_deprecated" field in the mutation.
func (m *PriceMutation) IsDeprecated() (r bool, exists bool) {
	v := m.is_deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeprecated returns the old "is_deprecated" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldIsDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeprecated: %w", err)
	}
	return oldValue.IsDeprecated, nil
}

// ResetIsDeprecated resets all changes to the "is_deprecated" field.
func (m *PriceMutation) ResetIsDeprecated() {
	m.is_deprecated = nil
}

// SetIsSensitive sets the "is_sensitive" field.
func (m *PriceMutation) SetIsSensitive(b bool) {
	m.is_sensitive = &b
}

// IsSensitive returns the value of the "is_sensitive" field in the mutation.
func (m *PriceMutation) IsSensitive() (r bool, exists bool) {
	v := m.is_sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSensitive returns the old "is_sensitive" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldIsSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSensitive: %w", err)
	}
	return oldValue.IsSensitive, nil
}

// ResetIsSensitive resets all changes to the "is_sensitive" field.
func (m *PriceMutation) ResetIsSensitive() {
	m.is_sensitive = nil
}

// SetIsHotGpu sets the "is_hot_gpu" field.
func (m *PriceMutation) SetIsHotGpu(b bool) {
	m.is_hot_gpu = &b
}

// IsHotGpu returns the value of the "is_hot_gpu" field in the mutation.
func (m *PriceMutation) IsHotGpu() (r bool, exists bool) {
	v := m.is_hot_gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHotGpu returns the old "is_hot_gpu" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldIsHotGpu(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHotGpu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHotGpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHotGpu: %w", err)
	}
	return oldValue.IsHotGpu, nil
}

// ResetIsHotGpu resets all changes to the "is_hot_gpu" field.
func (m *PriceMutation) ResetIsHotGpu() {
	m.is_hot_gpu = nil
}

// ClearGpu clears the "gpu" edge to the Gpu entity.
func (m *PriceMutation) ClearGpu() {
	m.clearedgpu = true
	m.clearedFields[price.FieldGpuID] = struct{}{}
}

// GpuCleared reports if the "gpu" edge to the Gpu entity was cleared.
func (m *PriceMutation) GpuCleared() bool {
	return m.clearedgpu
}

// GpuIDs returns the "gpu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GpuID instead. It exists only for internal usage by the builders.
func (m *PriceMutation) GpuIDs() (ids []int64) {
	if id := m.gpu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGpu resets all changes to the "gpu" edge.
func (m *PriceMutation) ResetGpu() {
	m.gpu = nil
	m.clearedgpu = false
}

// Where appends a list predicates to the PriceMutation builder.
func (m *PriceMutation) Where(ps ...predicate.Price) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Price, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Price).
func (m *PriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PriceMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, price.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, price.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, price.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, price.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, price.FieldDeletedAt)
	}
	if m.gpu != nil {
		fields = append(fields, price.FieldGpuID)
	}
	if m.gpu_version != nil {
		fields = append(fields, price.FieldGpuVersion)
	}
	if m.mission_type != nil {
		fields = append(fields, price.FieldMissionType)
	}
	if m.mission_category != nil {
		fields = append(fields, price.FieldMissionCategory)
	}
	if m.mission_billing_type != nil {
		fields = append(fields, price.FieldMissionBillingType)
	}
	if m.cep != nil {
		fields = append(fields, price.FieldCep)
	}
	if m.original_cep != nil {
		fields = append(fields, price.FieldOriginalCep)
	}
	if m.started_at != nil {
		fields = append(fields, price.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, price.FieldFinishedAt)
	}
	if m.is_deprecated != nil {
		fields = append(fields, price.FieldIsDeprecated)
	}
	if m.is_sensitive != nil {
		fields = append(fields, price.FieldIsSensitive)
	}
	if m.is_hot_gpu != nil {
		fields = append(fields, price.FieldIsHotGpu)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case price.FieldCreatedBy:
		return m.CreatedBy()
	case price.FieldUpdatedBy:
		return m.UpdatedBy()
	case price.FieldCreatedAt:
		return m.CreatedAt()
	case price.FieldUpdatedAt:
		return m.UpdatedAt()
	case price.FieldDeletedAt:
		return m.DeletedAt()
	case price.FieldGpuID:
		return m.GpuID()
	case price.FieldGpuVersion:
		return m.GpuVersion()
	case price.FieldMissionType:
		return m.MissionType()
	case price.FieldMissionCategory:
		return m.MissionCategory()
	case price.FieldMissionBillingType:
		return m.MissionBillingType()
	case price.FieldCep:
		return m.Cep()
	case price.FieldOriginalCep:
		return m.OriginalCep()
	case price.FieldStartedAt:
		return m.StartedAt()
	case price.FieldFinishedAt:
		return m.FinishedAt()
	case price.FieldIsDeprecated:
		return m.IsDeprecated()
	case price.FieldIsSensitive:
		return m.IsSensitive()
	case price.FieldIsHotGpu:
		return m.IsHotGpu()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case price.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case price.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case price.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case price.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case price.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case price.FieldGpuID:
		return m.OldGpuID(ctx)
	case price.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case price.FieldMissionType:
		return m.OldMissionType(ctx)
	case price.FieldMissionCategory:
		return m.OldMissionCategory(ctx)
	case price.FieldMissionBillingType:
		return m.OldMissionBillingType(ctx)
	case price.FieldCep:
		return m.OldCep(ctx)
	case price.FieldOriginalCep:
		return m.OldOriginalCep(ctx)
	case price.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case price.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case price.FieldIsDeprecated:
		return m.OldIsDeprecated(ctx)
	case price.FieldIsSensitive:
		return m.OldIsSensitive(ctx)
	case price.FieldIsHotGpu:
		return m.OldIsHotGpu(ctx)
	}
	return nil, fmt.Errorf("unknown Price field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case price.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case price.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case price.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case price.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case price.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case price.FieldGpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuID(v)
		return nil
	case price.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case price.FieldMissionType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case price.FieldMissionCategory:
		v, ok := value.(enums.MissionCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionCategory(v)
		return nil
	case price.FieldMissionBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBillingType(v)
		return nil
	case price.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCep(v)
		return nil
	case price.FieldOriginalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalCep(v)
		return nil
	case price.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case price.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case price.FieldIsDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeprecated(v)
		return nil
	case price.FieldIsSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSensitive(v)
		return nil
	case price.FieldIsHotGpu:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHotGpu(v)
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PriceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, price.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, price.FieldUpdatedBy)
	}
	if m.addcep != nil {
		fields = append(fields, price.FieldCep)
	}
	if m.addoriginal_cep != nil {
		fields = append(fields, price.FieldOriginalCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case price.FieldCreatedBy:
		return m.AddedCreatedBy()
	case price.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case price.FieldCep:
		return m.AddedCep()
	case price.FieldOriginalCep:
		return m.AddedOriginalCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case price.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case price.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case price.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCep(v)
		return nil
	case price.FieldOriginalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginalCep(v)
		return nil
	}
	return fmt.Errorf("unknown Price numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(price.FieldStartedAt) {
		fields = append(fields, price.FieldStartedAt)
	}
	if m.FieldCleared(price.FieldFinishedAt) {
		fields = append(fields, price.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PriceMutation) ClearField(name string) error {
	switch name {
	case price.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case price.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Price nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PriceMutation) ResetField(name string) error {
	switch name {
	case price.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case price.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case price.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case price.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case price.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case price.FieldGpuID:
		m.ResetGpuID()
		return nil
	case price.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case price.FieldMissionType:
		m.ResetMissionType()
		return nil
	case price.FieldMissionCategory:
		m.ResetMissionCategory()
		return nil
	case price.FieldMissionBillingType:
		m.ResetMissionBillingType()
		return nil
	case price.FieldCep:
		m.ResetCep()
		return nil
	case price.FieldOriginalCep:
		m.ResetOriginalCep()
		return nil
	case price.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case price.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case price.FieldIsDeprecated:
		m.ResetIsDeprecated()
		return nil
	case price.FieldIsSensitive:
		m.ResetIsSensitive()
		return nil
	case price.FieldIsHotGpu:
		m.ResetIsHotGpu()
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.gpu != nil {
		edges = append(edges, price.EdgeGpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case price.EdgeGpu:
		if id := m.gpu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgpu {
		edges = append(edges, price.EdgeGpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PriceMutation) EdgeCleared(name string) bool {
	switch name {
	case price.EdgeGpu:
		return m.clearedgpu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PriceMutation) ClearEdge(name string) error {
	switch name {
	case price.EdgeGpu:
		m.ClearGpu()
		return nil
	}
	return fmt.Errorf("unknown Price unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PriceMutation) ResetEdge(name string) error {
	switch name {
	case price.EdgeGpu:
		m.ResetGpu()
		return nil
	}
	return fmt.Errorf("unknown Price edge %s", name)
}

// ProfitAccountMutation represents an operation that mutates the ProfitAccount nodes in the graph.
type ProfitAccountMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	sum_cep           *int64
	addsum_cep        *int64
	remain_cep        *int64
	addremain_cep     *int64
	clearedFields     map[string]struct{}
	user              *int64
	cleareduser       bool
	earn_bills        map[int64]struct{}
	removedearn_bills map[int64]struct{}
	clearedearn_bills bool
	done              bool
	oldValue          func(context.Context) (*ProfitAccount, error)
	predicates        []predicate.ProfitAccount
}

var _ ent.Mutation = (*ProfitAccountMutation)(nil)

// profitaccountOption allows management of the mutation configuration using functional options.
type profitaccountOption func(*ProfitAccountMutation)

// newProfitAccountMutation creates new mutation for the ProfitAccount entity.
func newProfitAccountMutation(c config, op Op, opts ...profitaccountOption) *ProfitAccountMutation {
	m := &ProfitAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeProfitAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfitAccountID sets the ID field of the mutation.
func withProfitAccountID(id int64) profitaccountOption {
	return func(m *ProfitAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfitAccount
		)
		m.oldValue = func(ctx context.Context) (*ProfitAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfitAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfitAccount sets the old ProfitAccount of the mutation.
func withProfitAccount(node *ProfitAccount) profitaccountOption {
	return func(m *ProfitAccountMutation) {
		m.oldValue = func(context.Context) (*ProfitAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfitAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfitAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfitAccount entities.
func (m *ProfitAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfitAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfitAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfitAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ProfitAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProfitAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProfitAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProfitAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProfitAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProfitAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProfitAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ProfitAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ProfitAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProfitAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfitAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfitAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfitAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfitAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfitAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfitAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProfitAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProfitAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProfitAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ProfitAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProfitAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProfitAccountMutation) ResetUserID() {
	m.user = nil
}

// SetSumCep sets the "sum_cep" field.
func (m *ProfitAccountMutation) SetSumCep(i int64) {
	m.sum_cep = &i
	m.addsum_cep = nil
}

// SumCep returns the value of the "sum_cep" field in the mutation.
func (m *ProfitAccountMutation) SumCep() (r int64, exists bool) {
	v := m.sum_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumCep returns the old "sum_cep" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldSumCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumCep: %w", err)
	}
	return oldValue.SumCep, nil
}

// AddSumCep adds i to the "sum_cep" field.
func (m *ProfitAccountMutation) AddSumCep(i int64) {
	if m.addsum_cep != nil {
		*m.addsum_cep += i
	} else {
		m.addsum_cep = &i
	}
}

// AddedSumCep returns the value that was added to the "sum_cep" field in this mutation.
func (m *ProfitAccountMutation) AddedSumCep() (r int64, exists bool) {
	v := m.addsum_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumCep resets all changes to the "sum_cep" field.
func (m *ProfitAccountMutation) ResetSumCep() {
	m.sum_cep = nil
	m.addsum_cep = nil
}

// SetRemainCep sets the "remain_cep" field.
func (m *ProfitAccountMutation) SetRemainCep(i int64) {
	m.remain_cep = &i
	m.addremain_cep = nil
}

// RemainCep returns the value of the "remain_cep" field in the mutation.
func (m *ProfitAccountMutation) RemainCep() (r int64, exists bool) {
	v := m.remain_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainCep returns the old "remain_cep" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldRemainCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainCep: %w", err)
	}
	return oldValue.RemainCep, nil
}

// AddRemainCep adds i to the "remain_cep" field.
func (m *ProfitAccountMutation) AddRemainCep(i int64) {
	if m.addremain_cep != nil {
		*m.addremain_cep += i
	} else {
		m.addremain_cep = &i
	}
}

// AddedRemainCep returns the value that was added to the "remain_cep" field in this mutation.
func (m *ProfitAccountMutation) AddedRemainCep() (r int64, exists bool) {
	v := m.addremain_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainCep resets all changes to the "remain_cep" field.
func (m *ProfitAccountMutation) ResetRemainCep() {
	m.remain_cep = nil
	m.addremain_cep = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfitAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[profitaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfitAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfitAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfitAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *ProfitAccountMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *ProfitAccountMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *ProfitAccountMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *ProfitAccountMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *ProfitAccountMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *ProfitAccountMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *ProfitAccountMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// Where appends a list predicates to the ProfitAccountMutation builder.
func (m *ProfitAccountMutation) Where(ps ...predicate.ProfitAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfitAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfitAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfitAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfitAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfitAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfitAccount).
func (m *ProfitAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfitAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, profitaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, profitaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, profitaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profitaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, profitaccount.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, profitaccount.FieldUserID)
	}
	if m.sum_cep != nil {
		fields = append(fields, profitaccount.FieldSumCep)
	}
	if m.remain_cep != nil {
		fields = append(fields, profitaccount.FieldRemainCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfitAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profitaccount.FieldCreatedBy:
		return m.CreatedBy()
	case profitaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case profitaccount.FieldCreatedAt:
		return m.CreatedAt()
	case profitaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case profitaccount.FieldDeletedAt:
		return m.DeletedAt()
	case profitaccount.FieldUserID:
		return m.UserID()
	case profitaccount.FieldSumCep:
		return m.SumCep()
	case profitaccount.FieldRemainCep:
		return m.RemainCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfitAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profitaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case profitaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case profitaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profitaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profitaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case profitaccount.FieldUserID:
		return m.OldUserID(ctx)
	case profitaccount.FieldSumCep:
		return m.OldSumCep(ctx)
	case profitaccount.FieldRemainCep:
		return m.OldRemainCep(ctx)
	}
	return nil, fmt.Errorf("unknown ProfitAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profitaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case profitaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case profitaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profitaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profitaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case profitaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case profitaccount.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumCep(v)
		return nil
	case profitaccount.FieldRemainCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainCep(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfitAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, profitaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, profitaccount.FieldUpdatedBy)
	}
	if m.addsum_cep != nil {
		fields = append(fields, profitaccount.FieldSumCep)
	}
	if m.addremain_cep != nil {
		fields = append(fields, profitaccount.FieldRemainCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfitAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profitaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case profitaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case profitaccount.FieldSumCep:
		return m.AddedSumCep()
	case profitaccount.FieldRemainCep:
		return m.AddedRemainCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profitaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case profitaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case profitaccount.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumCep(v)
		return nil
	case profitaccount.FieldRemainCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainCep(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfitAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfitAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfitAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfitAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfitAccountMutation) ResetField(name string) error {
	switch name {
	case profitaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case profitaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case profitaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profitaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profitaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case profitaccount.FieldUserID:
		m.ResetUserID()
		return nil
	case profitaccount.FieldSumCep:
		m.ResetSumCep()
		return nil
	case profitaccount.FieldRemainCep:
		m.ResetRemainCep()
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfitAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, profitaccount.EdgeUser)
	}
	if m.earn_bills != nil {
		edges = append(edges, profitaccount.EdgeEarnBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfitAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profitaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case profitaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfitAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedearn_bills != nil {
		edges = append(edges, profitaccount.EdgeEarnBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfitAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profitaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfitAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, profitaccount.EdgeUser)
	}
	if m.clearedearn_bills {
		edges = append(edges, profitaccount.EdgeEarnBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfitAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case profitaccount.EdgeUser:
		return m.cleareduser
	case profitaccount.EdgeEarnBills:
		return m.clearedearn_bills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfitAccountMutation) ClearEdge(name string) error {
	switch name {
	case profitaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfitAccountMutation) ResetEdge(name string) error {
	switch name {
	case profitaccount.EdgeUser:
		m.ResetUser()
		return nil
	case profitaccount.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount edge %s", name)
}

// ProfitSettingMutation represents an operation that mutates the ProfitSetting nodes in the graph.
type ProfitSettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	ratio         *int64
	addratio      *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ProfitSetting, error)
	predicates    []predicate.ProfitSetting
}

var _ ent.Mutation = (*ProfitSettingMutation)(nil)

// profitsettingOption allows management of the mutation configuration using functional options.
type profitsettingOption func(*ProfitSettingMutation)

// newProfitSettingMutation creates new mutation for the ProfitSetting entity.
func newProfitSettingMutation(c config, op Op, opts ...profitsettingOption) *ProfitSettingMutation {
	m := &ProfitSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeProfitSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfitSettingID sets the ID field of the mutation.
func withProfitSettingID(id int64) profitsettingOption {
	return func(m *ProfitSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfitSetting
		)
		m.oldValue = func(ctx context.Context) (*ProfitSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfitSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfitSetting sets the old ProfitSetting of the mutation.
func withProfitSetting(node *ProfitSetting) profitsettingOption {
	return func(m *ProfitSettingMutation) {
		m.oldValue = func(context.Context) (*ProfitSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfitSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfitSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfitSetting entities.
func (m *ProfitSettingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfitSettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfitSettingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfitSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ProfitSettingMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProfitSettingMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProfitSettingMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProfitSettingMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProfitSettingMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProfitSettingMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProfitSettingMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ProfitSettingMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ProfitSettingMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProfitSettingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfitSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfitSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfitSettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfitSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfitSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfitSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProfitSettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProfitSettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProfitSettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ProfitSettingMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProfitSettingMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProfitSettingMutation) ResetUserID() {
	m.user = nil
}

// SetRatio sets the "ratio" field.
func (m *ProfitSettingMutation) SetRatio(i int64) {
	m.ratio = &i
	m.addratio = nil
}

// Ratio returns the value of the "ratio" field in the mutation.
func (m *ProfitSettingMutation) Ratio() (r int64, exists bool) {
	v := m.ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldRatio returns the old "ratio" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldRatio(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatio: %w", err)
	}
	return oldValue.Ratio, nil
}

// AddRatio adds i to the "ratio" field.
func (m *ProfitSettingMutation) AddRatio(i int64) {
	if m.addratio != nil {
		*m.addratio += i
	} else {
		m.addratio = &i
	}
}

// AddedRatio returns the value that was added to the "ratio" field in this mutation.
func (m *ProfitSettingMutation) AddedRatio() (r int64, exists bool) {
	v := m.addratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatio resets all changes to the "ratio" field.
func (m *ProfitSettingMutation) ResetRatio() {
	m.ratio = nil
	m.addratio = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfitSettingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[profitsetting.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfitSettingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfitSettingMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfitSettingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProfitSettingMutation builder.
func (m *ProfitSettingMutation) Where(ps ...predicate.ProfitSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfitSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfitSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfitSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfitSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfitSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfitSetting).
func (m *ProfitSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfitSettingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, profitsetting.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, profitsetting.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, profitsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profitsetting.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, profitsetting.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, profitsetting.FieldUserID)
	}
	if m.ratio != nil {
		fields = append(fields, profitsetting.FieldRatio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfitSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profitsetting.FieldCreatedBy:
		return m.CreatedBy()
	case profitsetting.FieldUpdatedBy:
		return m.UpdatedBy()
	case profitsetting.FieldCreatedAt:
		return m.CreatedAt()
	case profitsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case profitsetting.FieldDeletedAt:
		return m.DeletedAt()
	case profitsetting.FieldUserID:
		return m.UserID()
	case profitsetting.FieldRatio:
		return m.Ratio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfitSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profitsetting.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case profitsetting.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case profitsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profitsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profitsetting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case profitsetting.FieldUserID:
		return m.OldUserID(ctx)
	case profitsetting.FieldRatio:
		return m.OldRatio(ctx)
	}
	return nil, fmt.Errorf("unknown ProfitSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profitsetting.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case profitsetting.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case profitsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profitsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profitsetting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case profitsetting.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case profitsetting.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatio(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfitSettingMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, profitsetting.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, profitsetting.FieldUpdatedBy)
	}
	if m.addratio != nil {
		fields = append(fields, profitsetting.FieldRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfitSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profitsetting.FieldCreatedBy:
		return m.AddedCreatedBy()
	case profitsetting.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case profitsetting.FieldRatio:
		return m.AddedRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profitsetting.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case profitsetting.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case profitsetting.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatio(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfitSettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfitSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfitSettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfitSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfitSettingMutation) ResetField(name string) error {
	switch name {
	case profitsetting.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case profitsetting.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case profitsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profitsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profitsetting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case profitsetting.FieldUserID:
		m.ResetUserID()
		return nil
	case profitsetting.FieldRatio:
		m.ResetRatio()
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfitSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, profitsetting.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfitSettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profitsetting.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfitSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfitSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfitSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, profitsetting.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfitSettingMutation) EdgeCleared(name string) bool {
	switch name {
	case profitsetting.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfitSettingMutation) ClearEdge(name string) error {
	switch name {
	case profitsetting.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfitSettingMutation) ResetEdge(name string) error {
	switch name {
	case profitsetting.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting edge %s", name)
}

// RechargeCampaignRuleMutation represents an operation that mutates the RechargeCampaignRule nodes in the graph.
type RechargeCampaignRuleMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_by      *int64
	addcreated_by   *int64
	updated_by      *int64
	addupdated_by   *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	little_value    *int64
	addlittle_value *int64
	large_value     *int64
	addlarge_value  *int64
	gift_percent    *int64
	addgift_percent *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*RechargeCampaignRule, error)
	predicates      []predicate.RechargeCampaignRule
}

var _ ent.Mutation = (*RechargeCampaignRuleMutation)(nil)

// rechargecampaignruleOption allows management of the mutation configuration using functional options.
type rechargecampaignruleOption func(*RechargeCampaignRuleMutation)

// newRechargeCampaignRuleMutation creates new mutation for the RechargeCampaignRule entity.
func newRechargeCampaignRuleMutation(c config, op Op, opts ...rechargecampaignruleOption) *RechargeCampaignRuleMutation {
	m := &RechargeCampaignRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeRechargeCampaignRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRechargeCampaignRuleID sets the ID field of the mutation.
func withRechargeCampaignRuleID(id int64) rechargecampaignruleOption {
	return func(m *RechargeCampaignRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *RechargeCampaignRule
		)
		m.oldValue = func(ctx context.Context) (*RechargeCampaignRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RechargeCampaignRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRechargeCampaignRule sets the old RechargeCampaignRule of the mutation.
func withRechargeCampaignRule(node *RechargeCampaignRule) rechargecampaignruleOption {
	return func(m *RechargeCampaignRuleMutation) {
		m.oldValue = func(context.Context) (*RechargeCampaignRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RechargeCampaignRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RechargeCampaignRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RechargeCampaignRule entities.
func (m *RechargeCampaignRuleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RechargeCampaignRuleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RechargeCampaignRuleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RechargeCampaignRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *RechargeCampaignRuleMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RechargeCampaignRuleMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RechargeCampaignRuleMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RechargeCampaignRuleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RechargeCampaignRuleMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RechargeCampaignRuleMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RechargeCampaignRuleMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RechargeCampaignRuleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RechargeCampaignRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RechargeCampaignRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RechargeCampaignRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RechargeCampaignRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RechargeCampaignRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RechargeCampaignRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RechargeCampaignRuleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RechargeCampaignRuleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RechargeCampaignRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetLittleValue sets the "little_value" field.
func (m *RechargeCampaignRuleMutation) SetLittleValue(i int64) {
	m.little_value = &i
	m.addlittle_value = nil
}

// LittleValue returns the value of the "little_value" field in the mutation.
func (m *RechargeCampaignRuleMutation) LittleValue() (r int64, exists bool) {
	v := m.little_value
	if v == nil {
		return
	}
	return *v, true
}

// OldLittleValue returns the old "little_value" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldLittleValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLittleValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLittleValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLittleValue: %w", err)
	}
	return oldValue.LittleValue, nil
}

// AddLittleValue adds i to the "little_value" field.
func (m *RechargeCampaignRuleMutation) AddLittleValue(i int64) {
	if m.addlittle_value != nil {
		*m.addlittle_value += i
	} else {
		m.addlittle_value = &i
	}
}

// AddedLittleValue returns the value that was added to the "little_value" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedLittleValue() (r int64, exists bool) {
	v := m.addlittle_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetLittleValue resets all changes to the "little_value" field.
func (m *RechargeCampaignRuleMutation) ResetLittleValue() {
	m.little_value = nil
	m.addlittle_value = nil
}

// SetLargeValue sets the "large_value" field.
func (m *RechargeCampaignRuleMutation) SetLargeValue(i int64) {
	m.large_value = &i
	m.addlarge_value = nil
}

// LargeValue returns the value of the "large_value" field in the mutation.
func (m *RechargeCampaignRuleMutation) LargeValue() (r int64, exists bool) {
	v := m.large_value
	if v == nil {
		return
	}
	return *v, true
}

// OldLargeValue returns the old "large_value" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldLargeValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLargeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLargeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLargeValue: %w", err)
	}
	return oldValue.LargeValue, nil
}

// AddLargeValue adds i to the "large_value" field.
func (m *RechargeCampaignRuleMutation) AddLargeValue(i int64) {
	if m.addlarge_value != nil {
		*m.addlarge_value += i
	} else {
		m.addlarge_value = &i
	}
}

// AddedLargeValue returns the value that was added to the "large_value" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedLargeValue() (r int64, exists bool) {
	v := m.addlarge_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetLargeValue resets all changes to the "large_value" field.
func (m *RechargeCampaignRuleMutation) ResetLargeValue() {
	m.large_value = nil
	m.addlarge_value = nil
}

// SetGiftPercent sets the "gift_percent" field.
func (m *RechargeCampaignRuleMutation) SetGiftPercent(i int64) {
	m.gift_percent = &i
	m.addgift_percent = nil
}

// GiftPercent returns the value of the "gift_percent" field in the mutation.
func (m *RechargeCampaignRuleMutation) GiftPercent() (r int64, exists bool) {
	v := m.gift_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftPercent returns the old "gift_percent" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldGiftPercent(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftPercent: %w", err)
	}
	return oldValue.GiftPercent, nil
}

// AddGiftPercent adds i to the "gift_percent" field.
func (m *RechargeCampaignRuleMutation) AddGiftPercent(i int64) {
	if m.addgift_percent != nil {
		*m.addgift_percent += i
	} else {
		m.addgift_percent = &i
	}
}

// AddedGiftPercent returns the value that was added to the "gift_percent" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedGiftPercent() (r int64, exists bool) {
	v := m.addgift_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftPercent resets all changes to the "gift_percent" field.
func (m *RechargeCampaignRuleMutation) ResetGiftPercent() {
	m.gift_percent = nil
	m.addgift_percent = nil
}

// Where appends a list predicates to the RechargeCampaignRuleMutation builder.
func (m *RechargeCampaignRuleMutation) Where(ps ...predicate.RechargeCampaignRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RechargeCampaignRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RechargeCampaignRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RechargeCampaignRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RechargeCampaignRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RechargeCampaignRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RechargeCampaignRule).
func (m *RechargeCampaignRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RechargeCampaignRuleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, rechargecampaignrule.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, rechargecampaignrule.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, rechargecampaignrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rechargecampaignrule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rechargecampaignrule.FieldDeletedAt)
	}
	if m.little_value != nil {
		fields = append(fields, rechargecampaignrule.FieldLittleValue)
	}
	if m.large_value != nil {
		fields = append(fields, rechargecampaignrule.FieldLargeValue)
	}
	if m.gift_percent != nil {
		fields = append(fields, rechargecampaignrule.FieldGiftPercent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RechargeCampaignRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		return m.CreatedBy()
	case rechargecampaignrule.FieldUpdatedBy:
		return m.UpdatedBy()
	case rechargecampaignrule.FieldCreatedAt:
		return m.CreatedAt()
	case rechargecampaignrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case rechargecampaignrule.FieldDeletedAt:
		return m.DeletedAt()
	case rechargecampaignrule.FieldLittleValue:
		return m.LittleValue()
	case rechargecampaignrule.FieldLargeValue:
		return m.LargeValue()
	case rechargecampaignrule.FieldGiftPercent:
		return m.GiftPercent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RechargeCampaignRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rechargecampaignrule.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rechargecampaignrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rechargecampaignrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rechargecampaignrule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rechargecampaignrule.FieldLittleValue:
		return m.OldLittleValue(ctx)
	case rechargecampaignrule.FieldLargeValue:
		return m.OldLargeValue(ctx)
	case rechargecampaignrule.FieldGiftPercent:
		return m.OldGiftPercent(ctx)
	}
	return nil, fmt.Errorf("unknown RechargeCampaignRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeCampaignRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rechargecampaignrule.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rechargecampaignrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rechargecampaignrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rechargecampaignrule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rechargecampaignrule.FieldLittleValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLittleValue(v)
		return nil
	case rechargecampaignrule.FieldLargeValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLargeValue(v)
		return nil
	case rechargecampaignrule.FieldGiftPercent:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftPercent(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeCampaignRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RechargeCampaignRuleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, rechargecampaignrule.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, rechargecampaignrule.FieldUpdatedBy)
	}
	if m.addlittle_value != nil {
		fields = append(fields, rechargecampaignrule.FieldLittleValue)
	}
	if m.addlarge_value != nil {
		fields = append(fields, rechargecampaignrule.FieldLargeValue)
	}
	if m.addgift_percent != nil {
		fields = append(fields, rechargecampaignrule.FieldGiftPercent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RechargeCampaignRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		return m.AddedCreatedBy()
	case rechargecampaignrule.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case rechargecampaignrule.FieldLittleValue:
		return m.AddedLittleValue()
	case rechargecampaignrule.FieldLargeValue:
		return m.AddedLargeValue()
	case rechargecampaignrule.FieldGiftPercent:
		return m.AddedGiftPercent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeCampaignRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case rechargecampaignrule.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case rechargecampaignrule.FieldLittleValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLittleValue(v)
		return nil
	case rechargecampaignrule.FieldLargeValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLargeValue(v)
		return nil
	case rechargecampaignrule.FieldGiftPercent:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftPercent(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeCampaignRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RechargeCampaignRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RechargeCampaignRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RechargeCampaignRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RechargeCampaignRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RechargeCampaignRuleMutation) ResetField(name string) error {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rechargecampaignrule.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rechargecampaignrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rechargecampaignrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rechargecampaignrule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rechargecampaignrule.FieldLittleValue:
		m.ResetLittleValue()
		return nil
	case rechargecampaignrule.FieldLargeValue:
		m.ResetLargeValue()
		return nil
	case rechargecampaignrule.FieldGiftPercent:
		m.ResetGiftPercent()
		return nil
	}
	return fmt.Errorf("unknown RechargeCampaignRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RechargeCampaignRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RechargeCampaignRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RechargeCampaignRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RechargeCampaignRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RechargeCampaignRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RechargeCampaignRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RechargeCampaignRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RechargeCampaignRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RechargeCampaignRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RechargeCampaignRule edge %s", name)
}

// RechargeOrderMutation represents an operation that mutates the RechargeOrder nodes in the graph.
type RechargeOrderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	status                *rechargeorder.Status
	pure_cep              *int64
	addpure_cep           *int64
	gift_cep              *int64
	addgift_cep           *int64
	_type                 *rechargeorder.Type
	serial_number         *string
	third_api_resp        *string
	from_user_id          *int64
	addfrom_user_id       *int64
	out_transaction_id    *string
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	cost_bills            map[int64]struct{}
	removedcost_bills     map[int64]struct{}
	clearedcost_bills     bool
	vx_social             *int64
	clearedvx_social      bool
	campaign_order        *int64
	clearedcampaign_order bool
	done                  bool
	oldValue              func(context.Context) (*RechargeOrder, error)
	predicates            []predicate.RechargeOrder
}

var _ ent.Mutation = (*RechargeOrderMutation)(nil)

// rechargeorderOption allows management of the mutation configuration using functional options.
type rechargeorderOption func(*RechargeOrderMutation)

// newRechargeOrderMutation creates new mutation for the RechargeOrder entity.
func newRechargeOrderMutation(c config, op Op, opts ...rechargeorderOption) *RechargeOrderMutation {
	m := &RechargeOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeRechargeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRechargeOrderID sets the ID field of the mutation.
func withRechargeOrderID(id int64) rechargeorderOption {
	return func(m *RechargeOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *RechargeOrder
		)
		m.oldValue = func(ctx context.Context) (*RechargeOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RechargeOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRechargeOrder sets the old RechargeOrder of the mutation.
func withRechargeOrder(node *RechargeOrder) rechargeorderOption {
	return func(m *RechargeOrderMutation) {
		m.oldValue = func(context.Context) (*RechargeOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RechargeOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RechargeOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RechargeOrder entities.
func (m *RechargeOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RechargeOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RechargeOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RechargeOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *RechargeOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RechargeOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RechargeOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RechargeOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RechargeOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RechargeOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RechargeOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RechargeOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RechargeOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RechargeOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RechargeOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RechargeOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RechargeOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RechargeOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RechargeOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RechargeOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RechargeOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RechargeOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RechargeOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *RechargeOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RechargeOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RechargeOrderMutation) ResetUserID() {
	m.user = nil
}

// SetStatus sets the "status" field.
func (m *RechargeOrderMutation) SetStatus(r rechargeorder.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RechargeOrderMutation) Status() (r rechargeorder.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldStatus(ctx context.Context) (v rechargeorder.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RechargeOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *RechargeOrderMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *RechargeOrderMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *RechargeOrderMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *RechargeOrderMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *RechargeOrderMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *RechargeOrderMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *RechargeOrderMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *RechargeOrderMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *RechargeOrderMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *RechargeOrderMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetSocialID sets the "social_id" field.
func (m *RechargeOrderMutation) SetSocialID(i int64) {
	m.vx_social = &i
}

// SocialID returns the value of the "social_id" field in the mutation.
func (m *RechargeOrderMutation) SocialID() (r int64, exists bool) {
	v := m.vx_social
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialID returns the old "social_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldSocialID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialID: %w", err)
	}
	return oldValue.SocialID, nil
}

// ClearSocialID clears the value of the "social_id" field.
func (m *RechargeOrderMutation) ClearSocialID() {
	m.vx_social = nil
	m.clearedFields[rechargeorder.FieldSocialID] = struct{}{}
}

// SocialIDCleared returns if the "social_id" field was cleared in this mutation.
func (m *RechargeOrderMutation) SocialIDCleared() bool {
	_, ok := m.clearedFields[rechargeorder.FieldSocialID]
	return ok
}

// ResetSocialID resets all changes to the "social_id" field.
func (m *RechargeOrderMutation) ResetSocialID() {
	m.vx_social = nil
	delete(m.clearedFields, rechargeorder.FieldSocialID)
}

// SetType sets the "type" field.
func (m *RechargeOrderMutation) SetType(r rechargeorder.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RechargeOrderMutation) GetType() (r rechargeorder.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldType(ctx context.Context) (v rechargeorder.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RechargeOrderMutation) ResetType() {
	m._type = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *RechargeOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *RechargeOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *RechargeOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetThirdAPIResp sets the "third_api_resp" field.
func (m *RechargeOrderMutation) SetThirdAPIResp(s string) {
	m.third_api_resp = &s
}

// ThirdAPIResp returns the value of the "third_api_resp" field in the mutation.
func (m *RechargeOrderMutation) ThirdAPIResp() (r string, exists bool) {
	v := m.third_api_resp
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdAPIResp returns the old "third_api_resp" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldThirdAPIResp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdAPIResp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdAPIResp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdAPIResp: %w", err)
	}
	return oldValue.ThirdAPIResp, nil
}

// ResetThirdAPIResp resets all changes to the "third_api_resp" field.
func (m *RechargeOrderMutation) ResetThirdAPIResp() {
	m.third_api_resp = nil
}

// SetFromUserID sets the "from_user_id" field.
func (m *RechargeOrderMutation) SetFromUserID(i int64) {
	m.from_user_id = &i
	m.addfrom_user_id = nil
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *RechargeOrderMutation) FromUserID() (r int64, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldFromUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// AddFromUserID adds i to the "from_user_id" field.
func (m *RechargeOrderMutation) AddFromUserID(i int64) {
	if m.addfrom_user_id != nil {
		*m.addfrom_user_id += i
	} else {
		m.addfrom_user_id = &i
	}
}

// AddedFromUserID returns the value that was added to the "from_user_id" field in this mutation.
func (m *RechargeOrderMutation) AddedFromUserID() (r int64, exists bool) {
	v := m.addfrom_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *RechargeOrderMutation) ResetFromUserID() {
	m.from_user_id = nil
	m.addfrom_user_id = nil
}

// SetOutTransactionID sets the "out_transaction_id" field.
func (m *RechargeOrderMutation) SetOutTransactionID(s string) {
	m.out_transaction_id = &s
}

// OutTransactionID returns the value of the "out_transaction_id" field in the mutation.
func (m *RechargeOrderMutation) OutTransactionID() (r string, exists bool) {
	v := m.out_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTransactionID returns the old "out_transaction_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldOutTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTransactionID: %w", err)
	}
	return oldValue.OutTransactionID, nil
}

// ResetOutTransactionID resets all changes to the "out_transaction_id" field.
func (m *RechargeOrderMutation) ResetOutTransactionID() {
	m.out_transaction_id = nil
}

// SetCampaignOrderID sets the "campaign_order_id" field.
func (m *RechargeOrderMutation) SetCampaignOrderID(i int64) {
	m.campaign_order = &i
}

// CampaignOrderID returns the value of the "campaign_order_id" field in the mutation.
func (m *RechargeOrderMutation) CampaignOrderID() (r int64, exists bool) {
	v := m.campaign_order
	if v == nil {
		return
	}
	return *v, true
}

// OldCampaignOrderID returns the old "campaign_order_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCampaignOrderID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCampaignOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCampaignOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCampaignOrderID: %w", err)
	}
	return oldValue.CampaignOrderID, nil
}

// ClearCampaignOrderID clears the value of the "campaign_order_id" field.
func (m *RechargeOrderMutation) ClearCampaignOrderID() {
	m.campaign_order = nil
	m.clearedFields[rechargeorder.FieldCampaignOrderID] = struct{}{}
}

// CampaignOrderIDCleared returns if the "campaign_order_id" field was cleared in this mutation.
func (m *RechargeOrderMutation) CampaignOrderIDCleared() bool {
	_, ok := m.clearedFields[rechargeorder.FieldCampaignOrderID]
	return ok
}

// ResetCampaignOrderID resets all changes to the "campaign_order_id" field.
func (m *RechargeOrderMutation) ResetCampaignOrderID() {
	m.campaign_order = nil
	delete(m.clearedFields, rechargeorder.FieldCampaignOrderID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *RechargeOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[rechargeorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RechargeOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RechargeOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RechargeOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *RechargeOrderMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *RechargeOrderMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *RechargeOrderMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *RechargeOrderMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *RechargeOrderMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *RechargeOrderMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *RechargeOrderMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// SetVxSocialID sets the "vx_social" edge to the VXSocial entity by id.
func (m *RechargeOrderMutation) SetVxSocialID(id int64) {
	m.vx_social = &id
}

// ClearVxSocial clears the "vx_social" edge to the VXSocial entity.
func (m *RechargeOrderMutation) ClearVxSocial() {
	m.clearedvx_social = true
	m.clearedFields[rechargeorder.FieldSocialID] = struct{}{}
}

// VxSocialCleared reports if the "vx_social" edge to the VXSocial entity was cleared.
func (m *RechargeOrderMutation) VxSocialCleared() bool {
	return m.SocialIDCleared() || m.clearedvx_social
}

// VxSocialID returns the "vx_social" edge ID in the mutation.
func (m *RechargeOrderMutation) VxSocialID() (id int64, exists bool) {
	if m.vx_social != nil {
		return *m.vx_social, true
	}
	return
}

// VxSocialIDs returns the "vx_social" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VxSocialID instead. It exists only for internal usage by the builders.
func (m *RechargeOrderMutation) VxSocialIDs() (ids []int64) {
	if id := m.vx_social; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVxSocial resets all changes to the "vx_social" edge.
func (m *RechargeOrderMutation) ResetVxSocial() {
	m.vx_social = nil
	m.clearedvx_social = false
}

// ClearCampaignOrder clears the "campaign_order" edge to the CampaignOrder entity.
func (m *RechargeOrderMutation) ClearCampaignOrder() {
	m.clearedcampaign_order = true
	m.clearedFields[rechargeorder.FieldCampaignOrderID] = struct{}{}
}

// CampaignOrderCleared reports if the "campaign_order" edge to the CampaignOrder entity was cleared.
func (m *RechargeOrderMutation) CampaignOrderCleared() bool {
	return m.CampaignOrderIDCleared() || m.clearedcampaign_order
}

// CampaignOrderIDs returns the "campaign_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignOrderID instead. It exists only for internal usage by the builders.
func (m *RechargeOrderMutation) CampaignOrderIDs() (ids []int64) {
	if id := m.campaign_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaignOrder resets all changes to the "campaign_order" edge.
func (m *RechargeOrderMutation) ResetCampaignOrder() {
	m.campaign_order = nil
	m.clearedcampaign_order = false
}

// Where appends a list predicates to the RechargeOrderMutation builder.
func (m *RechargeOrderMutation) Where(ps ...predicate.RechargeOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RechargeOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RechargeOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RechargeOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RechargeOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RechargeOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RechargeOrder).
func (m *RechargeOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RechargeOrderMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, rechargeorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, rechargeorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, rechargeorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rechargeorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rechargeorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, rechargeorder.FieldUserID)
	}
	if m.status != nil {
		fields = append(fields, rechargeorder.FieldStatus)
	}
	if m.pure_cep != nil {
		fields = append(fields, rechargeorder.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, rechargeorder.FieldGiftCep)
	}
	if m.vx_social != nil {
		fields = append(fields, rechargeorder.FieldSocialID)
	}
	if m._type != nil {
		fields = append(fields, rechargeorder.FieldType)
	}
	if m.serial_number != nil {
		fields = append(fields, rechargeorder.FieldSerialNumber)
	}
	if m.third_api_resp != nil {
		fields = append(fields, rechargeorder.FieldThirdAPIResp)
	}
	if m.from_user_id != nil {
		fields = append(fields, rechargeorder.FieldFromUserID)
	}
	if m.out_transaction_id != nil {
		fields = append(fields, rechargeorder.FieldOutTransactionID)
	}
	if m.campaign_order != nil {
		fields = append(fields, rechargeorder.FieldCampaignOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RechargeOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rechargeorder.FieldCreatedBy:
		return m.CreatedBy()
	case rechargeorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case rechargeorder.FieldCreatedAt:
		return m.CreatedAt()
	case rechargeorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case rechargeorder.FieldDeletedAt:
		return m.DeletedAt()
	case rechargeorder.FieldUserID:
		return m.UserID()
	case rechargeorder.FieldStatus:
		return m.Status()
	case rechargeorder.FieldPureCep:
		return m.PureCep()
	case rechargeorder.FieldGiftCep:
		return m.GiftCep()
	case rechargeorder.FieldSocialID:
		return m.SocialID()
	case rechargeorder.FieldType:
		return m.GetType()
	case rechargeorder.FieldSerialNumber:
		return m.SerialNumber()
	case rechargeorder.FieldThirdAPIResp:
		return m.ThirdAPIResp()
	case rechargeorder.FieldFromUserID:
		return m.FromUserID()
	case rechargeorder.FieldOutTransactionID:
		return m.OutTransactionID()
	case rechargeorder.FieldCampaignOrderID:
		return m.CampaignOrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RechargeOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rechargeorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rechargeorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rechargeorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rechargeorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rechargeorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rechargeorder.FieldUserID:
		return m.OldUserID(ctx)
	case rechargeorder.FieldStatus:
		return m.OldStatus(ctx)
	case rechargeorder.FieldPureCep:
		return m.OldPureCep(ctx)
	case rechargeorder.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case rechargeorder.FieldSocialID:
		return m.OldSocialID(ctx)
	case rechargeorder.FieldType:
		return m.OldType(ctx)
	case rechargeorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case rechargeorder.FieldThirdAPIResp:
		return m.OldThirdAPIResp(ctx)
	case rechargeorder.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case rechargeorder.FieldOutTransactionID:
		return m.OldOutTransactionID(ctx)
	case rechargeorder.FieldCampaignOrderID:
		return m.OldCampaignOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown RechargeOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rechargeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rechargeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rechargeorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rechargeorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rechargeorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rechargeorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case rechargeorder.FieldStatus:
		v, ok := value.(rechargeorder.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rechargeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case rechargeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case rechargeorder.FieldSocialID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialID(v)
		return nil
	case rechargeorder.FieldType:
		v, ok := value.(rechargeorder.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case rechargeorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case rechargeorder.FieldThirdAPIResp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdAPIResp(v)
		return nil
	case rechargeorder.FieldFromUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case rechargeorder.FieldOutTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTransactionID(v)
		return nil
	case rechargeorder.FieldCampaignOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCampaignOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RechargeOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, rechargeorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, rechargeorder.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, rechargeorder.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, rechargeorder.FieldGiftCep)
	}
	if m.addfrom_user_id != nil {
		fields = append(fields, rechargeorder.FieldFromUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RechargeOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rechargeorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case rechargeorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case rechargeorder.FieldPureCep:
		return m.AddedPureCep()
	case rechargeorder.FieldGiftCep:
		return m.AddedGiftCep()
	case rechargeorder.FieldFromUserID:
		return m.AddedFromUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rechargeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case rechargeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case rechargeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case rechargeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case rechargeorder.FieldFromUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromUserID(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RechargeOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rechargeorder.FieldSocialID) {
		fields = append(fields, rechargeorder.FieldSocialID)
	}
	if m.FieldCleared(rechargeorder.FieldCampaignOrderID) {
		fields = append(fields, rechargeorder.FieldCampaignOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RechargeOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RechargeOrderMutation) ClearField(name string) error {
	switch name {
	case rechargeorder.FieldSocialID:
		m.ClearSocialID()
		return nil
	case rechargeorder.FieldCampaignOrderID:
		m.ClearCampaignOrderID()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RechargeOrderMutation) ResetField(name string) error {
	switch name {
	case rechargeorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rechargeorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rechargeorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rechargeorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rechargeorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rechargeorder.FieldUserID:
		m.ResetUserID()
		return nil
	case rechargeorder.FieldStatus:
		m.ResetStatus()
		return nil
	case rechargeorder.FieldPureCep:
		m.ResetPureCep()
		return nil
	case rechargeorder.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case rechargeorder.FieldSocialID:
		m.ResetSocialID()
		return nil
	case rechargeorder.FieldType:
		m.ResetType()
		return nil
	case rechargeorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case rechargeorder.FieldThirdAPIResp:
		m.ResetThirdAPIResp()
		return nil
	case rechargeorder.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case rechargeorder.FieldOutTransactionID:
		m.ResetOutTransactionID()
		return nil
	case rechargeorder.FieldCampaignOrderID:
		m.ResetCampaignOrderID()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RechargeOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, rechargeorder.EdgeUser)
	}
	if m.cost_bills != nil {
		edges = append(edges, rechargeorder.EdgeCostBills)
	}
	if m.vx_social != nil {
		edges = append(edges, rechargeorder.EdgeVxSocial)
	}
	if m.campaign_order != nil {
		edges = append(edges, rechargeorder.EdgeCampaignOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RechargeOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rechargeorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case rechargeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case rechargeorder.EdgeVxSocial:
		if id := m.vx_social; id != nil {
			return []ent.Value{*id}
		}
	case rechargeorder.EdgeCampaignOrder:
		if id := m.campaign_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RechargeOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcost_bills != nil {
		edges = append(edges, rechargeorder.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RechargeOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rechargeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RechargeOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, rechargeorder.EdgeUser)
	}
	if m.clearedcost_bills {
		edges = append(edges, rechargeorder.EdgeCostBills)
	}
	if m.clearedvx_social {
		edges = append(edges, rechargeorder.EdgeVxSocial)
	}
	if m.clearedcampaign_order {
		edges = append(edges, rechargeorder.EdgeCampaignOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RechargeOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case rechargeorder.EdgeUser:
		return m.cleareduser
	case rechargeorder.EdgeCostBills:
		return m.clearedcost_bills
	case rechargeorder.EdgeVxSocial:
		return m.clearedvx_social
	case rechargeorder.EdgeCampaignOrder:
		return m.clearedcampaign_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RechargeOrderMutation) ClearEdge(name string) error {
	switch name {
	case rechargeorder.EdgeUser:
		m.ClearUser()
		return nil
	case rechargeorder.EdgeVxSocial:
		m.ClearVxSocial()
		return nil
	case rechargeorder.EdgeCampaignOrder:
		m.ClearCampaignOrder()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RechargeOrderMutation) ResetEdge(name string) error {
	switch name {
	case rechargeorder.EdgeUser:
		m.ResetUser()
		return nil
	case rechargeorder.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case rechargeorder.EdgeVxSocial:
		m.ResetVxSocial()
		return nil
	case rechargeorder.EdgeCampaignOrder:
		m.ResetCampaignOrder()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder edge %s", name)
}

// RenewalAgreementMutation represents an operation that mutates the RenewalAgreement nodes in the graph.
type RenewalAgreementMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	next_pay_time     *time.Time
	_type             *enums.RenewalType
	sub_status        *enums.RenewalSubStatus
	pay_status        *enums.RenewalPayStatus
	symbol_id         *int64
	addsymbol_id      *int64
	first_pay         *int64
	addfirst_pay      *int64
	after_pay         *int64
	addafter_pay      *int64
	last_warning_time *time.Time
	sub_finished_time *time.Time
	clearedFields     map[string]struct{}
	user              *int64
	cleareduser       bool
	mission           *int64
	clearedmission    bool
	done              bool
	oldValue          func(context.Context) (*RenewalAgreement, error)
	predicates        []predicate.RenewalAgreement
}

var _ ent.Mutation = (*RenewalAgreementMutation)(nil)

// renewalagreementOption allows management of the mutation configuration using functional options.
type renewalagreementOption func(*RenewalAgreementMutation)

// newRenewalAgreementMutation creates new mutation for the RenewalAgreement entity.
func newRenewalAgreementMutation(c config, op Op, opts ...renewalagreementOption) *RenewalAgreementMutation {
	m := &RenewalAgreementMutation{
		config:        c,
		op:            op,
		typ:           TypeRenewalAgreement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRenewalAgreementID sets the ID field of the mutation.
func withRenewalAgreementID(id int64) renewalagreementOption {
	return func(m *RenewalAgreementMutation) {
		var (
			err   error
			once  sync.Once
			value *RenewalAgreement
		)
		m.oldValue = func(ctx context.Context) (*RenewalAgreement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RenewalAgreement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRenewalAgreement sets the old RenewalAgreement of the mutation.
func withRenewalAgreement(node *RenewalAgreement) renewalagreementOption {
	return func(m *RenewalAgreementMutation) {
		m.oldValue = func(context.Context) (*RenewalAgreement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RenewalAgreementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RenewalAgreementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RenewalAgreement entities.
func (m *RenewalAgreementMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RenewalAgreementMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RenewalAgreementMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RenewalAgreement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *RenewalAgreementMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RenewalAgreementMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RenewalAgreementMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RenewalAgreementMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RenewalAgreementMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RenewalAgreementMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RenewalAgreementMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RenewalAgreementMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RenewalAgreementMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RenewalAgreementMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RenewalAgreementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RenewalAgreementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RenewalAgreementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RenewalAgreementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RenewalAgreementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RenewalAgreementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RenewalAgreementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RenewalAgreementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RenewalAgreementMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetNextPayTime sets the "next_pay_time" field.
func (m *RenewalAgreementMutation) SetNextPayTime(t time.Time) {
	m.next_pay_time = &t
}

// NextPayTime returns the value of the "next_pay_time" field in the mutation.
func (m *RenewalAgreementMutation) NextPayTime() (r time.Time, exists bool) {
	v := m.next_pay_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNextPayTime returns the old "next_pay_time" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldNextPayTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextPayTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextPayTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextPayTime: %w", err)
	}
	return oldValue.NextPayTime, nil
}

// ResetNextPayTime resets all changes to the "next_pay_time" field.
func (m *RenewalAgreementMutation) ResetNextPayTime() {
	m.next_pay_time = nil
}

// SetType sets the "type" field.
func (m *RenewalAgreementMutation) SetType(et enums.RenewalType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *RenewalAgreementMutation) GetType() (r enums.RenewalType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldType(ctx context.Context) (v enums.RenewalType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RenewalAgreementMutation) ResetType() {
	m._type = nil
}

// SetSubStatus sets the "sub_status" field.
func (m *RenewalAgreementMutation) SetSubStatus(ess enums.RenewalSubStatus) {
	m.sub_status = &ess
}

// SubStatus returns the value of the "sub_status" field in the mutation.
func (m *RenewalAgreementMutation) SubStatus() (r enums.RenewalSubStatus, exists bool) {
	v := m.sub_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSubStatus returns the old "sub_status" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldSubStatus(ctx context.Context) (v enums.RenewalSubStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubStatus: %w", err)
	}
	return oldValue.SubStatus, nil
}

// ResetSubStatus resets all changes to the "sub_status" field.
func (m *RenewalAgreementMutation) ResetSubStatus() {
	m.sub_status = nil
}

// SetPayStatus sets the "pay_status" field.
func (m *RenewalAgreementMutation) SetPayStatus(eps enums.RenewalPayStatus) {
	m.pay_status = &eps
}

// PayStatus returns the value of the "pay_status" field in the mutation.
func (m *RenewalAgreementMutation) PayStatus() (r enums.RenewalPayStatus, exists bool) {
	v := m.pay_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPayStatus returns the old "pay_status" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldPayStatus(ctx context.Context) (v enums.RenewalPayStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayStatus: %w", err)
	}
	return oldValue.PayStatus, nil
}

// ResetPayStatus resets all changes to the "pay_status" field.
func (m *RenewalAgreementMutation) ResetPayStatus() {
	m.pay_status = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *RenewalAgreementMutation) SetSymbolID(i int64) {
	m.symbol_id = &i
	m.addsymbol_id = nil
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *RenewalAgreementMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// AddSymbolID adds i to the "symbol_id" field.
func (m *RenewalAgreementMutation) AddSymbolID(i int64) {
	if m.addsymbol_id != nil {
		*m.addsymbol_id += i
	} else {
		m.addsymbol_id = &i
	}
}

// AddedSymbolID returns the value that was added to the "symbol_id" field in this mutation.
func (m *RenewalAgreementMutation) AddedSymbolID() (r int64, exists bool) {
	v := m.addsymbol_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *RenewalAgreementMutation) ResetSymbolID() {
	m.symbol_id = nil
	m.addsymbol_id = nil
}

// SetFirstPay sets the "first_pay" field.
func (m *RenewalAgreementMutation) SetFirstPay(i int64) {
	m.first_pay = &i
	m.addfirst_pay = nil
}

// FirstPay returns the value of the "first_pay" field in the mutation.
func (m *RenewalAgreementMutation) FirstPay() (r int64, exists bool) {
	v := m.first_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstPay returns the old "first_pay" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldFirstPay(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstPay: %w", err)
	}
	return oldValue.FirstPay, nil
}

// AddFirstPay adds i to the "first_pay" field.
func (m *RenewalAgreementMutation) AddFirstPay(i int64) {
	if m.addfirst_pay != nil {
		*m.addfirst_pay += i
	} else {
		m.addfirst_pay = &i
	}
}

// AddedFirstPay returns the value that was added to the "first_pay" field in this mutation.
func (m *RenewalAgreementMutation) AddedFirstPay() (r int64, exists bool) {
	v := m.addfirst_pay
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstPay resets all changes to the "first_pay" field.
func (m *RenewalAgreementMutation) ResetFirstPay() {
	m.first_pay = nil
	m.addfirst_pay = nil
}

// SetAfterPay sets the "after_pay" field.
func (m *RenewalAgreementMutation) SetAfterPay(i int64) {
	m.after_pay = &i
	m.addafter_pay = nil
}

// AfterPay returns the value of the "after_pay" field in the mutation.
func (m *RenewalAgreementMutation) AfterPay() (r int64, exists bool) {
	v := m.after_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldAfterPay returns the old "after_pay" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldAfterPay(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfterPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfterPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfterPay: %w", err)
	}
	return oldValue.AfterPay, nil
}

// AddAfterPay adds i to the "after_pay" field.
func (m *RenewalAgreementMutation) AddAfterPay(i int64) {
	if m.addafter_pay != nil {
		*m.addafter_pay += i
	} else {
		m.addafter_pay = &i
	}
}

// AddedAfterPay returns the value that was added to the "after_pay" field in this mutation.
func (m *RenewalAgreementMutation) AddedAfterPay() (r int64, exists bool) {
	v := m.addafter_pay
	if v == nil {
		return
	}
	return *v, true
}

// ResetAfterPay resets all changes to the "after_pay" field.
func (m *RenewalAgreementMutation) ResetAfterPay() {
	m.after_pay = nil
	m.addafter_pay = nil
}

// SetLastWarningTime sets the "last_warning_time" field.
func (m *RenewalAgreementMutation) SetLastWarningTime(t time.Time) {
	m.last_warning_time = &t
}

// LastWarningTime returns the value of the "last_warning_time" field in the mutation.
func (m *RenewalAgreementMutation) LastWarningTime() (r time.Time, exists bool) {
	v := m.last_warning_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastWarningTime returns the old "last_warning_time" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldLastWarningTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastWarningTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastWarningTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastWarningTime: %w", err)
	}
	return oldValue.LastWarningTime, nil
}

// ResetLastWarningTime resets all changes to the "last_warning_time" field.
func (m *RenewalAgreementMutation) ResetLastWarningTime() {
	m.last_warning_time = nil
}

// SetSubFinishedTime sets the "sub_finished_time" field.
func (m *RenewalAgreementMutation) SetSubFinishedTime(t time.Time) {
	m.sub_finished_time = &t
}

// SubFinishedTime returns the value of the "sub_finished_time" field in the mutation.
func (m *RenewalAgreementMutation) SubFinishedTime() (r time.Time, exists bool) {
	v := m.sub_finished_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSubFinishedTime returns the old "sub_finished_time" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldSubFinishedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubFinishedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubFinishedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubFinishedTime: %w", err)
	}
	return oldValue.SubFinishedTime, nil
}

// ResetSubFinishedTime resets all changes to the "sub_finished_time" field.
func (m *RenewalAgreementMutation) ResetSubFinishedTime() {
	m.sub_finished_time = nil
}

// SetUserID sets the "user_id" field.
func (m *RenewalAgreementMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RenewalAgreementMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RenewalAgreementMutation) ResetUserID() {
	m.user = nil
}

// SetMissionID sets the "mission_id" field.
func (m *RenewalAgreementMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *RenewalAgreementMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *RenewalAgreementMutation) ResetMissionID() {
	m.mission = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RenewalAgreementMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[renewalagreement.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RenewalAgreementMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RenewalAgreementMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RenewalAgreementMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *RenewalAgreementMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[renewalagreement.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *RenewalAgreementMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *RenewalAgreementMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *RenewalAgreementMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// Where appends a list predicates to the RenewalAgreementMutation builder.
func (m *RenewalAgreementMutation) Where(ps ...predicate.RenewalAgreement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RenewalAgreementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RenewalAgreementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RenewalAgreement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RenewalAgreementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RenewalAgreementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RenewalAgreement).
func (m *RenewalAgreementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RenewalAgreementMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, renewalagreement.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, renewalagreement.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, renewalagreement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, renewalagreement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, renewalagreement.FieldDeletedAt)
	}
	if m.next_pay_time != nil {
		fields = append(fields, renewalagreement.FieldNextPayTime)
	}
	if m._type != nil {
		fields = append(fields, renewalagreement.FieldType)
	}
	if m.sub_status != nil {
		fields = append(fields, renewalagreement.FieldSubStatus)
	}
	if m.pay_status != nil {
		fields = append(fields, renewalagreement.FieldPayStatus)
	}
	if m.symbol_id != nil {
		fields = append(fields, renewalagreement.FieldSymbolID)
	}
	if m.first_pay != nil {
		fields = append(fields, renewalagreement.FieldFirstPay)
	}
	if m.after_pay != nil {
		fields = append(fields, renewalagreement.FieldAfterPay)
	}
	if m.last_warning_time != nil {
		fields = append(fields, renewalagreement.FieldLastWarningTime)
	}
	if m.sub_finished_time != nil {
		fields = append(fields, renewalagreement.FieldSubFinishedTime)
	}
	if m.user != nil {
		fields = append(fields, renewalagreement.FieldUserID)
	}
	if m.mission != nil {
		fields = append(fields, renewalagreement.FieldMissionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RenewalAgreementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case renewalagreement.FieldCreatedBy:
		return m.CreatedBy()
	case renewalagreement.FieldUpdatedBy:
		return m.UpdatedBy()
	case renewalagreement.FieldCreatedAt:
		return m.CreatedAt()
	case renewalagreement.FieldUpdatedAt:
		return m.UpdatedAt()
	case renewalagreement.FieldDeletedAt:
		return m.DeletedAt()
	case renewalagreement.FieldNextPayTime:
		return m.NextPayTime()
	case renewalagreement.FieldType:
		return m.GetType()
	case renewalagreement.FieldSubStatus:
		return m.SubStatus()
	case renewalagreement.FieldPayStatus:
		return m.PayStatus()
	case renewalagreement.FieldSymbolID:
		return m.SymbolID()
	case renewalagreement.FieldFirstPay:
		return m.FirstPay()
	case renewalagreement.FieldAfterPay:
		return m.AfterPay()
	case renewalagreement.FieldLastWarningTime:
		return m.LastWarningTime()
	case renewalagreement.FieldSubFinishedTime:
		return m.SubFinishedTime()
	case renewalagreement.FieldUserID:
		return m.UserID()
	case renewalagreement.FieldMissionID:
		return m.MissionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RenewalAgreementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case renewalagreement.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case renewalagreement.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case renewalagreement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case renewalagreement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case renewalagreement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case renewalagreement.FieldNextPayTime:
		return m.OldNextPayTime(ctx)
	case renewalagreement.FieldType:
		return m.OldType(ctx)
	case renewalagreement.FieldSubStatus:
		return m.OldSubStatus(ctx)
	case renewalagreement.FieldPayStatus:
		return m.OldPayStatus(ctx)
	case renewalagreement.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case renewalagreement.FieldFirstPay:
		return m.OldFirstPay(ctx)
	case renewalagreement.FieldAfterPay:
		return m.OldAfterPay(ctx)
	case renewalagreement.FieldLastWarningTime:
		return m.OldLastWarningTime(ctx)
	case renewalagreement.FieldSubFinishedTime:
		return m.OldSubFinishedTime(ctx)
	case renewalagreement.FieldUserID:
		return m.OldUserID(ctx)
	case renewalagreement.FieldMissionID:
		return m.OldMissionID(ctx)
	}
	return nil, fmt.Errorf("unknown RenewalAgreement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RenewalAgreementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case renewalagreement.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case renewalagreement.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case renewalagreement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case renewalagreement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case renewalagreement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case renewalagreement.FieldNextPayTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextPayTime(v)
		return nil
	case renewalagreement.FieldType:
		v, ok := value.(enums.RenewalType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case renewalagreement.FieldSubStatus:
		v, ok := value.(enums.RenewalSubStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubStatus(v)
		return nil
	case renewalagreement.FieldPayStatus:
		v, ok := value.(enums.RenewalPayStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayStatus(v)
		return nil
	case renewalagreement.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case renewalagreement.FieldFirstPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstPay(v)
		return nil
	case renewalagreement.FieldAfterPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfterPay(v)
		return nil
	case renewalagreement.FieldLastWarningTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastWarningTime(v)
		return nil
	case renewalagreement.FieldSubFinishedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubFinishedTime(v)
		return nil
	case renewalagreement.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case renewalagreement.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RenewalAgreementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, renewalagreement.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, renewalagreement.FieldUpdatedBy)
	}
	if m.addsymbol_id != nil {
		fields = append(fields, renewalagreement.FieldSymbolID)
	}
	if m.addfirst_pay != nil {
		fields = append(fields, renewalagreement.FieldFirstPay)
	}
	if m.addafter_pay != nil {
		fields = append(fields, renewalagreement.FieldAfterPay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RenewalAgreementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case renewalagreement.FieldCreatedBy:
		return m.AddedCreatedBy()
	case renewalagreement.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case renewalagreement.FieldSymbolID:
		return m.AddedSymbolID()
	case renewalagreement.FieldFirstPay:
		return m.AddedFirstPay()
	case renewalagreement.FieldAfterPay:
		return m.AddedAfterPay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RenewalAgreementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case renewalagreement.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case renewalagreement.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case renewalagreement.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSymbolID(v)
		return nil
	case renewalagreement.FieldFirstPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstPay(v)
		return nil
	case renewalagreement.FieldAfterPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAfterPay(v)
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RenewalAgreementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RenewalAgreementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RenewalAgreementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RenewalAgreement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RenewalAgreementMutation) ResetField(name string) error {
	switch name {
	case renewalagreement.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case renewalagreement.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case renewalagreement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case renewalagreement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case renewalagreement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case renewalagreement.FieldNextPayTime:
		m.ResetNextPayTime()
		return nil
	case renewalagreement.FieldType:
		m.ResetType()
		return nil
	case renewalagreement.FieldSubStatus:
		m.ResetSubStatus()
		return nil
	case renewalagreement.FieldPayStatus:
		m.ResetPayStatus()
		return nil
	case renewalagreement.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case renewalagreement.FieldFirstPay:
		m.ResetFirstPay()
		return nil
	case renewalagreement.FieldAfterPay:
		m.ResetAfterPay()
		return nil
	case renewalagreement.FieldLastWarningTime:
		m.ResetLastWarningTime()
		return nil
	case renewalagreement.FieldSubFinishedTime:
		m.ResetSubFinishedTime()
		return nil
	case renewalagreement.FieldUserID:
		m.ResetUserID()
		return nil
	case renewalagreement.FieldMissionID:
		m.ResetMissionID()
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RenewalAgreementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, renewalagreement.EdgeUser)
	}
	if m.mission != nil {
		edges = append(edges, renewalagreement.EdgeMission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RenewalAgreementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case renewalagreement.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case renewalagreement.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RenewalAgreementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RenewalAgreementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RenewalAgreementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, renewalagreement.EdgeUser)
	}
	if m.clearedmission {
		edges = append(edges, renewalagreement.EdgeMission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RenewalAgreementMutation) EdgeCleared(name string) bool {
	switch name {
	case renewalagreement.EdgeUser:
		return m.cleareduser
	case renewalagreement.EdgeMission:
		return m.clearedmission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RenewalAgreementMutation) ClearEdge(name string) error {
	switch name {
	case renewalagreement.EdgeUser:
		m.ClearUser()
		return nil
	case renewalagreement.EdgeMission:
		m.ClearMission()
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RenewalAgreementMutation) ResetEdge(name string) error {
	switch name {
	case renewalagreement.EdgeUser:
		m.ResetUser()
		return nil
	case renewalagreement.EdgeMission:
		m.ResetMission()
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement edge %s", name)
}

// SurveyMutation represents an operation that mutates the Survey nodes in the graph.
type SurveyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	created_by              *int64
	addcreated_by           *int64
	updated_by              *int64
	addupdated_by           *int64
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	title                   *string
	started_at              *time.Time
	ended_at                *time.Time
	sort_num                *int64
	addsort_num             *int64
	group                   *string
	gift_cep_amount         *int64
	addgift_cep_amount      *int64
	gift_type               *enums.SurveyGiftType
	hint                    *string
	desc                    *string
	is_gift_recharge        *bool
	background_image        *string
	clearedFields           map[string]struct{}
	survey_questions        map[int64]struct{}
	removedsurvey_questions map[int64]struct{}
	clearedsurvey_questions bool
	survey_responses        map[int64]struct{}
	removedsurvey_responses map[int64]struct{}
	clearedsurvey_responses bool
	done                    bool
	oldValue                func(context.Context) (*Survey, error)
	predicates              []predicate.Survey
}

var _ ent.Mutation = (*SurveyMutation)(nil)

// surveyOption allows management of the mutation configuration using functional options.
type surveyOption func(*SurveyMutation)

// newSurveyMutation creates new mutation for the Survey entity.
func newSurveyMutation(c config, op Op, opts ...surveyOption) *SurveyMutation {
	m := &SurveyMutation{
		config:        c,
		op:            op,
		typ:           TypeSurvey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyID sets the ID field of the mutation.
func withSurveyID(id int64) surveyOption {
	return func(m *SurveyMutation) {
		var (
			err   error
			once  sync.Once
			value *Survey
		)
		m.oldValue = func(ctx context.Context) (*Survey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Survey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurvey sets the old Survey of the mutation.
func withSurvey(node *Survey) surveyOption {
	return func(m *SurveyMutation) {
		m.oldValue = func(context.Context) (*Survey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Survey entities.
func (m *SurveyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Survey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *SurveyMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SurveyMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *SurveyMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SurveyMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SurveyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SurveyMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SurveyMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *SurveyMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SurveyMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SurveyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SurveyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SurveyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SurveyMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTitle sets the "title" field.
func (m *SurveyMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SurveyMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SurveyMutation) ResetTitle() {
	m.title = nil
}

// SetStartedAt sets the "started_at" field.
func (m *SurveyMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SurveyMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *SurveyMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[survey.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *SurveyMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[survey.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SurveyMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, survey.FieldStartedAt)
}

// SetEndedAt sets the "ended_at" field.
func (m *SurveyMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *SurveyMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *SurveyMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[survey.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *SurveyMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[survey.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *SurveyMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, survey.FieldEndedAt)
}

// SetSortNum sets the "sort_num" field.
func (m *SurveyMutation) SetSortNum(i int64) {
	m.sort_num = &i
	m.addsort_num = nil
}

// SortNum returns the value of the "sort_num" field in the mutation.
func (m *SurveyMutation) SortNum() (r int64, exists bool) {
	v := m.sort_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSortNum returns the old "sort_num" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldSortNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortNum: %w", err)
	}
	return oldValue.SortNum, nil
}

// AddSortNum adds i to the "sort_num" field.
func (m *SurveyMutation) AddSortNum(i int64) {
	if m.addsort_num != nil {
		*m.addsort_num += i
	} else {
		m.addsort_num = &i
	}
}

// AddedSortNum returns the value that was added to the "sort_num" field in this mutation.
func (m *SurveyMutation) AddedSortNum() (r int64, exists bool) {
	v := m.addsort_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortNum resets all changes to the "sort_num" field.
func (m *SurveyMutation) ResetSortNum() {
	m.sort_num = nil
	m.addsort_num = nil
}

// SetGroup sets the "group" field.
func (m *SurveyMutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *SurveyMutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *SurveyMutation) ResetGroup() {
	m.group = nil
}

// SetGiftCepAmount sets the "gift_cep_amount" field.
func (m *SurveyMutation) SetGiftCepAmount(i int64) {
	m.gift_cep_amount = &i
	m.addgift_cep_amount = nil
}

// GiftCepAmount returns the value of the "gift_cep_amount" field in the mutation.
func (m *SurveyMutation) GiftCepAmount() (r int64, exists bool) {
	v := m.gift_cep_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCepAmount returns the old "gift_cep_amount" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldGiftCepAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCepAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCepAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCepAmount: %w", err)
	}
	return oldValue.GiftCepAmount, nil
}

// AddGiftCepAmount adds i to the "gift_cep_amount" field.
func (m *SurveyMutation) AddGiftCepAmount(i int64) {
	if m.addgift_cep_amount != nil {
		*m.addgift_cep_amount += i
	} else {
		m.addgift_cep_amount = &i
	}
}

// AddedGiftCepAmount returns the value that was added to the "gift_cep_amount" field in this mutation.
func (m *SurveyMutation) AddedGiftCepAmount() (r int64, exists bool) {
	v := m.addgift_cep_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCepAmount resets all changes to the "gift_cep_amount" field.
func (m *SurveyMutation) ResetGiftCepAmount() {
	m.gift_cep_amount = nil
	m.addgift_cep_amount = nil
}

// SetGiftType sets the "gift_type" field.
func (m *SurveyMutation) SetGiftType(egt enums.SurveyGiftType) {
	m.gift_type = &egt
}

// GiftType returns the value of the "gift_type" field in the mutation.
func (m *SurveyMutation) GiftType() (r enums.SurveyGiftType, exists bool) {
	v := m.gift_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftType returns the old "gift_type" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldGiftType(ctx context.Context) (v enums.SurveyGiftType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftType: %w", err)
	}
	return oldValue.GiftType, nil
}

// ResetGiftType resets all changes to the "gift_type" field.
func (m *SurveyMutation) ResetGiftType() {
	m.gift_type = nil
}

// SetHint sets the "hint" field.
func (m *SurveyMutation) SetHint(s string) {
	m.hint = &s
}

// Hint returns the value of the "hint" field in the mutation.
func (m *SurveyMutation) Hint() (r string, exists bool) {
	v := m.hint
	if v == nil {
		return
	}
	return *v, true
}

// OldHint returns the old "hint" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldHint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHint: %w", err)
	}
	return oldValue.Hint, nil
}

// ResetHint resets all changes to the "hint" field.
func (m *SurveyMutation) ResetHint() {
	m.hint = nil
}

// SetDesc sets the "desc" field.
func (m *SurveyMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *SurveyMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *SurveyMutation) ResetDesc() {
	m.desc = nil
}

// SetIsGiftRecharge sets the "is_gift_recharge" field.
func (m *SurveyMutation) SetIsGiftRecharge(b bool) {
	m.is_gift_recharge = &b
}

// IsGiftRecharge returns the value of the "is_gift_recharge" field in the mutation.
func (m *SurveyMutation) IsGiftRecharge() (r bool, exists bool) {
	v := m.is_gift_recharge
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGiftRecharge returns the old "is_gift_recharge" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldIsGiftRecharge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGiftRecharge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGiftRecharge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGiftRecharge: %w", err)
	}
	return oldValue.IsGiftRecharge, nil
}

// ResetIsGiftRecharge resets all changes to the "is_gift_recharge" field.
func (m *SurveyMutation) ResetIsGiftRecharge() {
	m.is_gift_recharge = nil
}

// SetBackgroundImage sets the "background_image" field.
func (m *SurveyMutation) SetBackgroundImage(s string) {
	m.background_image = &s
}

// BackgroundImage returns the value of the "background_image" field in the mutation.
func (m *SurveyMutation) BackgroundImage() (r string, exists bool) {
	v := m.background_image
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundImage returns the old "background_image" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldBackgroundImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundImage: %w", err)
	}
	return oldValue.BackgroundImage, nil
}

// ResetBackgroundImage resets all changes to the "background_image" field.
func (m *SurveyMutation) ResetBackgroundImage() {
	m.background_image = nil
}

// AddSurveyQuestionIDs adds the "survey_questions" edge to the SurveyQuestion entity by ids.
func (m *SurveyMutation) AddSurveyQuestionIDs(ids ...int64) {
	if m.survey_questions == nil {
		m.survey_questions = make(map[int64]struct{})
	}
	for i := range ids {
		m.survey_questions[ids[i]] = struct{}{}
	}
}

// ClearSurveyQuestions clears the "survey_questions" edge to the SurveyQuestion entity.
func (m *SurveyMutation) ClearSurveyQuestions() {
	m.clearedsurvey_questions = true
}

// SurveyQuestionsCleared reports if the "survey_questions" edge to the SurveyQuestion entity was cleared.
func (m *SurveyMutation) SurveyQuestionsCleared() bool {
	return m.clearedsurvey_questions
}

// RemoveSurveyQuestionIDs removes the "survey_questions" edge to the SurveyQuestion entity by IDs.
func (m *SurveyMutation) RemoveSurveyQuestionIDs(ids ...int64) {
	if m.removedsurvey_questions == nil {
		m.removedsurvey_questions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.survey_questions, ids[i])
		m.removedsurvey_questions[ids[i]] = struct{}{}
	}
}

// RemovedSurveyQuestions returns the removed IDs of the "survey_questions" edge to the SurveyQuestion entity.
func (m *SurveyMutation) RemovedSurveyQuestionsIDs() (ids []int64) {
	for id := range m.removedsurvey_questions {
		ids = append(ids, id)
	}
	return
}

// SurveyQuestionsIDs returns the "survey_questions" edge IDs in the mutation.
func (m *SurveyMutation) SurveyQuestionsIDs() (ids []int64) {
	for id := range m.survey_questions {
		ids = append(ids, id)
	}
	return
}

// ResetSurveyQuestions resets all changes to the "survey_questions" edge.
func (m *SurveyMutation) ResetSurveyQuestions() {
	m.survey_questions = nil
	m.clearedsurvey_questions = false
	m.removedsurvey_questions = nil
}

// AddSurveyResponseIDs adds the "survey_responses" edge to the SurveyResponse entity by ids.
func (m *SurveyMutation) AddSurveyResponseIDs(ids ...int64) {
	if m.survey_responses == nil {
		m.survey_responses = make(map[int64]struct{})
	}
	for i := range ids {
		m.survey_responses[ids[i]] = struct{}{}
	}
}

// ClearSurveyResponses clears the "survey_responses" edge to the SurveyResponse entity.
func (m *SurveyMutation) ClearSurveyResponses() {
	m.clearedsurvey_responses = true
}

// SurveyResponsesCleared reports if the "survey_responses" edge to the SurveyResponse entity was cleared.
func (m *SurveyMutation) SurveyResponsesCleared() bool {
	return m.clearedsurvey_responses
}

// RemoveSurveyResponseIDs removes the "survey_responses" edge to the SurveyResponse entity by IDs.
func (m *SurveyMutation) RemoveSurveyResponseIDs(ids ...int64) {
	if m.removedsurvey_responses == nil {
		m.removedsurvey_responses = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.survey_responses, ids[i])
		m.removedsurvey_responses[ids[i]] = struct{}{}
	}
}

// RemovedSurveyResponses returns the removed IDs of the "survey_responses" edge to the SurveyResponse entity.
func (m *SurveyMutation) RemovedSurveyResponsesIDs() (ids []int64) {
	for id := range m.removedsurvey_responses {
		ids = append(ids, id)
	}
	return
}

// SurveyResponsesIDs returns the "survey_responses" edge IDs in the mutation.
func (m *SurveyMutation) SurveyResponsesIDs() (ids []int64) {
	for id := range m.survey_responses {
		ids = append(ids, id)
	}
	return
}

// ResetSurveyResponses resets all changes to the "survey_responses" edge.
func (m *SurveyMutation) ResetSurveyResponses() {
	m.survey_responses = nil
	m.clearedsurvey_responses = false
	m.removedsurvey_responses = nil
}

// Where appends a list predicates to the SurveyMutation builder.
func (m *SurveyMutation) Where(ps ...predicate.Survey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Survey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Survey).
func (m *SurveyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, survey.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, survey.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, survey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, survey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, survey.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, survey.FieldTitle)
	}
	if m.started_at != nil {
		fields = append(fields, survey.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, survey.FieldEndedAt)
	}
	if m.sort_num != nil {
		fields = append(fields, survey.FieldSortNum)
	}
	if m.group != nil {
		fields = append(fields, survey.FieldGroup)
	}
	if m.gift_cep_amount != nil {
		fields = append(fields, survey.FieldGiftCepAmount)
	}
	if m.gift_type != nil {
		fields = append(fields, survey.FieldGiftType)
	}
	if m.hint != nil {
		fields = append(fields, survey.FieldHint)
	}
	if m.desc != nil {
		fields = append(fields, survey.FieldDesc)
	}
	if m.is_gift_recharge != nil {
		fields = append(fields, survey.FieldIsGiftRecharge)
	}
	if m.background_image != nil {
		fields = append(fields, survey.FieldBackgroundImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case survey.FieldCreatedBy:
		return m.CreatedBy()
	case survey.FieldUpdatedBy:
		return m.UpdatedBy()
	case survey.FieldCreatedAt:
		return m.CreatedAt()
	case survey.FieldUpdatedAt:
		return m.UpdatedAt()
	case survey.FieldDeletedAt:
		return m.DeletedAt()
	case survey.FieldTitle:
		return m.Title()
	case survey.FieldStartedAt:
		return m.StartedAt()
	case survey.FieldEndedAt:
		return m.EndedAt()
	case survey.FieldSortNum:
		return m.SortNum()
	case survey.FieldGroup:
		return m.Group()
	case survey.FieldGiftCepAmount:
		return m.GiftCepAmount()
	case survey.FieldGiftType:
		return m.GiftType()
	case survey.FieldHint:
		return m.Hint()
	case survey.FieldDesc:
		return m.Desc()
	case survey.FieldIsGiftRecharge:
		return m.IsGiftRecharge()
	case survey.FieldBackgroundImage:
		return m.BackgroundImage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case survey.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case survey.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case survey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case survey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case survey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case survey.FieldTitle:
		return m.OldTitle(ctx)
	case survey.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case survey.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case survey.FieldSortNum:
		return m.OldSortNum(ctx)
	case survey.FieldGroup:
		return m.OldGroup(ctx)
	case survey.FieldGiftCepAmount:
		return m.OldGiftCepAmount(ctx)
	case survey.FieldGiftType:
		return m.OldGiftType(ctx)
	case survey.FieldHint:
		return m.OldHint(ctx)
	case survey.FieldDesc:
		return m.OldDesc(ctx)
	case survey.FieldIsGiftRecharge:
		return m.OldIsGiftRecharge(ctx)
	case survey.FieldBackgroundImage:
		return m.OldBackgroundImage(ctx)
	}
	return nil, fmt.Errorf("unknown Survey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case survey.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case survey.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case survey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case survey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case survey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case survey.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case survey.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case survey.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case survey.FieldSortNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortNum(v)
		return nil
	case survey.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case survey.FieldGiftCepAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCepAmount(v)
		return nil
	case survey.FieldGiftType:
		v, ok := value.(enums.SurveyGiftType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftType(v)
		return nil
	case survey.FieldHint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHint(v)
		return nil
	case survey.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case survey.FieldIsGiftRecharge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGiftRecharge(v)
		return nil
	case survey.FieldBackgroundImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundImage(v)
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, survey.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, survey.FieldUpdatedBy)
	}
	if m.addsort_num != nil {
		fields = append(fields, survey.FieldSortNum)
	}
	if m.addgift_cep_amount != nil {
		fields = append(fields, survey.FieldGiftCepAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case survey.FieldCreatedBy:
		return m.AddedCreatedBy()
	case survey.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case survey.FieldSortNum:
		return m.AddedSortNum()
	case survey.FieldGiftCepAmount:
		return m.AddedGiftCepAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case survey.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case survey.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case survey.FieldSortNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortNum(v)
		return nil
	case survey.FieldGiftCepAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCepAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Survey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(survey.FieldStartedAt) {
		fields = append(fields, survey.FieldStartedAt)
	}
	if m.FieldCleared(survey.FieldEndedAt) {
		fields = append(fields, survey.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyMutation) ClearField(name string) error {
	switch name {
	case survey.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case survey.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown Survey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyMutation) ResetField(name string) error {
	switch name {
	case survey.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case survey.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case survey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case survey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case survey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case survey.FieldTitle:
		m.ResetTitle()
		return nil
	case survey.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case survey.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case survey.FieldSortNum:
		m.ResetSortNum()
		return nil
	case survey.FieldGroup:
		m.ResetGroup()
		return nil
	case survey.FieldGiftCepAmount:
		m.ResetGiftCepAmount()
		return nil
	case survey.FieldGiftType:
		m.ResetGiftType()
		return nil
	case survey.FieldHint:
		m.ResetHint()
		return nil
	case survey.FieldDesc:
		m.ResetDesc()
		return nil
	case survey.FieldIsGiftRecharge:
		m.ResetIsGiftRecharge()
		return nil
	case survey.FieldBackgroundImage:
		m.ResetBackgroundImage()
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.survey_questions != nil {
		edges = append(edges, survey.EdgeSurveyQuestions)
	}
	if m.survey_responses != nil {
		edges = append(edges, survey.EdgeSurveyResponses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgeSurveyQuestions:
		ids := make([]ent.Value, 0, len(m.survey_questions))
		for id := range m.survey_questions {
			ids = append(ids, id)
		}
		return ids
	case survey.EdgeSurveyResponses:
		ids := make([]ent.Value, 0, len(m.survey_responses))
		for id := range m.survey_responses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsurvey_questions != nil {
		edges = append(edges, survey.EdgeSurveyQuestions)
	}
	if m.removedsurvey_responses != nil {
		edges = append(edges, survey.EdgeSurveyResponses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgeSurveyQuestions:
		ids := make([]ent.Value, 0, len(m.removedsurvey_questions))
		for id := range m.removedsurvey_questions {
			ids = append(ids, id)
		}
		return ids
	case survey.EdgeSurveyResponses:
		ids := make([]ent.Value, 0, len(m.removedsurvey_responses))
		for id := range m.removedsurvey_responses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsurvey_questions {
		edges = append(edges, survey.EdgeSurveyQuestions)
	}
	if m.clearedsurvey_responses {
		edges = append(edges, survey.EdgeSurveyResponses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyMutation) EdgeCleared(name string) bool {
	switch name {
	case survey.EdgeSurveyQuestions:
		return m.clearedsurvey_questions
	case survey.EdgeSurveyResponses:
		return m.clearedsurvey_responses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Survey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyMutation) ResetEdge(name string) error {
	switch name {
	case survey.EdgeSurveyQuestions:
		m.ResetSurveyQuestions()
		return nil
	case survey.EdgeSurveyResponses:
		m.ResetSurveyResponses()
		return nil
	}
	return fmt.Errorf("unknown Survey edge %s", name)
}

// SurveyAnswerMutation represents an operation that mutates the SurveyAnswer nodes in the graph.
type SurveyAnswerMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_by             *int64
	addcreated_by          *int64
	updated_by             *int64
	addupdated_by          *int64
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	survey_answer          *string
	clearedFields          map[string]struct{}
	survey_response        *int64
	clearedsurvey_response bool
	survey_question        *int64
	clearedsurvey_question bool
	done                   bool
	oldValue               func(context.Context) (*SurveyAnswer, error)
	predicates             []predicate.SurveyAnswer
}

var _ ent.Mutation = (*SurveyAnswerMutation)(nil)

// surveyanswerOption allows management of the mutation configuration using functional options.
type surveyanswerOption func(*SurveyAnswerMutation)

// newSurveyAnswerMutation creates new mutation for the SurveyAnswer entity.
func newSurveyAnswerMutation(c config, op Op, opts ...surveyanswerOption) *SurveyAnswerMutation {
	m := &SurveyAnswerMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyAnswer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyAnswerID sets the ID field of the mutation.
func withSurveyAnswerID(id int64) surveyanswerOption {
	return func(m *SurveyAnswerMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyAnswer
		)
		m.oldValue = func(ctx context.Context) (*SurveyAnswer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyAnswer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyAnswer sets the old SurveyAnswer of the mutation.
func withSurveyAnswer(node *SurveyAnswer) surveyanswerOption {
	return func(m *SurveyAnswerMutation) {
		m.oldValue = func(context.Context) (*SurveyAnswer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyAnswerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyAnswerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SurveyAnswer entities.
func (m *SurveyAnswerMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyAnswerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyAnswerMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SurveyAnswer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *SurveyAnswerMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SurveyAnswerMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SurveyAnswer entity.
// If the SurveyAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyAnswerMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *SurveyAnswerMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SurveyAnswerMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SurveyAnswerMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SurveyAnswerMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SurveyAnswerMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SurveyAnswer entity.
// If the SurveyAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyAnswerMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *SurveyAnswerMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SurveyAnswerMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SurveyAnswerMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyAnswerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyAnswerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SurveyAnswer entity.
// If the SurveyAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyAnswerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyAnswerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyAnswerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyAnswerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SurveyAnswer entity.
// If the SurveyAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyAnswerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyAnswerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SurveyAnswerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SurveyAnswerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SurveyAnswer entity.
// If the SurveyAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyAnswerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SurveyAnswerMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetSurveyResponseID sets the "survey_response_id" field.
func (m *SurveyAnswerMutation) SetSurveyResponseID(i int64) {
	m.survey_response = &i
}

// SurveyResponseID returns the value of the "survey_response_id" field in the mutation.
func (m *SurveyAnswerMutation) SurveyResponseID() (r int64, exists bool) {
	v := m.survey_response
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyResponseID returns the old "survey_response_id" field's value of the SurveyAnswer entity.
// If the SurveyAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyAnswerMutation) OldSurveyResponseID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyResponseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyResponseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyResponseID: %w", err)
	}
	return oldValue.SurveyResponseID, nil
}

// ResetSurveyResponseID resets all changes to the "survey_response_id" field.
func (m *SurveyAnswerMutation) ResetSurveyResponseID() {
	m.survey_response = nil
}

// SetSurveyQuestionID sets the "survey_question_id" field.
func (m *SurveyAnswerMutation) SetSurveyQuestionID(i int64) {
	m.survey_question = &i
}

// SurveyQuestionID returns the value of the "survey_question_id" field in the mutation.
func (m *SurveyAnswerMutation) SurveyQuestionID() (r int64, exists bool) {
	v := m.survey_question
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyQuestionID returns the old "survey_question_id" field's value of the SurveyAnswer entity.
// If the SurveyAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyAnswerMutation) OldSurveyQuestionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyQuestionID: %w", err)
	}
	return oldValue.SurveyQuestionID, nil
}

// ResetSurveyQuestionID resets all changes to the "survey_question_id" field.
func (m *SurveyAnswerMutation) ResetSurveyQuestionID() {
	m.survey_question = nil
}

// SetSurveyAnswer sets the "survey_answer" field.
func (m *SurveyAnswerMutation) SetSurveyAnswer(s string) {
	m.survey_answer = &s
}

// SurveyAnswer returns the value of the "survey_answer" field in the mutation.
func (m *SurveyAnswerMutation) SurveyAnswer() (r string, exists bool) {
	v := m.survey_answer
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyAnswer returns the old "survey_answer" field's value of the SurveyAnswer entity.
// If the SurveyAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyAnswerMutation) OldSurveyAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyAnswer: %w", err)
	}
	return oldValue.SurveyAnswer, nil
}

// ResetSurveyAnswer resets all changes to the "survey_answer" field.
func (m *SurveyAnswerMutation) ResetSurveyAnswer() {
	m.survey_answer = nil
}

// ClearSurveyResponse clears the "survey_response" edge to the SurveyResponse entity.
func (m *SurveyAnswerMutation) ClearSurveyResponse() {
	m.clearedsurvey_response = true
	m.clearedFields[surveyanswer.FieldSurveyResponseID] = struct{}{}
}

// SurveyResponseCleared reports if the "survey_response" edge to the SurveyResponse entity was cleared.
func (m *SurveyAnswerMutation) SurveyResponseCleared() bool {
	return m.clearedsurvey_response
}

// SurveyResponseIDs returns the "survey_response" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SurveyResponseID instead. It exists only for internal usage by the builders.
func (m *SurveyAnswerMutation) SurveyResponseIDs() (ids []int64) {
	if id := m.survey_response; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurveyResponse resets all changes to the "survey_response" edge.
func (m *SurveyAnswerMutation) ResetSurveyResponse() {
	m.survey_response = nil
	m.clearedsurvey_response = false
}

// ClearSurveyQuestion clears the "survey_question" edge to the SurveyQuestion entity.
func (m *SurveyAnswerMutation) ClearSurveyQuestion() {
	m.clearedsurvey_question = true
	m.clearedFields[surveyanswer.FieldSurveyQuestionID] = struct{}{}
}

// SurveyQuestionCleared reports if the "survey_question" edge to the SurveyQuestion entity was cleared.
func (m *SurveyAnswerMutation) SurveyQuestionCleared() bool {
	return m.clearedsurvey_question
}

// SurveyQuestionIDs returns the "survey_question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SurveyQuestionID instead. It exists only for internal usage by the builders.
func (m *SurveyAnswerMutation) SurveyQuestionIDs() (ids []int64) {
	if id := m.survey_question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurveyQuestion resets all changes to the "survey_question" edge.
func (m *SurveyAnswerMutation) ResetSurveyQuestion() {
	m.survey_question = nil
	m.clearedsurvey_question = false
}

// Where appends a list predicates to the SurveyAnswerMutation builder.
func (m *SurveyAnswerMutation) Where(ps ...predicate.SurveyAnswer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyAnswerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyAnswerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SurveyAnswer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyAnswerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyAnswerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SurveyAnswer).
func (m *SurveyAnswerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyAnswerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, surveyanswer.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, surveyanswer.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, surveyanswer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, surveyanswer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, surveyanswer.FieldDeletedAt)
	}
	if m.survey_response != nil {
		fields = append(fields, surveyanswer.FieldSurveyResponseID)
	}
	if m.survey_question != nil {
		fields = append(fields, surveyanswer.FieldSurveyQuestionID)
	}
	if m.survey_answer != nil {
		fields = append(fields, surveyanswer.FieldSurveyAnswer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyAnswerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveyanswer.FieldCreatedBy:
		return m.CreatedBy()
	case surveyanswer.FieldUpdatedBy:
		return m.UpdatedBy()
	case surveyanswer.FieldCreatedAt:
		return m.CreatedAt()
	case surveyanswer.FieldUpdatedAt:
		return m.UpdatedAt()
	case surveyanswer.FieldDeletedAt:
		return m.DeletedAt()
	case surveyanswer.FieldSurveyResponseID:
		return m.SurveyResponseID()
	case surveyanswer.FieldSurveyQuestionID:
		return m.SurveyQuestionID()
	case surveyanswer.FieldSurveyAnswer:
		return m.SurveyAnswer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyAnswerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveyanswer.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case surveyanswer.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case surveyanswer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case surveyanswer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case surveyanswer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case surveyanswer.FieldSurveyResponseID:
		return m.OldSurveyResponseID(ctx)
	case surveyanswer.FieldSurveyQuestionID:
		return m.OldSurveyQuestionID(ctx)
	case surveyanswer.FieldSurveyAnswer:
		return m.OldSurveyAnswer(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyAnswer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyAnswerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveyanswer.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case surveyanswer.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case surveyanswer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case surveyanswer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case surveyanswer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case surveyanswer.FieldSurveyResponseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyResponseID(v)
		return nil
	case surveyanswer.FieldSurveyQuestionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyQuestionID(v)
		return nil
	case surveyanswer.FieldSurveyAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyAnswer(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyAnswer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyAnswerMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, surveyanswer.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, surveyanswer.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyAnswerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveyanswer.FieldCreatedBy:
		return m.AddedCreatedBy()
	case surveyanswer.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyAnswerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveyanswer.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case surveyanswer.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyAnswer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyAnswerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyAnswerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyAnswerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SurveyAnswer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyAnswerMutation) ResetField(name string) error {
	switch name {
	case surveyanswer.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case surveyanswer.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case surveyanswer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case surveyanswer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case surveyanswer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case surveyanswer.FieldSurveyResponseID:
		m.ResetSurveyResponseID()
		return nil
	case surveyanswer.FieldSurveyQuestionID:
		m.ResetSurveyQuestionID()
		return nil
	case surveyanswer.FieldSurveyAnswer:
		m.ResetSurveyAnswer()
		return nil
	}
	return fmt.Errorf("unknown SurveyAnswer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyAnswerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.survey_response != nil {
		edges = append(edges, surveyanswer.EdgeSurveyResponse)
	}
	if m.survey_question != nil {
		edges = append(edges, surveyanswer.EdgeSurveyQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyAnswerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveyanswer.EdgeSurveyResponse:
		if id := m.survey_response; id != nil {
			return []ent.Value{*id}
		}
	case surveyanswer.EdgeSurveyQuestion:
		if id := m.survey_question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyAnswerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyAnswerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyAnswerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsurvey_response {
		edges = append(edges, surveyanswer.EdgeSurveyResponse)
	}
	if m.clearedsurvey_question {
		edges = append(edges, surveyanswer.EdgeSurveyQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyAnswerMutation) EdgeCleared(name string) bool {
	switch name {
	case surveyanswer.EdgeSurveyResponse:
		return m.clearedsurvey_response
	case surveyanswer.EdgeSurveyQuestion:
		return m.clearedsurvey_question
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyAnswerMutation) ClearEdge(name string) error {
	switch name {
	case surveyanswer.EdgeSurveyResponse:
		m.ClearSurveyResponse()
		return nil
	case surveyanswer.EdgeSurveyQuestion:
		m.ClearSurveyQuestion()
		return nil
	}
	return fmt.Errorf("unknown SurveyAnswer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyAnswerMutation) ResetEdge(name string) error {
	switch name {
	case surveyanswer.EdgeSurveyResponse:
		m.ResetSurveyResponse()
		return nil
	case surveyanswer.EdgeSurveyQuestion:
		m.ResetSurveyQuestion()
		return nil
	}
	return fmt.Errorf("unknown SurveyAnswer edge %s", name)
}

// SurveyQuestionMutation represents an operation that mutates the SurveyQuestion nodes in the graph.
type SurveyQuestionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	text                  *string
	_type                 *enums.SurveyQuestionType
	options               *[]string
	clearedFields         map[string]struct{}
	survey                *int64
	clearedsurvey         bool
	survey_answers        map[int64]struct{}
	removedsurvey_answers map[int64]struct{}
	clearedsurvey_answers bool
	done                  bool
	oldValue              func(context.Context) (*SurveyQuestion, error)
	predicates            []predicate.SurveyQuestion
}

var _ ent.Mutation = (*SurveyQuestionMutation)(nil)

// surveyquestionOption allows management of the mutation configuration using functional options.
type surveyquestionOption func(*SurveyQuestionMutation)

// newSurveyQuestionMutation creates new mutation for the SurveyQuestion entity.
func newSurveyQuestionMutation(c config, op Op, opts ...surveyquestionOption) *SurveyQuestionMutation {
	m := &SurveyQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyQuestionID sets the ID field of the mutation.
func withSurveyQuestionID(id int64) surveyquestionOption {
	return func(m *SurveyQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyQuestion
		)
		m.oldValue = func(ctx context.Context) (*SurveyQuestion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyQuestion sets the old SurveyQuestion of the mutation.
func withSurveyQuestion(node *SurveyQuestion) surveyquestionOption {
	return func(m *SurveyQuestionMutation) {
		m.oldValue = func(context.Context) (*SurveyQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SurveyQuestion entities.
func (m *SurveyQuestionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyQuestionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyQuestionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SurveyQuestion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *SurveyQuestionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SurveyQuestionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *SurveyQuestionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SurveyQuestionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SurveyQuestionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SurveyQuestionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SurveyQuestionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *SurveyQuestionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SurveyQuestionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SurveyQuestionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyQuestionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyQuestionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyQuestionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyQuestionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyQuestionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyQuestionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SurveyQuestionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SurveyQuestionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SurveyQuestionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetSurveyID sets the "survey_id" field.
func (m *SurveyQuestionMutation) SetSurveyID(i int64) {
	m.survey = &i
}

// SurveyID returns the value of the "survey_id" field in the mutation.
func (m *SurveyQuestionMutation) SurveyID() (r int64, exists bool) {
	v := m.survey
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyID returns the old "survey_id" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldSurveyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyID: %w", err)
	}
	return oldValue.SurveyID, nil
}

// ResetSurveyID resets all changes to the "survey_id" field.
func (m *SurveyQuestionMutation) ResetSurveyID() {
	m.survey = nil
}

// SetText sets the "text" field.
func (m *SurveyQuestionMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *SurveyQuestionMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *SurveyQuestionMutation) ResetText() {
	m.text = nil
}

// SetType sets the "type" field.
func (m *SurveyQuestionMutation) SetType(eqt enums.SurveyQuestionType) {
	m._type = &eqt
}

// GetType returns the value of the "type" field in the mutation.
func (m *SurveyQuestionMutation) GetType() (r enums.SurveyQuestionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldType(ctx context.Context) (v enums.SurveyQuestionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SurveyQuestionMutation) ResetType() {
	m._type = nil
}

// SetOptions sets the "options" field.
func (m *SurveyQuestionMutation) SetOptions(s []string) {
	m.options = &s
}

// Options returns the value of the "options" field in the mutation.
func (m *SurveyQuestionMutation) Options() (r []string, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the SurveyQuestion entity.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyQuestionMutation) OldOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// ClearOptions clears the value of the "options" field.
func (m *SurveyQuestionMutation) ClearOptions() {
	m.options = nil
	m.clearedFields[surveyquestion.FieldOptions] = struct{}{}
}

// OptionsCleared returns if the "options" field was cleared in this mutation.
func (m *SurveyQuestionMutation) OptionsCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldOptions]
	return ok
}

// ResetOptions resets all changes to the "options" field.
func (m *SurveyQuestionMutation) ResetOptions() {
	m.options = nil
	delete(m.clearedFields, surveyquestion.FieldOptions)
}

// ClearSurvey clears the "survey" edge to the Survey entity.
func (m *SurveyQuestionMutation) ClearSurvey() {
	m.clearedsurvey = true
	m.clearedFields[surveyquestion.FieldSurveyID] = struct{}{}
}

// SurveyCleared reports if the "survey" edge to the Survey entity was cleared.
func (m *SurveyQuestionMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// SurveyIDs returns the "survey" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *SurveyQuestionMutation) SurveyIDs() (ids []int64) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey resets all changes to the "survey" edge.
func (m *SurveyQuestionMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// AddSurveyAnswerIDs adds the "survey_answers" edge to the SurveyAnswer entity by ids.
func (m *SurveyQuestionMutation) AddSurveyAnswerIDs(ids ...int64) {
	if m.survey_answers == nil {
		m.survey_answers = make(map[int64]struct{})
	}
	for i := range ids {
		m.survey_answers[ids[i]] = struct{}{}
	}
}

// ClearSurveyAnswers clears the "survey_answers" edge to the SurveyAnswer entity.
func (m *SurveyQuestionMutation) ClearSurveyAnswers() {
	m.clearedsurvey_answers = true
}

// SurveyAnswersCleared reports if the "survey_answers" edge to the SurveyAnswer entity was cleared.
func (m *SurveyQuestionMutation) SurveyAnswersCleared() bool {
	return m.clearedsurvey_answers
}

// RemoveSurveyAnswerIDs removes the "survey_answers" edge to the SurveyAnswer entity by IDs.
func (m *SurveyQuestionMutation) RemoveSurveyAnswerIDs(ids ...int64) {
	if m.removedsurvey_answers == nil {
		m.removedsurvey_answers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.survey_answers, ids[i])
		m.removedsurvey_answers[ids[i]] = struct{}{}
	}
}

// RemovedSurveyAnswers returns the removed IDs of the "survey_answers" edge to the SurveyAnswer entity.
func (m *SurveyQuestionMutation) RemovedSurveyAnswersIDs() (ids []int64) {
	for id := range m.removedsurvey_answers {
		ids = append(ids, id)
	}
	return
}

// SurveyAnswersIDs returns the "survey_answers" edge IDs in the mutation.
func (m *SurveyQuestionMutation) SurveyAnswersIDs() (ids []int64) {
	for id := range m.survey_answers {
		ids = append(ids, id)
	}
	return
}

// ResetSurveyAnswers resets all changes to the "survey_answers" edge.
func (m *SurveyQuestionMutation) ResetSurveyAnswers() {
	m.survey_answers = nil
	m.clearedsurvey_answers = false
	m.removedsurvey_answers = nil
}

// Where appends a list predicates to the SurveyQuestionMutation builder.
func (m *SurveyQuestionMutation) Where(ps ...predicate.SurveyQuestion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyQuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyQuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SurveyQuestion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyQuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyQuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SurveyQuestion).
func (m *SurveyQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyQuestionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, surveyquestion.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, surveyquestion.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, surveyquestion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, surveyquestion.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, surveyquestion.FieldDeletedAt)
	}
	if m.survey != nil {
		fields = append(fields, surveyquestion.FieldSurveyID)
	}
	if m.text != nil {
		fields = append(fields, surveyquestion.FieldText)
	}
	if m._type != nil {
		fields = append(fields, surveyquestion.FieldType)
	}
	if m.options != nil {
		fields = append(fields, surveyquestion.FieldOptions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveyquestion.FieldCreatedBy:
		return m.CreatedBy()
	case surveyquestion.FieldUpdatedBy:
		return m.UpdatedBy()
	case surveyquestion.FieldCreatedAt:
		return m.CreatedAt()
	case surveyquestion.FieldUpdatedAt:
		return m.UpdatedAt()
	case surveyquestion.FieldDeletedAt:
		return m.DeletedAt()
	case surveyquestion.FieldSurveyID:
		return m.SurveyID()
	case surveyquestion.FieldText:
		return m.Text()
	case surveyquestion.FieldType:
		return m.GetType()
	case surveyquestion.FieldOptions:
		return m.Options()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveyquestion.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case surveyquestion.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case surveyquestion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case surveyquestion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case surveyquestion.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case surveyquestion.FieldSurveyID:
		return m.OldSurveyID(ctx)
	case surveyquestion.FieldText:
		return m.OldText(ctx)
	case surveyquestion.FieldType:
		return m.OldType(ctx)
	case surveyquestion.FieldOptions:
		return m.OldOptions(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyQuestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveyquestion.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case surveyquestion.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case surveyquestion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case surveyquestion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case surveyquestion.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case surveyquestion.FieldSurveyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyID(v)
		return nil
	case surveyquestion.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case surveyquestion.FieldType:
		v, ok := value.(enums.SurveyQuestionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case surveyquestion.FieldOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyQuestionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, surveyquestion.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, surveyquestion.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyQuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveyquestion.FieldCreatedBy:
		return m.AddedCreatedBy()
	case surveyquestion.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveyquestion.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case surveyquestion.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyQuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(surveyquestion.FieldOptions) {
		fields = append(fields, surveyquestion.FieldOptions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyQuestionMutation) ClearField(name string) error {
	switch name {
	case surveyquestion.FieldOptions:
		m.ClearOptions()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyQuestionMutation) ResetField(name string) error {
	switch name {
	case surveyquestion.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case surveyquestion.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case surveyquestion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case surveyquestion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case surveyquestion.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case surveyquestion.FieldSurveyID:
		m.ResetSurveyID()
		return nil
	case surveyquestion.FieldText:
		m.ResetText()
		return nil
	case surveyquestion.FieldType:
		m.ResetType()
		return nil
	case surveyquestion.FieldOptions:
		m.ResetOptions()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.survey != nil {
		edges = append(edges, surveyquestion.EdgeSurvey)
	}
	if m.survey_answers != nil {
		edges = append(edges, surveyquestion.EdgeSurveyAnswers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveyquestion.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	case surveyquestion.EdgeSurveyAnswers:
		ids := make([]ent.Value, 0, len(m.survey_answers))
		for id := range m.survey_answers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsurvey_answers != nil {
		edges = append(edges, surveyquestion.EdgeSurveyAnswers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case surveyquestion.EdgeSurveyAnswers:
		ids := make([]ent.Value, 0, len(m.removedsurvey_answers))
		for id := range m.removedsurvey_answers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsurvey {
		edges = append(edges, surveyquestion.EdgeSurvey)
	}
	if m.clearedsurvey_answers {
		edges = append(edges, surveyquestion.EdgeSurveyAnswers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case surveyquestion.EdgeSurvey:
		return m.clearedsurvey
	case surveyquestion.EdgeSurveyAnswers:
		return m.clearedsurvey_answers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyQuestionMutation) ClearEdge(name string) error {
	switch name {
	case surveyquestion.EdgeSurvey:
		m.ClearSurvey()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyQuestionMutation) ResetEdge(name string) error {
	switch name {
	case surveyquestion.EdgeSurvey:
		m.ResetSurvey()
		return nil
	case surveyquestion.EdgeSurveyAnswers:
		m.ResetSurveyAnswers()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion edge %s", name)
}

// SurveyResponseMutation represents an operation that mutates the SurveyResponse nodes in the graph.
type SurveyResponseMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	status                *enums.SurveyResponseStatus
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	survey                *int64
	clearedsurvey         bool
	approved_user         *int64
	clearedapproved_user  bool
	survey_answers        map[int64]struct{}
	removedsurvey_answers map[int64]struct{}
	clearedsurvey_answers bool
	done                  bool
	oldValue              func(context.Context) (*SurveyResponse, error)
	predicates            []predicate.SurveyResponse
}

var _ ent.Mutation = (*SurveyResponseMutation)(nil)

// surveyresponseOption allows management of the mutation configuration using functional options.
type surveyresponseOption func(*SurveyResponseMutation)

// newSurveyResponseMutation creates new mutation for the SurveyResponse entity.
func newSurveyResponseMutation(c config, op Op, opts ...surveyresponseOption) *SurveyResponseMutation {
	m := &SurveyResponseMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyResponse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyResponseID sets the ID field of the mutation.
func withSurveyResponseID(id int64) surveyresponseOption {
	return func(m *SurveyResponseMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyResponse
		)
		m.oldValue = func(ctx context.Context) (*SurveyResponse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyResponse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyResponse sets the old SurveyResponse of the mutation.
func withSurveyResponse(node *SurveyResponse) surveyresponseOption {
	return func(m *SurveyResponseMutation) {
		m.oldValue = func(context.Context) (*SurveyResponse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyResponseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyResponseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SurveyResponse entities.
func (m *SurveyResponseMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyResponseMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyResponseMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SurveyResponse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *SurveyResponseMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SurveyResponseMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *SurveyResponseMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SurveyResponseMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SurveyResponseMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SurveyResponseMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SurveyResponseMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *SurveyResponseMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SurveyResponseMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SurveyResponseMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyResponseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyResponseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyResponseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyResponseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyResponseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyResponseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SurveyResponseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SurveyResponseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SurveyResponseMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *SurveyResponseMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SurveyResponseMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SurveyResponseMutation) ResetUserID() {
	m.user = nil
}

// SetSurveyID sets the "survey_id" field.
func (m *SurveyResponseMutation) SetSurveyID(i int64) {
	m.survey = &i
}

// SurveyID returns the value of the "survey_id" field in the mutation.
func (m *SurveyResponseMutation) SurveyID() (r int64, exists bool) {
	v := m.survey
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyID returns the old "survey_id" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldSurveyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyID: %w", err)
	}
	return oldValue.SurveyID, nil
}

// ResetSurveyID resets all changes to the "survey_id" field.
func (m *SurveyResponseMutation) ResetSurveyID() {
	m.survey = nil
}

// SetStatus sets the "status" field.
func (m *SurveyResponseMutation) SetStatus(ers enums.SurveyResponseStatus) {
	m.status = &ers
}

// Status returns the value of the "status" field in the mutation.
func (m *SurveyResponseMutation) Status() (r enums.SurveyResponseStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldStatus(ctx context.Context) (v enums.SurveyResponseStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SurveyResponseMutation) ResetStatus() {
	m.status = nil
}

// SetApprovedBy sets the "approved_by" field.
func (m *SurveyResponseMutation) SetApprovedBy(i int64) {
	m.approved_user = &i
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *SurveyResponseMutation) ApprovedBy() (r int64, exists bool) {
	v := m.approved_user
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the SurveyResponse entity.
// If the SurveyResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyResponseMutation) OldApprovedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *SurveyResponseMutation) ResetApprovedBy() {
	m.approved_user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SurveyResponseMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[surveyresponse.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SurveyResponseMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SurveyResponseMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SurveyResponseMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearSurvey clears the "survey" edge to the Survey entity.
func (m *SurveyResponseMutation) ClearSurvey() {
	m.clearedsurvey = true
	m.clearedFields[surveyresponse.FieldSurveyID] = struct{}{}
}

// SurveyCleared reports if the "survey" edge to the Survey entity was cleared.
func (m *SurveyResponseMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// SurveyIDs returns the "survey" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *SurveyResponseMutation) SurveyIDs() (ids []int64) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey resets all changes to the "survey" edge.
func (m *SurveyResponseMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// SetApprovedUserID sets the "approved_user" edge to the User entity by id.
func (m *SurveyResponseMutation) SetApprovedUserID(id int64) {
	m.approved_user = &id
}

// ClearApprovedUser clears the "approved_user" edge to the User entity.
func (m *SurveyResponseMutation) ClearApprovedUser() {
	m.clearedapproved_user = true
	m.clearedFields[surveyresponse.FieldApprovedBy] = struct{}{}
}

// ApprovedUserCleared reports if the "approved_user" edge to the User entity was cleared.
func (m *SurveyResponseMutation) ApprovedUserCleared() bool {
	return m.clearedapproved_user
}

// ApprovedUserID returns the "approved_user" edge ID in the mutation.
func (m *SurveyResponseMutation) ApprovedUserID() (id int64, exists bool) {
	if m.approved_user != nil {
		return *m.approved_user, true
	}
	return
}

// ApprovedUserIDs returns the "approved_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedUserID instead. It exists only for internal usage by the builders.
func (m *SurveyResponseMutation) ApprovedUserIDs() (ids []int64) {
	if id := m.approved_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedUser resets all changes to the "approved_user" edge.
func (m *SurveyResponseMutation) ResetApprovedUser() {
	m.approved_user = nil
	m.clearedapproved_user = false
}

// AddSurveyAnswerIDs adds the "survey_answers" edge to the SurveyAnswer entity by ids.
func (m *SurveyResponseMutation) AddSurveyAnswerIDs(ids ...int64) {
	if m.survey_answers == nil {
		m.survey_answers = make(map[int64]struct{})
	}
	for i := range ids {
		m.survey_answers[ids[i]] = struct{}{}
	}
}

// ClearSurveyAnswers clears the "survey_answers" edge to the SurveyAnswer entity.
func (m *SurveyResponseMutation) ClearSurveyAnswers() {
	m.clearedsurvey_answers = true
}

// SurveyAnswersCleared reports if the "survey_answers" edge to the SurveyAnswer entity was cleared.
func (m *SurveyResponseMutation) SurveyAnswersCleared() bool {
	return m.clearedsurvey_answers
}

// RemoveSurveyAnswerIDs removes the "survey_answers" edge to the SurveyAnswer entity by IDs.
func (m *SurveyResponseMutation) RemoveSurveyAnswerIDs(ids ...int64) {
	if m.removedsurvey_answers == nil {
		m.removedsurvey_answers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.survey_answers, ids[i])
		m.removedsurvey_answers[ids[i]] = struct{}{}
	}
}

// RemovedSurveyAnswers returns the removed IDs of the "survey_answers" edge to the SurveyAnswer entity.
func (m *SurveyResponseMutation) RemovedSurveyAnswersIDs() (ids []int64) {
	for id := range m.removedsurvey_answers {
		ids = append(ids, id)
	}
	return
}

// SurveyAnswersIDs returns the "survey_answers" edge IDs in the mutation.
func (m *SurveyResponseMutation) SurveyAnswersIDs() (ids []int64) {
	for id := range m.survey_answers {
		ids = append(ids, id)
	}
	return
}

// ResetSurveyAnswers resets all changes to the "survey_answers" edge.
func (m *SurveyResponseMutation) ResetSurveyAnswers() {
	m.survey_answers = nil
	m.clearedsurvey_answers = false
	m.removedsurvey_answers = nil
}

// Where appends a list predicates to the SurveyResponseMutation builder.
func (m *SurveyResponseMutation) Where(ps ...predicate.SurveyResponse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyResponseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyResponseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SurveyResponse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyResponseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyResponseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SurveyResponse).
func (m *SurveyResponseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyResponseMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, surveyresponse.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, surveyresponse.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, surveyresponse.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, surveyresponse.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, surveyresponse.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, surveyresponse.FieldUserID)
	}
	if m.survey != nil {
		fields = append(fields, surveyresponse.FieldSurveyID)
	}
	if m.status != nil {
		fields = append(fields, surveyresponse.FieldStatus)
	}
	if m.approved_user != nil {
		fields = append(fields, surveyresponse.FieldApprovedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyResponseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveyresponse.FieldCreatedBy:
		return m.CreatedBy()
	case surveyresponse.FieldUpdatedBy:
		return m.UpdatedBy()
	case surveyresponse.FieldCreatedAt:
		return m.CreatedAt()
	case surveyresponse.FieldUpdatedAt:
		return m.UpdatedAt()
	case surveyresponse.FieldDeletedAt:
		return m.DeletedAt()
	case surveyresponse.FieldUserID:
		return m.UserID()
	case surveyresponse.FieldSurveyID:
		return m.SurveyID()
	case surveyresponse.FieldStatus:
		return m.Status()
	case surveyresponse.FieldApprovedBy:
		return m.ApprovedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyResponseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveyresponse.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case surveyresponse.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case surveyresponse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case surveyresponse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case surveyresponse.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case surveyresponse.FieldUserID:
		return m.OldUserID(ctx)
	case surveyresponse.FieldSurveyID:
		return m.OldSurveyID(ctx)
	case surveyresponse.FieldStatus:
		return m.OldStatus(ctx)
	case surveyresponse.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyResponse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyResponseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveyresponse.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case surveyresponse.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case surveyresponse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case surveyresponse.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case surveyresponse.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case surveyresponse.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case surveyresponse.FieldSurveyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyID(v)
		return nil
	case surveyresponse.FieldStatus:
		v, ok := value.(enums.SurveyResponseStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case surveyresponse.FieldApprovedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyResponse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyResponseMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, surveyresponse.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, surveyresponse.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyResponseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveyresponse.FieldCreatedBy:
		return m.AddedCreatedBy()
	case surveyresponse.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyResponseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveyresponse.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case surveyresponse.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyResponse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyResponseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyResponseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyResponseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SurveyResponse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyResponseMutation) ResetField(name string) error {
	switch name {
	case surveyresponse.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case surveyresponse.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case surveyresponse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case surveyresponse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case surveyresponse.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case surveyresponse.FieldUserID:
		m.ResetUserID()
		return nil
	case surveyresponse.FieldSurveyID:
		m.ResetSurveyID()
		return nil
	case surveyresponse.FieldStatus:
		m.ResetStatus()
		return nil
	case surveyresponse.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown SurveyResponse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyResponseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, surveyresponse.EdgeUser)
	}
	if m.survey != nil {
		edges = append(edges, surveyresponse.EdgeSurvey)
	}
	if m.approved_user != nil {
		edges = append(edges, surveyresponse.EdgeApprovedUser)
	}
	if m.survey_answers != nil {
		edges = append(edges, surveyresponse.EdgeSurveyAnswers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyResponseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveyresponse.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case surveyresponse.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	case surveyresponse.EdgeApprovedUser:
		if id := m.approved_user; id != nil {
			return []ent.Value{*id}
		}
	case surveyresponse.EdgeSurveyAnswers:
		ids := make([]ent.Value, 0, len(m.survey_answers))
		for id := range m.survey_answers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyResponseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsurvey_answers != nil {
		edges = append(edges, surveyresponse.EdgeSurveyAnswers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyResponseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case surveyresponse.EdgeSurveyAnswers:
		ids := make([]ent.Value, 0, len(m.removedsurvey_answers))
		for id := range m.removedsurvey_answers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyResponseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, surveyresponse.EdgeUser)
	}
	if m.clearedsurvey {
		edges = append(edges, surveyresponse.EdgeSurvey)
	}
	if m.clearedapproved_user {
		edges = append(edges, surveyresponse.EdgeApprovedUser)
	}
	if m.clearedsurvey_answers {
		edges = append(edges, surveyresponse.EdgeSurveyAnswers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyResponseMutation) EdgeCleared(name string) bool {
	switch name {
	case surveyresponse.EdgeUser:
		return m.cleareduser
	case surveyresponse.EdgeSurvey:
		return m.clearedsurvey
	case surveyresponse.EdgeApprovedUser:
		return m.clearedapproved_user
	case surveyresponse.EdgeSurveyAnswers:
		return m.clearedsurvey_answers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyResponseMutation) ClearEdge(name string) error {
	switch name {
	case surveyresponse.EdgeUser:
		m.ClearUser()
		return nil
	case surveyresponse.EdgeSurvey:
		m.ClearSurvey()
		return nil
	case surveyresponse.EdgeApprovedUser:
		m.ClearApprovedUser()
		return nil
	}
	return fmt.Errorf("unknown SurveyResponse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyResponseMutation) ResetEdge(name string) error {
	switch name {
	case surveyresponse.EdgeUser:
		m.ResetUser()
		return nil
	case surveyresponse.EdgeSurvey:
		m.ResetSurvey()
		return nil
	case surveyresponse.EdgeApprovedUser:
		m.ResetApprovedUser()
		return nil
	case surveyresponse.EdgeSurveyAnswers:
		m.ResetSurveyAnswers()
		return nil
	}
	return fmt.Errorf("unknown SurveyResponse edge %s", name)
}

// SymbolMutation represents an operation that mutates the Symbol nodes in the graph.
type SymbolMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	name                       *string
	clearedFields              map[string]struct{}
	wallets                    map[int64]struct{}
	removedwallets             map[int64]struct{}
	clearedwallets             bool
	bills                      map[int64]struct{}
	removedbills               map[int64]struct{}
	clearedbills               bool
	income_bills               map[int64]struct{}
	removedincome_bills        map[int64]struct{}
	clearedincome_bills        bool
	mission_orders             map[int64]struct{}
	removedmission_orders      map[int64]struct{}
	clearedmission_orders      bool
	transfer_orders            map[int64]struct{}
	removedtransfer_orders     map[int64]struct{}
	clearedtransfer_orders     bool
	extra_service_order        map[int64]struct{}
	removedextra_service_order map[int64]struct{}
	clearedextra_service_order bool
	done                       bool
	oldValue                   func(context.Context) (*Symbol, error)
	predicates                 []predicate.Symbol
}

var _ ent.Mutation = (*SymbolMutation)(nil)

// symbolOption allows management of the mutation configuration using functional options.
type symbolOption func(*SymbolMutation)

// newSymbolMutation creates new mutation for the Symbol entity.
func newSymbolMutation(c config, op Op, opts ...symbolOption) *SymbolMutation {
	m := &SymbolMutation{
		config:        c,
		op:            op,
		typ:           TypeSymbol,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSymbolID sets the ID field of the mutation.
func withSymbolID(id int64) symbolOption {
	return func(m *SymbolMutation) {
		var (
			err   error
			once  sync.Once
			value *Symbol
		)
		m.oldValue = func(ctx context.Context) (*Symbol, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Symbol.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSymbol sets the old Symbol of the mutation.
func withSymbol(node *Symbol) symbolOption {
	return func(m *SymbolMutation) {
		m.oldValue = func(context.Context) (*Symbol, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SymbolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SymbolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Symbol entities.
func (m *SymbolMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SymbolMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SymbolMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Symbol.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *SymbolMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SymbolMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *SymbolMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SymbolMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SymbolMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SymbolMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SymbolMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *SymbolMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SymbolMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SymbolMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SymbolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SymbolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SymbolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SymbolMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SymbolMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SymbolMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SymbolMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SymbolMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SymbolMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *SymbolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SymbolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SymbolMutation) ResetName() {
	m.name = nil
}

// AddWalletIDs adds the "wallets" edge to the Wallet entity by ids.
func (m *SymbolMutation) AddWalletIDs(ids ...int64) {
	if m.wallets == nil {
		m.wallets = make(map[int64]struct{})
	}
	for i := range ids {
		m.wallets[ids[i]] = struct{}{}
	}
}

// ClearWallets clears the "wallets" edge to the Wallet entity.
func (m *SymbolMutation) ClearWallets() {
	m.clearedwallets = true
}

// WalletsCleared reports if the "wallets" edge to the Wallet entity was cleared.
func (m *SymbolMutation) WalletsCleared() bool {
	return m.clearedwallets
}

// RemoveWalletIDs removes the "wallets" edge to the Wallet entity by IDs.
func (m *SymbolMutation) RemoveWalletIDs(ids ...int64) {
	if m.removedwallets == nil {
		m.removedwallets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.wallets, ids[i])
		m.removedwallets[ids[i]] = struct{}{}
	}
}

// RemovedWallets returns the removed IDs of the "wallets" edge to the Wallet entity.
func (m *SymbolMutation) RemovedWalletsIDs() (ids []int64) {
	for id := range m.removedwallets {
		ids = append(ids, id)
	}
	return
}

// WalletsIDs returns the "wallets" edge IDs in the mutation.
func (m *SymbolMutation) WalletsIDs() (ids []int64) {
	for id := range m.wallets {
		ids = append(ids, id)
	}
	return
}

// ResetWallets resets all changes to the "wallets" edge.
func (m *SymbolMutation) ResetWallets() {
	m.wallets = nil
	m.clearedwallets = false
	m.removedwallets = nil
}

// AddBillIDs adds the "bills" edge to the Bill entity by ids.
func (m *SymbolMutation) AddBillIDs(ids ...int64) {
	if m.bills == nil {
		m.bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the Bill entity.
func (m *SymbolMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the Bill entity was cleared.
func (m *SymbolMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the Bill entity by IDs.
func (m *SymbolMutation) RemoveBillIDs(ids ...int64) {
	if m.removedbills == nil {
		m.removedbills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the Bill entity.
func (m *SymbolMutation) RemovedBillsIDs() (ids []int64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *SymbolMutation) BillsIDs() (ids []int64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *SymbolMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// AddIncomeBillIDs adds the "income_bills" edge to the Bill entity by ids.
func (m *SymbolMutation) AddIncomeBillIDs(ids ...int64) {
	if m.income_bills == nil {
		m.income_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.income_bills[ids[i]] = struct{}{}
	}
}

// ClearIncomeBills clears the "income_bills" edge to the Bill entity.
func (m *SymbolMutation) ClearIncomeBills() {
	m.clearedincome_bills = true
}

// IncomeBillsCleared reports if the "income_bills" edge to the Bill entity was cleared.
func (m *SymbolMutation) IncomeBillsCleared() bool {
	return m.clearedincome_bills
}

// RemoveIncomeBillIDs removes the "income_bills" edge to the Bill entity by IDs.
func (m *SymbolMutation) RemoveIncomeBillIDs(ids ...int64) {
	if m.removedincome_bills == nil {
		m.removedincome_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.income_bills, ids[i])
		m.removedincome_bills[ids[i]] = struct{}{}
	}
}

// RemovedIncomeBills returns the removed IDs of the "income_bills" edge to the Bill entity.
func (m *SymbolMutation) RemovedIncomeBillsIDs() (ids []int64) {
	for id := range m.removedincome_bills {
		ids = append(ids, id)
	}
	return
}

// IncomeBillsIDs returns the "income_bills" edge IDs in the mutation.
func (m *SymbolMutation) IncomeBillsIDs() (ids []int64) {
	for id := range m.income_bills {
		ids = append(ids, id)
	}
	return
}

// ResetIncomeBills resets all changes to the "income_bills" edge.
func (m *SymbolMutation) ResetIncomeBills() {
	m.income_bills = nil
	m.clearedincome_bills = false
	m.removedincome_bills = nil
}

// AddMissionOrderIDs adds the "mission_orders" edge to the MissionOrder entity by ids.
func (m *SymbolMutation) AddMissionOrderIDs(ids ...int64) {
	if m.mission_orders == nil {
		m.mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionOrders clears the "mission_orders" edge to the MissionOrder entity.
func (m *SymbolMutation) ClearMissionOrders() {
	m.clearedmission_orders = true
}

// MissionOrdersCleared reports if the "mission_orders" edge to the MissionOrder entity was cleared.
func (m *SymbolMutation) MissionOrdersCleared() bool {
	return m.clearedmission_orders
}

// RemoveMissionOrderIDs removes the "mission_orders" edge to the MissionOrder entity by IDs.
func (m *SymbolMutation) RemoveMissionOrderIDs(ids ...int64) {
	if m.removedmission_orders == nil {
		m.removedmission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_orders, ids[i])
		m.removedmission_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionOrders returns the removed IDs of the "mission_orders" edge to the MissionOrder entity.
func (m *SymbolMutation) RemovedMissionOrdersIDs() (ids []int64) {
	for id := range m.removedmission_orders {
		ids = append(ids, id)
	}
	return
}

// MissionOrdersIDs returns the "mission_orders" edge IDs in the mutation.
func (m *SymbolMutation) MissionOrdersIDs() (ids []int64) {
	for id := range m.mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionOrders resets all changes to the "mission_orders" edge.
func (m *SymbolMutation) ResetMissionOrders() {
	m.mission_orders = nil
	m.clearedmission_orders = false
	m.removedmission_orders = nil
}

// AddTransferOrderIDs adds the "transfer_orders" edge to the TransferOrder entity by ids.
func (m *SymbolMutation) AddTransferOrderIDs(ids ...int64) {
	if m.transfer_orders == nil {
		m.transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.transfer_orders[ids[i]] = struct{}{}
	}
}

// ClearTransferOrders clears the "transfer_orders" edge to the TransferOrder entity.
func (m *SymbolMutation) ClearTransferOrders() {
	m.clearedtransfer_orders = true
}

// TransferOrdersCleared reports if the "transfer_orders" edge to the TransferOrder entity was cleared.
func (m *SymbolMutation) TransferOrdersCleared() bool {
	return m.clearedtransfer_orders
}

// RemoveTransferOrderIDs removes the "transfer_orders" edge to the TransferOrder entity by IDs.
func (m *SymbolMutation) RemoveTransferOrderIDs(ids ...int64) {
	if m.removedtransfer_orders == nil {
		m.removedtransfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.transfer_orders, ids[i])
		m.removedtransfer_orders[ids[i]] = struct{}{}
	}
}

// RemovedTransferOrders returns the removed IDs of the "transfer_orders" edge to the TransferOrder entity.
func (m *SymbolMutation) RemovedTransferOrdersIDs() (ids []int64) {
	for id := range m.removedtransfer_orders {
		ids = append(ids, id)
	}
	return
}

// TransferOrdersIDs returns the "transfer_orders" edge IDs in the mutation.
func (m *SymbolMutation) TransferOrdersIDs() (ids []int64) {
	for id := range m.transfer_orders {
		ids = append(ids, id)
	}
	return
}

// ResetTransferOrders resets all changes to the "transfer_orders" edge.
func (m *SymbolMutation) ResetTransferOrders() {
	m.transfer_orders = nil
	m.clearedtransfer_orders = false
	m.removedtransfer_orders = nil
}

// AddExtraServiceOrderIDs adds the "extra_service_order" edge to the ExtraServiceOrder entity by ids.
func (m *SymbolMutation) AddExtraServiceOrderIDs(ids ...int64) {
	if m.extra_service_order == nil {
		m.extra_service_order = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_order[ids[i]] = struct{}{}
	}
}

// ClearExtraServiceOrder clears the "extra_service_order" edge to the ExtraServiceOrder entity.
func (m *SymbolMutation) ClearExtraServiceOrder() {
	m.clearedextra_service_order = true
}

// ExtraServiceOrderCleared reports if the "extra_service_order" edge to the ExtraServiceOrder entity was cleared.
func (m *SymbolMutation) ExtraServiceOrderCleared() bool {
	return m.clearedextra_service_order
}

// RemoveExtraServiceOrderIDs removes the "extra_service_order" edge to the ExtraServiceOrder entity by IDs.
func (m *SymbolMutation) RemoveExtraServiceOrderIDs(ids ...int64) {
	if m.removedextra_service_order == nil {
		m.removedextra_service_order = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_order, ids[i])
		m.removedextra_service_order[ids[i]] = struct{}{}
	}
}

// RemovedExtraServiceOrder returns the removed IDs of the "extra_service_order" edge to the ExtraServiceOrder entity.
func (m *SymbolMutation) RemovedExtraServiceOrderIDs() (ids []int64) {
	for id := range m.removedextra_service_order {
		ids = append(ids, id)
	}
	return
}

// ExtraServiceOrderIDs returns the "extra_service_order" edge IDs in the mutation.
func (m *SymbolMutation) ExtraServiceOrderIDs() (ids []int64) {
	for id := range m.extra_service_order {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServiceOrder resets all changes to the "extra_service_order" edge.
func (m *SymbolMutation) ResetExtraServiceOrder() {
	m.extra_service_order = nil
	m.clearedextra_service_order = false
	m.removedextra_service_order = nil
}

// Where appends a list predicates to the SymbolMutation builder.
func (m *SymbolMutation) Where(ps ...predicate.Symbol) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SymbolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SymbolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Symbol, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SymbolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SymbolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Symbol).
func (m *SymbolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SymbolMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_by != nil {
		fields = append(fields, symbol.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, symbol.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, symbol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, symbol.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, symbol.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, symbol.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SymbolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case symbol.FieldCreatedBy:
		return m.CreatedBy()
	case symbol.FieldUpdatedBy:
		return m.UpdatedBy()
	case symbol.FieldCreatedAt:
		return m.CreatedAt()
	case symbol.FieldUpdatedAt:
		return m.UpdatedAt()
	case symbol.FieldDeletedAt:
		return m.DeletedAt()
	case symbol.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SymbolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case symbol.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case symbol.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case symbol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case symbol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case symbol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case symbol.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Symbol field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SymbolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case symbol.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case symbol.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case symbol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case symbol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case symbol.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case symbol.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Symbol field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SymbolMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, symbol.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, symbol.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SymbolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case symbol.FieldCreatedBy:
		return m.AddedCreatedBy()
	case symbol.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SymbolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case symbol.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case symbol.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Symbol numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SymbolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SymbolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SymbolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Symbol nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SymbolMutation) ResetField(name string) error {
	switch name {
	case symbol.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case symbol.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case symbol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case symbol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case symbol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case symbol.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Symbol field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SymbolMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.wallets != nil {
		edges = append(edges, symbol.EdgeWallets)
	}
	if m.bills != nil {
		edges = append(edges, symbol.EdgeBills)
	}
	if m.income_bills != nil {
		edges = append(edges, symbol.EdgeIncomeBills)
	}
	if m.mission_orders != nil {
		edges = append(edges, symbol.EdgeMissionOrders)
	}
	if m.transfer_orders != nil {
		edges = append(edges, symbol.EdgeTransferOrders)
	}
	if m.extra_service_order != nil {
		edges = append(edges, symbol.EdgeExtraServiceOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SymbolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case symbol.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.wallets))
		for id := range m.wallets {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeIncomeBills:
		ids := make([]ent.Value, 0, len(m.income_bills))
		for id := range m.income_bills {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.mission_orders))
		for id := range m.mission_orders {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeTransferOrders:
		ids := make([]ent.Value, 0, len(m.transfer_orders))
		for id := range m.transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeExtraServiceOrder:
		ids := make([]ent.Value, 0, len(m.extra_service_order))
		for id := range m.extra_service_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SymbolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedwallets != nil {
		edges = append(edges, symbol.EdgeWallets)
	}
	if m.removedbills != nil {
		edges = append(edges, symbol.EdgeBills)
	}
	if m.removedincome_bills != nil {
		edges = append(edges, symbol.EdgeIncomeBills)
	}
	if m.removedmission_orders != nil {
		edges = append(edges, symbol.EdgeMissionOrders)
	}
	if m.removedtransfer_orders != nil {
		edges = append(edges, symbol.EdgeTransferOrders)
	}
	if m.removedextra_service_order != nil {
		edges = append(edges, symbol.EdgeExtraServiceOrder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SymbolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case symbol.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.removedwallets))
		for id := range m.removedwallets {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeIncomeBills:
		ids := make([]ent.Value, 0, len(m.removedincome_bills))
		for id := range m.removedincome_bills {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_orders))
		for id := range m.removedmission_orders {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeTransferOrders:
		ids := make([]ent.Value, 0, len(m.removedtransfer_orders))
		for id := range m.removedtransfer_orders {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeExtraServiceOrder:
		ids := make([]ent.Value, 0, len(m.removedextra_service_order))
		for id := range m.removedextra_service_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SymbolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedwallets {
		edges = append(edges, symbol.EdgeWallets)
	}
	if m.clearedbills {
		edges = append(edges, symbol.EdgeBills)
	}
	if m.clearedincome_bills {
		edges = append(edges, symbol.EdgeIncomeBills)
	}
	if m.clearedmission_orders {
		edges = append(edges, symbol.EdgeMissionOrders)
	}
	if m.clearedtransfer_orders {
		edges = append(edges, symbol.EdgeTransferOrders)
	}
	if m.clearedextra_service_order {
		edges = append(edges, symbol.EdgeExtraServiceOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SymbolMutation) EdgeCleared(name string) bool {
	switch name {
	case symbol.EdgeWallets:
		return m.clearedwallets
	case symbol.EdgeBills:
		return m.clearedbills
	case symbol.EdgeIncomeBills:
		return m.clearedincome_bills
	case symbol.EdgeMissionOrders:
		return m.clearedmission_orders
	case symbol.EdgeTransferOrders:
		return m.clearedtransfer_orders
	case symbol.EdgeExtraServiceOrder:
		return m.clearedextra_service_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SymbolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Symbol unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SymbolMutation) ResetEdge(name string) error {
	switch name {
	case symbol.EdgeWallets:
		m.ResetWallets()
		return nil
	case symbol.EdgeBills:
		m.ResetBills()
		return nil
	case symbol.EdgeIncomeBills:
		m.ResetIncomeBills()
		return nil
	case symbol.EdgeMissionOrders:
		m.ResetMissionOrders()
		return nil
	case symbol.EdgeTransferOrders:
		m.ResetTransferOrders()
		return nil
	case symbol.EdgeExtraServiceOrder:
		m.ResetExtraServiceOrder()
		return nil
	}
	return fmt.Errorf("unknown Symbol edge %s", name)
}

// TransferOrderMutation represents an operation that mutates the TransferOrder nodes in the graph.
type TransferOrderMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_by             *int64
	addcreated_by          *int64
	updated_by             *int64
	addupdated_by          *int64
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	status                 *transferorder.Status
	amount                 *int64
	addamount              *int64
	_type                  *enums.TransferOrderType
	serial_number          *string
	third_api_resp         *string
	out_transaction_id     *string
	operate_user_id        *int64
	addoperate_user_id     *int64
	gift_type              *enums.TransferOrderGiftType
	clearedFields          map[string]struct{}
	source_user            *int64
	clearedsource_user     bool
	target_user            *int64
	clearedtarget_user     bool
	bills                  map[int64]struct{}
	removedbills           map[int64]struct{}
	clearedbills           bool
	vx_social              *int64
	clearedvx_social       bool
	symbol                 *int64
	clearedsymbol          bool
	withdraw_record        *int64
	clearedwithdraw_record bool
	done                   bool
	oldValue               func(context.Context) (*TransferOrder, error)
	predicates             []predicate.TransferOrder
}

var _ ent.Mutation = (*TransferOrderMutation)(nil)

// transferorderOption allows management of the mutation configuration using functional options.
type transferorderOption func(*TransferOrderMutation)

// newTransferOrderMutation creates new mutation for the TransferOrder entity.
func newTransferOrderMutation(c config, op Op, opts ...transferorderOption) *TransferOrderMutation {
	m := &TransferOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeTransferOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferOrderID sets the ID field of the mutation.
func withTransferOrderID(id int64) transferorderOption {
	return func(m *TransferOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *TransferOrder
		)
		m.oldValue = func(ctx context.Context) (*TransferOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransferOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransferOrder sets the old TransferOrder of the mutation.
func withTransferOrder(node *TransferOrder) transferorderOption {
	return func(m *TransferOrderMutation) {
		m.oldValue = func(context.Context) (*TransferOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransferOrder entities.
func (m *TransferOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransferOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *TransferOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TransferOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TransferOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TransferOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TransferOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TransferOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TransferOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TransferOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TransferOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TransferOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TransferOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransferOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransferOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransferOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransferOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransferOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransferOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransferOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransferOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetSourceUserID sets the "source_user_id" field.
func (m *TransferOrderMutation) SetSourceUserID(i int64) {
	m.source_user = &i
}

// SourceUserID returns the value of the "source_user_id" field in the mutation.
func (m *TransferOrderMutation) SourceUserID() (r int64, exists bool) {
	v := m.source_user
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceUserID returns the old "source_user_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldSourceUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceUserID: %w", err)
	}
	return oldValue.SourceUserID, nil
}

// ResetSourceUserID resets all changes to the "source_user_id" field.
func (m *TransferOrderMutation) ResetSourceUserID() {
	m.source_user = nil
}

// SetTargetUserID sets the "target_user_id" field.
func (m *TransferOrderMutation) SetTargetUserID(i int64) {
	m.target_user = &i
}

// TargetUserID returns the value of the "target_user_id" field in the mutation.
func (m *TransferOrderMutation) TargetUserID() (r int64, exists bool) {
	v := m.target_user
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetUserID returns the old "target_user_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldTargetUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetUserID: %w", err)
	}
	return oldValue.TargetUserID, nil
}

// ResetTargetUserID resets all changes to the "target_user_id" field.
func (m *TransferOrderMutation) ResetTargetUserID() {
	m.target_user = nil
}

// SetStatus sets the "status" field.
func (m *TransferOrderMutation) SetStatus(t transferorder.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TransferOrderMutation) Status() (r transferorder.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldStatus(ctx context.Context) (v transferorder.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransferOrderMutation) ResetStatus() {
	m.status = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *TransferOrderMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *TransferOrderMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *TransferOrderMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetAmount sets the "amount" field.
func (m *TransferOrderMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransferOrderMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TransferOrderMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransferOrderMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransferOrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetType sets the "type" field.
func (m *TransferOrderMutation) SetType(eot enums.TransferOrderType) {
	m._type = &eot
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransferOrderMutation) GetType() (r enums.TransferOrderType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldType(ctx context.Context) (v enums.TransferOrderType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransferOrderMutation) ResetType() {
	m._type = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *TransferOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *TransferOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *TransferOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetSocialID sets the "social_id" field.
func (m *TransferOrderMutation) SetSocialID(i int64) {
	m.vx_social = &i
}

// SocialID returns the value of the "social_id" field in the mutation.
func (m *TransferOrderMutation) SocialID() (r int64, exists bool) {
	v := m.vx_social
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialID returns the old "social_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldSocialID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialID: %w", err)
	}
	return oldValue.SocialID, nil
}

// ClearSocialID clears the value of the "social_id" field.
func (m *TransferOrderMutation) ClearSocialID() {
	m.vx_social = nil
	m.clearedFields[transferorder.FieldSocialID] = struct{}{}
}

// SocialIDCleared returns if the "social_id" field was cleared in this mutation.
func (m *TransferOrderMutation) SocialIDCleared() bool {
	_, ok := m.clearedFields[transferorder.FieldSocialID]
	return ok
}

// ResetSocialID resets all changes to the "social_id" field.
func (m *TransferOrderMutation) ResetSocialID() {
	m.vx_social = nil
	delete(m.clearedFields, transferorder.FieldSocialID)
}

// SetThirdAPIResp sets the "third_api_resp" field.
func (m *TransferOrderMutation) SetThirdAPIResp(s string) {
	m.third_api_resp = &s
}

// ThirdAPIResp returns the value of the "third_api_resp" field in the mutation.
func (m *TransferOrderMutation) ThirdAPIResp() (r string, exists bool) {
	v := m.third_api_resp
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdAPIResp returns the old "third_api_resp" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldThirdAPIResp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdAPIResp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdAPIResp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdAPIResp: %w", err)
	}
	return oldValue.ThirdAPIResp, nil
}

// ResetThirdAPIResp resets all changes to the "third_api_resp" field.
func (m *TransferOrderMutation) ResetThirdAPIResp() {
	m.third_api_resp = nil
}

// SetOutTransactionID sets the "out_transaction_id" field.
func (m *TransferOrderMutation) SetOutTransactionID(s string) {
	m.out_transaction_id = &s
}

// OutTransactionID returns the value of the "out_transaction_id" field in the mutation.
func (m *TransferOrderMutation) OutTransactionID() (r string, exists bool) {
	v := m.out_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTransactionID returns the old "out_transaction_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldOutTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTransactionID: %w", err)
	}
	return oldValue.OutTransactionID, nil
}

// ResetOutTransactionID resets all changes to the "out_transaction_id" field.
func (m *TransferOrderMutation) ResetOutTransactionID() {
	m.out_transaction_id = nil
}

// SetOperateUserID sets the "operate_user_id" field.
func (m *TransferOrderMutation) SetOperateUserID(i int64) {
	m.operate_user_id = &i
	m.addoperate_user_id = nil
}

// OperateUserID returns the value of the "operate_user_id" field in the mutation.
func (m *TransferOrderMutation) OperateUserID() (r int64, exists bool) {
	v := m.operate_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperateUserID returns the old "operate_user_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldOperateUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperateUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperateUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperateUserID: %w", err)
	}
	return oldValue.OperateUserID, nil
}

// AddOperateUserID adds i to the "operate_user_id" field.
func (m *TransferOrderMutation) AddOperateUserID(i int64) {
	if m.addoperate_user_id != nil {
		*m.addoperate_user_id += i
	} else {
		m.addoperate_user_id = &i
	}
}

// AddedOperateUserID returns the value that was added to the "operate_user_id" field in this mutation.
func (m *TransferOrderMutation) AddedOperateUserID() (r int64, exists bool) {
	v := m.addoperate_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperateUserID resets all changes to the "operate_user_id" field.
func (m *TransferOrderMutation) ResetOperateUserID() {
	m.operate_user_id = nil
	m.addoperate_user_id = nil
}

// SetGiftType sets the "gift_type" field.
func (m *TransferOrderMutation) SetGiftType(eogt enums.TransferOrderGiftType) {
	m.gift_type = &eogt
}

// GiftType returns the value of the "gift_type" field in the mutation.
func (m *TransferOrderMutation) GiftType() (r enums.TransferOrderGiftType, exists bool) {
	v := m.gift_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftType returns the old "gift_type" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldGiftType(ctx context.Context) (v enums.TransferOrderGiftType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftType: %w", err)
	}
	return oldValue.GiftType, nil
}

// ResetGiftType resets all changes to the "gift_type" field.
func (m *TransferOrderMutation) ResetGiftType() {
	m.gift_type = nil
}

// ClearSourceUser clears the "source_user" edge to the User entity.
func (m *TransferOrderMutation) ClearSourceUser() {
	m.clearedsource_user = true
	m.clearedFields[transferorder.FieldSourceUserID] = struct{}{}
}

// SourceUserCleared reports if the "source_user" edge to the User entity was cleared.
func (m *TransferOrderMutation) SourceUserCleared() bool {
	return m.clearedsource_user
}

// SourceUserIDs returns the "source_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceUserID instead. It exists only for internal usage by the builders.
func (m *TransferOrderMutation) SourceUserIDs() (ids []int64) {
	if id := m.source_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceUser resets all changes to the "source_user" edge.
func (m *TransferOrderMutation) ResetSourceUser() {
	m.source_user = nil
	m.clearedsource_user = false
}

// ClearTargetUser clears the "target_user" edge to the User entity.
func (m *TransferOrderMutation) ClearTargetUser() {
	m.clearedtarget_user = true
	m.clearedFields[transferorder.FieldTargetUserID] = struct{}{}
}

// TargetUserCleared reports if the "target_user" edge to the User entity was cleared.
func (m *TransferOrderMutation) TargetUserCleared() bool {
	return m.clearedtarget_user
}

// TargetUserIDs returns the "target_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetUserID instead. It exists only for internal usage by the builders.
func (m *TransferOrderMutation) TargetUserIDs() (ids []int64) {
	if id := m.target_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetUser resets all changes to the "target_user" edge.
func (m *TransferOrderMutation) ResetTargetUser() {
	m.target_user = nil
	m.clearedtarget_user = false
}

// AddBillIDs adds the "bills" edge to the Bill entity by ids.
func (m *TransferOrderMutation) AddBillIDs(ids ...int64) {
	if m.bills == nil {
		m.bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the Bill entity.
func (m *TransferOrderMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the Bill entity was cleared.
func (m *TransferOrderMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the Bill entity by IDs.
func (m *TransferOrderMutation) RemoveBillIDs(ids ...int64) {
	if m.removedbills == nil {
		m.removedbills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the Bill entity.
func (m *TransferOrderMutation) RemovedBillsIDs() (ids []int64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *TransferOrderMutation) BillsIDs() (ids []int64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *TransferOrderMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// SetVxSocialID sets the "vx_social" edge to the VXSocial entity by id.
func (m *TransferOrderMutation) SetVxSocialID(id int64) {
	m.vx_social = &id
}

// ClearVxSocial clears the "vx_social" edge to the VXSocial entity.
func (m *TransferOrderMutation) ClearVxSocial() {
	m.clearedvx_social = true
	m.clearedFields[transferorder.FieldSocialID] = struct{}{}
}

// VxSocialCleared reports if the "vx_social" edge to the VXSocial entity was cleared.
func (m *TransferOrderMutation) VxSocialCleared() bool {
	return m.SocialIDCleared() || m.clearedvx_social
}

// VxSocialID returns the "vx_social" edge ID in the mutation.
func (m *TransferOrderMutation) VxSocialID() (id int64, exists bool) {
	if m.vx_social != nil {
		return *m.vx_social, true
	}
	return
}

// VxSocialIDs returns the "vx_social" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VxSocialID instead. It exists only for internal usage by the builders.
func (m *TransferOrderMutation) VxSocialIDs() (ids []int64) {
	if id := m.vx_social; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVxSocial resets all changes to the "vx_social" edge.
func (m *TransferOrderMutation) ResetVxSocial() {
	m.vx_social = nil
	m.clearedvx_social = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *TransferOrderMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[transferorder.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *TransferOrderMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *TransferOrderMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *TransferOrderMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// SetWithdrawRecordID sets the "withdraw_record" edge to the WithdrawRecord entity by id.
func (m *TransferOrderMutation) SetWithdrawRecordID(id int64) {
	m.withdraw_record = &id
}

// ClearWithdrawRecord clears the "withdraw_record" edge to the WithdrawRecord entity.
func (m *TransferOrderMutation) ClearWithdrawRecord() {
	m.clearedwithdraw_record = true
}

// WithdrawRecordCleared reports if the "withdraw_record" edge to the WithdrawRecord entity was cleared.
func (m *TransferOrderMutation) WithdrawRecordCleared() bool {
	return m.clearedwithdraw_record
}

// WithdrawRecordID returns the "withdraw_record" edge ID in the mutation.
func (m *TransferOrderMutation) WithdrawRecordID() (id int64, exists bool) {
	if m.withdraw_record != nil {
		return *m.withdraw_record, true
	}
	return
}

// WithdrawRecordIDs returns the "withdraw_record" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WithdrawRecordID instead. It exists only for internal usage by the builders.
func (m *TransferOrderMutation) WithdrawRecordIDs() (ids []int64) {
	if id := m.withdraw_record; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWithdrawRecord resets all changes to the "withdraw_record" edge.
func (m *TransferOrderMutation) ResetWithdrawRecord() {
	m.withdraw_record = nil
	m.clearedwithdraw_record = false
}

// Where appends a list predicates to the TransferOrderMutation builder.
func (m *TransferOrderMutation) Where(ps ...predicate.TransferOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransferOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransferOrder).
func (m *TransferOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferOrderMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, transferorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, transferorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, transferorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transferorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transferorder.FieldDeletedAt)
	}
	if m.source_user != nil {
		fields = append(fields, transferorder.FieldSourceUserID)
	}
	if m.target_user != nil {
		fields = append(fields, transferorder.FieldTargetUserID)
	}
	if m.status != nil {
		fields = append(fields, transferorder.FieldStatus)
	}
	if m.symbol != nil {
		fields = append(fields, transferorder.FieldSymbolID)
	}
	if m.amount != nil {
		fields = append(fields, transferorder.FieldAmount)
	}
	if m._type != nil {
		fields = append(fields, transferorder.FieldType)
	}
	if m.serial_number != nil {
		fields = append(fields, transferorder.FieldSerialNumber)
	}
	if m.vx_social != nil {
		fields = append(fields, transferorder.FieldSocialID)
	}
	if m.third_api_resp != nil {
		fields = append(fields, transferorder.FieldThirdAPIResp)
	}
	if m.out_transaction_id != nil {
		fields = append(fields, transferorder.FieldOutTransactionID)
	}
	if m.operate_user_id != nil {
		fields = append(fields, transferorder.FieldOperateUserID)
	}
	if m.gift_type != nil {
		fields = append(fields, transferorder.FieldGiftType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transferorder.FieldCreatedBy:
		return m.CreatedBy()
	case transferorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case transferorder.FieldCreatedAt:
		return m.CreatedAt()
	case transferorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case transferorder.FieldDeletedAt:
		return m.DeletedAt()
	case transferorder.FieldSourceUserID:
		return m.SourceUserID()
	case transferorder.FieldTargetUserID:
		return m.TargetUserID()
	case transferorder.FieldStatus:
		return m.Status()
	case transferorder.FieldSymbolID:
		return m.SymbolID()
	case transferorder.FieldAmount:
		return m.Amount()
	case transferorder.FieldType:
		return m.GetType()
	case transferorder.FieldSerialNumber:
		return m.SerialNumber()
	case transferorder.FieldSocialID:
		return m.SocialID()
	case transferorder.FieldThirdAPIResp:
		return m.ThirdAPIResp()
	case transferorder.FieldOutTransactionID:
		return m.OutTransactionID()
	case transferorder.FieldOperateUserID:
		return m.OperateUserID()
	case transferorder.FieldGiftType:
		return m.GiftType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transferorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case transferorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case transferorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transferorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transferorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transferorder.FieldSourceUserID:
		return m.OldSourceUserID(ctx)
	case transferorder.FieldTargetUserID:
		return m.OldTargetUserID(ctx)
	case transferorder.FieldStatus:
		return m.OldStatus(ctx)
	case transferorder.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case transferorder.FieldAmount:
		return m.OldAmount(ctx)
	case transferorder.FieldType:
		return m.OldType(ctx)
	case transferorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case transferorder.FieldSocialID:
		return m.OldSocialID(ctx)
	case transferorder.FieldThirdAPIResp:
		return m.OldThirdAPIResp(ctx)
	case transferorder.FieldOutTransactionID:
		return m.OldOutTransactionID(ctx)
	case transferorder.FieldOperateUserID:
		return m.OldOperateUserID(ctx)
	case transferorder.FieldGiftType:
		return m.OldGiftType(ctx)
	}
	return nil, fmt.Errorf("unknown TransferOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transferorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case transferorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case transferorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transferorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transferorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transferorder.FieldSourceUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceUserID(v)
		return nil
	case transferorder.FieldTargetUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetUserID(v)
		return nil
	case transferorder.FieldStatus:
		v, ok := value.(transferorder.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transferorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case transferorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transferorder.FieldType:
		v, ok := value.(enums.TransferOrderType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transferorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case transferorder.FieldSocialID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialID(v)
		return nil
	case transferorder.FieldThirdAPIResp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdAPIResp(v)
		return nil
	case transferorder.FieldOutTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTransactionID(v)
		return nil
	case transferorder.FieldOperateUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperateUserID(v)
		return nil
	case transferorder.FieldGiftType:
		v, ok := value.(enums.TransferOrderGiftType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftType(v)
		return nil
	}
	return fmt.Errorf("unknown TransferOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, transferorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, transferorder.FieldUpdatedBy)
	}
	if m.addamount != nil {
		fields = append(fields, transferorder.FieldAmount)
	}
	if m.addoperate_user_id != nil {
		fields = append(fields, transferorder.FieldOperateUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transferorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case transferorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case transferorder.FieldAmount:
		return m.AddedAmount()
	case transferorder.FieldOperateUserID:
		return m.AddedOperateUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transferorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case transferorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case transferorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case transferorder.FieldOperateUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperateUserID(v)
		return nil
	}
	return fmt.Errorf("unknown TransferOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transferorder.FieldSocialID) {
		fields = append(fields, transferorder.FieldSocialID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferOrderMutation) ClearField(name string) error {
	switch name {
	case transferorder.FieldSocialID:
		m.ClearSocialID()
		return nil
	}
	return fmt.Errorf("unknown TransferOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferOrderMutation) ResetField(name string) error {
	switch name {
	case transferorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case transferorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case transferorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transferorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transferorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transferorder.FieldSourceUserID:
		m.ResetSourceUserID()
		return nil
	case transferorder.FieldTargetUserID:
		m.ResetTargetUserID()
		return nil
	case transferorder.FieldStatus:
		m.ResetStatus()
		return nil
	case transferorder.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case transferorder.FieldAmount:
		m.ResetAmount()
		return nil
	case transferorder.FieldType:
		m.ResetType()
		return nil
	case transferorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case transferorder.FieldSocialID:
		m.ResetSocialID()
		return nil
	case transferorder.FieldThirdAPIResp:
		m.ResetThirdAPIResp()
		return nil
	case transferorder.FieldOutTransactionID:
		m.ResetOutTransactionID()
		return nil
	case transferorder.FieldOperateUserID:
		m.ResetOperateUserID()
		return nil
	case transferorder.FieldGiftType:
		m.ResetGiftType()
		return nil
	}
	return fmt.Errorf("unknown TransferOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.source_user != nil {
		edges = append(edges, transferorder.EdgeSourceUser)
	}
	if m.target_user != nil {
		edges = append(edges, transferorder.EdgeTargetUser)
	}
	if m.bills != nil {
		edges = append(edges, transferorder.EdgeBills)
	}
	if m.vx_social != nil {
		edges = append(edges, transferorder.EdgeVxSocial)
	}
	if m.symbol != nil {
		edges = append(edges, transferorder.EdgeSymbol)
	}
	if m.withdraw_record != nil {
		edges = append(edges, transferorder.EdgeWithdrawRecord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transferorder.EdgeSourceUser:
		if id := m.source_user; id != nil {
			return []ent.Value{*id}
		}
	case transferorder.EdgeTargetUser:
		if id := m.target_user; id != nil {
			return []ent.Value{*id}
		}
	case transferorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case transferorder.EdgeVxSocial:
		if id := m.vx_social; id != nil {
			return []ent.Value{*id}
		}
	case transferorder.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	case transferorder.EdgeWithdrawRecord:
		if id := m.withdraw_record; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedbills != nil {
		edges = append(edges, transferorder.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transferorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedsource_user {
		edges = append(edges, transferorder.EdgeSourceUser)
	}
	if m.clearedtarget_user {
		edges = append(edges, transferorder.EdgeTargetUser)
	}
	if m.clearedbills {
		edges = append(edges, transferorder.EdgeBills)
	}
	if m.clearedvx_social {
		edges = append(edges, transferorder.EdgeVxSocial)
	}
	if m.clearedsymbol {
		edges = append(edges, transferorder.EdgeSymbol)
	}
	if m.clearedwithdraw_record {
		edges = append(edges, transferorder.EdgeWithdrawRecord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case transferorder.EdgeSourceUser:
		return m.clearedsource_user
	case transferorder.EdgeTargetUser:
		return m.clearedtarget_user
	case transferorder.EdgeBills:
		return m.clearedbills
	case transferorder.EdgeVxSocial:
		return m.clearedvx_social
	case transferorder.EdgeSymbol:
		return m.clearedsymbol
	case transferorder.EdgeWithdrawRecord:
		return m.clearedwithdraw_record
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferOrderMutation) ClearEdge(name string) error {
	switch name {
	case transferorder.EdgeSourceUser:
		m.ClearSourceUser()
		return nil
	case transferorder.EdgeTargetUser:
		m.ClearTargetUser()
		return nil
	case transferorder.EdgeVxSocial:
		m.ClearVxSocial()
		return nil
	case transferorder.EdgeSymbol:
		m.ClearSymbol()
		return nil
	case transferorder.EdgeWithdrawRecord:
		m.ClearWithdrawRecord()
		return nil
	}
	return fmt.Errorf("unknown TransferOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferOrderMutation) ResetEdge(name string) error {
	switch name {
	case transferorder.EdgeSourceUser:
		m.ResetSourceUser()
		return nil
	case transferorder.EdgeTargetUser:
		m.ResetTargetUser()
		return nil
	case transferorder.EdgeBills:
		m.ResetBills()
		return nil
	case transferorder.EdgeVxSocial:
		m.ResetVxSocial()
		return nil
	case transferorder.EdgeSymbol:
		m.ResetSymbol()
		return nil
	case transferorder.EdgeWithdrawRecord:
		m.ResetWithdrawRecord()
		return nil
	}
	return fmt.Errorf("unknown TransferOrder edge %s", name)
}

// TroubleDeductMutation represents an operation that mutates the TroubleDeduct nodes in the graph.
type TroubleDeductMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_by          *int64
	addcreated_by       *int64
	updated_by          *int64
	addupdated_by       *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	started_at          *time.Time
	finished_at         *time.Time
	time_of_duration    *float64
	addtime_of_duration *float64
	deduct_standard     *int64
	adddeduct_standard  *int64
	amount              *int64
	addamount           *int64
	current_balance     *int64
	addcurrent_balance  *int64
	status              *enums.TroubleDeductStatus
	reason              *string
	reject_reason       *string
	clearedFields       map[string]struct{}
	user                *int64
	cleareduser         bool
	device              *int64
	cleareddevice       bool
	done                bool
	oldValue            func(context.Context) (*TroubleDeduct, error)
	predicates          []predicate.TroubleDeduct
}

var _ ent.Mutation = (*TroubleDeductMutation)(nil)

// troubledeductOption allows management of the mutation configuration using functional options.
type troubledeductOption func(*TroubleDeductMutation)

// newTroubleDeductMutation creates new mutation for the TroubleDeduct entity.
func newTroubleDeductMutation(c config, op Op, opts ...troubledeductOption) *TroubleDeductMutation {
	m := &TroubleDeductMutation{
		config:        c,
		op:            op,
		typ:           TypeTroubleDeduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTroubleDeductID sets the ID field of the mutation.
func withTroubleDeductID(id int64) troubledeductOption {
	return func(m *TroubleDeductMutation) {
		var (
			err   error
			once  sync.Once
			value *TroubleDeduct
		)
		m.oldValue = func(ctx context.Context) (*TroubleDeduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TroubleDeduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTroubleDeduct sets the old TroubleDeduct of the mutation.
func withTroubleDeduct(node *TroubleDeduct) troubledeductOption {
	return func(m *TroubleDeductMutation) {
		m.oldValue = func(context.Context) (*TroubleDeduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TroubleDeductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TroubleDeductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TroubleDeduct entities.
func (m *TroubleDeductMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TroubleDeductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TroubleDeductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TroubleDeduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *TroubleDeductMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TroubleDeductMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TroubleDeductMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TroubleDeductMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TroubleDeductMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TroubleDeductMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TroubleDeductMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TroubleDeductMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TroubleDeductMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TroubleDeductMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TroubleDeductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TroubleDeductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TroubleDeductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TroubleDeductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TroubleDeductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TroubleDeductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TroubleDeductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TroubleDeductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TroubleDeductMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *TroubleDeductMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TroubleDeductMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TroubleDeductMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceID sets the "device_id" field.
func (m *TroubleDeductMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *TroubleDeductMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *TroubleDeductMutation) ResetDeviceID() {
	m.device = nil
}

// SetStartedAt sets the "started_at" field.
func (m *TroubleDeductMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *TroubleDeductMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *TroubleDeductMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *TroubleDeductMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *TroubleDeductMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *TroubleDeductMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetTimeOfDuration sets the "time_of_duration" field.
func (m *TroubleDeductMutation) SetTimeOfDuration(f float64) {
	m.time_of_duration = &f
	m.addtime_of_duration = nil
}

// TimeOfDuration returns the value of the "time_of_duration" field in the mutation.
func (m *TroubleDeductMutation) TimeOfDuration() (r float64, exists bool) {
	v := m.time_of_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeOfDuration returns the old "time_of_duration" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldTimeOfDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeOfDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeOfDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeOfDuration: %w", err)
	}
	return oldValue.TimeOfDuration, nil
}

// AddTimeOfDuration adds f to the "time_of_duration" field.
func (m *TroubleDeductMutation) AddTimeOfDuration(f float64) {
	if m.addtime_of_duration != nil {
		*m.addtime_of_duration += f
	} else {
		m.addtime_of_duration = &f
	}
}

// AddedTimeOfDuration returns the value that was added to the "time_of_duration" field in this mutation.
func (m *TroubleDeductMutation) AddedTimeOfDuration() (r float64, exists bool) {
	v := m.addtime_of_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeOfDuration resets all changes to the "time_of_duration" field.
func (m *TroubleDeductMutation) ResetTimeOfDuration() {
	m.time_of_duration = nil
	m.addtime_of_duration = nil
}

// SetDeductStandard sets the "deduct_standard" field.
func (m *TroubleDeductMutation) SetDeductStandard(i int64) {
	m.deduct_standard = &i
	m.adddeduct_standard = nil
}

// DeductStandard returns the value of the "deduct_standard" field in the mutation.
func (m *TroubleDeductMutation) DeductStandard() (r int64, exists bool) {
	v := m.deduct_standard
	if v == nil {
		return
	}
	return *v, true
}

// OldDeductStandard returns the old "deduct_standard" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldDeductStandard(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeductStandard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeductStandard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeductStandard: %w", err)
	}
	return oldValue.DeductStandard, nil
}

// AddDeductStandard adds i to the "deduct_standard" field.
func (m *TroubleDeductMutation) AddDeductStandard(i int64) {
	if m.adddeduct_standard != nil {
		*m.adddeduct_standard += i
	} else {
		m.adddeduct_standard = &i
	}
}

// AddedDeductStandard returns the value that was added to the "deduct_standard" field in this mutation.
func (m *TroubleDeductMutation) AddedDeductStandard() (r int64, exists bool) {
	v := m.adddeduct_standard
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeductStandard resets all changes to the "deduct_standard" field.
func (m *TroubleDeductMutation) ResetDeductStandard() {
	m.deduct_standard = nil
	m.adddeduct_standard = nil
}

// SetAmount sets the "amount" field.
func (m *TroubleDeductMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TroubleDeductMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TroubleDeductMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TroubleDeductMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TroubleDeductMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrentBalance sets the "current_balance" field.
func (m *TroubleDeductMutation) SetCurrentBalance(i int64) {
	m.current_balance = &i
	m.addcurrent_balance = nil
}

// CurrentBalance returns the value of the "current_balance" field in the mutation.
func (m *TroubleDeductMutation) CurrentBalance() (r int64, exists bool) {
	v := m.current_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentBalance returns the old "current_balance" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldCurrentBalance(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentBalance: %w", err)
	}
	return oldValue.CurrentBalance, nil
}

// AddCurrentBalance adds i to the "current_balance" field.
func (m *TroubleDeductMutation) AddCurrentBalance(i int64) {
	if m.addcurrent_balance != nil {
		*m.addcurrent_balance += i
	} else {
		m.addcurrent_balance = &i
	}
}

// AddedCurrentBalance returns the value that was added to the "current_balance" field in this mutation.
func (m *TroubleDeductMutation) AddedCurrentBalance() (r int64, exists bool) {
	v := m.addcurrent_balance
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentBalance resets all changes to the "current_balance" field.
func (m *TroubleDeductMutation) ResetCurrentBalance() {
	m.current_balance = nil
	m.addcurrent_balance = nil
}

// SetStatus sets the "status" field.
func (m *TroubleDeductMutation) SetStatus(eds enums.TroubleDeductStatus) {
	m.status = &eds
}

// Status returns the value of the "status" field in the mutation.
func (m *TroubleDeductMutation) Status() (r enums.TroubleDeductStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldStatus(ctx context.Context) (v enums.TroubleDeductStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TroubleDeductMutation) ResetStatus() {
	m.status = nil
}

// SetReason sets the "reason" field.
func (m *TroubleDeductMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *TroubleDeductMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *TroubleDeductMutation) ResetReason() {
	m.reason = nil
}

// SetRejectReason sets the "reject_reason" field.
func (m *TroubleDeductMutation) SetRejectReason(s string) {
	m.reject_reason = &s
}

// RejectReason returns the value of the "reject_reason" field in the mutation.
func (m *TroubleDeductMutation) RejectReason() (r string, exists bool) {
	v := m.reject_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectReason returns the old "reject_reason" field's value of the TroubleDeduct entity.
// If the TroubleDeduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TroubleDeductMutation) OldRejectReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectReason: %w", err)
	}
	return oldValue.RejectReason, nil
}

// ResetRejectReason resets all changes to the "reject_reason" field.
func (m *TroubleDeductMutation) ResetRejectReason() {
	m.reject_reason = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TroubleDeductMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[troublededuct.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TroubleDeductMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TroubleDeductMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TroubleDeductMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *TroubleDeductMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[troublededuct.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *TroubleDeductMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *TroubleDeductMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *TroubleDeductMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the TroubleDeductMutation builder.
func (m *TroubleDeductMutation) Where(ps ...predicate.TroubleDeduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TroubleDeductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TroubleDeductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TroubleDeduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TroubleDeductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TroubleDeductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TroubleDeduct).
func (m *TroubleDeductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TroubleDeductMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, troublededuct.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, troublededuct.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, troublededuct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, troublededuct.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, troublededuct.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, troublededuct.FieldUserID)
	}
	if m.device != nil {
		fields = append(fields, troublededuct.FieldDeviceID)
	}
	if m.started_at != nil {
		fields = append(fields, troublededuct.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, troublededuct.FieldFinishedAt)
	}
	if m.time_of_duration != nil {
		fields = append(fields, troublededuct.FieldTimeOfDuration)
	}
	if m.deduct_standard != nil {
		fields = append(fields, troublededuct.FieldDeductStandard)
	}
	if m.amount != nil {
		fields = append(fields, troublededuct.FieldAmount)
	}
	if m.current_balance != nil {
		fields = append(fields, troublededuct.FieldCurrentBalance)
	}
	if m.status != nil {
		fields = append(fields, troublededuct.FieldStatus)
	}
	if m.reason != nil {
		fields = append(fields, troublededuct.FieldReason)
	}
	if m.reject_reason != nil {
		fields = append(fields, troublededuct.FieldRejectReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TroubleDeductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case troublededuct.FieldCreatedBy:
		return m.CreatedBy()
	case troublededuct.FieldUpdatedBy:
		return m.UpdatedBy()
	case troublededuct.FieldCreatedAt:
		return m.CreatedAt()
	case troublededuct.FieldUpdatedAt:
		return m.UpdatedAt()
	case troublededuct.FieldDeletedAt:
		return m.DeletedAt()
	case troublededuct.FieldUserID:
		return m.UserID()
	case troublededuct.FieldDeviceID:
		return m.DeviceID()
	case troublededuct.FieldStartedAt:
		return m.StartedAt()
	case troublededuct.FieldFinishedAt:
		return m.FinishedAt()
	case troublededuct.FieldTimeOfDuration:
		return m.TimeOfDuration()
	case troublededuct.FieldDeductStandard:
		return m.DeductStandard()
	case troublededuct.FieldAmount:
		return m.Amount()
	case troublededuct.FieldCurrentBalance:
		return m.CurrentBalance()
	case troublededuct.FieldStatus:
		return m.Status()
	case troublededuct.FieldReason:
		return m.Reason()
	case troublededuct.FieldRejectReason:
		return m.RejectReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TroubleDeductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case troublededuct.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case troublededuct.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case troublededuct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case troublededuct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case troublededuct.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case troublededuct.FieldUserID:
		return m.OldUserID(ctx)
	case troublededuct.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case troublededuct.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case troublededuct.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case troublededuct.FieldTimeOfDuration:
		return m.OldTimeOfDuration(ctx)
	case troublededuct.FieldDeductStandard:
		return m.OldDeductStandard(ctx)
	case troublededuct.FieldAmount:
		return m.OldAmount(ctx)
	case troublededuct.FieldCurrentBalance:
		return m.OldCurrentBalance(ctx)
	case troublededuct.FieldStatus:
		return m.OldStatus(ctx)
	case troublededuct.FieldReason:
		return m.OldReason(ctx)
	case troublededuct.FieldRejectReason:
		return m.OldRejectReason(ctx)
	}
	return nil, fmt.Errorf("unknown TroubleDeduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TroubleDeductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case troublededuct.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case troublededuct.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case troublededuct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case troublededuct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case troublededuct.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case troublededuct.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case troublededuct.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case troublededuct.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case troublededuct.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case troublededuct.FieldTimeOfDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeOfDuration(v)
		return nil
	case troublededuct.FieldDeductStandard:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeductStandard(v)
		return nil
	case troublededuct.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case troublededuct.FieldCurrentBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentBalance(v)
		return nil
	case troublededuct.FieldStatus:
		v, ok := value.(enums.TroubleDeductStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case troublededuct.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case troublededuct.FieldRejectReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectReason(v)
		return nil
	}
	return fmt.Errorf("unknown TroubleDeduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TroubleDeductMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, troublededuct.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, troublededuct.FieldUpdatedBy)
	}
	if m.addtime_of_duration != nil {
		fields = append(fields, troublededuct.FieldTimeOfDuration)
	}
	if m.adddeduct_standard != nil {
		fields = append(fields, troublededuct.FieldDeductStandard)
	}
	if m.addamount != nil {
		fields = append(fields, troublededuct.FieldAmount)
	}
	if m.addcurrent_balance != nil {
		fields = append(fields, troublededuct.FieldCurrentBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TroubleDeductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case troublededuct.FieldCreatedBy:
		return m.AddedCreatedBy()
	case troublededuct.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case troublededuct.FieldTimeOfDuration:
		return m.AddedTimeOfDuration()
	case troublededuct.FieldDeductStandard:
		return m.AddedDeductStandard()
	case troublededuct.FieldAmount:
		return m.AddedAmount()
	case troublededuct.FieldCurrentBalance:
		return m.AddedCurrentBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TroubleDeductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case troublededuct.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case troublededuct.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case troublededuct.FieldTimeOfDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeOfDuration(v)
		return nil
	case troublededuct.FieldDeductStandard:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeductStandard(v)
		return nil
	case troublededuct.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case troublededuct.FieldCurrentBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentBalance(v)
		return nil
	}
	return fmt.Errorf("unknown TroubleDeduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TroubleDeductMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TroubleDeductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TroubleDeductMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TroubleDeduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TroubleDeductMutation) ResetField(name string) error {
	switch name {
	case troublededuct.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case troublededuct.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case troublededuct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case troublededuct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case troublededuct.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case troublededuct.FieldUserID:
		m.ResetUserID()
		return nil
	case troublededuct.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case troublededuct.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case troublededuct.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case troublededuct.FieldTimeOfDuration:
		m.ResetTimeOfDuration()
		return nil
	case troublededuct.FieldDeductStandard:
		m.ResetDeductStandard()
		return nil
	case troublededuct.FieldAmount:
		m.ResetAmount()
		return nil
	case troublededuct.FieldCurrentBalance:
		m.ResetCurrentBalance()
		return nil
	case troublededuct.FieldStatus:
		m.ResetStatus()
		return nil
	case troublededuct.FieldReason:
		m.ResetReason()
		return nil
	case troublededuct.FieldRejectReason:
		m.ResetRejectReason()
		return nil
	}
	return fmt.Errorf("unknown TroubleDeduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TroubleDeductMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, troublededuct.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, troublededuct.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TroubleDeductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case troublededuct.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case troublededuct.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TroubleDeductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TroubleDeductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TroubleDeductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, troublededuct.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, troublededuct.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TroubleDeductMutation) EdgeCleared(name string) bool {
	switch name {
	case troublededuct.EdgeUser:
		return m.cleareduser
	case troublededuct.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TroubleDeductMutation) ClearEdge(name string) error {
	switch name {
	case troublededuct.EdgeUser:
		m.ClearUser()
		return nil
	case troublededuct.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown TroubleDeduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TroubleDeductMutation) ResetEdge(name string) error {
	switch name {
	case troublededuct.EdgeUser:
		m.ResetUser()
		return nil
	case troublededuct.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown TroubleDeduct edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int64
	created_by                      *int64
	addcreated_by                   *int64
	updated_by                      *int64
	addupdated_by                   *int64
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	name                            *string
	nick_name                       *string
	jpg_url                         *string
	key                             *string
	secret                          *string
	phone                           *string
	password                        *string
	is_frozen                       *bool
	is_recharge                     *bool
	user_type                       *enums.UserType
	pop_version                     *string
	area_code                       *string
	email                           *string
	github_id                       *string
	cloud_space                     *int64
	addcloud_space                  *int64
	baidu_access_token              *string
	baidu_refresh_token             *string
	bound_at                        *time.Time
	user_status                     *enums.UserStatus
	channel                         *enums.UserChannelType
	channel_ratio                   *int64
	addchannel_ratio                *int64
	clearedFields                   map[string]struct{}
	vx_accounts                     map[int64]struct{}
	removedvx_accounts              map[int64]struct{}
	clearedvx_accounts              bool
	collects                        map[int64]struct{}
	removedcollects                 map[int64]struct{}
	clearedcollects                 bool
	devices                         map[int64]struct{}
	removeddevices                  map[int64]struct{}
	cleareddevices                  bool
	profit_settings                 map[int64]struct{}
	removedprofit_settings          map[int64]struct{}
	clearedprofit_settings          bool
	cost_account                    *int64
	clearedcost_account             bool
	profit_account                  *int64
	clearedprofit_account           bool
	cost_bills                      map[int64]struct{}
	removedcost_bills               map[int64]struct{}
	clearedcost_bills               bool
	earn_bills                      map[int64]struct{}
	removedearn_bills               map[int64]struct{}
	clearedearn_bills               bool
	mission_consume_orders          map[int64]struct{}
	removedmission_consume_orders   map[int64]struct{}
	clearedmission_consume_orders   bool
	mission_produce_orders          map[int64]struct{}
	removedmission_produce_orders   map[int64]struct{}
	clearedmission_produce_orders   bool
	recharge_orders                 map[int64]struct{}
	removedrecharge_orders          map[int64]struct{}
	clearedrecharge_orders          bool
	vx_socials                      map[int64]struct{}
	removedvx_socials               map[int64]struct{}
	clearedvx_socials               bool
	mission_batches                 map[int64]struct{}
	removedmission_batches          map[int64]struct{}
	clearedmission_batches          bool
	user_devices                    map[int64]struct{}
	removeduser_devices             map[int64]struct{}
	cleareduser_devices             bool
	parent                          *int64
	clearedparent                   bool
	children                        map[int64]struct{}
	removedchildren                 map[int64]struct{}
	clearedchildren                 bool
	applet_parent                   *int64
	clearedapplet_parent            bool
	applet_children                 map[int64]struct{}
	removedapplet_children          map[int64]struct{}
	clearedapplet_children          bool
	invites                         map[int64]struct{}
	removedinvites                  map[int64]struct{}
	clearedinvites                  bool
	campaign_orders                 map[int64]struct{}
	removedcampaign_orders          map[int64]struct{}
	clearedcampaign_orders          bool
	wallets                         map[int64]struct{}
	removedwallets                  map[int64]struct{}
	clearedwallets                  bool
	withdraw_account                *int64
	clearedwithdraw_account         bool
	income_bills                    map[int64]struct{}
	removedincome_bills             map[int64]struct{}
	clearedincome_bills             bool
	outcome_bills                   map[int64]struct{}
	removedoutcome_bills            map[int64]struct{}
	clearedoutcome_bills            bool
	mission_productions             map[int64]struct{}
	removedmission_productions      map[int64]struct{}
	clearedmission_productions      bool
	missions                        map[int64]struct{}
	removedmissions                 map[int64]struct{}
	clearedmissions                 bool
	income_transfer_orders          map[int64]struct{}
	removedincome_transfer_orders   map[int64]struct{}
	clearedincome_transfer_orders   bool
	outcome_transfer_orders         map[int64]struct{}
	removedoutcome_transfer_orders  map[int64]struct{}
	clearedoutcome_transfer_orders  bool
	consume_mission_orders          map[int64]struct{}
	removedconsume_mission_orders   map[int64]struct{}
	clearedconsume_mission_orders   bool
	produce_mission_orders          map[int64]struct{}
	removedproduce_mission_orders   map[int64]struct{}
	clearedproduce_mission_orders   bool
	login_records                   map[int64]struct{}
	removedlogin_records            map[int64]struct{}
	clearedlogin_records            bool
	renewal_agreements              map[int64]struct{}
	removedrenewal_agreements       map[int64]struct{}
	clearedrenewal_agreements       bool
	artworks                        map[int64]struct{}
	removedartworks                 map[int64]struct{}
	clearedartworks                 bool
	artwork_likes                   map[int64]struct{}
	removedartwork_likes            map[int64]struct{}
	clearedartwork_likes            bool
	cdk_infos                       map[int64]struct{}
	removedcdk_infos                map[int64]struct{}
	clearedcdk_infos                bool
	use_cdk_infos                   map[int64]struct{}
	removeduse_cdk_infos            map[int64]struct{}
	cleareduse_cdk_infos            bool
	lotto_records                   map[int64]struct{}
	removedlotto_records            map[int64]struct{}
	clearedlotto_records            bool
	lotto_user_counts               map[int64]struct{}
	removedlotto_user_counts        map[int64]struct{}
	clearedlotto_user_counts        bool
	lotto_get_count_records         map[int64]struct{}
	removedlotto_get_count_records  map[int64]struct{}
	clearedlotto_get_count_records  bool
	cloud_files                     map[int64]struct{}
	removedcloud_files              map[int64]struct{}
	clearedcloud_files              bool
	withdraw_records                map[int64]struct{}
	removedwithdraw_records         map[int64]struct{}
	clearedwithdraw_records         bool
	operate_withdraw_records        map[int64]struct{}
	removedoperate_withdraw_records map[int64]struct{}
	clearedoperate_withdraw_records bool
	trouble_deducts                 map[int64]struct{}
	removedtrouble_deducts          map[int64]struct{}
	clearedtrouble_deducts          bool
	income_manages                  map[int64]struct{}
	removedincome_manages           map[int64]struct{}
	clearedincome_manages           bool
	approve_income_manages          map[int64]struct{}
	removedapprove_income_manages   map[int64]struct{}
	clearedapprove_income_manages   bool
	survey_responses                map[int64]struct{}
	removedsurvey_responses         map[int64]struct{}
	clearedsurvey_responses         bool
	approve_survey_responses        map[int64]struct{}
	removedapprove_survey_responses map[int64]struct{}
	clearedapprove_survey_responses bool
	mission_failed_feedbacks        map[int64]struct{}
	removedmission_failed_feedbacks map[int64]struct{}
	clearedmission_failed_feedbacks bool
	api_tokens                      map[int64]struct{}
	removedapi_tokens               map[int64]struct{}
	clearedapi_tokens               bool
	user_models                     map[int64]struct{}
	removeduser_models              map[int64]struct{}
	cleareduser_models              bool
	invoke_model_orders             map[int64]struct{}
	removedinvoke_model_orders      map[int64]struct{}
	clearedinvoke_model_orders      bool
	done                            bool
	oldValue                        func(context.Context) (*User, error)
	predicates                      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetNickName sets the "nick_name" field.
func (m *UserMutation) SetNickName(s string) {
	m.nick_name = &s
}

// NickName returns the value of the "nick_name" field in the mutation.
func (m *UserMutation) NickName() (r string, exists bool) {
	v := m.nick_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNickName returns the old "nick_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickName: %w", err)
	}
	return oldValue.NickName, nil
}

// ResetNickName resets all changes to the "nick_name" field.
func (m *UserMutation) ResetNickName() {
	m.nick_name = nil
}

// SetJpgURL sets the "jpg_url" field.
func (m *UserMutation) SetJpgURL(s string) {
	m.jpg_url = &s
}

// JpgURL returns the value of the "jpg_url" field in the mutation.
func (m *UserMutation) JpgURL() (r string, exists bool) {
	v := m.jpg_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJpgURL returns the old "jpg_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJpgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJpgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJpgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJpgURL: %w", err)
	}
	return oldValue.JpgURL, nil
}

// ResetJpgURL resets all changes to the "jpg_url" field.
func (m *UserMutation) ResetJpgURL() {
	m.jpg_url = nil
}

// SetKey sets the "key" field.
func (m *UserMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UserMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UserMutation) ResetKey() {
	m.key = nil
}

// SetSecret sets the "secret" field.
func (m *UserMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *UserMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *UserMutation) ResetSecret() {
	m.secret = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetIsFrozen sets the "is_frozen" field.
func (m *UserMutation) SetIsFrozen(b bool) {
	m.is_frozen = &b
}

// IsFrozen returns the value of the "is_frozen" field in the mutation.
func (m *UserMutation) IsFrozen() (r bool, exists bool) {
	v := m.is_frozen
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFrozen returns the old "is_frozen" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsFrozen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFrozen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFrozen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFrozen: %w", err)
	}
	return oldValue.IsFrozen, nil
}

// ResetIsFrozen resets all changes to the "is_frozen" field.
func (m *UserMutation) ResetIsFrozen() {
	m.is_frozen = nil
}

// SetIsRecharge sets the "is_recharge" field.
func (m *UserMutation) SetIsRecharge(b bool) {
	m.is_recharge = &b
}

// IsRecharge returns the value of the "is_recharge" field in the mutation.
func (m *UserMutation) IsRecharge() (r bool, exists bool) {
	v := m.is_recharge
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRecharge returns the old "is_recharge" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsRecharge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRecharge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRecharge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRecharge: %w", err)
	}
	return oldValue.IsRecharge, nil
}

// ResetIsRecharge resets all changes to the "is_recharge" field.
func (m *UserMutation) ResetIsRecharge() {
	m.is_recharge = nil
}

// SetUserType sets the "user_type" field.
func (m *UserMutation) SetUserType(et enums.UserType) {
	m.user_type = &et
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *UserMutation) UserType() (r enums.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserType(ctx context.Context) (v enums.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ResetUserType resets all changes to the "user_type" field.
func (m *UserMutation) ResetUserType() {
	m.user_type = nil
}

// SetParentID sets the "parent_id" field.
func (m *UserMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *UserMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *UserMutation) ResetParentID() {
	m.parent = nil
}

// SetAppletParentID sets the "applet_parent_id" field.
func (m *UserMutation) SetAppletParentID(i int64) {
	m.applet_parent = &i
}

// AppletParentID returns the value of the "applet_parent_id" field in the mutation.
func (m *UserMutation) AppletParentID() (r int64, exists bool) {
	v := m.applet_parent
	if v == nil {
		return
	}
	return *v, true
}

// OldAppletParentID returns the old "applet_parent_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAppletParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppletParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppletParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppletParentID: %w", err)
	}
	return oldValue.AppletParentID, nil
}

// ResetAppletParentID resets all changes to the "applet_parent_id" field.
func (m *UserMutation) ResetAppletParentID() {
	m.applet_parent = nil
}

// SetPopVersion sets the "pop_version" field.
func (m *UserMutation) SetPopVersion(s string) {
	m.pop_version = &s
}

// PopVersion returns the value of the "pop_version" field in the mutation.
func (m *UserMutation) PopVersion() (r string, exists bool) {
	v := m.pop_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPopVersion returns the old "pop_version" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPopVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopVersion: %w", err)
	}
	return oldValue.PopVersion, nil
}

// ResetPopVersion resets all changes to the "pop_version" field.
func (m *UserMutation) ResetPopVersion() {
	m.pop_version = nil
}

// SetAreaCode sets the "area_code" field.
func (m *UserMutation) SetAreaCode(s string) {
	m.area_code = &s
}

// AreaCode returns the value of the "area_code" field in the mutation.
func (m *UserMutation) AreaCode() (r string, exists bool) {
	v := m.area_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaCode returns the old "area_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAreaCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaCode: %w", err)
	}
	return oldValue.AreaCode, nil
}

// ResetAreaCode resets all changes to the "area_code" field.
func (m *UserMutation) ResetAreaCode() {
	m.area_code = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetGithubID sets the "github_id" field.
func (m *UserMutation) SetGithubID(s string) {
	m.github_id = &s
}

// GithubID returns the value of the "github_id" field in the mutation.
func (m *UserMutation) GithubID() (r string, exists bool) {
	v := m.github_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubID returns the old "github_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGithubID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubID: %w", err)
	}
	return oldValue.GithubID, nil
}

// ResetGithubID resets all changes to the "github_id" field.
func (m *UserMutation) ResetGithubID() {
	m.github_id = nil
}

// SetCloudSpace sets the "cloud_space" field.
func (m *UserMutation) SetCloudSpace(i int64) {
	m.cloud_space = &i
	m.addcloud_space = nil
}

// CloudSpace returns the value of the "cloud_space" field in the mutation.
func (m *UserMutation) CloudSpace() (r int64, exists bool) {
	v := m.cloud_space
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudSpace returns the old "cloud_space" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCloudSpace(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudSpace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudSpace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudSpace: %w", err)
	}
	return oldValue.CloudSpace, nil
}

// AddCloudSpace adds i to the "cloud_space" field.
func (m *UserMutation) AddCloudSpace(i int64) {
	if m.addcloud_space != nil {
		*m.addcloud_space += i
	} else {
		m.addcloud_space = &i
	}
}

// AddedCloudSpace returns the value that was added to the "cloud_space" field in this mutation.
func (m *UserMutation) AddedCloudSpace() (r int64, exists bool) {
	v := m.addcloud_space
	if v == nil {
		return
	}
	return *v, true
}

// ResetCloudSpace resets all changes to the "cloud_space" field.
func (m *UserMutation) ResetCloudSpace() {
	m.cloud_space = nil
	m.addcloud_space = nil
}

// SetBaiduAccessToken sets the "baidu_access_token" field.
func (m *UserMutation) SetBaiduAccessToken(s string) {
	m.baidu_access_token = &s
}

// BaiduAccessToken returns the value of the "baidu_access_token" field in the mutation.
func (m *UserMutation) BaiduAccessToken() (r string, exists bool) {
	v := m.baidu_access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldBaiduAccessToken returns the old "baidu_access_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBaiduAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaiduAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaiduAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaiduAccessToken: %w", err)
	}
	return oldValue.BaiduAccessToken, nil
}

// ResetBaiduAccessToken resets all changes to the "baidu_access_token" field.
func (m *UserMutation) ResetBaiduAccessToken() {
	m.baidu_access_token = nil
}

// SetBaiduRefreshToken sets the "baidu_refresh_token" field.
func (m *UserMutation) SetBaiduRefreshToken(s string) {
	m.baidu_refresh_token = &s
}

// BaiduRefreshToken returns the value of the "baidu_refresh_token" field in the mutation.
func (m *UserMutation) BaiduRefreshToken() (r string, exists bool) {
	v := m.baidu_refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldBaiduRefreshToken returns the old "baidu_refresh_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBaiduRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaiduRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaiduRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaiduRefreshToken: %w", err)
	}
	return oldValue.BaiduRefreshToken, nil
}

// ResetBaiduRefreshToken resets all changes to the "baidu_refresh_token" field.
func (m *UserMutation) ResetBaiduRefreshToken() {
	m.baidu_refresh_token = nil
}

// SetBoundAt sets the "bound_at" field.
func (m *UserMutation) SetBoundAt(t time.Time) {
	m.bound_at = &t
}

// BoundAt returns the value of the "bound_at" field in the mutation.
func (m *UserMutation) BoundAt() (r time.Time, exists bool) {
	v := m.bound_at
	if v == nil {
		return
	}
	return *v, true
}

// OldBoundAt returns the old "bound_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBoundAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoundAt: %w", err)
	}
	return oldValue.BoundAt, nil
}

// ClearBoundAt clears the value of the "bound_at" field.
func (m *UserMutation) ClearBoundAt() {
	m.bound_at = nil
	m.clearedFields[user.FieldBoundAt] = struct{}{}
}

// BoundAtCleared returns if the "bound_at" field was cleared in this mutation.
func (m *UserMutation) BoundAtCleared() bool {
	_, ok := m.clearedFields[user.FieldBoundAt]
	return ok
}

// ResetBoundAt resets all changes to the "bound_at" field.
func (m *UserMutation) ResetBoundAt() {
	m.bound_at = nil
	delete(m.clearedFields, user.FieldBoundAt)
}

// SetUserStatus sets the "user_status" field.
func (m *UserMutation) SetUserStatus(es enums.UserStatus) {
	m.user_status = &es
}

// UserStatus returns the value of the "user_status" field in the mutation.
func (m *UserMutation) UserStatus() (r enums.UserStatus, exists bool) {
	v := m.user_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUserStatus returns the old "user_status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserStatus(ctx context.Context) (v enums.UserStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserStatus: %w", err)
	}
	return oldValue.UserStatus, nil
}

// ResetUserStatus resets all changes to the "user_status" field.
func (m *UserMutation) ResetUserStatus() {
	m.user_status = nil
}

// SetChannel sets the "channel" field.
func (m *UserMutation) SetChannel(ect enums.UserChannelType) {
	m.channel = &ect
}

// Channel returns the value of the "channel" field in the mutation.
func (m *UserMutation) Channel() (r enums.UserChannelType, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldChannel(ctx context.Context) (v enums.UserChannelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *UserMutation) ResetChannel() {
	m.channel = nil
}

// SetChannelRatio sets the "channel_ratio" field.
func (m *UserMutation) SetChannelRatio(i int64) {
	m.channel_ratio = &i
	m.addchannel_ratio = nil
}

// ChannelRatio returns the value of the "channel_ratio" field in the mutation.
func (m *UserMutation) ChannelRatio() (r int64, exists bool) {
	v := m.channel_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelRatio returns the old "channel_ratio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldChannelRatio(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelRatio: %w", err)
	}
	return oldValue.ChannelRatio, nil
}

// AddChannelRatio adds i to the "channel_ratio" field.
func (m *UserMutation) AddChannelRatio(i int64) {
	if m.addchannel_ratio != nil {
		*m.addchannel_ratio += i
	} else {
		m.addchannel_ratio = &i
	}
}

// AddedChannelRatio returns the value that was added to the "channel_ratio" field in this mutation.
func (m *UserMutation) AddedChannelRatio() (r int64, exists bool) {
	v := m.addchannel_ratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelRatio resets all changes to the "channel_ratio" field.
func (m *UserMutation) ResetChannelRatio() {
	m.channel_ratio = nil
	m.addchannel_ratio = nil
}

// AddVxAccountIDs adds the "vx_accounts" edge to the VXAccount entity by ids.
func (m *UserMutation) AddVxAccountIDs(ids ...int64) {
	if m.vx_accounts == nil {
		m.vx_accounts = make(map[int64]struct{})
	}
	for i := range ids {
		m.vx_accounts[ids[i]] = struct{}{}
	}
}

// ClearVxAccounts clears the "vx_accounts" edge to the VXAccount entity.
func (m *UserMutation) ClearVxAccounts() {
	m.clearedvx_accounts = true
}

// VxAccountsCleared reports if the "vx_accounts" edge to the VXAccount entity was cleared.
func (m *UserMutation) VxAccountsCleared() bool {
	return m.clearedvx_accounts
}

// RemoveVxAccountIDs removes the "vx_accounts" edge to the VXAccount entity by IDs.
func (m *UserMutation) RemoveVxAccountIDs(ids ...int64) {
	if m.removedvx_accounts == nil {
		m.removedvx_accounts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.vx_accounts, ids[i])
		m.removedvx_accounts[ids[i]] = struct{}{}
	}
}

// RemovedVxAccounts returns the removed IDs of the "vx_accounts" edge to the VXAccount entity.
func (m *UserMutation) RemovedVxAccountsIDs() (ids []int64) {
	for id := range m.removedvx_accounts {
		ids = append(ids, id)
	}
	return
}

// VxAccountsIDs returns the "vx_accounts" edge IDs in the mutation.
func (m *UserMutation) VxAccountsIDs() (ids []int64) {
	for id := range m.vx_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetVxAccounts resets all changes to the "vx_accounts" edge.
func (m *UserMutation) ResetVxAccounts() {
	m.vx_accounts = nil
	m.clearedvx_accounts = false
	m.removedvx_accounts = nil
}

// AddCollectIDs adds the "collects" edge to the Collect entity by ids.
func (m *UserMutation) AddCollectIDs(ids ...int64) {
	if m.collects == nil {
		m.collects = make(map[int64]struct{})
	}
	for i := range ids {
		m.collects[ids[i]] = struct{}{}
	}
}

// ClearCollects clears the "collects" edge to the Collect entity.
func (m *UserMutation) ClearCollects() {
	m.clearedcollects = true
}

// CollectsCleared reports if the "collects" edge to the Collect entity was cleared.
func (m *UserMutation) CollectsCleared() bool {
	return m.clearedcollects
}

// RemoveCollectIDs removes the "collects" edge to the Collect entity by IDs.
func (m *UserMutation) RemoveCollectIDs(ids ...int64) {
	if m.removedcollects == nil {
		m.removedcollects = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.collects, ids[i])
		m.removedcollects[ids[i]] = struct{}{}
	}
}

// RemovedCollects returns the removed IDs of the "collects" edge to the Collect entity.
func (m *UserMutation) RemovedCollectsIDs() (ids []int64) {
	for id := range m.removedcollects {
		ids = append(ids, id)
	}
	return
}

// CollectsIDs returns the "collects" edge IDs in the mutation.
func (m *UserMutation) CollectsIDs() (ids []int64) {
	for id := range m.collects {
		ids = append(ids, id)
	}
	return
}

// ResetCollects resets all changes to the "collects" edge.
func (m *UserMutation) ResetCollects() {
	m.collects = nil
	m.clearedcollects = false
	m.removedcollects = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...int64) {
	if m.devices == nil {
		m.devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *UserMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *UserMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...int64) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *UserMutation) RemovedDevicesIDs() (ids []int64) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *UserMutation) DevicesIDs() (ids []int64) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *UserMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddProfitSettingIDs adds the "profit_settings" edge to the ProfitSetting entity by ids.
func (m *UserMutation) AddProfitSettingIDs(ids ...int64) {
	if m.profit_settings == nil {
		m.profit_settings = make(map[int64]struct{})
	}
	for i := range ids {
		m.profit_settings[ids[i]] = struct{}{}
	}
}

// ClearProfitSettings clears the "profit_settings" edge to the ProfitSetting entity.
func (m *UserMutation) ClearProfitSettings() {
	m.clearedprofit_settings = true
}

// ProfitSettingsCleared reports if the "profit_settings" edge to the ProfitSetting entity was cleared.
func (m *UserMutation) ProfitSettingsCleared() bool {
	return m.clearedprofit_settings
}

// RemoveProfitSettingIDs removes the "profit_settings" edge to the ProfitSetting entity by IDs.
func (m *UserMutation) RemoveProfitSettingIDs(ids ...int64) {
	if m.removedprofit_settings == nil {
		m.removedprofit_settings = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.profit_settings, ids[i])
		m.removedprofit_settings[ids[i]] = struct{}{}
	}
}

// RemovedProfitSettings returns the removed IDs of the "profit_settings" edge to the ProfitSetting entity.
func (m *UserMutation) RemovedProfitSettingsIDs() (ids []int64) {
	for id := range m.removedprofit_settings {
		ids = append(ids, id)
	}
	return
}

// ProfitSettingsIDs returns the "profit_settings" edge IDs in the mutation.
func (m *UserMutation) ProfitSettingsIDs() (ids []int64) {
	for id := range m.profit_settings {
		ids = append(ids, id)
	}
	return
}

// ResetProfitSettings resets all changes to the "profit_settings" edge.
func (m *UserMutation) ResetProfitSettings() {
	m.profit_settings = nil
	m.clearedprofit_settings = false
	m.removedprofit_settings = nil
}

// SetCostAccountID sets the "cost_account" edge to the CostAccount entity by id.
func (m *UserMutation) SetCostAccountID(id int64) {
	m.cost_account = &id
}

// ClearCostAccount clears the "cost_account" edge to the CostAccount entity.
func (m *UserMutation) ClearCostAccount() {
	m.clearedcost_account = true
}

// CostAccountCleared reports if the "cost_account" edge to the CostAccount entity was cleared.
func (m *UserMutation) CostAccountCleared() bool {
	return m.clearedcost_account
}

// CostAccountID returns the "cost_account" edge ID in the mutation.
func (m *UserMutation) CostAccountID() (id int64, exists bool) {
	if m.cost_account != nil {
		return *m.cost_account, true
	}
	return
}

// CostAccountIDs returns the "cost_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CostAccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CostAccountIDs() (ids []int64) {
	if id := m.cost_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCostAccount resets all changes to the "cost_account" edge.
func (m *UserMutation) ResetCostAccount() {
	m.cost_account = nil
	m.clearedcost_account = false
}

// SetProfitAccountID sets the "profit_account" edge to the ProfitAccount entity by id.
func (m *UserMutation) SetProfitAccountID(id int64) {
	m.profit_account = &id
}

// ClearProfitAccount clears the "profit_account" edge to the ProfitAccount entity.
func (m *UserMutation) ClearProfitAccount() {
	m.clearedprofit_account = true
}

// ProfitAccountCleared reports if the "profit_account" edge to the ProfitAccount entity was cleared.
func (m *UserMutation) ProfitAccountCleared() bool {
	return m.clearedprofit_account
}

// ProfitAccountID returns the "profit_account" edge ID in the mutation.
func (m *UserMutation) ProfitAccountID() (id int64, exists bool) {
	if m.profit_account != nil {
		return *m.profit_account, true
	}
	return
}

// ProfitAccountIDs returns the "profit_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfitAccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfitAccountIDs() (ids []int64) {
	if id := m.profit_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfitAccount resets all changes to the "profit_account" edge.
func (m *UserMutation) ResetProfitAccount() {
	m.profit_account = nil
	m.clearedprofit_account = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *UserMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *UserMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *UserMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *UserMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *UserMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *UserMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *UserMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *UserMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *UserMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *UserMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *UserMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *UserMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *UserMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *UserMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// AddMissionConsumeOrderIDs adds the "mission_consume_orders" edge to the MissionConsumeOrder entity by ids.
func (m *UserMutation) AddMissionConsumeOrderIDs(ids ...int64) {
	if m.mission_consume_orders == nil {
		m.mission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_consume_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionConsumeOrders clears the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *UserMutation) ClearMissionConsumeOrders() {
	m.clearedmission_consume_orders = true
}

// MissionConsumeOrdersCleared reports if the "mission_consume_orders" edge to the MissionConsumeOrder entity was cleared.
func (m *UserMutation) MissionConsumeOrdersCleared() bool {
	return m.clearedmission_consume_orders
}

// RemoveMissionConsumeOrderIDs removes the "mission_consume_orders" edge to the MissionConsumeOrder entity by IDs.
func (m *UserMutation) RemoveMissionConsumeOrderIDs(ids ...int64) {
	if m.removedmission_consume_orders == nil {
		m.removedmission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_consume_orders, ids[i])
		m.removedmission_consume_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionConsumeOrders returns the removed IDs of the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *UserMutation) RemovedMissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.removedmission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// MissionConsumeOrdersIDs returns the "mission_consume_orders" edge IDs in the mutation.
func (m *UserMutation) MissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.mission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionConsumeOrders resets all changes to the "mission_consume_orders" edge.
func (m *UserMutation) ResetMissionConsumeOrders() {
	m.mission_consume_orders = nil
	m.clearedmission_consume_orders = false
	m.removedmission_consume_orders = nil
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *UserMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *UserMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *UserMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *UserMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *UserMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *UserMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *UserMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// AddRechargeOrderIDs adds the "recharge_orders" edge to the RechargeOrder entity by ids.
func (m *UserMutation) AddRechargeOrderIDs(ids ...int64) {
	if m.recharge_orders == nil {
		m.recharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.recharge_orders[ids[i]] = struct{}{}
	}
}

// ClearRechargeOrders clears the "recharge_orders" edge to the RechargeOrder entity.
func (m *UserMutation) ClearRechargeOrders() {
	m.clearedrecharge_orders = true
}

// RechargeOrdersCleared reports if the "recharge_orders" edge to the RechargeOrder entity was cleared.
func (m *UserMutation) RechargeOrdersCleared() bool {
	return m.clearedrecharge_orders
}

// RemoveRechargeOrderIDs removes the "recharge_orders" edge to the RechargeOrder entity by IDs.
func (m *UserMutation) RemoveRechargeOrderIDs(ids ...int64) {
	if m.removedrecharge_orders == nil {
		m.removedrecharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.recharge_orders, ids[i])
		m.removedrecharge_orders[ids[i]] = struct{}{}
	}
}

// RemovedRechargeOrders returns the removed IDs of the "recharge_orders" edge to the RechargeOrder entity.
func (m *UserMutation) RemovedRechargeOrdersIDs() (ids []int64) {
	for id := range m.removedrecharge_orders {
		ids = append(ids, id)
	}
	return
}

// RechargeOrdersIDs returns the "recharge_orders" edge IDs in the mutation.
func (m *UserMutation) RechargeOrdersIDs() (ids []int64) {
	for id := range m.recharge_orders {
		ids = append(ids, id)
	}
	return
}

// ResetRechargeOrders resets all changes to the "recharge_orders" edge.
func (m *UserMutation) ResetRechargeOrders() {
	m.recharge_orders = nil
	m.clearedrecharge_orders = false
	m.removedrecharge_orders = nil
}

// AddVxSocialIDs adds the "vx_socials" edge to the VXSocial entity by ids.
func (m *UserMutation) AddVxSocialIDs(ids ...int64) {
	if m.vx_socials == nil {
		m.vx_socials = make(map[int64]struct{})
	}
	for i := range ids {
		m.vx_socials[ids[i]] = struct{}{}
	}
}

// ClearVxSocials clears the "vx_socials" edge to the VXSocial entity.
func (m *UserMutation) ClearVxSocials() {
	m.clearedvx_socials = true
}

// VxSocialsCleared reports if the "vx_socials" edge to the VXSocial entity was cleared.
func (m *UserMutation) VxSocialsCleared() bool {
	return m.clearedvx_socials
}

// RemoveVxSocialIDs removes the "vx_socials" edge to the VXSocial entity by IDs.
func (m *UserMutation) RemoveVxSocialIDs(ids ...int64) {
	if m.removedvx_socials == nil {
		m.removedvx_socials = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.vx_socials, ids[i])
		m.removedvx_socials[ids[i]] = struct{}{}
	}
}

// RemovedVxSocials returns the removed IDs of the "vx_socials" edge to the VXSocial entity.
func (m *UserMutation) RemovedVxSocialsIDs() (ids []int64) {
	for id := range m.removedvx_socials {
		ids = append(ids, id)
	}
	return
}

// VxSocialsIDs returns the "vx_socials" edge IDs in the mutation.
func (m *UserMutation) VxSocialsIDs() (ids []int64) {
	for id := range m.vx_socials {
		ids = append(ids, id)
	}
	return
}

// ResetVxSocials resets all changes to the "vx_socials" edge.
func (m *UserMutation) ResetVxSocials() {
	m.vx_socials = nil
	m.clearedvx_socials = false
	m.removedvx_socials = nil
}

// AddMissionBatchIDs adds the "mission_batches" edge to the MissionBatch entity by ids.
func (m *UserMutation) AddMissionBatchIDs(ids ...int64) {
	if m.mission_batches == nil {
		m.mission_batches = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_batches[ids[i]] = struct{}{}
	}
}

// ClearMissionBatches clears the "mission_batches" edge to the MissionBatch entity.
func (m *UserMutation) ClearMissionBatches() {
	m.clearedmission_batches = true
}

// MissionBatchesCleared reports if the "mission_batches" edge to the MissionBatch entity was cleared.
func (m *UserMutation) MissionBatchesCleared() bool {
	return m.clearedmission_batches
}

// RemoveMissionBatchIDs removes the "mission_batches" edge to the MissionBatch entity by IDs.
func (m *UserMutation) RemoveMissionBatchIDs(ids ...int64) {
	if m.removedmission_batches == nil {
		m.removedmission_batches = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_batches, ids[i])
		m.removedmission_batches[ids[i]] = struct{}{}
	}
}

// RemovedMissionBatches returns the removed IDs of the "mission_batches" edge to the MissionBatch entity.
func (m *UserMutation) RemovedMissionBatchesIDs() (ids []int64) {
	for id := range m.removedmission_batches {
		ids = append(ids, id)
	}
	return
}

// MissionBatchesIDs returns the "mission_batches" edge IDs in the mutation.
func (m *UserMutation) MissionBatchesIDs() (ids []int64) {
	for id := range m.mission_batches {
		ids = append(ids, id)
	}
	return
}

// ResetMissionBatches resets all changes to the "mission_batches" edge.
func (m *UserMutation) ResetMissionBatches() {
	m.mission_batches = nil
	m.clearedmission_batches = false
	m.removedmission_batches = nil
}

// AddUserDeviceIDs adds the "user_devices" edge to the UserDevice entity by ids.
func (m *UserMutation) AddUserDeviceIDs(ids ...int64) {
	if m.user_devices == nil {
		m.user_devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_devices[ids[i]] = struct{}{}
	}
}

// ClearUserDevices clears the "user_devices" edge to the UserDevice entity.
func (m *UserMutation) ClearUserDevices() {
	m.cleareduser_devices = true
}

// UserDevicesCleared reports if the "user_devices" edge to the UserDevice entity was cleared.
func (m *UserMutation) UserDevicesCleared() bool {
	return m.cleareduser_devices
}

// RemoveUserDeviceIDs removes the "user_devices" edge to the UserDevice entity by IDs.
func (m *UserMutation) RemoveUserDeviceIDs(ids ...int64) {
	if m.removeduser_devices == nil {
		m.removeduser_devices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_devices, ids[i])
		m.removeduser_devices[ids[i]] = struct{}{}
	}
}

// RemovedUserDevices returns the removed IDs of the "user_devices" edge to the UserDevice entity.
func (m *UserMutation) RemovedUserDevicesIDs() (ids []int64) {
	for id := range m.removeduser_devices {
		ids = append(ids, id)
	}
	return
}

// UserDevicesIDs returns the "user_devices" edge IDs in the mutation.
func (m *UserMutation) UserDevicesIDs() (ids []int64) {
	for id := range m.user_devices {
		ids = append(ids, id)
	}
	return
}

// ResetUserDevices resets all changes to the "user_devices" edge.
func (m *UserMutation) ResetUserDevices() {
	m.user_devices = nil
	m.cleareduser_devices = false
	m.removeduser_devices = nil
}

// ClearParent clears the "parent" edge to the User entity.
func (m *UserMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[user.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the User entity was cleared.
func (m *UserMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *UserMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the User entity by ids.
func (m *UserMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the User entity.
func (m *UserMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the User entity was cleared.
func (m *UserMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the User entity by IDs.
func (m *UserMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the User entity.
func (m *UserMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *UserMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *UserMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearAppletParent clears the "applet_parent" edge to the User entity.
func (m *UserMutation) ClearAppletParent() {
	m.clearedapplet_parent = true
	m.clearedFields[user.FieldAppletParentID] = struct{}{}
}

// AppletParentCleared reports if the "applet_parent" edge to the User entity was cleared.
func (m *UserMutation) AppletParentCleared() bool {
	return m.clearedapplet_parent
}

// AppletParentIDs returns the "applet_parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppletParentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AppletParentIDs() (ids []int64) {
	if id := m.applet_parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppletParent resets all changes to the "applet_parent" edge.
func (m *UserMutation) ResetAppletParent() {
	m.applet_parent = nil
	m.clearedapplet_parent = false
}

// AddAppletChildIDs adds the "applet_children" edge to the User entity by ids.
func (m *UserMutation) AddAppletChildIDs(ids ...int64) {
	if m.applet_children == nil {
		m.applet_children = make(map[int64]struct{})
	}
	for i := range ids {
		m.applet_children[ids[i]] = struct{}{}
	}
}

// ClearAppletChildren clears the "applet_children" edge to the User entity.
func (m *UserMutation) ClearAppletChildren() {
	m.clearedapplet_children = true
}

// AppletChildrenCleared reports if the "applet_children" edge to the User entity was cleared.
func (m *UserMutation) AppletChildrenCleared() bool {
	return m.clearedapplet_children
}

// RemoveAppletChildIDs removes the "applet_children" edge to the User entity by IDs.
func (m *UserMutation) RemoveAppletChildIDs(ids ...int64) {
	if m.removedapplet_children == nil {
		m.removedapplet_children = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.applet_children, ids[i])
		m.removedapplet_children[ids[i]] = struct{}{}
	}
}

// RemovedAppletChildren returns the removed IDs of the "applet_children" edge to the User entity.
func (m *UserMutation) RemovedAppletChildrenIDs() (ids []int64) {
	for id := range m.removedapplet_children {
		ids = append(ids, id)
	}
	return
}

// AppletChildrenIDs returns the "applet_children" edge IDs in the mutation.
func (m *UserMutation) AppletChildrenIDs() (ids []int64) {
	for id := range m.applet_children {
		ids = append(ids, id)
	}
	return
}

// ResetAppletChildren resets all changes to the "applet_children" edge.
func (m *UserMutation) ResetAppletChildren() {
	m.applet_children = nil
	m.clearedapplet_children = false
	m.removedapplet_children = nil
}

// AddInviteIDs adds the "invites" edge to the Invite entity by ids.
func (m *UserMutation) AddInviteIDs(ids ...int64) {
	if m.invites == nil {
		m.invites = make(map[int64]struct{})
	}
	for i := range ids {
		m.invites[ids[i]] = struct{}{}
	}
}

// ClearInvites clears the "invites" edge to the Invite entity.
func (m *UserMutation) ClearInvites() {
	m.clearedinvites = true
}

// InvitesCleared reports if the "invites" edge to the Invite entity was cleared.
func (m *UserMutation) InvitesCleared() bool {
	return m.clearedinvites
}

// RemoveInviteIDs removes the "invites" edge to the Invite entity by IDs.
func (m *UserMutation) RemoveInviteIDs(ids ...int64) {
	if m.removedinvites == nil {
		m.removedinvites = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invites, ids[i])
		m.removedinvites[ids[i]] = struct{}{}
	}
}

// RemovedInvites returns the removed IDs of the "invites" edge to the Invite entity.
func (m *UserMutation) RemovedInvitesIDs() (ids []int64) {
	for id := range m.removedinvites {
		ids = append(ids, id)
	}
	return
}

// InvitesIDs returns the "invites" edge IDs in the mutation.
func (m *UserMutation) InvitesIDs() (ids []int64) {
	for id := range m.invites {
		ids = append(ids, id)
	}
	return
}

// ResetInvites resets all changes to the "invites" edge.
func (m *UserMutation) ResetInvites() {
	m.invites = nil
	m.clearedinvites = false
	m.removedinvites = nil
}

// AddCampaignOrderIDs adds the "campaign_orders" edge to the CampaignOrder entity by ids.
func (m *UserMutation) AddCampaignOrderIDs(ids ...int64) {
	if m.campaign_orders == nil {
		m.campaign_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.campaign_orders[ids[i]] = struct{}{}
	}
}

// ClearCampaignOrders clears the "campaign_orders" edge to the CampaignOrder entity.
func (m *UserMutation) ClearCampaignOrders() {
	m.clearedcampaign_orders = true
}

// CampaignOrdersCleared reports if the "campaign_orders" edge to the CampaignOrder entity was cleared.
func (m *UserMutation) CampaignOrdersCleared() bool {
	return m.clearedcampaign_orders
}

// RemoveCampaignOrderIDs removes the "campaign_orders" edge to the CampaignOrder entity by IDs.
func (m *UserMutation) RemoveCampaignOrderIDs(ids ...int64) {
	if m.removedcampaign_orders == nil {
		m.removedcampaign_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.campaign_orders, ids[i])
		m.removedcampaign_orders[ids[i]] = struct{}{}
	}
}

// RemovedCampaignOrders returns the removed IDs of the "campaign_orders" edge to the CampaignOrder entity.
func (m *UserMutation) RemovedCampaignOrdersIDs() (ids []int64) {
	for id := range m.removedcampaign_orders {
		ids = append(ids, id)
	}
	return
}

// CampaignOrdersIDs returns the "campaign_orders" edge IDs in the mutation.
func (m *UserMutation) CampaignOrdersIDs() (ids []int64) {
	for id := range m.campaign_orders {
		ids = append(ids, id)
	}
	return
}

// ResetCampaignOrders resets all changes to the "campaign_orders" edge.
func (m *UserMutation) ResetCampaignOrders() {
	m.campaign_orders = nil
	m.clearedcampaign_orders = false
	m.removedcampaign_orders = nil
}

// AddWalletIDs adds the "wallets" edge to the Wallet entity by ids.
func (m *UserMutation) AddWalletIDs(ids ...int64) {
	if m.wallets == nil {
		m.wallets = make(map[int64]struct{})
	}
	for i := range ids {
		m.wallets[ids[i]] = struct{}{}
	}
}

// ClearWallets clears the "wallets" edge to the Wallet entity.
func (m *UserMutation) ClearWallets() {
	m.clearedwallets = true
}

// WalletsCleared reports if the "wallets" edge to the Wallet entity was cleared.
func (m *UserMutation) WalletsCleared() bool {
	return m.clearedwallets
}

// RemoveWalletIDs removes the "wallets" edge to the Wallet entity by IDs.
func (m *UserMutation) RemoveWalletIDs(ids ...int64) {
	if m.removedwallets == nil {
		m.removedwallets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.wallets, ids[i])
		m.removedwallets[ids[i]] = struct{}{}
	}
}

// RemovedWallets returns the removed IDs of the "wallets" edge to the Wallet entity.
func (m *UserMutation) RemovedWalletsIDs() (ids []int64) {
	for id := range m.removedwallets {
		ids = append(ids, id)
	}
	return
}

// WalletsIDs returns the "wallets" edge IDs in the mutation.
func (m *UserMutation) WalletsIDs() (ids []int64) {
	for id := range m.wallets {
		ids = append(ids, id)
	}
	return
}

// ResetWallets resets all changes to the "wallets" edge.
func (m *UserMutation) ResetWallets() {
	m.wallets = nil
	m.clearedwallets = false
	m.removedwallets = nil
}

// SetWithdrawAccountID sets the "withdraw_account" edge to the WithdrawAccount entity by id.
func (m *UserMutation) SetWithdrawAccountID(id int64) {
	m.withdraw_account = &id
}

// ClearWithdrawAccount clears the "withdraw_account" edge to the WithdrawAccount entity.
func (m *UserMutation) ClearWithdrawAccount() {
	m.clearedwithdraw_account = true
}

// WithdrawAccountCleared reports if the "withdraw_account" edge to the WithdrawAccount entity was cleared.
func (m *UserMutation) WithdrawAccountCleared() bool {
	return m.clearedwithdraw_account
}

// WithdrawAccountID returns the "withdraw_account" edge ID in the mutation.
func (m *UserMutation) WithdrawAccountID() (id int64, exists bool) {
	if m.withdraw_account != nil {
		return *m.withdraw_account, true
	}
	return
}

// WithdrawAccountIDs returns the "withdraw_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WithdrawAccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) WithdrawAccountIDs() (ids []int64) {
	if id := m.withdraw_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWithdrawAccount resets all changes to the "withdraw_account" edge.
func (m *UserMutation) ResetWithdrawAccount() {
	m.withdraw_account = nil
	m.clearedwithdraw_account = false
}

// AddIncomeBillIDs adds the "income_bills" edge to the Bill entity by ids.
func (m *UserMutation) AddIncomeBillIDs(ids ...int64) {
	if m.income_bills == nil {
		m.income_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.income_bills[ids[i]] = struct{}{}
	}
}

// ClearIncomeBills clears the "income_bills" edge to the Bill entity.
func (m *UserMutation) ClearIncomeBills() {
	m.clearedincome_bills = true
}

// IncomeBillsCleared reports if the "income_bills" edge to the Bill entity was cleared.
func (m *UserMutation) IncomeBillsCleared() bool {
	return m.clearedincome_bills
}

// RemoveIncomeBillIDs removes the "income_bills" edge to the Bill entity by IDs.
func (m *UserMutation) RemoveIncomeBillIDs(ids ...int64) {
	if m.removedincome_bills == nil {
		m.removedincome_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.income_bills, ids[i])
		m.removedincome_bills[ids[i]] = struct{}{}
	}
}

// RemovedIncomeBills returns the removed IDs of the "income_bills" edge to the Bill entity.
func (m *UserMutation) RemovedIncomeBillsIDs() (ids []int64) {
	for id := range m.removedincome_bills {
		ids = append(ids, id)
	}
	return
}

// IncomeBillsIDs returns the "income_bills" edge IDs in the mutation.
func (m *UserMutation) IncomeBillsIDs() (ids []int64) {
	for id := range m.income_bills {
		ids = append(ids, id)
	}
	return
}

// ResetIncomeBills resets all changes to the "income_bills" edge.
func (m *UserMutation) ResetIncomeBills() {
	m.income_bills = nil
	m.clearedincome_bills = false
	m.removedincome_bills = nil
}

// AddOutcomeBillIDs adds the "outcome_bills" edge to the Bill entity by ids.
func (m *UserMutation) AddOutcomeBillIDs(ids ...int64) {
	if m.outcome_bills == nil {
		m.outcome_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.outcome_bills[ids[i]] = struct{}{}
	}
}

// ClearOutcomeBills clears the "outcome_bills" edge to the Bill entity.
func (m *UserMutation) ClearOutcomeBills() {
	m.clearedoutcome_bills = true
}

// OutcomeBillsCleared reports if the "outcome_bills" edge to the Bill entity was cleared.
func (m *UserMutation) OutcomeBillsCleared() bool {
	return m.clearedoutcome_bills
}

// RemoveOutcomeBillIDs removes the "outcome_bills" edge to the Bill entity by IDs.
func (m *UserMutation) RemoveOutcomeBillIDs(ids ...int64) {
	if m.removedoutcome_bills == nil {
		m.removedoutcome_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.outcome_bills, ids[i])
		m.removedoutcome_bills[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeBills returns the removed IDs of the "outcome_bills" edge to the Bill entity.
func (m *UserMutation) RemovedOutcomeBillsIDs() (ids []int64) {
	for id := range m.removedoutcome_bills {
		ids = append(ids, id)
	}
	return
}

// OutcomeBillsIDs returns the "outcome_bills" edge IDs in the mutation.
func (m *UserMutation) OutcomeBillsIDs() (ids []int64) {
	for id := range m.outcome_bills {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeBills resets all changes to the "outcome_bills" edge.
func (m *UserMutation) ResetOutcomeBills() {
	m.outcome_bills = nil
	m.clearedoutcome_bills = false
	m.removedoutcome_bills = nil
}

// AddMissionProductionIDs adds the "mission_productions" edge to the MissionProduction entity by ids.
func (m *UserMutation) AddMissionProductionIDs(ids ...int64) {
	if m.mission_productions == nil {
		m.mission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_productions[ids[i]] = struct{}{}
	}
}

// ClearMissionProductions clears the "mission_productions" edge to the MissionProduction entity.
func (m *UserMutation) ClearMissionProductions() {
	m.clearedmission_productions = true
}

// MissionProductionsCleared reports if the "mission_productions" edge to the MissionProduction entity was cleared.
func (m *UserMutation) MissionProductionsCleared() bool {
	return m.clearedmission_productions
}

// RemoveMissionProductionIDs removes the "mission_productions" edge to the MissionProduction entity by IDs.
func (m *UserMutation) RemoveMissionProductionIDs(ids ...int64) {
	if m.removedmission_productions == nil {
		m.removedmission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_productions, ids[i])
		m.removedmission_productions[ids[i]] = struct{}{}
	}
}

// RemovedMissionProductions returns the removed IDs of the "mission_productions" edge to the MissionProduction entity.
func (m *UserMutation) RemovedMissionProductionsIDs() (ids []int64) {
	for id := range m.removedmission_productions {
		ids = append(ids, id)
	}
	return
}

// MissionProductionsIDs returns the "mission_productions" edge IDs in the mutation.
func (m *UserMutation) MissionProductionsIDs() (ids []int64) {
	for id := range m.mission_productions {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProductions resets all changes to the "mission_productions" edge.
func (m *UserMutation) ResetMissionProductions() {
	m.mission_productions = nil
	m.clearedmission_productions = false
	m.removedmission_productions = nil
}

// AddMissionIDs adds the "missions" edge to the Mission entity by ids.
func (m *UserMutation) AddMissionIDs(ids ...int64) {
	if m.missions == nil {
		m.missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.missions[ids[i]] = struct{}{}
	}
}

// ClearMissions clears the "missions" edge to the Mission entity.
func (m *UserMutation) ClearMissions() {
	m.clearedmissions = true
}

// MissionsCleared reports if the "missions" edge to the Mission entity was cleared.
func (m *UserMutation) MissionsCleared() bool {
	return m.clearedmissions
}

// RemoveMissionIDs removes the "missions" edge to the Mission entity by IDs.
func (m *UserMutation) RemoveMissionIDs(ids ...int64) {
	if m.removedmissions == nil {
		m.removedmissions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.missions, ids[i])
		m.removedmissions[ids[i]] = struct{}{}
	}
}

// RemovedMissions returns the removed IDs of the "missions" edge to the Mission entity.
func (m *UserMutation) RemovedMissionsIDs() (ids []int64) {
	for id := range m.removedmissions {
		ids = append(ids, id)
	}
	return
}

// MissionsIDs returns the "missions" edge IDs in the mutation.
func (m *UserMutation) MissionsIDs() (ids []int64) {
	for id := range m.missions {
		ids = append(ids, id)
	}
	return
}

// ResetMissions resets all changes to the "missions" edge.
func (m *UserMutation) ResetMissions() {
	m.missions = nil
	m.clearedmissions = false
	m.removedmissions = nil
}

// AddIncomeTransferOrderIDs adds the "income_transfer_orders" edge to the TransferOrder entity by ids.
func (m *UserMutation) AddIncomeTransferOrderIDs(ids ...int64) {
	if m.income_transfer_orders == nil {
		m.income_transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.income_transfer_orders[ids[i]] = struct{}{}
	}
}

// ClearIncomeTransferOrders clears the "income_transfer_orders" edge to the TransferOrder entity.
func (m *UserMutation) ClearIncomeTransferOrders() {
	m.clearedincome_transfer_orders = true
}

// IncomeTransferOrdersCleared reports if the "income_transfer_orders" edge to the TransferOrder entity was cleared.
func (m *UserMutation) IncomeTransferOrdersCleared() bool {
	return m.clearedincome_transfer_orders
}

// RemoveIncomeTransferOrderIDs removes the "income_transfer_orders" edge to the TransferOrder entity by IDs.
func (m *UserMutation) RemoveIncomeTransferOrderIDs(ids ...int64) {
	if m.removedincome_transfer_orders == nil {
		m.removedincome_transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.income_transfer_orders, ids[i])
		m.removedincome_transfer_orders[ids[i]] = struct{}{}
	}
}

// RemovedIncomeTransferOrders returns the removed IDs of the "income_transfer_orders" edge to the TransferOrder entity.
func (m *UserMutation) RemovedIncomeTransferOrdersIDs() (ids []int64) {
	for id := range m.removedincome_transfer_orders {
		ids = append(ids, id)
	}
	return
}

// IncomeTransferOrdersIDs returns the "income_transfer_orders" edge IDs in the mutation.
func (m *UserMutation) IncomeTransferOrdersIDs() (ids []int64) {
	for id := range m.income_transfer_orders {
		ids = append(ids, id)
	}
	return
}

// ResetIncomeTransferOrders resets all changes to the "income_transfer_orders" edge.
func (m *UserMutation) ResetIncomeTransferOrders() {
	m.income_transfer_orders = nil
	m.clearedincome_transfer_orders = false
	m.removedincome_transfer_orders = nil
}

// AddOutcomeTransferOrderIDs adds the "outcome_transfer_orders" edge to the TransferOrder entity by ids.
func (m *UserMutation) AddOutcomeTransferOrderIDs(ids ...int64) {
	if m.outcome_transfer_orders == nil {
		m.outcome_transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.outcome_transfer_orders[ids[i]] = struct{}{}
	}
}

// ClearOutcomeTransferOrders clears the "outcome_transfer_orders" edge to the TransferOrder entity.
func (m *UserMutation) ClearOutcomeTransferOrders() {
	m.clearedoutcome_transfer_orders = true
}

// OutcomeTransferOrdersCleared reports if the "outcome_transfer_orders" edge to the TransferOrder entity was cleared.
func (m *UserMutation) OutcomeTransferOrdersCleared() bool {
	return m.clearedoutcome_transfer_orders
}

// RemoveOutcomeTransferOrderIDs removes the "outcome_transfer_orders" edge to the TransferOrder entity by IDs.
func (m *UserMutation) RemoveOutcomeTransferOrderIDs(ids ...int64) {
	if m.removedoutcome_transfer_orders == nil {
		m.removedoutcome_transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.outcome_transfer_orders, ids[i])
		m.removedoutcome_transfer_orders[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeTransferOrders returns the removed IDs of the "outcome_transfer_orders" edge to the TransferOrder entity.
func (m *UserMutation) RemovedOutcomeTransferOrdersIDs() (ids []int64) {
	for id := range m.removedoutcome_transfer_orders {
		ids = append(ids, id)
	}
	return
}

// OutcomeTransferOrdersIDs returns the "outcome_transfer_orders" edge IDs in the mutation.
func (m *UserMutation) OutcomeTransferOrdersIDs() (ids []int64) {
	for id := range m.outcome_transfer_orders {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeTransferOrders resets all changes to the "outcome_transfer_orders" edge.
func (m *UserMutation) ResetOutcomeTransferOrders() {
	m.outcome_transfer_orders = nil
	m.clearedoutcome_transfer_orders = false
	m.removedoutcome_transfer_orders = nil
}

// AddConsumeMissionOrderIDs adds the "consume_mission_orders" edge to the MissionOrder entity by ids.
func (m *UserMutation) AddConsumeMissionOrderIDs(ids ...int64) {
	if m.consume_mission_orders == nil {
		m.consume_mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.consume_mission_orders[ids[i]] = struct{}{}
	}
}

// ClearConsumeMissionOrders clears the "consume_mission_orders" edge to the MissionOrder entity.
func (m *UserMutation) ClearConsumeMissionOrders() {
	m.clearedconsume_mission_orders = true
}

// ConsumeMissionOrdersCleared reports if the "consume_mission_orders" edge to the MissionOrder entity was cleared.
func (m *UserMutation) ConsumeMissionOrdersCleared() bool {
	return m.clearedconsume_mission_orders
}

// RemoveConsumeMissionOrderIDs removes the "consume_mission_orders" edge to the MissionOrder entity by IDs.
func (m *UserMutation) RemoveConsumeMissionOrderIDs(ids ...int64) {
	if m.removedconsume_mission_orders == nil {
		m.removedconsume_mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.consume_mission_orders, ids[i])
		m.removedconsume_mission_orders[ids[i]] = struct{}{}
	}
}

// RemovedConsumeMissionOrders returns the removed IDs of the "consume_mission_orders" edge to the MissionOrder entity.
func (m *UserMutation) RemovedConsumeMissionOrdersIDs() (ids []int64) {
	for id := range m.removedconsume_mission_orders {
		ids = append(ids, id)
	}
	return
}

// ConsumeMissionOrdersIDs returns the "consume_mission_orders" edge IDs in the mutation.
func (m *UserMutation) ConsumeMissionOrdersIDs() (ids []int64) {
	for id := range m.consume_mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetConsumeMissionOrders resets all changes to the "consume_mission_orders" edge.
func (m *UserMutation) ResetConsumeMissionOrders() {
	m.consume_mission_orders = nil
	m.clearedconsume_mission_orders = false
	m.removedconsume_mission_orders = nil
}

// AddProduceMissionOrderIDs adds the "produce_mission_orders" edge to the MissionOrder entity by ids.
func (m *UserMutation) AddProduceMissionOrderIDs(ids ...int64) {
	if m.produce_mission_orders == nil {
		m.produce_mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.produce_mission_orders[ids[i]] = struct{}{}
	}
}

// ClearProduceMissionOrders clears the "produce_mission_orders" edge to the MissionOrder entity.
func (m *UserMutation) ClearProduceMissionOrders() {
	m.clearedproduce_mission_orders = true
}

// ProduceMissionOrdersCleared reports if the "produce_mission_orders" edge to the MissionOrder entity was cleared.
func (m *UserMutation) ProduceMissionOrdersCleared() bool {
	return m.clearedproduce_mission_orders
}

// RemoveProduceMissionOrderIDs removes the "produce_mission_orders" edge to the MissionOrder entity by IDs.
func (m *UserMutation) RemoveProduceMissionOrderIDs(ids ...int64) {
	if m.removedproduce_mission_orders == nil {
		m.removedproduce_mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.produce_mission_orders, ids[i])
		m.removedproduce_mission_orders[ids[i]] = struct{}{}
	}
}

// RemovedProduceMissionOrders returns the removed IDs of the "produce_mission_orders" edge to the MissionOrder entity.
func (m *UserMutation) RemovedProduceMissionOrdersIDs() (ids []int64) {
	for id := range m.removedproduce_mission_orders {
		ids = append(ids, id)
	}
	return
}

// ProduceMissionOrdersIDs returns the "produce_mission_orders" edge IDs in the mutation.
func (m *UserMutation) ProduceMissionOrdersIDs() (ids []int64) {
	for id := range m.produce_mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetProduceMissionOrders resets all changes to the "produce_mission_orders" edge.
func (m *UserMutation) ResetProduceMissionOrders() {
	m.produce_mission_orders = nil
	m.clearedproduce_mission_orders = false
	m.removedproduce_mission_orders = nil
}

// AddLoginRecordIDs adds the "login_records" edge to the LoginRecord entity by ids.
func (m *UserMutation) AddLoginRecordIDs(ids ...int64) {
	if m.login_records == nil {
		m.login_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.login_records[ids[i]] = struct{}{}
	}
}

// ClearLoginRecords clears the "login_records" edge to the LoginRecord entity.
func (m *UserMutation) ClearLoginRecords() {
	m.clearedlogin_records = true
}

// LoginRecordsCleared reports if the "login_records" edge to the LoginRecord entity was cleared.
func (m *UserMutation) LoginRecordsCleared() bool {
	return m.clearedlogin_records
}

// RemoveLoginRecordIDs removes the "login_records" edge to the LoginRecord entity by IDs.
func (m *UserMutation) RemoveLoginRecordIDs(ids ...int64) {
	if m.removedlogin_records == nil {
		m.removedlogin_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.login_records, ids[i])
		m.removedlogin_records[ids[i]] = struct{}{}
	}
}

// RemovedLoginRecords returns the removed IDs of the "login_records" edge to the LoginRecord entity.
func (m *UserMutation) RemovedLoginRecordsIDs() (ids []int64) {
	for id := range m.removedlogin_records {
		ids = append(ids, id)
	}
	return
}

// LoginRecordsIDs returns the "login_records" edge IDs in the mutation.
func (m *UserMutation) LoginRecordsIDs() (ids []int64) {
	for id := range m.login_records {
		ids = append(ids, id)
	}
	return
}

// ResetLoginRecords resets all changes to the "login_records" edge.
func (m *UserMutation) ResetLoginRecords() {
	m.login_records = nil
	m.clearedlogin_records = false
	m.removedlogin_records = nil
}

// AddRenewalAgreementIDs adds the "renewal_agreements" edge to the RenewalAgreement entity by ids.
func (m *UserMutation) AddRenewalAgreementIDs(ids ...int64) {
	if m.renewal_agreements == nil {
		m.renewal_agreements = make(map[int64]struct{})
	}
	for i := range ids {
		m.renewal_agreements[ids[i]] = struct{}{}
	}
}

// ClearRenewalAgreements clears the "renewal_agreements" edge to the RenewalAgreement entity.
func (m *UserMutation) ClearRenewalAgreements() {
	m.clearedrenewal_agreements = true
}

// RenewalAgreementsCleared reports if the "renewal_agreements" edge to the RenewalAgreement entity was cleared.
func (m *UserMutation) RenewalAgreementsCleared() bool {
	return m.clearedrenewal_agreements
}

// RemoveRenewalAgreementIDs removes the "renewal_agreements" edge to the RenewalAgreement entity by IDs.
func (m *UserMutation) RemoveRenewalAgreementIDs(ids ...int64) {
	if m.removedrenewal_agreements == nil {
		m.removedrenewal_agreements = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.renewal_agreements, ids[i])
		m.removedrenewal_agreements[ids[i]] = struct{}{}
	}
}

// RemovedRenewalAgreements returns the removed IDs of the "renewal_agreements" edge to the RenewalAgreement entity.
func (m *UserMutation) RemovedRenewalAgreementsIDs() (ids []int64) {
	for id := range m.removedrenewal_agreements {
		ids = append(ids, id)
	}
	return
}

// RenewalAgreementsIDs returns the "renewal_agreements" edge IDs in the mutation.
func (m *UserMutation) RenewalAgreementsIDs() (ids []int64) {
	for id := range m.renewal_agreements {
		ids = append(ids, id)
	}
	return
}

// ResetRenewalAgreements resets all changes to the "renewal_agreements" edge.
func (m *UserMutation) ResetRenewalAgreements() {
	m.renewal_agreements = nil
	m.clearedrenewal_agreements = false
	m.removedrenewal_agreements = nil
}

// AddArtworkIDs adds the "artworks" edge to the Artwork entity by ids.
func (m *UserMutation) AddArtworkIDs(ids ...int64) {
	if m.artworks == nil {
		m.artworks = make(map[int64]struct{})
	}
	for i := range ids {
		m.artworks[ids[i]] = struct{}{}
	}
}

// ClearArtworks clears the "artworks" edge to the Artwork entity.
func (m *UserMutation) ClearArtworks() {
	m.clearedartworks = true
}

// ArtworksCleared reports if the "artworks" edge to the Artwork entity was cleared.
func (m *UserMutation) ArtworksCleared() bool {
	return m.clearedartworks
}

// RemoveArtworkIDs removes the "artworks" edge to the Artwork entity by IDs.
func (m *UserMutation) RemoveArtworkIDs(ids ...int64) {
	if m.removedartworks == nil {
		m.removedartworks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.artworks, ids[i])
		m.removedartworks[ids[i]] = struct{}{}
	}
}

// RemovedArtworks returns the removed IDs of the "artworks" edge to the Artwork entity.
func (m *UserMutation) RemovedArtworksIDs() (ids []int64) {
	for id := range m.removedartworks {
		ids = append(ids, id)
	}
	return
}

// ArtworksIDs returns the "artworks" edge IDs in the mutation.
func (m *UserMutation) ArtworksIDs() (ids []int64) {
	for id := range m.artworks {
		ids = append(ids, id)
	}
	return
}

// ResetArtworks resets all changes to the "artworks" edge.
func (m *UserMutation) ResetArtworks() {
	m.artworks = nil
	m.clearedartworks = false
	m.removedartworks = nil
}

// AddArtworkLikeIDs adds the "artwork_likes" edge to the ArtworkLike entity by ids.
func (m *UserMutation) AddArtworkLikeIDs(ids ...int64) {
	if m.artwork_likes == nil {
		m.artwork_likes = make(map[int64]struct{})
	}
	for i := range ids {
		m.artwork_likes[ids[i]] = struct{}{}
	}
}

// ClearArtworkLikes clears the "artwork_likes" edge to the ArtworkLike entity.
func (m *UserMutation) ClearArtworkLikes() {
	m.clearedartwork_likes = true
}

// ArtworkLikesCleared reports if the "artwork_likes" edge to the ArtworkLike entity was cleared.
func (m *UserMutation) ArtworkLikesCleared() bool {
	return m.clearedartwork_likes
}

// RemoveArtworkLikeIDs removes the "artwork_likes" edge to the ArtworkLike entity by IDs.
func (m *UserMutation) RemoveArtworkLikeIDs(ids ...int64) {
	if m.removedartwork_likes == nil {
		m.removedartwork_likes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.artwork_likes, ids[i])
		m.removedartwork_likes[ids[i]] = struct{}{}
	}
}

// RemovedArtworkLikes returns the removed IDs of the "artwork_likes" edge to the ArtworkLike entity.
func (m *UserMutation) RemovedArtworkLikesIDs() (ids []int64) {
	for id := range m.removedartwork_likes {
		ids = append(ids, id)
	}
	return
}

// ArtworkLikesIDs returns the "artwork_likes" edge IDs in the mutation.
func (m *UserMutation) ArtworkLikesIDs() (ids []int64) {
	for id := range m.artwork_likes {
		ids = append(ids, id)
	}
	return
}

// ResetArtworkLikes resets all changes to the "artwork_likes" edge.
func (m *UserMutation) ResetArtworkLikes() {
	m.artwork_likes = nil
	m.clearedartwork_likes = false
	m.removedartwork_likes = nil
}

// AddCdkInfoIDs adds the "cdk_infos" edge to the CDKInfo entity by ids.
func (m *UserMutation) AddCdkInfoIDs(ids ...int64) {
	if m.cdk_infos == nil {
		m.cdk_infos = make(map[int64]struct{})
	}
	for i := range ids {
		m.cdk_infos[ids[i]] = struct{}{}
	}
}

// ClearCdkInfos clears the "cdk_infos" edge to the CDKInfo entity.
func (m *UserMutation) ClearCdkInfos() {
	m.clearedcdk_infos = true
}

// CdkInfosCleared reports if the "cdk_infos" edge to the CDKInfo entity was cleared.
func (m *UserMutation) CdkInfosCleared() bool {
	return m.clearedcdk_infos
}

// RemoveCdkInfoIDs removes the "cdk_infos" edge to the CDKInfo entity by IDs.
func (m *UserMutation) RemoveCdkInfoIDs(ids ...int64) {
	if m.removedcdk_infos == nil {
		m.removedcdk_infos = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cdk_infos, ids[i])
		m.removedcdk_infos[ids[i]] = struct{}{}
	}
}

// RemovedCdkInfos returns the removed IDs of the "cdk_infos" edge to the CDKInfo entity.
func (m *UserMutation) RemovedCdkInfosIDs() (ids []int64) {
	for id := range m.removedcdk_infos {
		ids = append(ids, id)
	}
	return
}

// CdkInfosIDs returns the "cdk_infos" edge IDs in the mutation.
func (m *UserMutation) CdkInfosIDs() (ids []int64) {
	for id := range m.cdk_infos {
		ids = append(ids, id)
	}
	return
}

// ResetCdkInfos resets all changes to the "cdk_infos" edge.
func (m *UserMutation) ResetCdkInfos() {
	m.cdk_infos = nil
	m.clearedcdk_infos = false
	m.removedcdk_infos = nil
}

// AddUseCdkInfoIDs adds the "use_cdk_infos" edge to the CDKInfo entity by ids.
func (m *UserMutation) AddUseCdkInfoIDs(ids ...int64) {
	if m.use_cdk_infos == nil {
		m.use_cdk_infos = make(map[int64]struct{})
	}
	for i := range ids {
		m.use_cdk_infos[ids[i]] = struct{}{}
	}
}

// ClearUseCdkInfos clears the "use_cdk_infos" edge to the CDKInfo entity.
func (m *UserMutation) ClearUseCdkInfos() {
	m.cleareduse_cdk_infos = true
}

// UseCdkInfosCleared reports if the "use_cdk_infos" edge to the CDKInfo entity was cleared.
func (m *UserMutation) UseCdkInfosCleared() bool {
	return m.cleareduse_cdk_infos
}

// RemoveUseCdkInfoIDs removes the "use_cdk_infos" edge to the CDKInfo entity by IDs.
func (m *UserMutation) RemoveUseCdkInfoIDs(ids ...int64) {
	if m.removeduse_cdk_infos == nil {
		m.removeduse_cdk_infos = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.use_cdk_infos, ids[i])
		m.removeduse_cdk_infos[ids[i]] = struct{}{}
	}
}

// RemovedUseCdkInfos returns the removed IDs of the "use_cdk_infos" edge to the CDKInfo entity.
func (m *UserMutation) RemovedUseCdkInfosIDs() (ids []int64) {
	for id := range m.removeduse_cdk_infos {
		ids = append(ids, id)
	}
	return
}

// UseCdkInfosIDs returns the "use_cdk_infos" edge IDs in the mutation.
func (m *UserMutation) UseCdkInfosIDs() (ids []int64) {
	for id := range m.use_cdk_infos {
		ids = append(ids, id)
	}
	return
}

// ResetUseCdkInfos resets all changes to the "use_cdk_infos" edge.
func (m *UserMutation) ResetUseCdkInfos() {
	m.use_cdk_infos = nil
	m.cleareduse_cdk_infos = false
	m.removeduse_cdk_infos = nil
}

// AddLottoRecordIDs adds the "lotto_records" edge to the LottoRecord entity by ids.
func (m *UserMutation) AddLottoRecordIDs(ids ...int64) {
	if m.lotto_records == nil {
		m.lotto_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.lotto_records[ids[i]] = struct{}{}
	}
}

// ClearLottoRecords clears the "lotto_records" edge to the LottoRecord entity.
func (m *UserMutation) ClearLottoRecords() {
	m.clearedlotto_records = true
}

// LottoRecordsCleared reports if the "lotto_records" edge to the LottoRecord entity was cleared.
func (m *UserMutation) LottoRecordsCleared() bool {
	return m.clearedlotto_records
}

// RemoveLottoRecordIDs removes the "lotto_records" edge to the LottoRecord entity by IDs.
func (m *UserMutation) RemoveLottoRecordIDs(ids ...int64) {
	if m.removedlotto_records == nil {
		m.removedlotto_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lotto_records, ids[i])
		m.removedlotto_records[ids[i]] = struct{}{}
	}
}

// RemovedLottoRecords returns the removed IDs of the "lotto_records" edge to the LottoRecord entity.
func (m *UserMutation) RemovedLottoRecordsIDs() (ids []int64) {
	for id := range m.removedlotto_records {
		ids = append(ids, id)
	}
	return
}

// LottoRecordsIDs returns the "lotto_records" edge IDs in the mutation.
func (m *UserMutation) LottoRecordsIDs() (ids []int64) {
	for id := range m.lotto_records {
		ids = append(ids, id)
	}
	return
}

// ResetLottoRecords resets all changes to the "lotto_records" edge.
func (m *UserMutation) ResetLottoRecords() {
	m.lotto_records = nil
	m.clearedlotto_records = false
	m.removedlotto_records = nil
}

// AddLottoUserCountIDs adds the "lotto_user_counts" edge to the LottoUserCount entity by ids.
func (m *UserMutation) AddLottoUserCountIDs(ids ...int64) {
	if m.lotto_user_counts == nil {
		m.lotto_user_counts = make(map[int64]struct{})
	}
	for i := range ids {
		m.lotto_user_counts[ids[i]] = struct{}{}
	}
}

// ClearLottoUserCounts clears the "lotto_user_counts" edge to the LottoUserCount entity.
func (m *UserMutation) ClearLottoUserCounts() {
	m.clearedlotto_user_counts = true
}

// LottoUserCountsCleared reports if the "lotto_user_counts" edge to the LottoUserCount entity was cleared.
func (m *UserMutation) LottoUserCountsCleared() bool {
	return m.clearedlotto_user_counts
}

// RemoveLottoUserCountIDs removes the "lotto_user_counts" edge to the LottoUserCount entity by IDs.
func (m *UserMutation) RemoveLottoUserCountIDs(ids ...int64) {
	if m.removedlotto_user_counts == nil {
		m.removedlotto_user_counts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lotto_user_counts, ids[i])
		m.removedlotto_user_counts[ids[i]] = struct{}{}
	}
}

// RemovedLottoUserCounts returns the removed IDs of the "lotto_user_counts" edge to the LottoUserCount entity.
func (m *UserMutation) RemovedLottoUserCountsIDs() (ids []int64) {
	for id := range m.removedlotto_user_counts {
		ids = append(ids, id)
	}
	return
}

// LottoUserCountsIDs returns the "lotto_user_counts" edge IDs in the mutation.
func (m *UserMutation) LottoUserCountsIDs() (ids []int64) {
	for id := range m.lotto_user_counts {
		ids = append(ids, id)
	}
	return
}

// ResetLottoUserCounts resets all changes to the "lotto_user_counts" edge.
func (m *UserMutation) ResetLottoUserCounts() {
	m.lotto_user_counts = nil
	m.clearedlotto_user_counts = false
	m.removedlotto_user_counts = nil
}

// AddLottoGetCountRecordIDs adds the "lotto_get_count_records" edge to the LottoGetCountRecord entity by ids.
func (m *UserMutation) AddLottoGetCountRecordIDs(ids ...int64) {
	if m.lotto_get_count_records == nil {
		m.lotto_get_count_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.lotto_get_count_records[ids[i]] = struct{}{}
	}
}

// ClearLottoGetCountRecords clears the "lotto_get_count_records" edge to the LottoGetCountRecord entity.
func (m *UserMutation) ClearLottoGetCountRecords() {
	m.clearedlotto_get_count_records = true
}

// LottoGetCountRecordsCleared reports if the "lotto_get_count_records" edge to the LottoGetCountRecord entity was cleared.
func (m *UserMutation) LottoGetCountRecordsCleared() bool {
	return m.clearedlotto_get_count_records
}

// RemoveLottoGetCountRecordIDs removes the "lotto_get_count_records" edge to the LottoGetCountRecord entity by IDs.
func (m *UserMutation) RemoveLottoGetCountRecordIDs(ids ...int64) {
	if m.removedlotto_get_count_records == nil {
		m.removedlotto_get_count_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lotto_get_count_records, ids[i])
		m.removedlotto_get_count_records[ids[i]] = struct{}{}
	}
}

// RemovedLottoGetCountRecords returns the removed IDs of the "lotto_get_count_records" edge to the LottoGetCountRecord entity.
func (m *UserMutation) RemovedLottoGetCountRecordsIDs() (ids []int64) {
	for id := range m.removedlotto_get_count_records {
		ids = append(ids, id)
	}
	return
}

// LottoGetCountRecordsIDs returns the "lotto_get_count_records" edge IDs in the mutation.
func (m *UserMutation) LottoGetCountRecordsIDs() (ids []int64) {
	for id := range m.lotto_get_count_records {
		ids = append(ids, id)
	}
	return
}

// ResetLottoGetCountRecords resets all changes to the "lotto_get_count_records" edge.
func (m *UserMutation) ResetLottoGetCountRecords() {
	m.lotto_get_count_records = nil
	m.clearedlotto_get_count_records = false
	m.removedlotto_get_count_records = nil
}

// AddCloudFileIDs adds the "cloud_files" edge to the CloudFile entity by ids.
func (m *UserMutation) AddCloudFileIDs(ids ...int64) {
	if m.cloud_files == nil {
		m.cloud_files = make(map[int64]struct{})
	}
	for i := range ids {
		m.cloud_files[ids[i]] = struct{}{}
	}
}

// ClearCloudFiles clears the "cloud_files" edge to the CloudFile entity.
func (m *UserMutation) ClearCloudFiles() {
	m.clearedcloud_files = true
}

// CloudFilesCleared reports if the "cloud_files" edge to the CloudFile entity was cleared.
func (m *UserMutation) CloudFilesCleared() bool {
	return m.clearedcloud_files
}

// RemoveCloudFileIDs removes the "cloud_files" edge to the CloudFile entity by IDs.
func (m *UserMutation) RemoveCloudFileIDs(ids ...int64) {
	if m.removedcloud_files == nil {
		m.removedcloud_files = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cloud_files, ids[i])
		m.removedcloud_files[ids[i]] = struct{}{}
	}
}

// RemovedCloudFiles returns the removed IDs of the "cloud_files" edge to the CloudFile entity.
func (m *UserMutation) RemovedCloudFilesIDs() (ids []int64) {
	for id := range m.removedcloud_files {
		ids = append(ids, id)
	}
	return
}

// CloudFilesIDs returns the "cloud_files" edge IDs in the mutation.
func (m *UserMutation) CloudFilesIDs() (ids []int64) {
	for id := range m.cloud_files {
		ids = append(ids, id)
	}
	return
}

// ResetCloudFiles resets all changes to the "cloud_files" edge.
func (m *UserMutation) ResetCloudFiles() {
	m.cloud_files = nil
	m.clearedcloud_files = false
	m.removedcloud_files = nil
}

// AddWithdrawRecordIDs adds the "withdraw_records" edge to the WithdrawRecord entity by ids.
func (m *UserMutation) AddWithdrawRecordIDs(ids ...int64) {
	if m.withdraw_records == nil {
		m.withdraw_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.withdraw_records[ids[i]] = struct{}{}
	}
}

// ClearWithdrawRecords clears the "withdraw_records" edge to the WithdrawRecord entity.
func (m *UserMutation) ClearWithdrawRecords() {
	m.clearedwithdraw_records = true
}

// WithdrawRecordsCleared reports if the "withdraw_records" edge to the WithdrawRecord entity was cleared.
func (m *UserMutation) WithdrawRecordsCleared() bool {
	return m.clearedwithdraw_records
}

// RemoveWithdrawRecordIDs removes the "withdraw_records" edge to the WithdrawRecord entity by IDs.
func (m *UserMutation) RemoveWithdrawRecordIDs(ids ...int64) {
	if m.removedwithdraw_records == nil {
		m.removedwithdraw_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.withdraw_records, ids[i])
		m.removedwithdraw_records[ids[i]] = struct{}{}
	}
}

// RemovedWithdrawRecords returns the removed IDs of the "withdraw_records" edge to the WithdrawRecord entity.
func (m *UserMutation) RemovedWithdrawRecordsIDs() (ids []int64) {
	for id := range m.removedwithdraw_records {
		ids = append(ids, id)
	}
	return
}

// WithdrawRecordsIDs returns the "withdraw_records" edge IDs in the mutation.
func (m *UserMutation) WithdrawRecordsIDs() (ids []int64) {
	for id := range m.withdraw_records {
		ids = append(ids, id)
	}
	return
}

// ResetWithdrawRecords resets all changes to the "withdraw_records" edge.
func (m *UserMutation) ResetWithdrawRecords() {
	m.withdraw_records = nil
	m.clearedwithdraw_records = false
	m.removedwithdraw_records = nil
}

// AddOperateWithdrawRecordIDs adds the "operate_withdraw_records" edge to the WithdrawRecord entity by ids.
func (m *UserMutation) AddOperateWithdrawRecordIDs(ids ...int64) {
	if m.operate_withdraw_records == nil {
		m.operate_withdraw_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.operate_withdraw_records[ids[i]] = struct{}{}
	}
}

// ClearOperateWithdrawRecords clears the "operate_withdraw_records" edge to the WithdrawRecord entity.
func (m *UserMutation) ClearOperateWithdrawRecords() {
	m.clearedoperate_withdraw_records = true
}

// OperateWithdrawRecordsCleared reports if the "operate_withdraw_records" edge to the WithdrawRecord entity was cleared.
func (m *UserMutation) OperateWithdrawRecordsCleared() bool {
	return m.clearedoperate_withdraw_records
}

// RemoveOperateWithdrawRecordIDs removes the "operate_withdraw_records" edge to the WithdrawRecord entity by IDs.
func (m *UserMutation) RemoveOperateWithdrawRecordIDs(ids ...int64) {
	if m.removedoperate_withdraw_records == nil {
		m.removedoperate_withdraw_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.operate_withdraw_records, ids[i])
		m.removedoperate_withdraw_records[ids[i]] = struct{}{}
	}
}

// RemovedOperateWithdrawRecords returns the removed IDs of the "operate_withdraw_records" edge to the WithdrawRecord entity.
func (m *UserMutation) RemovedOperateWithdrawRecordsIDs() (ids []int64) {
	for id := range m.removedoperate_withdraw_records {
		ids = append(ids, id)
	}
	return
}

// OperateWithdrawRecordsIDs returns the "operate_withdraw_records" edge IDs in the mutation.
func (m *UserMutation) OperateWithdrawRecordsIDs() (ids []int64) {
	for id := range m.operate_withdraw_records {
		ids = append(ids, id)
	}
	return
}

// ResetOperateWithdrawRecords resets all changes to the "operate_withdraw_records" edge.
func (m *UserMutation) ResetOperateWithdrawRecords() {
	m.operate_withdraw_records = nil
	m.clearedoperate_withdraw_records = false
	m.removedoperate_withdraw_records = nil
}

// AddTroubleDeductIDs adds the "trouble_deducts" edge to the TroubleDeduct entity by ids.
func (m *UserMutation) AddTroubleDeductIDs(ids ...int64) {
	if m.trouble_deducts == nil {
		m.trouble_deducts = make(map[int64]struct{})
	}
	for i := range ids {
		m.trouble_deducts[ids[i]] = struct{}{}
	}
}

// ClearTroubleDeducts clears the "trouble_deducts" edge to the TroubleDeduct entity.
func (m *UserMutation) ClearTroubleDeducts() {
	m.clearedtrouble_deducts = true
}

// TroubleDeductsCleared reports if the "trouble_deducts" edge to the TroubleDeduct entity was cleared.
func (m *UserMutation) TroubleDeductsCleared() bool {
	return m.clearedtrouble_deducts
}

// RemoveTroubleDeductIDs removes the "trouble_deducts" edge to the TroubleDeduct entity by IDs.
func (m *UserMutation) RemoveTroubleDeductIDs(ids ...int64) {
	if m.removedtrouble_deducts == nil {
		m.removedtrouble_deducts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.trouble_deducts, ids[i])
		m.removedtrouble_deducts[ids[i]] = struct{}{}
	}
}

// RemovedTroubleDeducts returns the removed IDs of the "trouble_deducts" edge to the TroubleDeduct entity.
func (m *UserMutation) RemovedTroubleDeductsIDs() (ids []int64) {
	for id := range m.removedtrouble_deducts {
		ids = append(ids, id)
	}
	return
}

// TroubleDeductsIDs returns the "trouble_deducts" edge IDs in the mutation.
func (m *UserMutation) TroubleDeductsIDs() (ids []int64) {
	for id := range m.trouble_deducts {
		ids = append(ids, id)
	}
	return
}

// ResetTroubleDeducts resets all changes to the "trouble_deducts" edge.
func (m *UserMutation) ResetTroubleDeducts() {
	m.trouble_deducts = nil
	m.clearedtrouble_deducts = false
	m.removedtrouble_deducts = nil
}

// AddIncomeManageIDs adds the "income_manages" edge to the IncomeManage entity by ids.
func (m *UserMutation) AddIncomeManageIDs(ids ...int64) {
	if m.income_manages == nil {
		m.income_manages = make(map[int64]struct{})
	}
	for i := range ids {
		m.income_manages[ids[i]] = struct{}{}
	}
}

// ClearIncomeManages clears the "income_manages" edge to the IncomeManage entity.
func (m *UserMutation) ClearIncomeManages() {
	m.clearedincome_manages = true
}

// IncomeManagesCleared reports if the "income_manages" edge to the IncomeManage entity was cleared.
func (m *UserMutation) IncomeManagesCleared() bool {
	return m.clearedincome_manages
}

// RemoveIncomeManageIDs removes the "income_manages" edge to the IncomeManage entity by IDs.
func (m *UserMutation) RemoveIncomeManageIDs(ids ...int64) {
	if m.removedincome_manages == nil {
		m.removedincome_manages = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.income_manages, ids[i])
		m.removedincome_manages[ids[i]] = struct{}{}
	}
}

// RemovedIncomeManages returns the removed IDs of the "income_manages" edge to the IncomeManage entity.
func (m *UserMutation) RemovedIncomeManagesIDs() (ids []int64) {
	for id := range m.removedincome_manages {
		ids = append(ids, id)
	}
	return
}

// IncomeManagesIDs returns the "income_manages" edge IDs in the mutation.
func (m *UserMutation) IncomeManagesIDs() (ids []int64) {
	for id := range m.income_manages {
		ids = append(ids, id)
	}
	return
}

// ResetIncomeManages resets all changes to the "income_manages" edge.
func (m *UserMutation) ResetIncomeManages() {
	m.income_manages = nil
	m.clearedincome_manages = false
	m.removedincome_manages = nil
}

// AddApproveIncomeManageIDs adds the "approve_income_manages" edge to the IncomeManage entity by ids.
func (m *UserMutation) AddApproveIncomeManageIDs(ids ...int64) {
	if m.approve_income_manages == nil {
		m.approve_income_manages = make(map[int64]struct{})
	}
	for i := range ids {
		m.approve_income_manages[ids[i]] = struct{}{}
	}
}

// ClearApproveIncomeManages clears the "approve_income_manages" edge to the IncomeManage entity.
func (m *UserMutation) ClearApproveIncomeManages() {
	m.clearedapprove_income_manages = true
}

// ApproveIncomeManagesCleared reports if the "approve_income_manages" edge to the IncomeManage entity was cleared.
func (m *UserMutation) ApproveIncomeManagesCleared() bool {
	return m.clearedapprove_income_manages
}

// RemoveApproveIncomeManageIDs removes the "approve_income_manages" edge to the IncomeManage entity by IDs.
func (m *UserMutation) RemoveApproveIncomeManageIDs(ids ...int64) {
	if m.removedapprove_income_manages == nil {
		m.removedapprove_income_manages = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.approve_income_manages, ids[i])
		m.removedapprove_income_manages[ids[i]] = struct{}{}
	}
}

// RemovedApproveIncomeManages returns the removed IDs of the "approve_income_manages" edge to the IncomeManage entity.
func (m *UserMutation) RemovedApproveIncomeManagesIDs() (ids []int64) {
	for id := range m.removedapprove_income_manages {
		ids = append(ids, id)
	}
	return
}

// ApproveIncomeManagesIDs returns the "approve_income_manages" edge IDs in the mutation.
func (m *UserMutation) ApproveIncomeManagesIDs() (ids []int64) {
	for id := range m.approve_income_manages {
		ids = append(ids, id)
	}
	return
}

// ResetApproveIncomeManages resets all changes to the "approve_income_manages" edge.
func (m *UserMutation) ResetApproveIncomeManages() {
	m.approve_income_manages = nil
	m.clearedapprove_income_manages = false
	m.removedapprove_income_manages = nil
}

// AddSurveyResponseIDs adds the "survey_responses" edge to the SurveyResponse entity by ids.
func (m *UserMutation) AddSurveyResponseIDs(ids ...int64) {
	if m.survey_responses == nil {
		m.survey_responses = make(map[int64]struct{})
	}
	for i := range ids {
		m.survey_responses[ids[i]] = struct{}{}
	}
}

// ClearSurveyResponses clears the "survey_responses" edge to the SurveyResponse entity.
func (m *UserMutation) ClearSurveyResponses() {
	m.clearedsurvey_responses = true
}

// SurveyResponsesCleared reports if the "survey_responses" edge to the SurveyResponse entity was cleared.
func (m *UserMutation) SurveyResponsesCleared() bool {
	return m.clearedsurvey_responses
}

// RemoveSurveyResponseIDs removes the "survey_responses" edge to the SurveyResponse entity by IDs.
func (m *UserMutation) RemoveSurveyResponseIDs(ids ...int64) {
	if m.removedsurvey_responses == nil {
		m.removedsurvey_responses = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.survey_responses, ids[i])
		m.removedsurvey_responses[ids[i]] = struct{}{}
	}
}

// RemovedSurveyResponses returns the removed IDs of the "survey_responses" edge to the SurveyResponse entity.
func (m *UserMutation) RemovedSurveyResponsesIDs() (ids []int64) {
	for id := range m.removedsurvey_responses {
		ids = append(ids, id)
	}
	return
}

// SurveyResponsesIDs returns the "survey_responses" edge IDs in the mutation.
func (m *UserMutation) SurveyResponsesIDs() (ids []int64) {
	for id := range m.survey_responses {
		ids = append(ids, id)
	}
	return
}

// ResetSurveyResponses resets all changes to the "survey_responses" edge.
func (m *UserMutation) ResetSurveyResponses() {
	m.survey_responses = nil
	m.clearedsurvey_responses = false
	m.removedsurvey_responses = nil
}

// AddApproveSurveyResponseIDs adds the "approve_survey_responses" edge to the SurveyResponse entity by ids.
func (m *UserMutation) AddApproveSurveyResponseIDs(ids ...int64) {
	if m.approve_survey_responses == nil {
		m.approve_survey_responses = make(map[int64]struct{})
	}
	for i := range ids {
		m.approve_survey_responses[ids[i]] = struct{}{}
	}
}

// ClearApproveSurveyResponses clears the "approve_survey_responses" edge to the SurveyResponse entity.
func (m *UserMutation) ClearApproveSurveyResponses() {
	m.clearedapprove_survey_responses = true
}

// ApproveSurveyResponsesCleared reports if the "approve_survey_responses" edge to the SurveyResponse entity was cleared.
func (m *UserMutation) ApproveSurveyResponsesCleared() bool {
	return m.clearedapprove_survey_responses
}

// RemoveApproveSurveyResponseIDs removes the "approve_survey_responses" edge to the SurveyResponse entity by IDs.
func (m *UserMutation) RemoveApproveSurveyResponseIDs(ids ...int64) {
	if m.removedapprove_survey_responses == nil {
		m.removedapprove_survey_responses = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.approve_survey_responses, ids[i])
		m.removedapprove_survey_responses[ids[i]] = struct{}{}
	}
}

// RemovedApproveSurveyResponses returns the removed IDs of the "approve_survey_responses" edge to the SurveyResponse entity.
func (m *UserMutation) RemovedApproveSurveyResponsesIDs() (ids []int64) {
	for id := range m.removedapprove_survey_responses {
		ids = append(ids, id)
	}
	return
}

// ApproveSurveyResponsesIDs returns the "approve_survey_responses" edge IDs in the mutation.
func (m *UserMutation) ApproveSurveyResponsesIDs() (ids []int64) {
	for id := range m.approve_survey_responses {
		ids = append(ids, id)
	}
	return
}

// ResetApproveSurveyResponses resets all changes to the "approve_survey_responses" edge.
func (m *UserMutation) ResetApproveSurveyResponses() {
	m.approve_survey_responses = nil
	m.clearedapprove_survey_responses = false
	m.removedapprove_survey_responses = nil
}

// AddMissionFailedFeedbackIDs adds the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity by ids.
func (m *UserMutation) AddMissionFailedFeedbackIDs(ids ...int64) {
	if m.mission_failed_feedbacks == nil {
		m.mission_failed_feedbacks = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_failed_feedbacks[ids[i]] = struct{}{}
	}
}

// ClearMissionFailedFeedbacks clears the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity.
func (m *UserMutation) ClearMissionFailedFeedbacks() {
	m.clearedmission_failed_feedbacks = true
}

// MissionFailedFeedbacksCleared reports if the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity was cleared.
func (m *UserMutation) MissionFailedFeedbacksCleared() bool {
	return m.clearedmission_failed_feedbacks
}

// RemoveMissionFailedFeedbackIDs removes the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity by IDs.
func (m *UserMutation) RemoveMissionFailedFeedbackIDs(ids ...int64) {
	if m.removedmission_failed_feedbacks == nil {
		m.removedmission_failed_feedbacks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_failed_feedbacks, ids[i])
		m.removedmission_failed_feedbacks[ids[i]] = struct{}{}
	}
}

// RemovedMissionFailedFeedbacks returns the removed IDs of the "mission_failed_feedbacks" edge to the MissionFailedFeedback entity.
func (m *UserMutation) RemovedMissionFailedFeedbacksIDs() (ids []int64) {
	for id := range m.removedmission_failed_feedbacks {
		ids = append(ids, id)
	}
	return
}

// MissionFailedFeedbacksIDs returns the "mission_failed_feedbacks" edge IDs in the mutation.
func (m *UserMutation) MissionFailedFeedbacksIDs() (ids []int64) {
	for id := range m.mission_failed_feedbacks {
		ids = append(ids, id)
	}
	return
}

// ResetMissionFailedFeedbacks resets all changes to the "mission_failed_feedbacks" edge.
func (m *UserMutation) ResetMissionFailedFeedbacks() {
	m.mission_failed_feedbacks = nil
	m.clearedmission_failed_feedbacks = false
	m.removedmission_failed_feedbacks = nil
}

// AddAPITokenIDs adds the "api_tokens" edge to the ApiToken entity by ids.
func (m *UserMutation) AddAPITokenIDs(ids ...int64) {
	if m.api_tokens == nil {
		m.api_tokens = make(map[int64]struct{})
	}
	for i := range ids {
		m.api_tokens[ids[i]] = struct{}{}
	}
}

// ClearAPITokens clears the "api_tokens" edge to the ApiToken entity.
func (m *UserMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the ApiToken entity was cleared.
func (m *UserMutation) APITokensCleared() bool {
	return m.clearedapi_tokens
}

// RemoveAPITokenIDs removes the "api_tokens" edge to the ApiToken entity by IDs.
func (m *UserMutation) RemoveAPITokenIDs(ids ...int64) {
	if m.removedapi_tokens == nil {
		m.removedapi_tokens = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.api_tokens, ids[i])
		m.removedapi_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAPITokens returns the removed IDs of the "api_tokens" edge to the ApiToken entity.
func (m *UserMutation) RemovedAPITokensIDs() (ids []int64) {
	for id := range m.removedapi_tokens {
		ids = append(ids, id)
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
func (m *UserMutation) APITokensIDs() (ids []int64) {
	for id := range m.api_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *UserMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
	m.removedapi_tokens = nil
}

// AddUserModelIDs adds the "user_models" edge to the UserModel entity by ids.
func (m *UserMutation) AddUserModelIDs(ids ...int64) {
	if m.user_models == nil {
		m.user_models = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_models[ids[i]] = struct{}{}
	}
}

// ClearUserModels clears the "user_models" edge to the UserModel entity.
func (m *UserMutation) ClearUserModels() {
	m.cleareduser_models = true
}

// UserModelsCleared reports if the "user_models" edge to the UserModel entity was cleared.
func (m *UserMutation) UserModelsCleared() bool {
	return m.cleareduser_models
}

// RemoveUserModelIDs removes the "user_models" edge to the UserModel entity by IDs.
func (m *UserMutation) RemoveUserModelIDs(ids ...int64) {
	if m.removeduser_models == nil {
		m.removeduser_models = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_models, ids[i])
		m.removeduser_models[ids[i]] = struct{}{}
	}
}

// RemovedUserModels returns the removed IDs of the "user_models" edge to the UserModel entity.
func (m *UserMutation) RemovedUserModelsIDs() (ids []int64) {
	for id := range m.removeduser_models {
		ids = append(ids, id)
	}
	return
}

// UserModelsIDs returns the "user_models" edge IDs in the mutation.
func (m *UserMutation) UserModelsIDs() (ids []int64) {
	for id := range m.user_models {
		ids = append(ids, id)
	}
	return
}

// ResetUserModels resets all changes to the "user_models" edge.
func (m *UserMutation) ResetUserModels() {
	m.user_models = nil
	m.cleareduser_models = false
	m.removeduser_models = nil
}

// AddInvokeModelOrderIDs adds the "invoke_model_orders" edge to the InvokeModelOrder entity by ids.
func (m *UserMutation) AddInvokeModelOrderIDs(ids ...int64) {
	if m.invoke_model_orders == nil {
		m.invoke_model_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.invoke_model_orders[ids[i]] = struct{}{}
	}
}

// ClearInvokeModelOrders clears the "invoke_model_orders" edge to the InvokeModelOrder entity.
func (m *UserMutation) ClearInvokeModelOrders() {
	m.clearedinvoke_model_orders = true
}

// InvokeModelOrdersCleared reports if the "invoke_model_orders" edge to the InvokeModelOrder entity was cleared.
func (m *UserMutation) InvokeModelOrdersCleared() bool {
	return m.clearedinvoke_model_orders
}

// RemoveInvokeModelOrderIDs removes the "invoke_model_orders" edge to the InvokeModelOrder entity by IDs.
func (m *UserMutation) RemoveInvokeModelOrderIDs(ids ...int64) {
	if m.removedinvoke_model_orders == nil {
		m.removedinvoke_model_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invoke_model_orders, ids[i])
		m.removedinvoke_model_orders[ids[i]] = struct{}{}
	}
}

// RemovedInvokeModelOrders returns the removed IDs of the "invoke_model_orders" edge to the InvokeModelOrder entity.
func (m *UserMutation) RemovedInvokeModelOrdersIDs() (ids []int64) {
	for id := range m.removedinvoke_model_orders {
		ids = append(ids, id)
	}
	return
}

// InvokeModelOrdersIDs returns the "invoke_model_orders" edge IDs in the mutation.
func (m *UserMutation) InvokeModelOrdersIDs() (ids []int64) {
	for id := range m.invoke_model_orders {
		ids = append(ids, id)
	}
	return
}

// ResetInvokeModelOrders resets all changes to the "invoke_model_orders" edge.
func (m *UserMutation) ResetInvokeModelOrders() {
	m.invoke_model_orders = nil
	m.clearedinvoke_model_orders = false
	m.removedinvoke_model_orders = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 28)
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.nick_name != nil {
		fields = append(fields, user.FieldNickName)
	}
	if m.jpg_url != nil {
		fields = append(fields, user.FieldJpgURL)
	}
	if m.key != nil {
		fields = append(fields, user.FieldKey)
	}
	if m.secret != nil {
		fields = append(fields, user.FieldSecret)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.is_frozen != nil {
		fields = append(fields, user.FieldIsFrozen)
	}
	if m.is_recharge != nil {
		fields = append(fields, user.FieldIsRecharge)
	}
	if m.user_type != nil {
		fields = append(fields, user.FieldUserType)
	}
	if m.parent != nil {
		fields = append(fields, user.FieldParentID)
	}
	if m.applet_parent != nil {
		fields = append(fields, user.FieldAppletParentID)
	}
	if m.pop_version != nil {
		fields = append(fields, user.FieldPopVersion)
	}
	if m.area_code != nil {
		fields = append(fields, user.FieldAreaCode)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.github_id != nil {
		fields = append(fields, user.FieldGithubID)
	}
	if m.cloud_space != nil {
		fields = append(fields, user.FieldCloudSpace)
	}
	if m.baidu_access_token != nil {
		fields = append(fields, user.FieldBaiduAccessToken)
	}
	if m.baidu_refresh_token != nil {
		fields = append(fields, user.FieldBaiduRefreshToken)
	}
	if m.bound_at != nil {
		fields = append(fields, user.FieldBoundAt)
	}
	if m.user_status != nil {
		fields = append(fields, user.FieldUserStatus)
	}
	if m.channel != nil {
		fields = append(fields, user.FieldChannel)
	}
	if m.channel_ratio != nil {
		fields = append(fields, user.FieldChannelRatio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldNickName:
		return m.NickName()
	case user.FieldJpgURL:
		return m.JpgURL()
	case user.FieldKey:
		return m.Key()
	case user.FieldSecret:
		return m.Secret()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPassword:
		return m.Password()
	case user.FieldIsFrozen:
		return m.IsFrozen()
	case user.FieldIsRecharge:
		return m.IsRecharge()
	case user.FieldUserType:
		return m.UserType()
	case user.FieldParentID:
		return m.ParentID()
	case user.FieldAppletParentID:
		return m.AppletParentID()
	case user.FieldPopVersion:
		return m.PopVersion()
	case user.FieldAreaCode:
		return m.AreaCode()
	case user.FieldEmail:
		return m.Email()
	case user.FieldGithubID:
		return m.GithubID()
	case user.FieldCloudSpace:
		return m.CloudSpace()
	case user.FieldBaiduAccessToken:
		return m.BaiduAccessToken()
	case user.FieldBaiduRefreshToken:
		return m.BaiduRefreshToken()
	case user.FieldBoundAt:
		return m.BoundAt()
	case user.FieldUserStatus:
		return m.UserStatus()
	case user.FieldChannel:
		return m.Channel()
	case user.FieldChannelRatio:
		return m.ChannelRatio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldNickName:
		return m.OldNickName(ctx)
	case user.FieldJpgURL:
		return m.OldJpgURL(ctx)
	case user.FieldKey:
		return m.OldKey(ctx)
	case user.FieldSecret:
		return m.OldSecret(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldIsFrozen:
		return m.OldIsFrozen(ctx)
	case user.FieldIsRecharge:
		return m.OldIsRecharge(ctx)
	case user.FieldUserType:
		return m.OldUserType(ctx)
	case user.FieldParentID:
		return m.OldParentID(ctx)
	case user.FieldAppletParentID:
		return m.OldAppletParentID(ctx)
	case user.FieldPopVersion:
		return m.OldPopVersion(ctx)
	case user.FieldAreaCode:
		return m.OldAreaCode(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldGithubID:
		return m.OldGithubID(ctx)
	case user.FieldCloudSpace:
		return m.OldCloudSpace(ctx)
	case user.FieldBaiduAccessToken:
		return m.OldBaiduAccessToken(ctx)
	case user.FieldBaiduRefreshToken:
		return m.OldBaiduRefreshToken(ctx)
	case user.FieldBoundAt:
		return m.OldBoundAt(ctx)
	case user.FieldUserStatus:
		return m.OldUserStatus(ctx)
	case user.FieldChannel:
		return m.OldChannel(ctx)
	case user.FieldChannelRatio:
		return m.OldChannelRatio(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldNickName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickName(v)
		return nil
	case user.FieldJpgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJpgURL(v)
		return nil
	case user.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case user.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldIsFrozen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFrozen(v)
		return nil
	case user.FieldIsRecharge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRecharge(v)
		return nil
	case user.FieldUserType:
		v, ok := value.(enums.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case user.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case user.FieldAppletParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppletParentID(v)
		return nil
	case user.FieldPopVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopVersion(v)
		return nil
	case user.FieldAreaCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaCode(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldGithubID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubID(v)
		return nil
	case user.FieldCloudSpace:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudSpace(v)
		return nil
	case user.FieldBaiduAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaiduAccessToken(v)
		return nil
	case user.FieldBaiduRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaiduRefreshToken(v)
		return nil
	case user.FieldBoundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoundAt(v)
		return nil
	case user.FieldUserStatus:
		v, ok := value.(enums.UserStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserStatus(v)
		return nil
	case user.FieldChannel:
		v, ok := value.(enums.UserChannelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case user.FieldChannelRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelRatio(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.addcloud_space != nil {
		fields = append(fields, user.FieldCloudSpace)
	}
	if m.addchannel_ratio != nil {
		fields = append(fields, user.FieldChannelRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case user.FieldCloudSpace:
		return m.AddedCloudSpace()
	case user.FieldChannelRatio:
		return m.AddedChannelRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case user.FieldCloudSpace:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCloudSpace(v)
		return nil
	case user.FieldChannelRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelRatio(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldBoundAt) {
		fields = append(fields, user.FieldBoundAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldBoundAt:
		m.ClearBoundAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldNickName:
		m.ResetNickName()
		return nil
	case user.FieldJpgURL:
		m.ResetJpgURL()
		return nil
	case user.FieldKey:
		m.ResetKey()
		return nil
	case user.FieldSecret:
		m.ResetSecret()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldIsFrozen:
		m.ResetIsFrozen()
		return nil
	case user.FieldIsRecharge:
		m.ResetIsRecharge()
		return nil
	case user.FieldUserType:
		m.ResetUserType()
		return nil
	case user.FieldParentID:
		m.ResetParentID()
		return nil
	case user.FieldAppletParentID:
		m.ResetAppletParentID()
		return nil
	case user.FieldPopVersion:
		m.ResetPopVersion()
		return nil
	case user.FieldAreaCode:
		m.ResetAreaCode()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldGithubID:
		m.ResetGithubID()
		return nil
	case user.FieldCloudSpace:
		m.ResetCloudSpace()
		return nil
	case user.FieldBaiduAccessToken:
		m.ResetBaiduAccessToken()
		return nil
	case user.FieldBaiduRefreshToken:
		m.ResetBaiduRefreshToken()
		return nil
	case user.FieldBoundAt:
		m.ResetBoundAt()
		return nil
	case user.FieldUserStatus:
		m.ResetUserStatus()
		return nil
	case user.FieldChannel:
		m.ResetChannel()
		return nil
	case user.FieldChannelRatio:
		m.ResetChannelRatio()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 51)
	if m.vx_accounts != nil {
		edges = append(edges, user.EdgeVxAccounts)
	}
	if m.collects != nil {
		edges = append(edges, user.EdgeCollects)
	}
	if m.devices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.profit_settings != nil {
		edges = append(edges, user.EdgeProfitSettings)
	}
	if m.cost_account != nil {
		edges = append(edges, user.EdgeCostAccount)
	}
	if m.profit_account != nil {
		edges = append(edges, user.EdgeProfitAccount)
	}
	if m.cost_bills != nil {
		edges = append(edges, user.EdgeCostBills)
	}
	if m.earn_bills != nil {
		edges = append(edges, user.EdgeEarnBills)
	}
	if m.mission_consume_orders != nil {
		edges = append(edges, user.EdgeMissionConsumeOrders)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, user.EdgeMissionProduceOrders)
	}
	if m.recharge_orders != nil {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.vx_socials != nil {
		edges = append(edges, user.EdgeVxSocials)
	}
	if m.mission_batches != nil {
		edges = append(edges, user.EdgeMissionBatches)
	}
	if m.user_devices != nil {
		edges = append(edges, user.EdgeUserDevices)
	}
	if m.parent != nil {
		edges = append(edges, user.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, user.EdgeChildren)
	}
	if m.applet_parent != nil {
		edges = append(edges, user.EdgeAppletParent)
	}
	if m.applet_children != nil {
		edges = append(edges, user.EdgeAppletChildren)
	}
	if m.invites != nil {
		edges = append(edges, user.EdgeInvites)
	}
	if m.campaign_orders != nil {
		edges = append(edges, user.EdgeCampaignOrders)
	}
	if m.wallets != nil {
		edges = append(edges, user.EdgeWallets)
	}
	if m.withdraw_account != nil {
		edges = append(edges, user.EdgeWithdrawAccount)
	}
	if m.income_bills != nil {
		edges = append(edges, user.EdgeIncomeBills)
	}
	if m.outcome_bills != nil {
		edges = append(edges, user.EdgeOutcomeBills)
	}
	if m.mission_productions != nil {
		edges = append(edges, user.EdgeMissionProductions)
	}
	if m.missions != nil {
		edges = append(edges, user.EdgeMissions)
	}
	if m.income_transfer_orders != nil {
		edges = append(edges, user.EdgeIncomeTransferOrders)
	}
	if m.outcome_transfer_orders != nil {
		edges = append(edges, user.EdgeOutcomeTransferOrders)
	}
	if m.consume_mission_orders != nil {
		edges = append(edges, user.EdgeConsumeMissionOrders)
	}
	if m.produce_mission_orders != nil {
		edges = append(edges, user.EdgeProduceMissionOrders)
	}
	if m.login_records != nil {
		edges = append(edges, user.EdgeLoginRecords)
	}
	if m.renewal_agreements != nil {
		edges = append(edges, user.EdgeRenewalAgreements)
	}
	if m.artworks != nil {
		edges = append(edges, user.EdgeArtworks)
	}
	if m.artwork_likes != nil {
		edges = append(edges, user.EdgeArtworkLikes)
	}
	if m.cdk_infos != nil {
		edges = append(edges, user.EdgeCdkInfos)
	}
	if m.use_cdk_infos != nil {
		edges = append(edges, user.EdgeUseCdkInfos)
	}
	if m.lotto_records != nil {
		edges = append(edges, user.EdgeLottoRecords)
	}
	if m.lotto_user_counts != nil {
		edges = append(edges, user.EdgeLottoUserCounts)
	}
	if m.lotto_get_count_records != nil {
		edges = append(edges, user.EdgeLottoGetCountRecords)
	}
	if m.cloud_files != nil {
		edges = append(edges, user.EdgeCloudFiles)
	}
	if m.withdraw_records != nil {
		edges = append(edges, user.EdgeWithdrawRecords)
	}
	if m.operate_withdraw_records != nil {
		edges = append(edges, user.EdgeOperateWithdrawRecords)
	}
	if m.trouble_deducts != nil {
		edges = append(edges, user.EdgeTroubleDeducts)
	}
	if m.income_manages != nil {
		edges = append(edges, user.EdgeIncomeManages)
	}
	if m.approve_income_manages != nil {
		edges = append(edges, user.EdgeApproveIncomeManages)
	}
	if m.survey_responses != nil {
		edges = append(edges, user.EdgeSurveyResponses)
	}
	if m.approve_survey_responses != nil {
		edges = append(edges, user.EdgeApproveSurveyResponses)
	}
	if m.mission_failed_feedbacks != nil {
		edges = append(edges, user.EdgeMissionFailedFeedbacks)
	}
	if m.api_tokens != nil {
		edges = append(edges, user.EdgeAPITokens)
	}
	if m.user_models != nil {
		edges = append(edges, user.EdgeUserModels)
	}
	if m.invoke_model_orders != nil {
		edges = append(edges, user.EdgeInvokeModelOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVxAccounts:
		ids := make([]ent.Value, 0, len(m.vx_accounts))
		for id := range m.vx_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCollects:
		ids := make([]ent.Value, 0, len(m.collects))
		for id := range m.collects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfitSettings:
		ids := make([]ent.Value, 0, len(m.profit_settings))
		for id := range m.profit_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCostAccount:
		if id := m.cost_account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeProfitAccount:
		if id := m.profit_account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.mission_consume_orders))
		for id := range m.mission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.recharge_orders))
		for id := range m.recharge_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVxSocials:
		ids := make([]ent.Value, 0, len(m.vx_socials))
		for id := range m.vx_socials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionBatches:
		ids := make([]ent.Value, 0, len(m.mission_batches))
		for id := range m.mission_batches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.user_devices))
		for id := range m.user_devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAppletParent:
		if id := m.applet_parent; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAppletChildren:
		ids := make([]ent.Value, 0, len(m.applet_children))
		for id := range m.applet_children {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.invites))
		for id := range m.invites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCampaignOrders:
		ids := make([]ent.Value, 0, len(m.campaign_orders))
		for id := range m.campaign_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.wallets))
		for id := range m.wallets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWithdrawAccount:
		if id := m.withdraw_account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeIncomeBills:
		ids := make([]ent.Value, 0, len(m.income_bills))
		for id := range m.income_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOutcomeBills:
		ids := make([]ent.Value, 0, len(m.outcome_bills))
		for id := range m.outcome_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.mission_productions))
		for id := range m.mission_productions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.missions))
		for id := range m.missions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncomeTransferOrders:
		ids := make([]ent.Value, 0, len(m.income_transfer_orders))
		for id := range m.income_transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOutcomeTransferOrders:
		ids := make([]ent.Value, 0, len(m.outcome_transfer_orders))
		for id := range m.outcome_transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConsumeMissionOrders:
		ids := make([]ent.Value, 0, len(m.consume_mission_orders))
		for id := range m.consume_mission_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProduceMissionOrders:
		ids := make([]ent.Value, 0, len(m.produce_mission_orders))
		for id := range m.produce_mission_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginRecords:
		ids := make([]ent.Value, 0, len(m.login_records))
		for id := range m.login_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRenewalAgreements:
		ids := make([]ent.Value, 0, len(m.renewal_agreements))
		for id := range m.renewal_agreements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtworks:
		ids := make([]ent.Value, 0, len(m.artworks))
		for id := range m.artworks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtworkLikes:
		ids := make([]ent.Value, 0, len(m.artwork_likes))
		for id := range m.artwork_likes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCdkInfos:
		ids := make([]ent.Value, 0, len(m.cdk_infos))
		for id := range m.cdk_infos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUseCdkInfos:
		ids := make([]ent.Value, 0, len(m.use_cdk_infos))
		for id := range m.use_cdk_infos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLottoRecords:
		ids := make([]ent.Value, 0, len(m.lotto_records))
		for id := range m.lotto_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLottoUserCounts:
		ids := make([]ent.Value, 0, len(m.lotto_user_counts))
		for id := range m.lotto_user_counts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLottoGetCountRecords:
		ids := make([]ent.Value, 0, len(m.lotto_get_count_records))
		for id := range m.lotto_get_count_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCloudFiles:
		ids := make([]ent.Value, 0, len(m.cloud_files))
		for id := range m.cloud_files {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWithdrawRecords:
		ids := make([]ent.Value, 0, len(m.withdraw_records))
		for id := range m.withdraw_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOperateWithdrawRecords:
		ids := make([]ent.Value, 0, len(m.operate_withdraw_records))
		for id := range m.operate_withdraw_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTroubleDeducts:
		ids := make([]ent.Value, 0, len(m.trouble_deducts))
		for id := range m.trouble_deducts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncomeManages:
		ids := make([]ent.Value, 0, len(m.income_manages))
		for id := range m.income_manages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApproveIncomeManages:
		ids := make([]ent.Value, 0, len(m.approve_income_manages))
		for id := range m.approve_income_manages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSurveyResponses:
		ids := make([]ent.Value, 0, len(m.survey_responses))
		for id := range m.survey_responses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApproveSurveyResponses:
		ids := make([]ent.Value, 0, len(m.approve_survey_responses))
		for id := range m.approve_survey_responses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionFailedFeedbacks:
		ids := make([]ent.Value, 0, len(m.mission_failed_feedbacks))
		for id := range m.mission_failed_feedbacks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.api_tokens))
		for id := range m.api_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserModels:
		ids := make([]ent.Value, 0, len(m.user_models))
		for id := range m.user_models {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvokeModelOrders:
		ids := make([]ent.Value, 0, len(m.invoke_model_orders))
		for id := range m.invoke_model_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 51)
	if m.removedvx_accounts != nil {
		edges = append(edges, user.EdgeVxAccounts)
	}
	if m.removedcollects != nil {
		edges = append(edges, user.EdgeCollects)
	}
	if m.removeddevices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.removedprofit_settings != nil {
		edges = append(edges, user.EdgeProfitSettings)
	}
	if m.removedcost_bills != nil {
		edges = append(edges, user.EdgeCostBills)
	}
	if m.removedearn_bills != nil {
		edges = append(edges, user.EdgeEarnBills)
	}
	if m.removedmission_consume_orders != nil {
		edges = append(edges, user.EdgeMissionConsumeOrders)
	}
	if m.removedmission_produce_orders != nil {
		edges = append(edges, user.EdgeMissionProduceOrders)
	}
	if m.removedrecharge_orders != nil {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.removedvx_socials != nil {
		edges = append(edges, user.EdgeVxSocials)
	}
	if m.removedmission_batches != nil {
		edges = append(edges, user.EdgeMissionBatches)
	}
	if m.removeduser_devices != nil {
		edges = append(edges, user.EdgeUserDevices)
	}
	if m.removedchildren != nil {
		edges = append(edges, user.EdgeChildren)
	}
	if m.removedapplet_children != nil {
		edges = append(edges, user.EdgeAppletChildren)
	}
	if m.removedinvites != nil {
		edges = append(edges, user.EdgeInvites)
	}
	if m.removedcampaign_orders != nil {
		edges = append(edges, user.EdgeCampaignOrders)
	}
	if m.removedwallets != nil {
		edges = append(edges, user.EdgeWallets)
	}
	if m.removedincome_bills != nil {
		edges = append(edges, user.EdgeIncomeBills)
	}
	if m.removedoutcome_bills != nil {
		edges = append(edges, user.EdgeOutcomeBills)
	}
	if m.removedmission_productions != nil {
		edges = append(edges, user.EdgeMissionProductions)
	}
	if m.removedmissions != nil {
		edges = append(edges, user.EdgeMissions)
	}
	if m.removedincome_transfer_orders != nil {
		edges = append(edges, user.EdgeIncomeTransferOrders)
	}
	if m.removedoutcome_transfer_orders != nil {
		edges = append(edges, user.EdgeOutcomeTransferOrders)
	}
	if m.removedconsume_mission_orders != nil {
		edges = append(edges, user.EdgeConsumeMissionOrders)
	}
	if m.removedproduce_mission_orders != nil {
		edges = append(edges, user.EdgeProduceMissionOrders)
	}
	if m.removedlogin_records != nil {
		edges = append(edges, user.EdgeLoginRecords)
	}
	if m.removedrenewal_agreements != nil {
		edges = append(edges, user.EdgeRenewalAgreements)
	}
	if m.removedartworks != nil {
		edges = append(edges, user.EdgeArtworks)
	}
	if m.removedartwork_likes != nil {
		edges = append(edges, user.EdgeArtworkLikes)
	}
	if m.removedcdk_infos != nil {
		edges = append(edges, user.EdgeCdkInfos)
	}
	if m.removeduse_cdk_infos != nil {
		edges = append(edges, user.EdgeUseCdkInfos)
	}
	if m.removedlotto_records != nil {
		edges = append(edges, user.EdgeLottoRecords)
	}
	if m.removedlotto_user_counts != nil {
		edges = append(edges, user.EdgeLottoUserCounts)
	}
	if m.removedlotto_get_count_records != nil {
		edges = append(edges, user.EdgeLottoGetCountRecords)
	}
	if m.removedcloud_files != nil {
		edges = append(edges, user.EdgeCloudFiles)
	}
	if m.removedwithdraw_records != nil {
		edges = append(edges, user.EdgeWithdrawRecords)
	}
	if m.removedoperate_withdraw_records != nil {
		edges = append(edges, user.EdgeOperateWithdrawRecords)
	}
	if m.removedtrouble_deducts != nil {
		edges = append(edges, user.EdgeTroubleDeducts)
	}
	if m.removedincome_manages != nil {
		edges = append(edges, user.EdgeIncomeManages)
	}
	if m.removedapprove_income_manages != nil {
		edges = append(edges, user.EdgeApproveIncomeManages)
	}
	if m.removedsurvey_responses != nil {
		edges = append(edges, user.EdgeSurveyResponses)
	}
	if m.removedapprove_survey_responses != nil {
		edges = append(edges, user.EdgeApproveSurveyResponses)
	}
	if m.removedmission_failed_feedbacks != nil {
		edges = append(edges, user.EdgeMissionFailedFeedbacks)
	}
	if m.removedapi_tokens != nil {
		edges = append(edges, user.EdgeAPITokens)
	}
	if m.removeduser_models != nil {
		edges = append(edges, user.EdgeUserModels)
	}
	if m.removedinvoke_model_orders != nil {
		edges = append(edges, user.EdgeInvokeModelOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVxAccounts:
		ids := make([]ent.Value, 0, len(m.removedvx_accounts))
		for id := range m.removedvx_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCollects:
		ids := make([]ent.Value, 0, len(m.removedcollects))
		for id := range m.removedcollects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfitSettings:
		ids := make([]ent.Value, 0, len(m.removedprofit_settings))
		for id := range m.removedprofit_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_consume_orders))
		for id := range m.removedmission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.removedrecharge_orders))
		for id := range m.removedrecharge_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVxSocials:
		ids := make([]ent.Value, 0, len(m.removedvx_socials))
		for id := range m.removedvx_socials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionBatches:
		ids := make([]ent.Value, 0, len(m.removedmission_batches))
		for id := range m.removedmission_batches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.removeduser_devices))
		for id := range m.removeduser_devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAppletChildren:
		ids := make([]ent.Value, 0, len(m.removedapplet_children))
		for id := range m.removedapplet_children {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.removedinvites))
		for id := range m.removedinvites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCampaignOrders:
		ids := make([]ent.Value, 0, len(m.removedcampaign_orders))
		for id := range m.removedcampaign_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.removedwallets))
		for id := range m.removedwallets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncomeBills:
		ids := make([]ent.Value, 0, len(m.removedincome_bills))
		for id := range m.removedincome_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOutcomeBills:
		ids := make([]ent.Value, 0, len(m.removedoutcome_bills))
		for id := range m.removedoutcome_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.removedmission_productions))
		for id := range m.removedmission_productions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.removedmissions))
		for id := range m.removedmissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncomeTransferOrders:
		ids := make([]ent.Value, 0, len(m.removedincome_transfer_orders))
		for id := range m.removedincome_transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOutcomeTransferOrders:
		ids := make([]ent.Value, 0, len(m.removedoutcome_transfer_orders))
		for id := range m.removedoutcome_transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConsumeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedconsume_mission_orders))
		for id := range m.removedconsume_mission_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProduceMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedproduce_mission_orders))
		for id := range m.removedproduce_mission_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginRecords:
		ids := make([]ent.Value, 0, len(m.removedlogin_records))
		for id := range m.removedlogin_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRenewalAgreements:
		ids := make([]ent.Value, 0, len(m.removedrenewal_agreements))
		for id := range m.removedrenewal_agreements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtworks:
		ids := make([]ent.Value, 0, len(m.removedartworks))
		for id := range m.removedartworks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtworkLikes:
		ids := make([]ent.Value, 0, len(m.removedartwork_likes))
		for id := range m.removedartwork_likes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCdkInfos:
		ids := make([]ent.Value, 0, len(m.removedcdk_infos))
		for id := range m.removedcdk_infos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUseCdkInfos:
		ids := make([]ent.Value, 0, len(m.removeduse_cdk_infos))
		for id := range m.removeduse_cdk_infos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLottoRecords:
		ids := make([]ent.Value, 0, len(m.removedlotto_records))
		for id := range m.removedlotto_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLottoUserCounts:
		ids := make([]ent.Value, 0, len(m.removedlotto_user_counts))
		for id := range m.removedlotto_user_counts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLottoGetCountRecords:
		ids := make([]ent.Value, 0, len(m.removedlotto_get_count_records))
		for id := range m.removedlotto_get_count_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCloudFiles:
		ids := make([]ent.Value, 0, len(m.removedcloud_files))
		for id := range m.removedcloud_files {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWithdrawRecords:
		ids := make([]ent.Value, 0, len(m.removedwithdraw_records))
		for id := range m.removedwithdraw_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOperateWithdrawRecords:
		ids := make([]ent.Value, 0, len(m.removedoperate_withdraw_records))
		for id := range m.removedoperate_withdraw_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTroubleDeducts:
		ids := make([]ent.Value, 0, len(m.removedtrouble_deducts))
		for id := range m.removedtrouble_deducts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncomeManages:
		ids := make([]ent.Value, 0, len(m.removedincome_manages))
		for id := range m.removedincome_manages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApproveIncomeManages:
		ids := make([]ent.Value, 0, len(m.removedapprove_income_manages))
		for id := range m.removedapprove_income_manages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSurveyResponses:
		ids := make([]ent.Value, 0, len(m.removedsurvey_responses))
		for id := range m.removedsurvey_responses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApproveSurveyResponses:
		ids := make([]ent.Value, 0, len(m.removedapprove_survey_responses))
		for id := range m.removedapprove_survey_responses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionFailedFeedbacks:
		ids := make([]ent.Value, 0, len(m.removedmission_failed_feedbacks))
		for id := range m.removedmission_failed_feedbacks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.removedapi_tokens))
		for id := range m.removedapi_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserModels:
		ids := make([]ent.Value, 0, len(m.removeduser_models))
		for id := range m.removeduser_models {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvokeModelOrders:
		ids := make([]ent.Value, 0, len(m.removedinvoke_model_orders))
		for id := range m.removedinvoke_model_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 51)
	if m.clearedvx_accounts {
		edges = append(edges, user.EdgeVxAccounts)
	}
	if m.clearedcollects {
		edges = append(edges, user.EdgeCollects)
	}
	if m.cleareddevices {
		edges = append(edges, user.EdgeDevices)
	}
	if m.clearedprofit_settings {
		edges = append(edges, user.EdgeProfitSettings)
	}
	if m.clearedcost_account {
		edges = append(edges, user.EdgeCostAccount)
	}
	if m.clearedprofit_account {
		edges = append(edges, user.EdgeProfitAccount)
	}
	if m.clearedcost_bills {
		edges = append(edges, user.EdgeCostBills)
	}
	if m.clearedearn_bills {
		edges = append(edges, user.EdgeEarnBills)
	}
	if m.clearedmission_consume_orders {
		edges = append(edges, user.EdgeMissionConsumeOrders)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, user.EdgeMissionProduceOrders)
	}
	if m.clearedrecharge_orders {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.clearedvx_socials {
		edges = append(edges, user.EdgeVxSocials)
	}
	if m.clearedmission_batches {
		edges = append(edges, user.EdgeMissionBatches)
	}
	if m.cleareduser_devices {
		edges = append(edges, user.EdgeUserDevices)
	}
	if m.clearedparent {
		edges = append(edges, user.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, user.EdgeChildren)
	}
	if m.clearedapplet_parent {
		edges = append(edges, user.EdgeAppletParent)
	}
	if m.clearedapplet_children {
		edges = append(edges, user.EdgeAppletChildren)
	}
	if m.clearedinvites {
		edges = append(edges, user.EdgeInvites)
	}
	if m.clearedcampaign_orders {
		edges = append(edges, user.EdgeCampaignOrders)
	}
	if m.clearedwallets {
		edges = append(edges, user.EdgeWallets)
	}
	if m.clearedwithdraw_account {
		edges = append(edges, user.EdgeWithdrawAccount)
	}
	if m.clearedincome_bills {
		edges = append(edges, user.EdgeIncomeBills)
	}
	if m.clearedoutcome_bills {
		edges = append(edges, user.EdgeOutcomeBills)
	}
	if m.clearedmission_productions {
		edges = append(edges, user.EdgeMissionProductions)
	}
	if m.clearedmissions {
		edges = append(edges, user.EdgeMissions)
	}
	if m.clearedincome_transfer_orders {
		edges = append(edges, user.EdgeIncomeTransferOrders)
	}
	if m.clearedoutcome_transfer_orders {
		edges = append(edges, user.EdgeOutcomeTransferOrders)
	}
	if m.clearedconsume_mission_orders {
		edges = append(edges, user.EdgeConsumeMissionOrders)
	}
	if m.clearedproduce_mission_orders {
		edges = append(edges, user.EdgeProduceMissionOrders)
	}
	if m.clearedlogin_records {
		edges = append(edges, user.EdgeLoginRecords)
	}
	if m.clearedrenewal_agreements {
		edges = append(edges, user.EdgeRenewalAgreements)
	}
	if m.clearedartworks {
		edges = append(edges, user.EdgeArtworks)
	}
	if m.clearedartwork_likes {
		edges = append(edges, user.EdgeArtworkLikes)
	}
	if m.clearedcdk_infos {
		edges = append(edges, user.EdgeCdkInfos)
	}
	if m.cleareduse_cdk_infos {
		edges = append(edges, user.EdgeUseCdkInfos)
	}
	if m.clearedlotto_records {
		edges = append(edges, user.EdgeLottoRecords)
	}
	if m.clearedlotto_user_counts {
		edges = append(edges, user.EdgeLottoUserCounts)
	}
	if m.clearedlotto_get_count_records {
		edges = append(edges, user.EdgeLottoGetCountRecords)
	}
	if m.clearedcloud_files {
		edges = append(edges, user.EdgeCloudFiles)
	}
	if m.clearedwithdraw_records {
		edges = append(edges, user.EdgeWithdrawRecords)
	}
	if m.clearedoperate_withdraw_records {
		edges = append(edges, user.EdgeOperateWithdrawRecords)
	}
	if m.clearedtrouble_deducts {
		edges = append(edges, user.EdgeTroubleDeducts)
	}
	if m.clearedincome_manages {
		edges = append(edges, user.EdgeIncomeManages)
	}
	if m.clearedapprove_income_manages {
		edges = append(edges, user.EdgeApproveIncomeManages)
	}
	if m.clearedsurvey_responses {
		edges = append(edges, user.EdgeSurveyResponses)
	}
	if m.clearedapprove_survey_responses {
		edges = append(edges, user.EdgeApproveSurveyResponses)
	}
	if m.clearedmission_failed_feedbacks {
		edges = append(edges, user.EdgeMissionFailedFeedbacks)
	}
	if m.clearedapi_tokens {
		edges = append(edges, user.EdgeAPITokens)
	}
	if m.cleareduser_models {
		edges = append(edges, user.EdgeUserModels)
	}
	if m.clearedinvoke_model_orders {
		edges = append(edges, user.EdgeInvokeModelOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeVxAccounts:
		return m.clearedvx_accounts
	case user.EdgeCollects:
		return m.clearedcollects
	case user.EdgeDevices:
		return m.cleareddevices
	case user.EdgeProfitSettings:
		return m.clearedprofit_settings
	case user.EdgeCostAccount:
		return m.clearedcost_account
	case user.EdgeProfitAccount:
		return m.clearedprofit_account
	case user.EdgeCostBills:
		return m.clearedcost_bills
	case user.EdgeEarnBills:
		return m.clearedearn_bills
	case user.EdgeMissionConsumeOrders:
		return m.clearedmission_consume_orders
	case user.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case user.EdgeRechargeOrders:
		return m.clearedrecharge_orders
	case user.EdgeVxSocials:
		return m.clearedvx_socials
	case user.EdgeMissionBatches:
		return m.clearedmission_batches
	case user.EdgeUserDevices:
		return m.cleareduser_devices
	case user.EdgeParent:
		return m.clearedparent
	case user.EdgeChildren:
		return m.clearedchildren
	case user.EdgeAppletParent:
		return m.clearedapplet_parent
	case user.EdgeAppletChildren:
		return m.clearedapplet_children
	case user.EdgeInvites:
		return m.clearedinvites
	case user.EdgeCampaignOrders:
		return m.clearedcampaign_orders
	case user.EdgeWallets:
		return m.clearedwallets
	case user.EdgeWithdrawAccount:
		return m.clearedwithdraw_account
	case user.EdgeIncomeBills:
		return m.clearedincome_bills
	case user.EdgeOutcomeBills:
		return m.clearedoutcome_bills
	case user.EdgeMissionProductions:
		return m.clearedmission_productions
	case user.EdgeMissions:
		return m.clearedmissions
	case user.EdgeIncomeTransferOrders:
		return m.clearedincome_transfer_orders
	case user.EdgeOutcomeTransferOrders:
		return m.clearedoutcome_transfer_orders
	case user.EdgeConsumeMissionOrders:
		return m.clearedconsume_mission_orders
	case user.EdgeProduceMissionOrders:
		return m.clearedproduce_mission_orders
	case user.EdgeLoginRecords:
		return m.clearedlogin_records
	case user.EdgeRenewalAgreements:
		return m.clearedrenewal_agreements
	case user.EdgeArtworks:
		return m.clearedartworks
	case user.EdgeArtworkLikes:
		return m.clearedartwork_likes
	case user.EdgeCdkInfos:
		return m.clearedcdk_infos
	case user.EdgeUseCdkInfos:
		return m.cleareduse_cdk_infos
	case user.EdgeLottoRecords:
		return m.clearedlotto_records
	case user.EdgeLottoUserCounts:
		return m.clearedlotto_user_counts
	case user.EdgeLottoGetCountRecords:
		return m.clearedlotto_get_count_records
	case user.EdgeCloudFiles:
		return m.clearedcloud_files
	case user.EdgeWithdrawRecords:
		return m.clearedwithdraw_records
	case user.EdgeOperateWithdrawRecords:
		return m.clearedoperate_withdraw_records
	case user.EdgeTroubleDeducts:
		return m.clearedtrouble_deducts
	case user.EdgeIncomeManages:
		return m.clearedincome_manages
	case user.EdgeApproveIncomeManages:
		return m.clearedapprove_income_manages
	case user.EdgeSurveyResponses:
		return m.clearedsurvey_responses
	case user.EdgeApproveSurveyResponses:
		return m.clearedapprove_survey_responses
	case user.EdgeMissionFailedFeedbacks:
		return m.clearedmission_failed_feedbacks
	case user.EdgeAPITokens:
		return m.clearedapi_tokens
	case user.EdgeUserModels:
		return m.cleareduser_models
	case user.EdgeInvokeModelOrders:
		return m.clearedinvoke_model_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCostAccount:
		m.ClearCostAccount()
		return nil
	case user.EdgeProfitAccount:
		m.ClearProfitAccount()
		return nil
	case user.EdgeParent:
		m.ClearParent()
		return nil
	case user.EdgeAppletParent:
		m.ClearAppletParent()
		return nil
	case user.EdgeWithdrawAccount:
		m.ClearWithdrawAccount()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeVxAccounts:
		m.ResetVxAccounts()
		return nil
	case user.EdgeCollects:
		m.ResetCollects()
		return nil
	case user.EdgeDevices:
		m.ResetDevices()
		return nil
	case user.EdgeProfitSettings:
		m.ResetProfitSettings()
		return nil
	case user.EdgeCostAccount:
		m.ResetCostAccount()
		return nil
	case user.EdgeProfitAccount:
		m.ResetProfitAccount()
		return nil
	case user.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case user.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	case user.EdgeMissionConsumeOrders:
		m.ResetMissionConsumeOrders()
		return nil
	case user.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case user.EdgeRechargeOrders:
		m.ResetRechargeOrders()
		return nil
	case user.EdgeVxSocials:
		m.ResetVxSocials()
		return nil
	case user.EdgeMissionBatches:
		m.ResetMissionBatches()
		return nil
	case user.EdgeUserDevices:
		m.ResetUserDevices()
		return nil
	case user.EdgeParent:
		m.ResetParent()
		return nil
	case user.EdgeChildren:
		m.ResetChildren()
		return nil
	case user.EdgeAppletParent:
		m.ResetAppletParent()
		return nil
	case user.EdgeAppletChildren:
		m.ResetAppletChildren()
		return nil
	case user.EdgeInvites:
		m.ResetInvites()
		return nil
	case user.EdgeCampaignOrders:
		m.ResetCampaignOrders()
		return nil
	case user.EdgeWallets:
		m.ResetWallets()
		return nil
	case user.EdgeWithdrawAccount:
		m.ResetWithdrawAccount()
		return nil
	case user.EdgeIncomeBills:
		m.ResetIncomeBills()
		return nil
	case user.EdgeOutcomeBills:
		m.ResetOutcomeBills()
		return nil
	case user.EdgeMissionProductions:
		m.ResetMissionProductions()
		return nil
	case user.EdgeMissions:
		m.ResetMissions()
		return nil
	case user.EdgeIncomeTransferOrders:
		m.ResetIncomeTransferOrders()
		return nil
	case user.EdgeOutcomeTransferOrders:
		m.ResetOutcomeTransferOrders()
		return nil
	case user.EdgeConsumeMissionOrders:
		m.ResetConsumeMissionOrders()
		return nil
	case user.EdgeProduceMissionOrders:
		m.ResetProduceMissionOrders()
		return nil
	case user.EdgeLoginRecords:
		m.ResetLoginRecords()
		return nil
	case user.EdgeRenewalAgreements:
		m.ResetRenewalAgreements()
		return nil
	case user.EdgeArtworks:
		m.ResetArtworks()
		return nil
	case user.EdgeArtworkLikes:
		m.ResetArtworkLikes()
		return nil
	case user.EdgeCdkInfos:
		m.ResetCdkInfos()
		return nil
	case user.EdgeUseCdkInfos:
		m.ResetUseCdkInfos()
		return nil
	case user.EdgeLottoRecords:
		m.ResetLottoRecords()
		return nil
	case user.EdgeLottoUserCounts:
		m.ResetLottoUserCounts()
		return nil
	case user.EdgeLottoGetCountRecords:
		m.ResetLottoGetCountRecords()
		return nil
	case user.EdgeCloudFiles:
		m.ResetCloudFiles()
		return nil
	case user.EdgeWithdrawRecords:
		m.ResetWithdrawRecords()
		return nil
	case user.EdgeOperateWithdrawRecords:
		m.ResetOperateWithdrawRecords()
		return nil
	case user.EdgeTroubleDeducts:
		m.ResetTroubleDeducts()
		return nil
	case user.EdgeIncomeManages:
		m.ResetIncomeManages()
		return nil
	case user.EdgeApproveIncomeManages:
		m.ResetApproveIncomeManages()
		return nil
	case user.EdgeSurveyResponses:
		m.ResetSurveyResponses()
		return nil
	case user.EdgeApproveSurveyResponses:
		m.ResetApproveSurveyResponses()
		return nil
	case user.EdgeMissionFailedFeedbacks:
		m.ResetMissionFailedFeedbacks()
		return nil
	case user.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	case user.EdgeUserModels:
		m.ResetUserModels()
		return nil
	case user.EdgeInvokeModelOrders:
		m.ResetInvokeModelOrders()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDeviceMutation represents an operation that mutates the UserDevice nodes in the graph.
type UserDeviceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	bind_at       *time.Time
	unbind_at     *time.Time
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	device        *int64
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*UserDevice, error)
	predicates    []predicate.UserDevice
}

var _ ent.Mutation = (*UserDeviceMutation)(nil)

// userdeviceOption allows management of the mutation configuration using functional options.
type userdeviceOption func(*UserDeviceMutation)

// newUserDeviceMutation creates new mutation for the UserDevice entity.
func newUserDeviceMutation(c config, op Op, opts ...userdeviceOption) *UserDeviceMutation {
	m := &UserDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDeviceID sets the ID field of the mutation.
func withUserDeviceID(id int64) userdeviceOption {
	return func(m *UserDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDevice
		)
		m.oldValue = func(ctx context.Context) (*UserDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDevice sets the old UserDevice of the mutation.
func withUserDevice(node *UserDevice) userdeviceOption {
	return func(m *UserDeviceMutation) {
		m.oldValue = func(context.Context) (*UserDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserDevice entities.
func (m *UserDeviceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDeviceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserDeviceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserDeviceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserDeviceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserDeviceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserDeviceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserDeviceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserDeviceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserDeviceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserDeviceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserDeviceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserDeviceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserDeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserDeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserDeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserDeviceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserDeviceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserDeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserDeviceMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserDeviceMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserDeviceMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceID sets the "device_id" field.
func (m *UserDeviceMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *UserDeviceMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *UserDeviceMutation) ResetDeviceID() {
	m.device = nil
}

// SetBindAt sets the "bind_at" field.
func (m *UserDeviceMutation) SetBindAt(t time.Time) {
	m.bind_at = &t
}

// BindAt returns the value of the "bind_at" field in the mutation.
func (m *UserDeviceMutation) BindAt() (r time.Time, exists bool) {
	v := m.bind_at
	if v == nil {
		return
	}
	return *v, true
}

// OldBindAt returns the old "bind_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldBindAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindAt: %w", err)
	}
	return oldValue.BindAt, nil
}

// ClearBindAt clears the value of the "bind_at" field.
func (m *UserDeviceMutation) ClearBindAt() {
	m.bind_at = nil
	m.clearedFields[userdevice.FieldBindAt] = struct{}{}
}

// BindAtCleared returns if the "bind_at" field was cleared in this mutation.
func (m *UserDeviceMutation) BindAtCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldBindAt]
	return ok
}

// ResetBindAt resets all changes to the "bind_at" field.
func (m *UserDeviceMutation) ResetBindAt() {
	m.bind_at = nil
	delete(m.clearedFields, userdevice.FieldBindAt)
}

// SetUnbindAt sets the "unbind_at" field.
func (m *UserDeviceMutation) SetUnbindAt(t time.Time) {
	m.unbind_at = &t
}

// UnbindAt returns the value of the "unbind_at" field in the mutation.
func (m *UserDeviceMutation) UnbindAt() (r time.Time, exists bool) {
	v := m.unbind_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUnbindAt returns the old "unbind_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUnbindAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnbindAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnbindAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnbindAt: %w", err)
	}
	return oldValue.UnbindAt, nil
}

// ClearUnbindAt clears the value of the "unbind_at" field.
func (m *UserDeviceMutation) ClearUnbindAt() {
	m.unbind_at = nil
	m.clearedFields[userdevice.FieldUnbindAt] = struct{}{}
}

// UnbindAtCleared returns if the "unbind_at" field was cleared in this mutation.
func (m *UserDeviceMutation) UnbindAtCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUnbindAt]
	return ok
}

// ResetUnbindAt resets all changes to the "unbind_at" field.
func (m *UserDeviceMutation) ResetUnbindAt() {
	m.unbind_at = nil
	delete(m.clearedFields, userdevice.FieldUnbindAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserDeviceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userdevice.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserDeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserDeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *UserDeviceMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[userdevice.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *UserDeviceMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *UserDeviceMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the UserDeviceMutation builder.
func (m *UserDeviceMutation) Where(ps ...predicate.UserDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserDevice).
func (m *UserDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDeviceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userdevice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userdevice.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.device != nil {
		fields = append(fields, userdevice.FieldDeviceID)
	}
	if m.bind_at != nil {
		fields = append(fields, userdevice.FieldBindAt)
	}
	if m.unbind_at != nil {
		fields = append(fields, userdevice.FieldUnbindAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.CreatedBy()
	case userdevice.FieldUpdatedBy:
		return m.UpdatedBy()
	case userdevice.FieldCreatedAt:
		return m.CreatedAt()
	case userdevice.FieldUpdatedAt:
		return m.UpdatedAt()
	case userdevice.FieldDeletedAt:
		return m.DeletedAt()
	case userdevice.FieldUserID:
		return m.UserID()
	case userdevice.FieldDeviceID:
		return m.DeviceID()
	case userdevice.FieldBindAt:
		return m.BindAt()
	case userdevice.FieldUnbindAt:
		return m.UnbindAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userdevice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userdevice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userdevice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userdevice.FieldUserID:
		return m.OldUserID(ctx)
	case userdevice.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case userdevice.FieldBindAt:
		return m.OldBindAt(ctx)
	case userdevice.FieldUnbindAt:
		return m.OldUnbindAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userdevice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userdevice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userdevice.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdevice.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case userdevice.FieldBindAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindAt(v)
		return nil
	case userdevice.FieldUnbindAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnbindAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userdevice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userdevice.FieldBindAt) {
		fields = append(fields, userdevice.FieldBindAt)
	}
	if m.FieldCleared(userdevice.FieldUnbindAt) {
		fields = append(fields, userdevice.FieldUnbindAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDeviceMutation) ClearField(name string) error {
	switch name {
	case userdevice.FieldBindAt:
		m.ClearBindAt()
		return nil
	case userdevice.FieldUnbindAt:
		m.ClearUnbindAt()
		return nil
	}
	return fmt.Errorf("unknown UserDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDeviceMutation) ResetField(name string) error {
	switch name {
	case userdevice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userdevice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userdevice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userdevice.FieldUserID:
		m.ResetUserID()
		return nil
	case userdevice.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case userdevice.FieldBindAt:
		m.ResetBindAt()
		return nil
	case userdevice.FieldUnbindAt:
		m.ResetUnbindAt()
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userdevice.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, userdevice.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userdevice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userdevice.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userdevice.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, userdevice.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case userdevice.EdgeUser:
		return m.cleareduser
	case userdevice.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDeviceMutation) ClearEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ClearUser()
		return nil
	case userdevice.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown UserDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDeviceMutation) ResetEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ResetUser()
		return nil
	case userdevice.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown UserDevice edge %s", name)
}

// UserModelMutation represents an operation that mutates the UserModel nodes in the graph.
type UserModelMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	relation      *enums.UserModelRelation
	status        *enums.UserModelRelationStatus
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	model         *int64
	clearedmodel  bool
	done          bool
	oldValue      func(context.Context) (*UserModel, error)
	predicates    []predicate.UserModel
}

var _ ent.Mutation = (*UserModelMutation)(nil)

// usermodelOption allows management of the mutation configuration using functional options.
type usermodelOption func(*UserModelMutation)

// newUserModelMutation creates new mutation for the UserModel entity.
func newUserModelMutation(c config, op Op, opts ...usermodelOption) *UserModelMutation {
	m := &UserModelMutation{
		config:        c,
		op:            op,
		typ:           TypeUserModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserModelID sets the ID field of the mutation.
func withUserModelID(id int64) usermodelOption {
	return func(m *UserModelMutation) {
		var (
			err   error
			once  sync.Once
			value *UserModel
		)
		m.oldValue = func(ctx context.Context) (*UserModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserModel sets the old UserModel of the mutation.
func withUserModel(node *UserModel) usermodelOption {
	return func(m *UserModelMutation) {
		m.oldValue = func(context.Context) (*UserModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserModel entities.
func (m *UserModelMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserModelMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserModelMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserModelMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserModelMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserModel entity.
// If the UserModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserModelMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserModelMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserModelMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserModelMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserModelMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserModelMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserModel entity.
// If the UserModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserModelMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserModelMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserModelMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserModelMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserModel entity.
// If the UserModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserModel entity.
// If the UserModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserModelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserModelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserModel entity.
// If the UserModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserModelMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserModelMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserModelMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserModelMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserModel entity.
// If the UserModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserModelMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserModelMutation) ResetUserID() {
	m.user = nil
}

// SetModelID sets the "model_id" field.
func (m *UserModelMutation) SetModelID(i int64) {
	m.model = &i
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *UserModelMutation) ModelID() (r int64, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the UserModel entity.
// If the UserModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserModelMutation) OldModelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *UserModelMutation) ResetModelID() {
	m.model = nil
}

// SetRelation sets the "relation" field.
func (m *UserModelMutation) SetRelation(emr enums.UserModelRelation) {
	m.relation = &emr
}

// Relation returns the value of the "relation" field in the mutation.
func (m *UserModelMutation) Relation() (r enums.UserModelRelation, exists bool) {
	v := m.relation
	if v == nil {
		return
	}
	return *v, true
}

// OldRelation returns the old "relation" field's value of the UserModel entity.
// If the UserModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserModelMutation) OldRelation(ctx context.Context) (v enums.UserModelRelation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelation: %w", err)
	}
	return oldValue.Relation, nil
}

// ResetRelation resets all changes to the "relation" field.
func (m *UserModelMutation) ResetRelation() {
	m.relation = nil
}

// SetStatus sets the "status" field.
func (m *UserModelMutation) SetStatus(emrs enums.UserModelRelationStatus) {
	m.status = &emrs
}

// Status returns the value of the "status" field in the mutation.
func (m *UserModelMutation) Status() (r enums.UserModelRelationStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserModel entity.
// If the UserModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserModelMutation) OldStatus(ctx context.Context) (v enums.UserModelRelationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserModelMutation) ResetStatus() {
	m.status = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserModelMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usermodel.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserModelMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserModelMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserModelMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearModel clears the "model" edge to the Model entity.
func (m *UserModelMutation) ClearModel() {
	m.clearedmodel = true
	m.clearedFields[usermodel.FieldModelID] = struct{}{}
}

// ModelCleared reports if the "model" edge to the Model entity was cleared.
func (m *UserModelMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *UserModelMutation) ModelIDs() (ids []int64) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *UserModelMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// Where appends a list predicates to the UserModelMutation builder.
func (m *UserModelMutation) Where(ps ...predicate.UserModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserModel).
func (m *UserModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserModelMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, usermodel.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, usermodel.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, usermodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usermodel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usermodel.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, usermodel.FieldUserID)
	}
	if m.model != nil {
		fields = append(fields, usermodel.FieldModelID)
	}
	if m.relation != nil {
		fields = append(fields, usermodel.FieldRelation)
	}
	if m.status != nil {
		fields = append(fields, usermodel.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usermodel.FieldCreatedBy:
		return m.CreatedBy()
	case usermodel.FieldUpdatedBy:
		return m.UpdatedBy()
	case usermodel.FieldCreatedAt:
		return m.CreatedAt()
	case usermodel.FieldUpdatedAt:
		return m.UpdatedAt()
	case usermodel.FieldDeletedAt:
		return m.DeletedAt()
	case usermodel.FieldUserID:
		return m.UserID()
	case usermodel.FieldModelID:
		return m.ModelID()
	case usermodel.FieldRelation:
		return m.Relation()
	case usermodel.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usermodel.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case usermodel.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case usermodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usermodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usermodel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usermodel.FieldUserID:
		return m.OldUserID(ctx)
	case usermodel.FieldModelID:
		return m.OldModelID(ctx)
	case usermodel.FieldRelation:
		return m.OldRelation(ctx)
	case usermodel.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usermodel.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case usermodel.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case usermodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usermodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usermodel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usermodel.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usermodel.FieldModelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case usermodel.FieldRelation:
		v, ok := value.(enums.UserModelRelation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelation(v)
		return nil
	case usermodel.FieldStatus:
		v, ok := value.(enums.UserModelRelationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserModelMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, usermodel.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, usermodel.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usermodel.FieldCreatedBy:
		return m.AddedCreatedBy()
	case usermodel.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usermodel.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case usermodel.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserModelMutation) ResetField(name string) error {
	switch name {
	case usermodel.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case usermodel.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case usermodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usermodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usermodel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usermodel.FieldUserID:
		m.ResetUserID()
		return nil
	case usermodel.FieldModelID:
		m.ResetModelID()
		return nil
	case usermodel.FieldRelation:
		m.ResetRelation()
		return nil
	case usermodel.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usermodel.EdgeUser)
	}
	if m.model != nil {
		edges = append(edges, usermodel.EdgeModel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usermodel.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usermodel.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserModelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usermodel.EdgeUser)
	}
	if m.clearedmodel {
		edges = append(edges, usermodel.EdgeModel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserModelMutation) EdgeCleared(name string) bool {
	switch name {
	case usermodel.EdgeUser:
		return m.cleareduser
	case usermodel.EdgeModel:
		return m.clearedmodel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserModelMutation) ClearEdge(name string) error {
	switch name {
	case usermodel.EdgeUser:
		m.ClearUser()
		return nil
	case usermodel.EdgeModel:
		m.ClearModel()
		return nil
	}
	return fmt.Errorf("unknown UserModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserModelMutation) ResetEdge(name string) error {
	switch name {
	case usermodel.EdgeUser:
		m.ResetUser()
		return nil
	case usermodel.EdgeModel:
		m.ResetModel()
		return nil
	}
	return fmt.Errorf("unknown UserModel edge %s", name)
}

// VXAccountMutation represents an operation that mutates the VXAccount nodes in the graph.
type VXAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	open_id       *string
	union_id      *string
	scope         *string
	session_key   *string
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*VXAccount, error)
	predicates    []predicate.VXAccount
}

var _ ent.Mutation = (*VXAccountMutation)(nil)

// vxaccountOption allows management of the mutation configuration using functional options.
type vxaccountOption func(*VXAccountMutation)

// newVXAccountMutation creates new mutation for the VXAccount entity.
func newVXAccountMutation(c config, op Op, opts ...vxaccountOption) *VXAccountMutation {
	m := &VXAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeVXAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVXAccountID sets the ID field of the mutation.
func withVXAccountID(id int64) vxaccountOption {
	return func(m *VXAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *VXAccount
		)
		m.oldValue = func(ctx context.Context) (*VXAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VXAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVXAccount sets the old VXAccount of the mutation.
func withVXAccount(node *VXAccount) vxaccountOption {
	return func(m *VXAccountMutation) {
		m.oldValue = func(context.Context) (*VXAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VXAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VXAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VXAccount entities.
func (m *VXAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VXAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VXAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VXAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *VXAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VXAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VXAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VXAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VXAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VXAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VXAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VXAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VXAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VXAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VXAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VXAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VXAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VXAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VXAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VXAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VXAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VXAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VXAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetOpenID sets the "open_id" field.
func (m *VXAccountMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *VXAccountMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *VXAccountMutation) ResetOpenID() {
	m.open_id = nil
}

// SetUnionID sets the "union_id" field.
func (m *VXAccountMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *VXAccountMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *VXAccountMutation) ResetUnionID() {
	m.union_id = nil
}

// SetScope sets the "scope" field.
func (m *VXAccountMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *VXAccountMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *VXAccountMutation) ResetScope() {
	m.scope = nil
}

// SetSessionKey sets the "session_key" field.
func (m *VXAccountMutation) SetSessionKey(s string) {
	m.session_key = &s
}

// SessionKey returns the value of the "session_key" field in the mutation.
func (m *VXAccountMutation) SessionKey() (r string, exists bool) {
	v := m.session_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionKey returns the old "session_key" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldSessionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionKey: %w", err)
	}
	return oldValue.SessionKey, nil
}

// ResetSessionKey resets all changes to the "session_key" field.
func (m *VXAccountMutation) ResetSessionKey() {
	m.session_key = nil
}

// SetUserID sets the "user_id" field.
func (m *VXAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VXAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VXAccountMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *VXAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[vxaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VXAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VXAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VXAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VXAccountMutation builder.
func (m *VXAccountMutation) Where(ps ...predicate.VXAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VXAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VXAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VXAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VXAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VXAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VXAccount).
func (m *VXAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VXAccountMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, vxaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, vxaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, vxaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vxaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vxaccount.FieldDeletedAt)
	}
	if m.open_id != nil {
		fields = append(fields, vxaccount.FieldOpenID)
	}
	if m.union_id != nil {
		fields = append(fields, vxaccount.FieldUnionID)
	}
	if m.scope != nil {
		fields = append(fields, vxaccount.FieldScope)
	}
	if m.session_key != nil {
		fields = append(fields, vxaccount.FieldSessionKey)
	}
	if m.user != nil {
		fields = append(fields, vxaccount.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VXAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vxaccount.FieldCreatedBy:
		return m.CreatedBy()
	case vxaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case vxaccount.FieldCreatedAt:
		return m.CreatedAt()
	case vxaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case vxaccount.FieldDeletedAt:
		return m.DeletedAt()
	case vxaccount.FieldOpenID:
		return m.OpenID()
	case vxaccount.FieldUnionID:
		return m.UnionID()
	case vxaccount.FieldScope:
		return m.Scope()
	case vxaccount.FieldSessionKey:
		return m.SessionKey()
	case vxaccount.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VXAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vxaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vxaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vxaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vxaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vxaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vxaccount.FieldOpenID:
		return m.OldOpenID(ctx)
	case vxaccount.FieldUnionID:
		return m.OldUnionID(ctx)
	case vxaccount.FieldScope:
		return m.OldScope(ctx)
	case vxaccount.FieldSessionKey:
		return m.OldSessionKey(ctx)
	case vxaccount.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown VXAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vxaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vxaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vxaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vxaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vxaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vxaccount.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case vxaccount.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	case vxaccount.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case vxaccount.FieldSessionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionKey(v)
		return nil
	case vxaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown VXAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VXAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vxaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vxaccount.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VXAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vxaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vxaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vxaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vxaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VXAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VXAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VXAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VXAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VXAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VXAccountMutation) ResetField(name string) error {
	switch name {
	case vxaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vxaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vxaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vxaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vxaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vxaccount.FieldOpenID:
		m.ResetOpenID()
		return nil
	case vxaccount.FieldUnionID:
		m.ResetUnionID()
		return nil
	case vxaccount.FieldScope:
		m.ResetScope()
		return nil
	case vxaccount.FieldSessionKey:
		m.ResetSessionKey()
		return nil
	case vxaccount.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown VXAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VXAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, vxaccount.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VXAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vxaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VXAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VXAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VXAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, vxaccount.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VXAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case vxaccount.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VXAccountMutation) ClearEdge(name string) error {
	switch name {
	case vxaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown VXAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VXAccountMutation) ResetEdge(name string) error {
	switch name {
	case vxaccount.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown VXAccount edge %s", name)
}

// VXSocialMutation represents an operation that mutates the VXSocial nodes in the graph.
type VXSocialMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_by             *int64
	addcreated_by          *int64
	updated_by             *int64
	addupdated_by          *int64
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	app_id                 *string
	open_id                *string
	union_id               *string
	scope                  *vxsocial.Scope
	session_key            *string
	access_token           *string
	refresh_token          *string
	clearedFields          map[string]struct{}
	user                   *int64
	cleareduser            bool
	recharge_orders        map[int64]struct{}
	removedrecharge_orders map[int64]struct{}
	clearedrecharge_orders bool
	transfer_orders        map[int64]struct{}
	removedtransfer_orders map[int64]struct{}
	clearedtransfer_orders bool
	done                   bool
	oldValue               func(context.Context) (*VXSocial, error)
	predicates             []predicate.VXSocial
}

var _ ent.Mutation = (*VXSocialMutation)(nil)

// vxsocialOption allows management of the mutation configuration using functional options.
type vxsocialOption func(*VXSocialMutation)

// newVXSocialMutation creates new mutation for the VXSocial entity.
func newVXSocialMutation(c config, op Op, opts ...vxsocialOption) *VXSocialMutation {
	m := &VXSocialMutation{
		config:        c,
		op:            op,
		typ:           TypeVXSocial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVXSocialID sets the ID field of the mutation.
func withVXSocialID(id int64) vxsocialOption {
	return func(m *VXSocialMutation) {
		var (
			err   error
			once  sync.Once
			value *VXSocial
		)
		m.oldValue = func(ctx context.Context) (*VXSocial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VXSocial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVXSocial sets the old VXSocial of the mutation.
func withVXSocial(node *VXSocial) vxsocialOption {
	return func(m *VXSocialMutation) {
		m.oldValue = func(context.Context) (*VXSocial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VXSocialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VXSocialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VXSocial entities.
func (m *VXSocialMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VXSocialMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VXSocialMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VXSocial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *VXSocialMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VXSocialMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VXSocialMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VXSocialMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VXSocialMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VXSocialMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VXSocialMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VXSocialMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VXSocialMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VXSocialMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VXSocialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VXSocialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VXSocialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VXSocialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VXSocialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VXSocialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VXSocialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VXSocialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VXSocialMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *VXSocialMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *VXSocialMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *VXSocialMutation) ResetAppID() {
	m.app_id = nil
}

// SetOpenID sets the "open_id" field.
func (m *VXSocialMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *VXSocialMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *VXSocialMutation) ResetOpenID() {
	m.open_id = nil
}

// SetUnionID sets the "union_id" field.
func (m *VXSocialMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *VXSocialMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *VXSocialMutation) ResetUnionID() {
	m.union_id = nil
}

// SetScope sets the "scope" field.
func (m *VXSocialMutation) SetScope(v vxsocial.Scope) {
	m.scope = &v
}

// Scope returns the value of the "scope" field in the mutation.
func (m *VXSocialMutation) Scope() (r vxsocial.Scope, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldScope(ctx context.Context) (v vxsocial.Scope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *VXSocialMutation) ResetScope() {
	m.scope = nil
}

// SetSessionKey sets the "session_key" field.
func (m *VXSocialMutation) SetSessionKey(s string) {
	m.session_key = &s
}

// SessionKey returns the value of the "session_key" field in the mutation.
func (m *VXSocialMutation) SessionKey() (r string, exists bool) {
	v := m.session_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionKey returns the old "session_key" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldSessionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionKey: %w", err)
	}
	return oldValue.SessionKey, nil
}

// ResetSessionKey resets all changes to the "session_key" field.
func (m *VXSocialMutation) ResetSessionKey() {
	m.session_key = nil
}

// SetAccessToken sets the "access_token" field.
func (m *VXSocialMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *VXSocialMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *VXSocialMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *VXSocialMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *VXSocialMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *VXSocialMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetUserID sets the "user_id" field.
func (m *VXSocialMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VXSocialMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VXSocialMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *VXSocialMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[vxsocial.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VXSocialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VXSocialMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VXSocialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddRechargeOrderIDs adds the "recharge_orders" edge to the RechargeOrder entity by ids.
func (m *VXSocialMutation) AddRechargeOrderIDs(ids ...int64) {
	if m.recharge_orders == nil {
		m.recharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.recharge_orders[ids[i]] = struct{}{}
	}
}

// ClearRechargeOrders clears the "recharge_orders" edge to the RechargeOrder entity.
func (m *VXSocialMutation) ClearRechargeOrders() {
	m.clearedrecharge_orders = true
}

// RechargeOrdersCleared reports if the "recharge_orders" edge to the RechargeOrder entity was cleared.
func (m *VXSocialMutation) RechargeOrdersCleared() bool {
	return m.clearedrecharge_orders
}

// RemoveRechargeOrderIDs removes the "recharge_orders" edge to the RechargeOrder entity by IDs.
func (m *VXSocialMutation) RemoveRechargeOrderIDs(ids ...int64) {
	if m.removedrecharge_orders == nil {
		m.removedrecharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.recharge_orders, ids[i])
		m.removedrecharge_orders[ids[i]] = struct{}{}
	}
}

// RemovedRechargeOrders returns the removed IDs of the "recharge_orders" edge to the RechargeOrder entity.
func (m *VXSocialMutation) RemovedRechargeOrdersIDs() (ids []int64) {
	for id := range m.removedrecharge_orders {
		ids = append(ids, id)
	}
	return
}

// RechargeOrdersIDs returns the "recharge_orders" edge IDs in the mutation.
func (m *VXSocialMutation) RechargeOrdersIDs() (ids []int64) {
	for id := range m.recharge_orders {
		ids = append(ids, id)
	}
	return
}

// ResetRechargeOrders resets all changes to the "recharge_orders" edge.
func (m *VXSocialMutation) ResetRechargeOrders() {
	m.recharge_orders = nil
	m.clearedrecharge_orders = false
	m.removedrecharge_orders = nil
}

// AddTransferOrderIDs adds the "transfer_orders" edge to the TransferOrder entity by ids.
func (m *VXSocialMutation) AddTransferOrderIDs(ids ...int64) {
	if m.transfer_orders == nil {
		m.transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.transfer_orders[ids[i]] = struct{}{}
	}
}

// ClearTransferOrders clears the "transfer_orders" edge to the TransferOrder entity.
func (m *VXSocialMutation) ClearTransferOrders() {
	m.clearedtransfer_orders = true
}

// TransferOrdersCleared reports if the "transfer_orders" edge to the TransferOrder entity was cleared.
func (m *VXSocialMutation) TransferOrdersCleared() bool {
	return m.clearedtransfer_orders
}

// RemoveTransferOrderIDs removes the "transfer_orders" edge to the TransferOrder entity by IDs.
func (m *VXSocialMutation) RemoveTransferOrderIDs(ids ...int64) {
	if m.removedtransfer_orders == nil {
		m.removedtransfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.transfer_orders, ids[i])
		m.removedtransfer_orders[ids[i]] = struct{}{}
	}
}

// RemovedTransferOrders returns the removed IDs of the "transfer_orders" edge to the TransferOrder entity.
func (m *VXSocialMutation) RemovedTransferOrdersIDs() (ids []int64) {
	for id := range m.removedtransfer_orders {
		ids = append(ids, id)
	}
	return
}

// TransferOrdersIDs returns the "transfer_orders" edge IDs in the mutation.
func (m *VXSocialMutation) TransferOrdersIDs() (ids []int64) {
	for id := range m.transfer_orders {
		ids = append(ids, id)
	}
	return
}

// ResetTransferOrders resets all changes to the "transfer_orders" edge.
func (m *VXSocialMutation) ResetTransferOrders() {
	m.transfer_orders = nil
	m.clearedtransfer_orders = false
	m.removedtransfer_orders = nil
}

// Where appends a list predicates to the VXSocialMutation builder.
func (m *VXSocialMutation) Where(ps ...predicate.VXSocial) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VXSocialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VXSocialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VXSocial, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VXSocialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VXSocialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VXSocial).
func (m *VXSocialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VXSocialMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, vxsocial.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, vxsocial.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, vxsocial.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vxsocial.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vxsocial.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, vxsocial.FieldAppID)
	}
	if m.open_id != nil {
		fields = append(fields, vxsocial.FieldOpenID)
	}
	if m.union_id != nil {
		fields = append(fields, vxsocial.FieldUnionID)
	}
	if m.scope != nil {
		fields = append(fields, vxsocial.FieldScope)
	}
	if m.session_key != nil {
		fields = append(fields, vxsocial.FieldSessionKey)
	}
	if m.access_token != nil {
		fields = append(fields, vxsocial.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, vxsocial.FieldRefreshToken)
	}
	if m.user != nil {
		fields = append(fields, vxsocial.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VXSocialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vxsocial.FieldCreatedBy:
		return m.CreatedBy()
	case vxsocial.FieldUpdatedBy:
		return m.UpdatedBy()
	case vxsocial.FieldCreatedAt:
		return m.CreatedAt()
	case vxsocial.FieldUpdatedAt:
		return m.UpdatedAt()
	case vxsocial.FieldDeletedAt:
		return m.DeletedAt()
	case vxsocial.FieldAppID:
		return m.AppID()
	case vxsocial.FieldOpenID:
		return m.OpenID()
	case vxsocial.FieldUnionID:
		return m.UnionID()
	case vxsocial.FieldScope:
		return m.Scope()
	case vxsocial.FieldSessionKey:
		return m.SessionKey()
	case vxsocial.FieldAccessToken:
		return m.AccessToken()
	case vxsocial.FieldRefreshToken:
		return m.RefreshToken()
	case vxsocial.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VXSocialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vxsocial.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vxsocial.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vxsocial.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vxsocial.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vxsocial.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vxsocial.FieldAppID:
		return m.OldAppID(ctx)
	case vxsocial.FieldOpenID:
		return m.OldOpenID(ctx)
	case vxsocial.FieldUnionID:
		return m.OldUnionID(ctx)
	case vxsocial.FieldScope:
		return m.OldScope(ctx)
	case vxsocial.FieldSessionKey:
		return m.OldSessionKey(ctx)
	case vxsocial.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case vxsocial.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case vxsocial.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown VXSocial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXSocialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vxsocial.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vxsocial.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vxsocial.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vxsocial.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vxsocial.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vxsocial.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case vxsocial.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case vxsocial.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	case vxsocial.FieldScope:
		v, ok := value.(vxsocial.Scope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case vxsocial.FieldSessionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionKey(v)
		return nil
	case vxsocial.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case vxsocial.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case vxsocial.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown VXSocial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VXSocialMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vxsocial.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vxsocial.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VXSocialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vxsocial.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vxsocial.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXSocialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vxsocial.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vxsocial.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VXSocial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VXSocialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VXSocialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VXSocialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VXSocial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VXSocialMutation) ResetField(name string) error {
	switch name {
	case vxsocial.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vxsocial.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vxsocial.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vxsocial.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vxsocial.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vxsocial.FieldAppID:
		m.ResetAppID()
		return nil
	case vxsocial.FieldOpenID:
		m.ResetOpenID()
		return nil
	case vxsocial.FieldUnionID:
		m.ResetUnionID()
		return nil
	case vxsocial.FieldScope:
		m.ResetScope()
		return nil
	case vxsocial.FieldSessionKey:
		m.ResetSessionKey()
		return nil
	case vxsocial.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case vxsocial.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case vxsocial.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown VXSocial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VXSocialMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, vxsocial.EdgeUser)
	}
	if m.recharge_orders != nil {
		edges = append(edges, vxsocial.EdgeRechargeOrders)
	}
	if m.transfer_orders != nil {
		edges = append(edges, vxsocial.EdgeTransferOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VXSocialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vxsocial.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case vxsocial.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.recharge_orders))
		for id := range m.recharge_orders {
			ids = append(ids, id)
		}
		return ids
	case vxsocial.EdgeTransferOrders:
		ids := make([]ent.Value, 0, len(m.transfer_orders))
		for id := range m.transfer_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VXSocialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrecharge_orders != nil {
		edges = append(edges, vxsocial.EdgeRechargeOrders)
	}
	if m.removedtransfer_orders != nil {
		edges = append(edges, vxsocial.EdgeTransferOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VXSocialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vxsocial.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.removedrecharge_orders))
		for id := range m.removedrecharge_orders {
			ids = append(ids, id)
		}
		return ids
	case vxsocial.EdgeTransferOrders:
		ids := make([]ent.Value, 0, len(m.removedtransfer_orders))
		for id := range m.removedtransfer_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VXSocialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, vxsocial.EdgeUser)
	}
	if m.clearedrecharge_orders {
		edges = append(edges, vxsocial.EdgeRechargeOrders)
	}
	if m.clearedtransfer_orders {
		edges = append(edges, vxsocial.EdgeTransferOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VXSocialMutation) EdgeCleared(name string) bool {
	switch name {
	case vxsocial.EdgeUser:
		return m.cleareduser
	case vxsocial.EdgeRechargeOrders:
		return m.clearedrecharge_orders
	case vxsocial.EdgeTransferOrders:
		return m.clearedtransfer_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VXSocialMutation) ClearEdge(name string) error {
	switch name {
	case vxsocial.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown VXSocial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VXSocialMutation) ResetEdge(name string) error {
	switch name {
	case vxsocial.EdgeUser:
		m.ResetUser()
		return nil
	case vxsocial.EdgeRechargeOrders:
		m.ResetRechargeOrders()
		return nil
	case vxsocial.EdgeTransferOrders:
		m.ResetTransferOrders()
		return nil
	}
	return fmt.Errorf("unknown VXSocial edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_by         *int64
	addcreated_by      *int64
	updated_by         *int64
	addupdated_by      *int64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	amount             *int64
	addamount          *int64
	total_amount       *int64
	addtotal_amount    *int64
	withdraw_amount    *int64
	addwithdraw_amount *int64
	clearedFields      map[string]struct{}
	user               *int64
	cleareduser        bool
	symbol             *int64
	clearedsymbol      bool
	done               bool
	oldValue           func(context.Context) (*Wallet, error)
	predicates         []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id int64) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wallet entities.
func (m *WalletMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *WalletMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WalletMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *WalletMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *WalletMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WalletMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WalletMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WalletMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *WalletMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *WalletMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WalletMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WalletMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WalletMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WalletMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WalletMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WalletMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *WalletMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WalletMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WalletMutation) ResetUserID() {
	m.user = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *WalletMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *WalletMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *WalletMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetAmount sets the "amount" field.
func (m *WalletMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *WalletMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *WalletMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *WalletMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *WalletMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *WalletMutation) SetTotalAmount(i int64) {
	m.total_amount = &i
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *WalletMutation) TotalAmount() (r int64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldTotalAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds i to the "total_amount" field.
func (m *WalletMutation) AddTotalAmount(i int64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += i
	} else {
		m.addtotal_amount = &i
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *WalletMutation) AddedTotalAmount() (r int64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *WalletMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetWithdrawAmount sets the "withdraw_amount" field.
func (m *WalletMutation) SetWithdrawAmount(i int64) {
	m.withdraw_amount = &i
	m.addwithdraw_amount = nil
}

// WithdrawAmount returns the value of the "withdraw_amount" field in the mutation.
func (m *WalletMutation) WithdrawAmount() (r int64, exists bool) {
	v := m.withdraw_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawAmount returns the old "withdraw_amount" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldWithdrawAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawAmount: %w", err)
	}
	return oldValue.WithdrawAmount, nil
}

// AddWithdrawAmount adds i to the "withdraw_amount" field.
func (m *WalletMutation) AddWithdrawAmount(i int64) {
	if m.addwithdraw_amount != nil {
		*m.addwithdraw_amount += i
	} else {
		m.addwithdraw_amount = &i
	}
}

// AddedWithdrawAmount returns the value that was added to the "withdraw_amount" field in this mutation.
func (m *WalletMutation) AddedWithdrawAmount() (r int64, exists bool) {
	v := m.addwithdraw_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawAmount resets all changes to the "withdraw_amount" field.
func (m *WalletMutation) ResetWithdrawAmount() {
	m.withdraw_amount = nil
	m.addwithdraw_amount = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *WalletMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[wallet.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WalletMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WalletMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WalletMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *WalletMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[wallet.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *WalletMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *WalletMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *WalletMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Wallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, wallet.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, wallet.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, wallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wallet.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, wallet.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, wallet.FieldUserID)
	}
	if m.symbol != nil {
		fields = append(fields, wallet.FieldSymbolID)
	}
	if m.amount != nil {
		fields = append(fields, wallet.FieldAmount)
	}
	if m.total_amount != nil {
		fields = append(fields, wallet.FieldTotalAmount)
	}
	if m.withdraw_amount != nil {
		fields = append(fields, wallet.FieldWithdrawAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldCreatedBy:
		return m.CreatedBy()
	case wallet.FieldUpdatedBy:
		return m.UpdatedBy()
	case wallet.FieldCreatedAt:
		return m.CreatedAt()
	case wallet.FieldUpdatedAt:
		return m.UpdatedAt()
	case wallet.FieldDeletedAt:
		return m.DeletedAt()
	case wallet.FieldUserID:
		return m.UserID()
	case wallet.FieldSymbolID:
		return m.SymbolID()
	case wallet.FieldAmount:
		return m.Amount()
	case wallet.FieldTotalAmount:
		return m.TotalAmount()
	case wallet.FieldWithdrawAmount:
		return m.WithdrawAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case wallet.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case wallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case wallet.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case wallet.FieldUserID:
		return m.OldUserID(ctx)
	case wallet.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case wallet.FieldAmount:
		return m.OldAmount(ctx)
	case wallet.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case wallet.FieldWithdrawAmount:
		return m.OldWithdrawAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case wallet.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case wallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wallet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case wallet.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case wallet.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case wallet.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case wallet.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case wallet.FieldTotalAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case wallet.FieldWithdrawAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, wallet.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, wallet.FieldUpdatedBy)
	}
	if m.addamount != nil {
		fields = append(fields, wallet.FieldAmount)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, wallet.FieldTotalAmount)
	}
	if m.addwithdraw_amount != nil {
		fields = append(fields, wallet.FieldWithdrawAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldCreatedBy:
		return m.AddedCreatedBy()
	case wallet.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case wallet.FieldAmount:
		return m.AddedAmount()
	case wallet.FieldTotalAmount:
		return m.AddedTotalAmount()
	case wallet.FieldWithdrawAmount:
		return m.AddedWithdrawAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case wallet.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case wallet.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case wallet.FieldTotalAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case wallet.FieldWithdrawAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case wallet.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case wallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case wallet.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case wallet.FieldUserID:
		m.ResetUserID()
		return nil
	case wallet.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case wallet.FieldAmount:
		m.ResetAmount()
		return nil
	case wallet.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case wallet.FieldWithdrawAmount:
		m.ResetWithdrawAmount()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, wallet.EdgeUser)
	}
	if m.symbol != nil {
		edges = append(edges, wallet.EdgeSymbol)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case wallet.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, wallet.EdgeUser)
	}
	if m.clearedsymbol {
		edges = append(edges, wallet.EdgeSymbol)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	switch name {
	case wallet.EdgeUser:
		return m.cleareduser
	case wallet.EdgeSymbol:
		return m.clearedsymbol
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	switch name {
	case wallet.EdgeUser:
		m.ClearUser()
		return nil
	case wallet.EdgeSymbol:
		m.ClearSymbol()
		return nil
	}
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	switch name {
	case wallet.EdgeUser:
		m.ResetUser()
		return nil
	case wallet.EdgeSymbol:
		m.ResetSymbol()
		return nil
	}
	return fmt.Errorf("unknown Wallet edge %s", name)
}

// WithdrawAccountMutation represents an operation that mutates the WithdrawAccount nodes in the graph.
type WithdrawAccountMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_by       *int64
	addcreated_by    *int64
	updated_by       *int64
	addupdated_by    *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	business_name    *string
	business_id      *int64
	addbusiness_id   *int64
	business_type    *enums.BusinessType
	id_card          *string
	personal_name    *string
	phone            *string
	bank_card_number *string
	bank             *string
	way              *enums.WithdrawType
	alipay_card_no   *string
	company_account  *string
	clearedFields    map[string]struct{}
	user             *int64
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*WithdrawAccount, error)
	predicates       []predicate.WithdrawAccount
}

var _ ent.Mutation = (*WithdrawAccountMutation)(nil)

// withdrawaccountOption allows management of the mutation configuration using functional options.
type withdrawaccountOption func(*WithdrawAccountMutation)

// newWithdrawAccountMutation creates new mutation for the WithdrawAccount entity.
func newWithdrawAccountMutation(c config, op Op, opts ...withdrawaccountOption) *WithdrawAccountMutation {
	m := &WithdrawAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeWithdrawAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWithdrawAccountID sets the ID field of the mutation.
func withWithdrawAccountID(id int64) withdrawaccountOption {
	return func(m *WithdrawAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *WithdrawAccount
		)
		m.oldValue = func(ctx context.Context) (*WithdrawAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WithdrawAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWithdrawAccount sets the old WithdrawAccount of the mutation.
func withWithdrawAccount(node *WithdrawAccount) withdrawaccountOption {
	return func(m *WithdrawAccountMutation) {
		m.oldValue = func(context.Context) (*WithdrawAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WithdrawAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WithdrawAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WithdrawAccount entities.
func (m *WithdrawAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WithdrawAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WithdrawAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WithdrawAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *WithdrawAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WithdrawAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *WithdrawAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *WithdrawAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WithdrawAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WithdrawAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WithdrawAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *WithdrawAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *WithdrawAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WithdrawAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WithdrawAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WithdrawAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WithdrawAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WithdrawAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WithdrawAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WithdrawAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WithdrawAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WithdrawAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WithdrawAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *WithdrawAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WithdrawAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WithdrawAccountMutation) ResetUserID() {
	m.user = nil
}

// SetBusinessName sets the "business_name" field.
func (m *WithdrawAccountMutation) SetBusinessName(s string) {
	m.business_name = &s
}

// BusinessName returns the value of the "business_name" field in the mutation.
func (m *WithdrawAccountMutation) BusinessName() (r string, exists bool) {
	v := m.business_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessName returns the old "business_name" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBusinessName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessName: %w", err)
	}
	return oldValue.BusinessName, nil
}

// ResetBusinessName resets all changes to the "business_name" field.
func (m *WithdrawAccountMutation) ResetBusinessName() {
	m.business_name = nil
}

// SetBusinessID sets the "business_id" field.
func (m *WithdrawAccountMutation) SetBusinessID(i int64) {
	m.business_id = &i
	m.addbusiness_id = nil
}

// BusinessID returns the value of the "business_id" field in the mutation.
func (m *WithdrawAccountMutation) BusinessID() (r int64, exists bool) {
	v := m.business_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessID returns the old "business_id" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBusinessID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessID: %w", err)
	}
	return oldValue.BusinessID, nil
}

// AddBusinessID adds i to the "business_id" field.
func (m *WithdrawAccountMutation) AddBusinessID(i int64) {
	if m.addbusiness_id != nil {
		*m.addbusiness_id += i
	} else {
		m.addbusiness_id = &i
	}
}

// AddedBusinessID returns the value that was added to the "business_id" field in this mutation.
func (m *WithdrawAccountMutation) AddedBusinessID() (r int64, exists bool) {
	v := m.addbusiness_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBusinessID resets all changes to the "business_id" field.
func (m *WithdrawAccountMutation) ResetBusinessID() {
	m.business_id = nil
	m.addbusiness_id = nil
}

// SetBusinessType sets the "business_type" field.
func (m *WithdrawAccountMutation) SetBusinessType(et enums.BusinessType) {
	m.business_type = &et
}

// BusinessType returns the value of the "business_type" field in the mutation.
func (m *WithdrawAccountMutation) BusinessType() (r enums.BusinessType, exists bool) {
	v := m.business_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessType returns the old "business_type" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBusinessType(ctx context.Context) (v enums.BusinessType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessType: %w", err)
	}
	return oldValue.BusinessType, nil
}

// ResetBusinessType resets all changes to the "business_type" field.
func (m *WithdrawAccountMutation) ResetBusinessType() {
	m.business_type = nil
}

// SetIDCard sets the "id_card" field.
func (m *WithdrawAccountMutation) SetIDCard(s string) {
	m.id_card = &s
}

// IDCard returns the value of the "id_card" field in the mutation.
func (m *WithdrawAccountMutation) IDCard() (r string, exists bool) {
	v := m.id_card
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCard returns the old "id_card" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldIDCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCard: %w", err)
	}
	return oldValue.IDCard, nil
}

// ResetIDCard resets all changes to the "id_card" field.
func (m *WithdrawAccountMutation) ResetIDCard() {
	m.id_card = nil
}

// SetPersonalName sets the "personal_name" field.
func (m *WithdrawAccountMutation) SetPersonalName(s string) {
	m.personal_name = &s
}

// PersonalName returns the value of the "personal_name" field in the mutation.
func (m *WithdrawAccountMutation) PersonalName() (r string, exists bool) {
	v := m.personal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalName returns the old "personal_name" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldPersonalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalName: %w", err)
	}
	return oldValue.PersonalName, nil
}

// ResetPersonalName resets all changes to the "personal_name" field.
func (m *WithdrawAccountMutation) ResetPersonalName() {
	m.personal_name = nil
}

// SetPhone sets the "phone" field.
func (m *WithdrawAccountMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *WithdrawAccountMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *WithdrawAccountMutation) ResetPhone() {
	m.phone = nil
}

// SetBankCardNumber sets the "bank_card_number" field.
func (m *WithdrawAccountMutation) SetBankCardNumber(s string) {
	m.bank_card_number = &s
}

// BankCardNumber returns the value of the "bank_card_number" field in the mutation.
func (m *WithdrawAccountMutation) BankCardNumber() (r string, exists bool) {
	v := m.bank_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBankCardNumber returns the old "bank_card_number" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBankCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankCardNumber: %w", err)
	}
	return oldValue.BankCardNumber, nil
}

// ResetBankCardNumber resets all changes to the "bank_card_number" field.
func (m *WithdrawAccountMutation) ResetBankCardNumber() {
	m.bank_card_number = nil
}

// SetBank sets the "bank" field.
func (m *WithdrawAccountMutation) SetBank(s string) {
	m.bank = &s
}

// Bank returns the value of the "bank" field in the mutation.
func (m *WithdrawAccountMutation) Bank() (r string, exists bool) {
	v := m.bank
	if v == nil {
		return
	}
	return *v, true
}

// OldBank returns the old "bank" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBank: %w", err)
	}
	return oldValue.Bank, nil
}

// ResetBank resets all changes to the "bank" field.
func (m *WithdrawAccountMutation) ResetBank() {
	m.bank = nil
}

// SetWay sets the "way" field.
func (m *WithdrawAccountMutation) SetWay(et enums.WithdrawType) {
	m.way = &et
}

// Way returns the value of the "way" field in the mutation.
func (m *WithdrawAccountMutation) Way() (r enums.WithdrawType, exists bool) {
	v := m.way
	if v == nil {
		return
	}
	return *v, true
}

// OldWay returns the old "way" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldWay(ctx context.Context) (v enums.WithdrawType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWay: %w", err)
	}
	return oldValue.Way, nil
}

// ResetWay resets all changes to the "way" field.
func (m *WithdrawAccountMutation) ResetWay() {
	m.way = nil
}

// SetAlipayCardNo sets the "alipay_card_no" field.
func (m *WithdrawAccountMutation) SetAlipayCardNo(s string) {
	m.alipay_card_no = &s
}

// AlipayCardNo returns the value of the "alipay_card_no" field in the mutation.
func (m *WithdrawAccountMutation) AlipayCardNo() (r string, exists bool) {
	v := m.alipay_card_no
	if v == nil {
		return
	}
	return *v, true
}

// OldAlipayCardNo returns the old "alipay_card_no" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldAlipayCardNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlipayCardNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlipayCardNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlipayCardNo: %w", err)
	}
	return oldValue.AlipayCardNo, nil
}

// ResetAlipayCardNo resets all changes to the "alipay_card_no" field.
func (m *WithdrawAccountMutation) ResetAlipayCardNo() {
	m.alipay_card_no = nil
}

// SetCompanyAccount sets the "company_account" field.
func (m *WithdrawAccountMutation) SetCompanyAccount(s string) {
	m.company_account = &s
}

// CompanyAccount returns the value of the "company_account" field in the mutation.
func (m *WithdrawAccountMutation) CompanyAccount() (r string, exists bool) {
	v := m.company_account
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyAccount returns the old "company_account" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldCompanyAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyAccount: %w", err)
	}
	return oldValue.CompanyAccount, nil
}

// ResetCompanyAccount resets all changes to the "company_account" field.
func (m *WithdrawAccountMutation) ResetCompanyAccount() {
	m.company_account = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *WithdrawAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[withdrawaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WithdrawAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WithdrawAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WithdrawAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WithdrawAccountMutation builder.
func (m *WithdrawAccountMutation) Where(ps ...predicate.WithdrawAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WithdrawAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WithdrawAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WithdrawAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WithdrawAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WithdrawAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WithdrawAccount).
func (m *WithdrawAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WithdrawAccountMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, withdrawaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, withdrawaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, withdrawaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, withdrawaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, withdrawaccount.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, withdrawaccount.FieldUserID)
	}
	if m.business_name != nil {
		fields = append(fields, withdrawaccount.FieldBusinessName)
	}
	if m.business_id != nil {
		fields = append(fields, withdrawaccount.FieldBusinessID)
	}
	if m.business_type != nil {
		fields = append(fields, withdrawaccount.FieldBusinessType)
	}
	if m.id_card != nil {
		fields = append(fields, withdrawaccount.FieldIDCard)
	}
	if m.personal_name != nil {
		fields = append(fields, withdrawaccount.FieldPersonalName)
	}
	if m.phone != nil {
		fields = append(fields, withdrawaccount.FieldPhone)
	}
	if m.bank_card_number != nil {
		fields = append(fields, withdrawaccount.FieldBankCardNumber)
	}
	if m.bank != nil {
		fields = append(fields, withdrawaccount.FieldBank)
	}
	if m.way != nil {
		fields = append(fields, withdrawaccount.FieldWay)
	}
	if m.alipay_card_no != nil {
		fields = append(fields, withdrawaccount.FieldAlipayCardNo)
	}
	if m.company_account != nil {
		fields = append(fields, withdrawaccount.FieldCompanyAccount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WithdrawAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		return m.CreatedBy()
	case withdrawaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case withdrawaccount.FieldCreatedAt:
		return m.CreatedAt()
	case withdrawaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case withdrawaccount.FieldDeletedAt:
		return m.DeletedAt()
	case withdrawaccount.FieldUserID:
		return m.UserID()
	case withdrawaccount.FieldBusinessName:
		return m.BusinessName()
	case withdrawaccount.FieldBusinessID:
		return m.BusinessID()
	case withdrawaccount.FieldBusinessType:
		return m.BusinessType()
	case withdrawaccount.FieldIDCard:
		return m.IDCard()
	case withdrawaccount.FieldPersonalName:
		return m.PersonalName()
	case withdrawaccount.FieldPhone:
		return m.Phone()
	case withdrawaccount.FieldBankCardNumber:
		return m.BankCardNumber()
	case withdrawaccount.FieldBank:
		return m.Bank()
	case withdrawaccount.FieldWay:
		return m.Way()
	case withdrawaccount.FieldAlipayCardNo:
		return m.AlipayCardNo()
	case withdrawaccount.FieldCompanyAccount:
		return m.CompanyAccount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WithdrawAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case withdrawaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case withdrawaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case withdrawaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case withdrawaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case withdrawaccount.FieldUserID:
		return m.OldUserID(ctx)
	case withdrawaccount.FieldBusinessName:
		return m.OldBusinessName(ctx)
	case withdrawaccount.FieldBusinessID:
		return m.OldBusinessID(ctx)
	case withdrawaccount.FieldBusinessType:
		return m.OldBusinessType(ctx)
	case withdrawaccount.FieldIDCard:
		return m.OldIDCard(ctx)
	case withdrawaccount.FieldPersonalName:
		return m.OldPersonalName(ctx)
	case withdrawaccount.FieldPhone:
		return m.OldPhone(ctx)
	case withdrawaccount.FieldBankCardNumber:
		return m.OldBankCardNumber(ctx)
	case withdrawaccount.FieldBank:
		return m.OldBank(ctx)
	case withdrawaccount.FieldWay:
		return m.OldWay(ctx)
	case withdrawaccount.FieldAlipayCardNo:
		return m.OldAlipayCardNo(ctx)
	case withdrawaccount.FieldCompanyAccount:
		return m.OldCompanyAccount(ctx)
	}
	return nil, fmt.Errorf("unknown WithdrawAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case withdrawaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case withdrawaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case withdrawaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case withdrawaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case withdrawaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case withdrawaccount.FieldBusinessName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessName(v)
		return nil
	case withdrawaccount.FieldBusinessID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessID(v)
		return nil
	case withdrawaccount.FieldBusinessType:
		v, ok := value.(enums.BusinessType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessType(v)
		return nil
	case withdrawaccount.FieldIDCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCard(v)
		return nil
	case withdrawaccount.FieldPersonalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalName(v)
		return nil
	case withdrawaccount.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case withdrawaccount.FieldBankCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankCardNumber(v)
		return nil
	case withdrawaccount.FieldBank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBank(v)
		return nil
	case withdrawaccount.FieldWay:
		v, ok := value.(enums.WithdrawType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWay(v)
		return nil
	case withdrawaccount.FieldAlipayCardNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlipayCardNo(v)
		return nil
	case withdrawaccount.FieldCompanyAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyAccount(v)
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WithdrawAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, withdrawaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, withdrawaccount.FieldUpdatedBy)
	}
	if m.addbusiness_id != nil {
		fields = append(fields, withdrawaccount.FieldBusinessID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WithdrawAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case withdrawaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case withdrawaccount.FieldBusinessID:
		return m.AddedBusinessID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case withdrawaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case withdrawaccount.FieldBusinessID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBusinessID(v)
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WithdrawAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WithdrawAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WithdrawAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WithdrawAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WithdrawAccountMutation) ResetField(name string) error {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case withdrawaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case withdrawaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case withdrawaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case withdrawaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case withdrawaccount.FieldUserID:
		m.ResetUserID()
		return nil
	case withdrawaccount.FieldBusinessName:
		m.ResetBusinessName()
		return nil
	case withdrawaccount.FieldBusinessID:
		m.ResetBusinessID()
		return nil
	case withdrawaccount.FieldBusinessType:
		m.ResetBusinessType()
		return nil
	case withdrawaccount.FieldIDCard:
		m.ResetIDCard()
		return nil
	case withdrawaccount.FieldPersonalName:
		m.ResetPersonalName()
		return nil
	case withdrawaccount.FieldPhone:
		m.ResetPhone()
		return nil
	case withdrawaccount.FieldBankCardNumber:
		m.ResetBankCardNumber()
		return nil
	case withdrawaccount.FieldBank:
		m.ResetBank()
		return nil
	case withdrawaccount.FieldWay:
		m.ResetWay()
		return nil
	case withdrawaccount.FieldAlipayCardNo:
		m.ResetAlipayCardNo()
		return nil
	case withdrawaccount.FieldCompanyAccount:
		m.ResetCompanyAccount()
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WithdrawAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, withdrawaccount.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WithdrawAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case withdrawaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WithdrawAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WithdrawAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WithdrawAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, withdrawaccount.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WithdrawAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case withdrawaccount.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WithdrawAccountMutation) ClearEdge(name string) error {
	switch name {
	case withdrawaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WithdrawAccountMutation) ResetEdge(name string) error {
	switch name {
	case withdrawaccount.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount edge %s", name)
}

// WithdrawRecordMutation represents an operation that mutates the WithdrawRecord nodes in the graph.
type WithdrawRecordMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	withdraw_account      *string
	business_name         *string
	bank                  *string
	_type                 *enums.WithdrawType
	amount                *int64
	addamount             *int64
	remain_amount         *int64
	addremain_amount      *int64
	rate                  *int64
	addrate               *int64
	real_amount           *int64
	addreal_amount        *int64
	status                *enums.WithdrawStatus
	reject_reason         *string
	symbol_id             *int64
	addsymbol_id          *int64
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	operate_user          *int64
	clearedoperate_user   bool
	transfer_order        *int64
	clearedtransfer_order bool
	done                  bool
	oldValue              func(context.Context) (*WithdrawRecord, error)
	predicates            []predicate.WithdrawRecord
}

var _ ent.Mutation = (*WithdrawRecordMutation)(nil)

// withdrawrecordOption allows management of the mutation configuration using functional options.
type withdrawrecordOption func(*WithdrawRecordMutation)

// newWithdrawRecordMutation creates new mutation for the WithdrawRecord entity.
func newWithdrawRecordMutation(c config, op Op, opts ...withdrawrecordOption) *WithdrawRecordMutation {
	m := &WithdrawRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeWithdrawRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWithdrawRecordID sets the ID field of the mutation.
func withWithdrawRecordID(id int64) withdrawrecordOption {
	return func(m *WithdrawRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *WithdrawRecord
		)
		m.oldValue = func(ctx context.Context) (*WithdrawRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WithdrawRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWithdrawRecord sets the old WithdrawRecord of the mutation.
func withWithdrawRecord(node *WithdrawRecord) withdrawrecordOption {
	return func(m *WithdrawRecordMutation) {
		m.oldValue = func(context.Context) (*WithdrawRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WithdrawRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WithdrawRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WithdrawRecord entities.
func (m *WithdrawRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WithdrawRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WithdrawRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WithdrawRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *WithdrawRecordMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WithdrawRecordMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *WithdrawRecordMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *WithdrawRecordMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WithdrawRecordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WithdrawRecordMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WithdrawRecordMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *WithdrawRecordMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *WithdrawRecordMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WithdrawRecordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WithdrawRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WithdrawRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WithdrawRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WithdrawRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WithdrawRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WithdrawRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WithdrawRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WithdrawRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WithdrawRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *WithdrawRecordMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WithdrawRecordMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WithdrawRecordMutation) ResetUserID() {
	m.user = nil
}

// SetWithdrawAccount sets the "withdraw_account" field.
func (m *WithdrawRecordMutation) SetWithdrawAccount(s string) {
	m.withdraw_account = &s
}

// WithdrawAccount returns the value of the "withdraw_account" field in the mutation.
func (m *WithdrawRecordMutation) WithdrawAccount() (r string, exists bool) {
	v := m.withdraw_account
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawAccount returns the old "withdraw_account" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldWithdrawAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawAccount: %w", err)
	}
	return oldValue.WithdrawAccount, nil
}

// ResetWithdrawAccount resets all changes to the "withdraw_account" field.
func (m *WithdrawRecordMutation) ResetWithdrawAccount() {
	m.withdraw_account = nil
}

// SetBusinessName sets the "business_name" field.
func (m *WithdrawRecordMutation) SetBusinessName(s string) {
	m.business_name = &s
}

// BusinessName returns the value of the "business_name" field in the mutation.
func (m *WithdrawRecordMutation) BusinessName() (r string, exists bool) {
	v := m.business_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessName returns the old "business_name" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldBusinessName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessName: %w", err)
	}
	return oldValue.BusinessName, nil
}

// ResetBusinessName resets all changes to the "business_name" field.
func (m *WithdrawRecordMutation) ResetBusinessName() {
	m.business_name = nil
}

// SetBank sets the "bank" field.
func (m *WithdrawRecordMutation) SetBank(s string) {
	m.bank = &s
}

// Bank returns the value of the "bank" field in the mutation.
func (m *WithdrawRecordMutation) Bank() (r string, exists bool) {
	v := m.bank
	if v == nil {
		return
	}
	return *v, true
}

// OldBank returns the old "bank" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldBank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBank: %w", err)
	}
	return oldValue.Bank, nil
}

// ResetBank resets all changes to the "bank" field.
func (m *WithdrawRecordMutation) ResetBank() {
	m.bank = nil
}

// SetType sets the "type" field.
func (m *WithdrawRecordMutation) SetType(et enums.WithdrawType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *WithdrawRecordMutation) GetType() (r enums.WithdrawType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldType(ctx context.Context) (v enums.WithdrawType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WithdrawRecordMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *WithdrawRecordMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *WithdrawRecordMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *WithdrawRecordMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *WithdrawRecordMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *WithdrawRecordMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetRemainAmount sets the "remain_amount" field.
func (m *WithdrawRecordMutation) SetRemainAmount(i int64) {
	m.remain_amount = &i
	m.addremain_amount = nil
}

// RemainAmount returns the value of the "remain_amount" field in the mutation.
func (m *WithdrawRecordMutation) RemainAmount() (r int64, exists bool) {
	v := m.remain_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainAmount returns the old "remain_amount" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldRemainAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainAmount: %w", err)
	}
	return oldValue.RemainAmount, nil
}

// AddRemainAmount adds i to the "remain_amount" field.
func (m *WithdrawRecordMutation) AddRemainAmount(i int64) {
	if m.addremain_amount != nil {
		*m.addremain_amount += i
	} else {
		m.addremain_amount = &i
	}
}

// AddedRemainAmount returns the value that was added to the "remain_amount" field in this mutation.
func (m *WithdrawRecordMutation) AddedRemainAmount() (r int64, exists bool) {
	v := m.addremain_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainAmount resets all changes to the "remain_amount" field.
func (m *WithdrawRecordMutation) ResetRemainAmount() {
	m.remain_amount = nil
	m.addremain_amount = nil
}

// SetRate sets the "rate" field.
func (m *WithdrawRecordMutation) SetRate(i int64) {
	m.rate = &i
	m.addrate = nil
}

// Rate returns the value of the "rate" field in the mutation.
func (m *WithdrawRecordMutation) Rate() (r int64, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldRate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds i to the "rate" field.
func (m *WithdrawRecordMutation) AddRate(i int64) {
	if m.addrate != nil {
		*m.addrate += i
	} else {
		m.addrate = &i
	}
}

// AddedRate returns the value that was added to the "rate" field in this mutation.
func (m *WithdrawRecordMutation) AddedRate() (r int64, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate resets all changes to the "rate" field.
func (m *WithdrawRecordMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetRealAmount sets the "real_amount" field.
func (m *WithdrawRecordMutation) SetRealAmount(i int64) {
	m.real_amount = &i
	m.addreal_amount = nil
}

// RealAmount returns the value of the "real_amount" field in the mutation.
func (m *WithdrawRecordMutation) RealAmount() (r int64, exists bool) {
	v := m.real_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRealAmount returns the old "real_amount" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldRealAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealAmount: %w", err)
	}
	return oldValue.RealAmount, nil
}

// AddRealAmount adds i to the "real_amount" field.
func (m *WithdrawRecordMutation) AddRealAmount(i int64) {
	if m.addreal_amount != nil {
		*m.addreal_amount += i
	} else {
		m.addreal_amount = &i
	}
}

// AddedRealAmount returns the value that was added to the "real_amount" field in this mutation.
func (m *WithdrawRecordMutation) AddedRealAmount() (r int64, exists bool) {
	v := m.addreal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRealAmount resets all changes to the "real_amount" field.
func (m *WithdrawRecordMutation) ResetRealAmount() {
	m.real_amount = nil
	m.addreal_amount = nil
}

// SetStatus sets the "status" field.
func (m *WithdrawRecordMutation) SetStatus(es enums.WithdrawStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *WithdrawRecordMutation) Status() (r enums.WithdrawStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldStatus(ctx context.Context) (v enums.WithdrawStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WithdrawRecordMutation) ResetStatus() {
	m.status = nil
}

// SetRejectReason sets the "reject_reason" field.
func (m *WithdrawRecordMutation) SetRejectReason(s string) {
	m.reject_reason = &s
}

// RejectReason returns the value of the "reject_reason" field in the mutation.
func (m *WithdrawRecordMutation) RejectReason() (r string, exists bool) {
	v := m.reject_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectReason returns the old "reject_reason" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldRejectReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectReason: %w", err)
	}
	return oldValue.RejectReason, nil
}

// ResetRejectReason resets all changes to the "reject_reason" field.
func (m *WithdrawRecordMutation) ResetRejectReason() {
	m.reject_reason = nil
}

// SetOperateUserID sets the "operate_user_id" field.
func (m *WithdrawRecordMutation) SetOperateUserID(i int64) {
	m.operate_user = &i
}

// OperateUserID returns the value of the "operate_user_id" field in the mutation.
func (m *WithdrawRecordMutation) OperateUserID() (r int64, exists bool) {
	v := m.operate_user
	if v == nil {
		return
	}
	return *v, true
}

// OldOperateUserID returns the old "operate_user_id" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldOperateUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperateUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperateUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperateUserID: %w", err)
	}
	return oldValue.OperateUserID, nil
}

// ResetOperateUserID resets all changes to the "operate_user_id" field.
func (m *WithdrawRecordMutation) ResetOperateUserID() {
	m.operate_user = nil
}

// SetTransferOrderID sets the "transfer_order_id" field.
func (m *WithdrawRecordMutation) SetTransferOrderID(i int64) {
	m.transfer_order = &i
}

// TransferOrderID returns the value of the "transfer_order_id" field in the mutation.
func (m *WithdrawRecordMutation) TransferOrderID() (r int64, exists bool) {
	v := m.transfer_order
	if v == nil {
		return
	}
	return *v, true
}

// OldTransferOrderID returns the old "transfer_order_id" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldTransferOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransferOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransferOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransferOrderID: %w", err)
	}
	return oldValue.TransferOrderID, nil
}

// ResetTransferOrderID resets all changes to the "transfer_order_id" field.
func (m *WithdrawRecordMutation) ResetTransferOrderID() {
	m.transfer_order = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *WithdrawRecordMutation) SetSymbolID(i int64) {
	m.symbol_id = &i
	m.addsymbol_id = nil
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *WithdrawRecordMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the WithdrawRecord entity.
// If the WithdrawRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawRecordMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// AddSymbolID adds i to the "symbol_id" field.
func (m *WithdrawRecordMutation) AddSymbolID(i int64) {
	if m.addsymbol_id != nil {
		*m.addsymbol_id += i
	} else {
		m.addsymbol_id = &i
	}
}

// AddedSymbolID returns the value that was added to the "symbol_id" field in this mutation.
func (m *WithdrawRecordMutation) AddedSymbolID() (r int64, exists bool) {
	v := m.addsymbol_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *WithdrawRecordMutation) ResetSymbolID() {
	m.symbol_id = nil
	m.addsymbol_id = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *WithdrawRecordMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[withdrawrecord.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WithdrawRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WithdrawRecordMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WithdrawRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOperateUser clears the "operate_user" edge to the User entity.
func (m *WithdrawRecordMutation) ClearOperateUser() {
	m.clearedoperate_user = true
	m.clearedFields[withdrawrecord.FieldOperateUserID] = struct{}{}
}

// OperateUserCleared reports if the "operate_user" edge to the User entity was cleared.
func (m *WithdrawRecordMutation) OperateUserCleared() bool {
	return m.clearedoperate_user
}

// OperateUserIDs returns the "operate_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperateUserID instead. It exists only for internal usage by the builders.
func (m *WithdrawRecordMutation) OperateUserIDs() (ids []int64) {
	if id := m.operate_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperateUser resets all changes to the "operate_user" edge.
func (m *WithdrawRecordMutation) ResetOperateUser() {
	m.operate_user = nil
	m.clearedoperate_user = false
}

// ClearTransferOrder clears the "transfer_order" edge to the TransferOrder entity.
func (m *WithdrawRecordMutation) ClearTransferOrder() {
	m.clearedtransfer_order = true
	m.clearedFields[withdrawrecord.FieldTransferOrderID] = struct{}{}
}

// TransferOrderCleared reports if the "transfer_order" edge to the TransferOrder entity was cleared.
func (m *WithdrawRecordMutation) TransferOrderCleared() bool {
	return m.clearedtransfer_order
}

// TransferOrderIDs returns the "transfer_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferOrderID instead. It exists only for internal usage by the builders.
func (m *WithdrawRecordMutation) TransferOrderIDs() (ids []int64) {
	if id := m.transfer_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransferOrder resets all changes to the "transfer_order" edge.
func (m *WithdrawRecordMutation) ResetTransferOrder() {
	m.transfer_order = nil
	m.clearedtransfer_order = false
}

// Where appends a list predicates to the WithdrawRecordMutation builder.
func (m *WithdrawRecordMutation) Where(ps ...predicate.WithdrawRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WithdrawRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WithdrawRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WithdrawRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WithdrawRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WithdrawRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WithdrawRecord).
func (m *WithdrawRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WithdrawRecordMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_by != nil {
		fields = append(fields, withdrawrecord.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, withdrawrecord.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, withdrawrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, withdrawrecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, withdrawrecord.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, withdrawrecord.FieldUserID)
	}
	if m.withdraw_account != nil {
		fields = append(fields, withdrawrecord.FieldWithdrawAccount)
	}
	if m.business_name != nil {
		fields = append(fields, withdrawrecord.FieldBusinessName)
	}
	if m.bank != nil {
		fields = append(fields, withdrawrecord.FieldBank)
	}
	if m._type != nil {
		fields = append(fields, withdrawrecord.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, withdrawrecord.FieldAmount)
	}
	if m.remain_amount != nil {
		fields = append(fields, withdrawrecord.FieldRemainAmount)
	}
	if m.rate != nil {
		fields = append(fields, withdrawrecord.FieldRate)
	}
	if m.real_amount != nil {
		fields = append(fields, withdrawrecord.FieldRealAmount)
	}
	if m.status != nil {
		fields = append(fields, withdrawrecord.FieldStatus)
	}
	if m.reject_reason != nil {
		fields = append(fields, withdrawrecord.FieldRejectReason)
	}
	if m.operate_user != nil {
		fields = append(fields, withdrawrecord.FieldOperateUserID)
	}
	if m.transfer_order != nil {
		fields = append(fields, withdrawrecord.FieldTransferOrderID)
	}
	if m.symbol_id != nil {
		fields = append(fields, withdrawrecord.FieldSymbolID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WithdrawRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case withdrawrecord.FieldCreatedBy:
		return m.CreatedBy()
	case withdrawrecord.FieldUpdatedBy:
		return m.UpdatedBy()
	case withdrawrecord.FieldCreatedAt:
		return m.CreatedAt()
	case withdrawrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case withdrawrecord.FieldDeletedAt:
		return m.DeletedAt()
	case withdrawrecord.FieldUserID:
		return m.UserID()
	case withdrawrecord.FieldWithdrawAccount:
		return m.WithdrawAccount()
	case withdrawrecord.FieldBusinessName:
		return m.BusinessName()
	case withdrawrecord.FieldBank:
		return m.Bank()
	case withdrawrecord.FieldType:
		return m.GetType()
	case withdrawrecord.FieldAmount:
		return m.Amount()
	case withdrawrecord.FieldRemainAmount:
		return m.RemainAmount()
	case withdrawrecord.FieldRate:
		return m.Rate()
	case withdrawrecord.FieldRealAmount:
		return m.RealAmount()
	case withdrawrecord.FieldStatus:
		return m.Status()
	case withdrawrecord.FieldRejectReason:
		return m.RejectReason()
	case withdrawrecord.FieldOperateUserID:
		return m.OperateUserID()
	case withdrawrecord.FieldTransferOrderID:
		return m.TransferOrderID()
	case withdrawrecord.FieldSymbolID:
		return m.SymbolID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WithdrawRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case withdrawrecord.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case withdrawrecord.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case withdrawrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case withdrawrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case withdrawrecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case withdrawrecord.FieldUserID:
		return m.OldUserID(ctx)
	case withdrawrecord.FieldWithdrawAccount:
		return m.OldWithdrawAccount(ctx)
	case withdrawrecord.FieldBusinessName:
		return m.OldBusinessName(ctx)
	case withdrawrecord.FieldBank:
		return m.OldBank(ctx)
	case withdrawrecord.FieldType:
		return m.OldType(ctx)
	case withdrawrecord.FieldAmount:
		return m.OldAmount(ctx)
	case withdrawrecord.FieldRemainAmount:
		return m.OldRemainAmount(ctx)
	case withdrawrecord.FieldRate:
		return m.OldRate(ctx)
	case withdrawrecord.FieldRealAmount:
		return m.OldRealAmount(ctx)
	case withdrawrecord.FieldStatus:
		return m.OldStatus(ctx)
	case withdrawrecord.FieldRejectReason:
		return m.OldRejectReason(ctx)
	case withdrawrecord.FieldOperateUserID:
		return m.OldOperateUserID(ctx)
	case withdrawrecord.FieldTransferOrderID:
		return m.OldTransferOrderID(ctx)
	case withdrawrecord.FieldSymbolID:
		return m.OldSymbolID(ctx)
	}
	return nil, fmt.Errorf("unknown WithdrawRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case withdrawrecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case withdrawrecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case withdrawrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case withdrawrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case withdrawrecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case withdrawrecord.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case withdrawrecord.FieldWithdrawAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawAccount(v)
		return nil
	case withdrawrecord.FieldBusinessName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessName(v)
		return nil
	case withdrawrecord.FieldBank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBank(v)
		return nil
	case withdrawrecord.FieldType:
		v, ok := value.(enums.WithdrawType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case withdrawrecord.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case withdrawrecord.FieldRemainAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainAmount(v)
		return nil
	case withdrawrecord.FieldRate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case withdrawrecord.FieldRealAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealAmount(v)
		return nil
	case withdrawrecord.FieldStatus:
		v, ok := value.(enums.WithdrawStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case withdrawrecord.FieldRejectReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectReason(v)
		return nil
	case withdrawrecord.FieldOperateUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperateUserID(v)
		return nil
	case withdrawrecord.FieldTransferOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransferOrderID(v)
		return nil
	case withdrawrecord.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	}
	return fmt.Errorf("unknown WithdrawRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WithdrawRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, withdrawrecord.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, withdrawrecord.FieldUpdatedBy)
	}
	if m.addamount != nil {
		fields = append(fields, withdrawrecord.FieldAmount)
	}
	if m.addremain_amount != nil {
		fields = append(fields, withdrawrecord.FieldRemainAmount)
	}
	if m.addrate != nil {
		fields = append(fields, withdrawrecord.FieldRate)
	}
	if m.addreal_amount != nil {
		fields = append(fields, withdrawrecord.FieldRealAmount)
	}
	if m.addsymbol_id != nil {
		fields = append(fields, withdrawrecord.FieldSymbolID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WithdrawRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case withdrawrecord.FieldCreatedBy:
		return m.AddedCreatedBy()
	case withdrawrecord.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case withdrawrecord.FieldAmount:
		return m.AddedAmount()
	case withdrawrecord.FieldRemainAmount:
		return m.AddedRemainAmount()
	case withdrawrecord.FieldRate:
		return m.AddedRate()
	case withdrawrecord.FieldRealAmount:
		return m.AddedRealAmount()
	case withdrawrecord.FieldSymbolID:
		return m.AddedSymbolID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case withdrawrecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case withdrawrecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case withdrawrecord.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case withdrawrecord.FieldRemainAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainAmount(v)
		return nil
	case withdrawrecord.FieldRate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	case withdrawrecord.FieldRealAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRealAmount(v)
		return nil
	case withdrawrecord.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSymbolID(v)
		return nil
	}
	return fmt.Errorf("unknown WithdrawRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WithdrawRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WithdrawRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WithdrawRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WithdrawRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WithdrawRecordMutation) ResetField(name string) error {
	switch name {
	case withdrawrecord.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case withdrawrecord.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case withdrawrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case withdrawrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case withdrawrecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case withdrawrecord.FieldUserID:
		m.ResetUserID()
		return nil
	case withdrawrecord.FieldWithdrawAccount:
		m.ResetWithdrawAccount()
		return nil
	case withdrawrecord.FieldBusinessName:
		m.ResetBusinessName()
		return nil
	case withdrawrecord.FieldBank:
		m.ResetBank()
		return nil
	case withdrawrecord.FieldType:
		m.ResetType()
		return nil
	case withdrawrecord.FieldAmount:
		m.ResetAmount()
		return nil
	case withdrawrecord.FieldRemainAmount:
		m.ResetRemainAmount()
		return nil
	case withdrawrecord.FieldRate:
		m.ResetRate()
		return nil
	case withdrawrecord.FieldRealAmount:
		m.ResetRealAmount()
		return nil
	case withdrawrecord.FieldStatus:
		m.ResetStatus()
		return nil
	case withdrawrecord.FieldRejectReason:
		m.ResetRejectReason()
		return nil
	case withdrawrecord.FieldOperateUserID:
		m.ResetOperateUserID()
		return nil
	case withdrawrecord.FieldTransferOrderID:
		m.ResetTransferOrderID()
		return nil
	case withdrawrecord.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	}
	return fmt.Errorf("unknown WithdrawRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WithdrawRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, withdrawrecord.EdgeUser)
	}
	if m.operate_user != nil {
		edges = append(edges, withdrawrecord.EdgeOperateUser)
	}
	if m.transfer_order != nil {
		edges = append(edges, withdrawrecord.EdgeTransferOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WithdrawRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case withdrawrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case withdrawrecord.EdgeOperateUser:
		if id := m.operate_user; id != nil {
			return []ent.Value{*id}
		}
	case withdrawrecord.EdgeTransferOrder:
		if id := m.transfer_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WithdrawRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WithdrawRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WithdrawRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, withdrawrecord.EdgeUser)
	}
	if m.clearedoperate_user {
		edges = append(edges, withdrawrecord.EdgeOperateUser)
	}
	if m.clearedtransfer_order {
		edges = append(edges, withdrawrecord.EdgeTransferOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WithdrawRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case withdrawrecord.EdgeUser:
		return m.cleareduser
	case withdrawrecord.EdgeOperateUser:
		return m.clearedoperate_user
	case withdrawrecord.EdgeTransferOrder:
		return m.clearedtransfer_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WithdrawRecordMutation) ClearEdge(name string) error {
	switch name {
	case withdrawrecord.EdgeUser:
		m.ClearUser()
		return nil
	case withdrawrecord.EdgeOperateUser:
		m.ClearOperateUser()
		return nil
	case withdrawrecord.EdgeTransferOrder:
		m.ClearTransferOrder()
		return nil
	}
	return fmt.Errorf("unknown WithdrawRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WithdrawRecordMutation) ResetEdge(name string) error {
	switch name {
	case withdrawrecord.EdgeUser:
		m.ResetUser()
		return nil
	case withdrawrecord.EdgeOperateUser:
		m.ResetOperateUser()
		return nil
	case withdrawrecord.EdgeTransferOrder:
		m.ResetTransferOrder()
		return nil
	}
	return fmt.Errorf("unknown WithdrawRecord edge %s", name)
}
