// Code generated by ent, DO NOT EDIT.

package cep_ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/artwork"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/artworklike"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/bill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/campaign"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/campaignorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/cdkinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/collect"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/device"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/devicegpumission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/earnbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enumcondition"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enummissionstatus"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/extraservice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/extraserviceorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/extraserviceprice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/frpcinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/frpsinfo"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/gpu"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/hmackeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/inputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/invite"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/loginrecord"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/mission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionbatch"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionconsumeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionextraservice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkind"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionproduceorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionproduction"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/outputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/platformaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/predicate"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/price"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitsetting"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/rechargecampaignrule"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/rechargeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/renewalagreement"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/symbol"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/transferorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/user"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/userdevice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxsocial"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/wallet"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/withdrawaccount"
	"github.com/stark-sim/cephalon-ent/pkg/enums"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtwork              = "Artwork"
	TypeArtworkLike          = "ArtworkLike"
	TypeBill                 = "Bill"
	TypeCDKInfo              = "CDKInfo"
	TypeCampaign             = "Campaign"
	TypeCampaignOrder        = "CampaignOrder"
	TypeCollect              = "Collect"
	TypeCostAccount          = "CostAccount"
	TypeCostBill             = "CostBill"
	TypeDevice               = "Device"
	TypeDeviceGpuMission     = "DeviceGpuMission"
	TypeEarnBill             = "EarnBill"
	TypeEnumCondition        = "EnumCondition"
	TypeEnumMissionStatus    = "EnumMissionStatus"
	TypeExtraService         = "ExtraService"
	TypeExtraServiceOrder    = "ExtraServiceOrder"
	TypeExtraServicePrice    = "ExtraServicePrice"
	TypeFrpcInfo             = "FrpcInfo"
	TypeFrpsInfo             = "FrpsInfo"
	TypeGpu                  = "Gpu"
	TypeHmacKeyPair          = "HmacKeyPair"
	TypeInputLog             = "InputLog"
	TypeInvite               = "Invite"
	TypeLoginRecord          = "LoginRecord"
	TypeMission              = "Mission"
	TypeMissionBatch         = "MissionBatch"
	TypeMissionConsumeOrder  = "MissionConsumeOrder"
	TypeMissionExtraService  = "MissionExtraService"
	TypeMissionKeyPair       = "MissionKeyPair"
	TypeMissionKind          = "MissionKind"
	TypeMissionOrder         = "MissionOrder"
	TypeMissionProduceOrder  = "MissionProduceOrder"
	TypeMissionProduction    = "MissionProduction"
	TypeOutputLog            = "OutputLog"
	TypePlatformAccount      = "PlatformAccount"
	TypePrice                = "Price"
	TypeProfitAccount        = "ProfitAccount"
	TypeProfitSetting        = "ProfitSetting"
	TypeRechargeCampaignRule = "RechargeCampaignRule"
	TypeRechargeOrder        = "RechargeOrder"
	TypeRenewalAgreement     = "RenewalAgreement"
	TypeSymbol               = "Symbol"
	TypeTransferOrder        = "TransferOrder"
	TypeUser                 = "User"
	TypeUserDevice           = "UserDevice"
	TypeVXAccount            = "VXAccount"
	TypeVXSocial             = "VXSocial"
	TypeWallet               = "Wallet"
	TypeWithdrawAccount      = "WithdrawAccount"
)

// ArtworkMutation represents an operation that mutates the Artwork nodes in the graph.
type ArtworkMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_by           *int64
	addcreated_by        *int64
	updated_by           *int64
	addupdated_by        *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	url                  *string
	clearedFields        map[string]struct{}
	author               *int64
	clearedauthor        bool
	artwork_likes        map[int64]struct{}
	removedartwork_likes map[int64]struct{}
	clearedartwork_likes bool
	done                 bool
	oldValue             func(context.Context) (*Artwork, error)
	predicates           []predicate.Artwork
}

var _ ent.Mutation = (*ArtworkMutation)(nil)

// artworkOption allows management of the mutation configuration using functional options.
type artworkOption func(*ArtworkMutation)

// newArtworkMutation creates new mutation for the Artwork entity.
func newArtworkMutation(c config, op Op, opts ...artworkOption) *ArtworkMutation {
	m := &ArtworkMutation{
		config:        c,
		op:            op,
		typ:           TypeArtwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtworkID sets the ID field of the mutation.
func withArtworkID(id int64) artworkOption {
	return func(m *ArtworkMutation) {
		var (
			err   error
			once  sync.Once
			value *Artwork
		)
		m.oldValue = func(ctx context.Context) (*Artwork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtwork sets the old Artwork of the mutation.
func withArtwork(node *Artwork) artworkOption {
	return func(m *ArtworkMutation) {
		m.oldValue = func(context.Context) (*Artwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Artwork entities.
func (m *ArtworkMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtworkMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtworkMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artwork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ArtworkMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ArtworkMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ArtworkMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ArtworkMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ArtworkMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ArtworkMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ArtworkMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ArtworkMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ArtworkMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ArtworkMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtworkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtworkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtworkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtworkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtworkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtworkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArtworkMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArtworkMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArtworkMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *ArtworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtworkMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *ArtworkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ArtworkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ArtworkMutation) ResetURL() {
	m.url = nil
}

// SetAuthorID sets the "author_id" field.
func (m *ArtworkMutation) SetAuthorID(i int64) {
	m.author = &i
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *ArtworkMutation) AuthorID() (r int64, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Artwork entity.
// If the Artwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkMutation) OldAuthorID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *ArtworkMutation) ResetAuthorID() {
	m.author = nil
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *ArtworkMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[artwork.FieldAuthorID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *ArtworkMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *ArtworkMutation) AuthorIDs() (ids []int64) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *ArtworkMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// AddArtworkLikeIDs adds the "artwork_likes" edge to the ArtworkLike entity by ids.
func (m *ArtworkMutation) AddArtworkLikeIDs(ids ...int64) {
	if m.artwork_likes == nil {
		m.artwork_likes = make(map[int64]struct{})
	}
	for i := range ids {
		m.artwork_likes[ids[i]] = struct{}{}
	}
}

// ClearArtworkLikes clears the "artwork_likes" edge to the ArtworkLike entity.
func (m *ArtworkMutation) ClearArtworkLikes() {
	m.clearedartwork_likes = true
}

// ArtworkLikesCleared reports if the "artwork_likes" edge to the ArtworkLike entity was cleared.
func (m *ArtworkMutation) ArtworkLikesCleared() bool {
	return m.clearedartwork_likes
}

// RemoveArtworkLikeIDs removes the "artwork_likes" edge to the ArtworkLike entity by IDs.
func (m *ArtworkMutation) RemoveArtworkLikeIDs(ids ...int64) {
	if m.removedartwork_likes == nil {
		m.removedartwork_likes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.artwork_likes, ids[i])
		m.removedartwork_likes[ids[i]] = struct{}{}
	}
}

// RemovedArtworkLikes returns the removed IDs of the "artwork_likes" edge to the ArtworkLike entity.
func (m *ArtworkMutation) RemovedArtworkLikesIDs() (ids []int64) {
	for id := range m.removedartwork_likes {
		ids = append(ids, id)
	}
	return
}

// ArtworkLikesIDs returns the "artwork_likes" edge IDs in the mutation.
func (m *ArtworkMutation) ArtworkLikesIDs() (ids []int64) {
	for id := range m.artwork_likes {
		ids = append(ids, id)
	}
	return
}

// ResetArtworkLikes resets all changes to the "artwork_likes" edge.
func (m *ArtworkMutation) ResetArtworkLikes() {
	m.artwork_likes = nil
	m.clearedartwork_likes = false
	m.removedartwork_likes = nil
}

// Where appends a list predicates to the ArtworkMutation builder.
func (m *ArtworkMutation) Where(ps ...predicate.Artwork) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtworkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtworkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artwork, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtworkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtworkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artwork).
func (m *ArtworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtworkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, artwork.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, artwork.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, artwork.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, artwork.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, artwork.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, artwork.FieldName)
	}
	if m.url != nil {
		fields = append(fields, artwork.FieldURL)
	}
	if m.author != nil {
		fields = append(fields, artwork.FieldAuthorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artwork.FieldCreatedBy:
		return m.CreatedBy()
	case artwork.FieldUpdatedBy:
		return m.UpdatedBy()
	case artwork.FieldCreatedAt:
		return m.CreatedAt()
	case artwork.FieldUpdatedAt:
		return m.UpdatedAt()
	case artwork.FieldDeletedAt:
		return m.DeletedAt()
	case artwork.FieldName:
		return m.Name()
	case artwork.FieldURL:
		return m.URL()
	case artwork.FieldAuthorID:
		return m.AuthorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artwork.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case artwork.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case artwork.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artwork.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artwork.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case artwork.FieldName:
		return m.OldName(ctx)
	case artwork.FieldURL:
		return m.OldURL(ctx)
	case artwork.FieldAuthorID:
		return m.OldAuthorID(ctx)
	}
	return nil, fmt.Errorf("unknown Artwork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artwork.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case artwork.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case artwork.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artwork.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artwork.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case artwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case artwork.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case artwork.FieldAuthorID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	}
	return fmt.Errorf("unknown Artwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtworkMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, artwork.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, artwork.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtworkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case artwork.FieldCreatedBy:
		return m.AddedCreatedBy()
	case artwork.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case artwork.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case artwork.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Artwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artwork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtworkMutation) ResetField(name string) error {
	switch name {
	case artwork.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case artwork.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case artwork.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artwork.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artwork.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case artwork.FieldName:
		m.ResetName()
		return nil
	case artwork.FieldURL:
		m.ResetURL()
		return nil
	case artwork.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	}
	return fmt.Errorf("unknown Artwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.author != nil {
		edges = append(edges, artwork.EdgeAuthor)
	}
	if m.artwork_likes != nil {
		edges = append(edges, artwork.EdgeArtworkLikes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artwork.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case artwork.EdgeArtworkLikes:
		ids := make([]ent.Value, 0, len(m.artwork_likes))
		for id := range m.artwork_likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedartwork_likes != nil {
		edges = append(edges, artwork.EdgeArtworkLikes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artwork.EdgeArtworkLikes:
		ids := make([]ent.Value, 0, len(m.removedartwork_likes))
		for id := range m.removedartwork_likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauthor {
		edges = append(edges, artwork.EdgeAuthor)
	}
	if m.clearedartwork_likes {
		edges = append(edges, artwork.EdgeArtworkLikes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtworkMutation) EdgeCleared(name string) bool {
	switch name {
	case artwork.EdgeAuthor:
		return m.clearedauthor
	case artwork.EdgeArtworkLikes:
		return m.clearedartwork_likes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtworkMutation) ClearEdge(name string) error {
	switch name {
	case artwork.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Artwork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtworkMutation) ResetEdge(name string) error {
	switch name {
	case artwork.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case artwork.EdgeArtworkLikes:
		m.ResetArtworkLikes()
		return nil
	}
	return fmt.Errorf("unknown Artwork edge %s", name)
}

// ArtworkLikeMutation represents an operation that mutates the ArtworkLike nodes in the graph.
type ArtworkLikeMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_by     *int64
	addcreated_by  *int64
	updated_by     *int64
	addupdated_by  *int64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	date           *int32
	adddate        *int32
	clearedFields  map[string]struct{}
	user           *int64
	cleareduser    bool
	artwork        *int64
	clearedartwork bool
	done           bool
	oldValue       func(context.Context) (*ArtworkLike, error)
	predicates     []predicate.ArtworkLike
}

var _ ent.Mutation = (*ArtworkLikeMutation)(nil)

// artworklikeOption allows management of the mutation configuration using functional options.
type artworklikeOption func(*ArtworkLikeMutation)

// newArtworkLikeMutation creates new mutation for the ArtworkLike entity.
func newArtworkLikeMutation(c config, op Op, opts ...artworklikeOption) *ArtworkLikeMutation {
	m := &ArtworkLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeArtworkLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtworkLikeID sets the ID field of the mutation.
func withArtworkLikeID(id int64) artworklikeOption {
	return func(m *ArtworkLikeMutation) {
		var (
			err   error
			once  sync.Once
			value *ArtworkLike
		)
		m.oldValue = func(ctx context.Context) (*ArtworkLike, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArtworkLike.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtworkLike sets the old ArtworkLike of the mutation.
func withArtworkLike(node *ArtworkLike) artworklikeOption {
	return func(m *ArtworkLikeMutation) {
		m.oldValue = func(context.Context) (*ArtworkLike, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtworkLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtworkLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArtworkLike entities.
func (m *ArtworkLikeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtworkLikeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtworkLikeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArtworkLike.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ArtworkLikeMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ArtworkLikeMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ArtworkLikeMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ArtworkLikeMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ArtworkLikeMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ArtworkLikeMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ArtworkLikeMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ArtworkLikeMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ArtworkLikeMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ArtworkLikeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtworkLikeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtworkLikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtworkLikeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtworkLikeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtworkLikeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtworkLikeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArtworkLikeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArtworkLikeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArtworkLikeMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ArtworkLikeMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ArtworkLikeMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ArtworkLikeMutation) ResetUserID() {
	m.user = nil
}

// SetArtworkID sets the "artwork_id" field.
func (m *ArtworkLikeMutation) SetArtworkID(i int64) {
	m.artwork = &i
}

// ArtworkID returns the value of the "artwork_id" field in the mutation.
func (m *ArtworkLikeMutation) ArtworkID() (r int64, exists bool) {
	v := m.artwork
	if v == nil {
		return
	}
	return *v, true
}

// OldArtworkID returns the old "artwork_id" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldArtworkID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtworkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtworkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtworkID: %w", err)
	}
	return oldValue.ArtworkID, nil
}

// ResetArtworkID resets all changes to the "artwork_id" field.
func (m *ArtworkLikeMutation) ResetArtworkID() {
	m.artwork = nil
}

// SetDate sets the "date" field.
func (m *ArtworkLikeMutation) SetDate(i int32) {
	m.date = &i
	m.adddate = nil
}

// Date returns the value of the "date" field in the mutation.
func (m *ArtworkLikeMutation) Date() (r int32, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the ArtworkLike entity.
// If the ArtworkLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtworkLikeMutation) OldDate(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to the "date" field.
func (m *ArtworkLikeMutation) AddDate(i int32) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the "date" field in this mutation.
func (m *ArtworkLikeMutation) AddedDate() (r int32, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate resets all changes to the "date" field.
func (m *ArtworkLikeMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ArtworkLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[artworklike.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ArtworkLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ArtworkLikeMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ArtworkLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearArtwork clears the "artwork" edge to the Artwork entity.
func (m *ArtworkLikeMutation) ClearArtwork() {
	m.clearedartwork = true
	m.clearedFields[artworklike.FieldArtworkID] = struct{}{}
}

// ArtworkCleared reports if the "artwork" edge to the Artwork entity was cleared.
func (m *ArtworkLikeMutation) ArtworkCleared() bool {
	return m.clearedartwork
}

// ArtworkIDs returns the "artwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtworkID instead. It exists only for internal usage by the builders.
func (m *ArtworkLikeMutation) ArtworkIDs() (ids []int64) {
	if id := m.artwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtwork resets all changes to the "artwork" edge.
func (m *ArtworkLikeMutation) ResetArtwork() {
	m.artwork = nil
	m.clearedartwork = false
}

// Where appends a list predicates to the ArtworkLikeMutation builder.
func (m *ArtworkLikeMutation) Where(ps ...predicate.ArtworkLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtworkLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtworkLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArtworkLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtworkLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtworkLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArtworkLike).
func (m *ArtworkLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtworkLikeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, artworklike.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, artworklike.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, artworklike.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, artworklike.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, artworklike.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, artworklike.FieldUserID)
	}
	if m.artwork != nil {
		fields = append(fields, artworklike.FieldArtworkID)
	}
	if m.date != nil {
		fields = append(fields, artworklike.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtworkLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artworklike.FieldCreatedBy:
		return m.CreatedBy()
	case artworklike.FieldUpdatedBy:
		return m.UpdatedBy()
	case artworklike.FieldCreatedAt:
		return m.CreatedAt()
	case artworklike.FieldUpdatedAt:
		return m.UpdatedAt()
	case artworklike.FieldDeletedAt:
		return m.DeletedAt()
	case artworklike.FieldUserID:
		return m.UserID()
	case artworklike.FieldArtworkID:
		return m.ArtworkID()
	case artworklike.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtworkLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artworklike.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case artworklike.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case artworklike.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artworklike.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artworklike.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case artworklike.FieldUserID:
		return m.OldUserID(ctx)
	case artworklike.FieldArtworkID:
		return m.OldArtworkID(ctx)
	case artworklike.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown ArtworkLike field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtworkLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artworklike.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case artworklike.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case artworklike.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artworklike.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artworklike.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case artworklike.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case artworklike.FieldArtworkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtworkID(v)
		return nil
	case artworklike.FieldDate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtworkLikeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, artworklike.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, artworklike.FieldUpdatedBy)
	}
	if m.adddate != nil {
		fields = append(fields, artworklike.FieldDate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtworkLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case artworklike.FieldCreatedBy:
		return m.AddedCreatedBy()
	case artworklike.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case artworklike.FieldDate:
		return m.AddedDate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtworkLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case artworklike.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case artworklike.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case artworklike.FieldDate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtworkLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtworkLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtworkLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArtworkLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtworkLikeMutation) ResetField(name string) error {
	switch name {
	case artworklike.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case artworklike.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case artworklike.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artworklike.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artworklike.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case artworklike.FieldUserID:
		m.ResetUserID()
		return nil
	case artworklike.FieldArtworkID:
		m.ResetArtworkID()
		return nil
	case artworklike.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtworkLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, artworklike.EdgeUser)
	}
	if m.artwork != nil {
		edges = append(edges, artworklike.EdgeArtwork)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtworkLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artworklike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case artworklike.EdgeArtwork:
		if id := m.artwork; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtworkLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtworkLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtworkLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, artworklike.EdgeUser)
	}
	if m.clearedartwork {
		edges = append(edges, artworklike.EdgeArtwork)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtworkLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case artworklike.EdgeUser:
		return m.cleareduser
	case artworklike.EdgeArtwork:
		return m.clearedartwork
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtworkLikeMutation) ClearEdge(name string) error {
	switch name {
	case artworklike.EdgeUser:
		m.ClearUser()
		return nil
	case artworklike.EdgeArtwork:
		m.ClearArtwork()
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtworkLikeMutation) ResetEdge(name string) error {
	switch name {
	case artworklike.EdgeUser:
		m.ResetUser()
		return nil
	case artworklike.EdgeArtwork:
		m.ResetArtwork()
		return nil
	}
	return fmt.Errorf("unknown ArtworkLike edge %s", name)
}

// BillMutation represents an operation that mutates the Bill nodes in the graph.
type BillMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	created_by              *int64
	addcreated_by           *int64
	updated_by              *int64
	addupdated_by           *int64
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	_type                   *enums.BillType
	way                     *enums.BillWay
	profit_symbol_id        *int64
	addprofit_symbol_id     *int64
	amount                  *int64
	addamount               *int64
	target_before_amount    *int64
	addtarget_before_amount *int64
	target_after_amount     *int64
	addtarget_after_amount  *int64
	source_before_amount    *int64
	addsource_before_amount *int64
	source_after_amount     *int64
	addsource_after_amount  *int64
	serial_number           *string
	clearedFields           map[string]struct{}
	source_user             *int64
	clearedsource_user      bool
	target_user             *int64
	clearedtarget_user      bool
	transfer_order          *int64
	clearedtransfer_order   bool
	mission_order           *int64
	clearedmission_order    bool
	invite                  *int64
	clearedinvite           bool
	symbol                  *int64
	clearedsymbol           bool
	done                    bool
	oldValue                func(context.Context) (*Bill, error)
	predicates              []predicate.Bill
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows management of the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for the Bill entity.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the ID field of the mutation.
func withBillID(id int64) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bill entities.
func (m *BillMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *BillMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BillMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *BillMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *BillMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BillMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BillMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BillMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *BillMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *BillMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BillMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *BillMutation) SetType(et enums.BillType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *BillMutation) GetType() (r enums.BillType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldType(ctx context.Context) (v enums.BillType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BillMutation) ResetType() {
	m._type = nil
}

// SetOrderID sets the "order_id" field.
func (m *BillMutation) SetOrderID(i int64) {
	m.transfer_order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *BillMutation) OrderID() (r int64, exists bool) {
	v := m.transfer_order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *BillMutation) ClearOrderID() {
	m.transfer_order = nil
	m.clearedFields[bill.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *BillMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[bill.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *BillMutation) ResetOrderID() {
	m.transfer_order = nil
	delete(m.clearedFields, bill.FieldOrderID)
}

// SetWay sets the "way" field.
func (m *BillMutation) SetWay(ew enums.BillWay) {
	m.way = &ew
}

// Way returns the value of the "way" field in the mutation.
func (m *BillMutation) Way() (r enums.BillWay, exists bool) {
	v := m.way
	if v == nil {
		return
	}
	return *v, true
}

// OldWay returns the old "way" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldWay(ctx context.Context) (v enums.BillWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWay: %w", err)
	}
	return oldValue.Way, nil
}

// ResetWay resets all changes to the "way" field.
func (m *BillMutation) ResetWay() {
	m.way = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *BillMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *BillMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *BillMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetProfitSymbolID sets the "profit_symbol_id" field.
func (m *BillMutation) SetProfitSymbolID(i int64) {
	m.profit_symbol_id = &i
	m.addprofit_symbol_id = nil
}

// ProfitSymbolID returns the value of the "profit_symbol_id" field in the mutation.
func (m *BillMutation) ProfitSymbolID() (r int64, exists bool) {
	v := m.profit_symbol_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitSymbolID returns the old "profit_symbol_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldProfitSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitSymbolID: %w", err)
	}
	return oldValue.ProfitSymbolID, nil
}

// AddProfitSymbolID adds i to the "profit_symbol_id" field.
func (m *BillMutation) AddProfitSymbolID(i int64) {
	if m.addprofit_symbol_id != nil {
		*m.addprofit_symbol_id += i
	} else {
		m.addprofit_symbol_id = &i
	}
}

// AddedProfitSymbolID returns the value that was added to the "profit_symbol_id" field in this mutation.
func (m *BillMutation) AddedProfitSymbolID() (r int64, exists bool) {
	v := m.addprofit_symbol_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitSymbolID resets all changes to the "profit_symbol_id" field.
func (m *BillMutation) ResetProfitSymbolID() {
	m.profit_symbol_id = nil
	m.addprofit_symbol_id = nil
}

// SetAmount sets the "amount" field.
func (m *BillMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *BillMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *BillMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *BillMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *BillMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetTargetUserID sets the "target_user_id" field.
func (m *BillMutation) SetTargetUserID(i int64) {
	m.target_user = &i
}

// TargetUserID returns the value of the "target_user_id" field in the mutation.
func (m *BillMutation) TargetUserID() (r int64, exists bool) {
	v := m.target_user
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetUserID returns the old "target_user_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldTargetUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetUserID: %w", err)
	}
	return oldValue.TargetUserID, nil
}

// ResetTargetUserID resets all changes to the "target_user_id" field.
func (m *BillMutation) ResetTargetUserID() {
	m.target_user = nil
}

// SetTargetBeforeAmount sets the "target_before_amount" field.
func (m *BillMutation) SetTargetBeforeAmount(i int64) {
	m.target_before_amount = &i
	m.addtarget_before_amount = nil
}

// TargetBeforeAmount returns the value of the "target_before_amount" field in the mutation.
func (m *BillMutation) TargetBeforeAmount() (r int64, exists bool) {
	v := m.target_before_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetBeforeAmount returns the old "target_before_amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldTargetBeforeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetBeforeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetBeforeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetBeforeAmount: %w", err)
	}
	return oldValue.TargetBeforeAmount, nil
}

// AddTargetBeforeAmount adds i to the "target_before_amount" field.
func (m *BillMutation) AddTargetBeforeAmount(i int64) {
	if m.addtarget_before_amount != nil {
		*m.addtarget_before_amount += i
	} else {
		m.addtarget_before_amount = &i
	}
}

// AddedTargetBeforeAmount returns the value that was added to the "target_before_amount" field in this mutation.
func (m *BillMutation) AddedTargetBeforeAmount() (r int64, exists bool) {
	v := m.addtarget_before_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetBeforeAmount resets all changes to the "target_before_amount" field.
func (m *BillMutation) ResetTargetBeforeAmount() {
	m.target_before_amount = nil
	m.addtarget_before_amount = nil
}

// SetTargetAfterAmount sets the "target_after_amount" field.
func (m *BillMutation) SetTargetAfterAmount(i int64) {
	m.target_after_amount = &i
	m.addtarget_after_amount = nil
}

// TargetAfterAmount returns the value of the "target_after_amount" field in the mutation.
func (m *BillMutation) TargetAfterAmount() (r int64, exists bool) {
	v := m.target_after_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetAfterAmount returns the old "target_after_amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldTargetAfterAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetAfterAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetAfterAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetAfterAmount: %w", err)
	}
	return oldValue.TargetAfterAmount, nil
}

// AddTargetAfterAmount adds i to the "target_after_amount" field.
func (m *BillMutation) AddTargetAfterAmount(i int64) {
	if m.addtarget_after_amount != nil {
		*m.addtarget_after_amount += i
	} else {
		m.addtarget_after_amount = &i
	}
}

// AddedTargetAfterAmount returns the value that was added to the "target_after_amount" field in this mutation.
func (m *BillMutation) AddedTargetAfterAmount() (r int64, exists bool) {
	v := m.addtarget_after_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetAfterAmount resets all changes to the "target_after_amount" field.
func (m *BillMutation) ResetTargetAfterAmount() {
	m.target_after_amount = nil
	m.addtarget_after_amount = nil
}

// SetSourceUserID sets the "source_user_id" field.
func (m *BillMutation) SetSourceUserID(i int64) {
	m.source_user = &i
}

// SourceUserID returns the value of the "source_user_id" field in the mutation.
func (m *BillMutation) SourceUserID() (r int64, exists bool) {
	v := m.source_user
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceUserID returns the old "source_user_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSourceUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceUserID: %w", err)
	}
	return oldValue.SourceUserID, nil
}

// ResetSourceUserID resets all changes to the "source_user_id" field.
func (m *BillMutation) ResetSourceUserID() {
	m.source_user = nil
}

// SetSourceBeforeAmount sets the "source_before_amount" field.
func (m *BillMutation) SetSourceBeforeAmount(i int64) {
	m.source_before_amount = &i
	m.addsource_before_amount = nil
}

// SourceBeforeAmount returns the value of the "source_before_amount" field in the mutation.
func (m *BillMutation) SourceBeforeAmount() (r int64, exists bool) {
	v := m.source_before_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceBeforeAmount returns the old "source_before_amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSourceBeforeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceBeforeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceBeforeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceBeforeAmount: %w", err)
	}
	return oldValue.SourceBeforeAmount, nil
}

// AddSourceBeforeAmount adds i to the "source_before_amount" field.
func (m *BillMutation) AddSourceBeforeAmount(i int64) {
	if m.addsource_before_amount != nil {
		*m.addsource_before_amount += i
	} else {
		m.addsource_before_amount = &i
	}
}

// AddedSourceBeforeAmount returns the value that was added to the "source_before_amount" field in this mutation.
func (m *BillMutation) AddedSourceBeforeAmount() (r int64, exists bool) {
	v := m.addsource_before_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSourceBeforeAmount resets all changes to the "source_before_amount" field.
func (m *BillMutation) ResetSourceBeforeAmount() {
	m.source_before_amount = nil
	m.addsource_before_amount = nil
}

// SetSourceAfterAmount sets the "source_after_amount" field.
func (m *BillMutation) SetSourceAfterAmount(i int64) {
	m.source_after_amount = &i
	m.addsource_after_amount = nil
}

// SourceAfterAmount returns the value of the "source_after_amount" field in the mutation.
func (m *BillMutation) SourceAfterAmount() (r int64, exists bool) {
	v := m.source_after_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceAfterAmount returns the old "source_after_amount" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSourceAfterAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceAfterAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceAfterAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceAfterAmount: %w", err)
	}
	return oldValue.SourceAfterAmount, nil
}

// AddSourceAfterAmount adds i to the "source_after_amount" field.
func (m *BillMutation) AddSourceAfterAmount(i int64) {
	if m.addsource_after_amount != nil {
		*m.addsource_after_amount += i
	} else {
		m.addsource_after_amount = &i
	}
}

// AddedSourceAfterAmount returns the value that was added to the "source_after_amount" field in this mutation.
func (m *BillMutation) AddedSourceAfterAmount() (r int64, exists bool) {
	v := m.addsource_after_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSourceAfterAmount resets all changes to the "source_after_amount" field.
func (m *BillMutation) ResetSourceAfterAmount() {
	m.source_after_amount = nil
	m.addsource_after_amount = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *BillMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *BillMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *BillMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetInviteID sets the "invite_id" field.
func (m *BillMutation) SetInviteID(i int64) {
	m.invite = &i
}

// InviteID returns the value of the "invite_id" field in the mutation.
func (m *BillMutation) InviteID() (r int64, exists bool) {
	v := m.invite
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteID returns the old "invite_id" field's value of the Bill entity.
// If the Bill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillMutation) OldInviteID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteID: %w", err)
	}
	return oldValue.InviteID, nil
}

// ResetInviteID resets all changes to the "invite_id" field.
func (m *BillMutation) ResetInviteID() {
	m.invite = nil
}

// ClearSourceUser clears the "source_user" edge to the User entity.
func (m *BillMutation) ClearSourceUser() {
	m.clearedsource_user = true
	m.clearedFields[bill.FieldSourceUserID] = struct{}{}
}

// SourceUserCleared reports if the "source_user" edge to the User entity was cleared.
func (m *BillMutation) SourceUserCleared() bool {
	return m.clearedsource_user
}

// SourceUserIDs returns the "source_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceUserID instead. It exists only for internal usage by the builders.
func (m *BillMutation) SourceUserIDs() (ids []int64) {
	if id := m.source_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceUser resets all changes to the "source_user" edge.
func (m *BillMutation) ResetSourceUser() {
	m.source_user = nil
	m.clearedsource_user = false
}

// ClearTargetUser clears the "target_user" edge to the User entity.
func (m *BillMutation) ClearTargetUser() {
	m.clearedtarget_user = true
	m.clearedFields[bill.FieldTargetUserID] = struct{}{}
}

// TargetUserCleared reports if the "target_user" edge to the User entity was cleared.
func (m *BillMutation) TargetUserCleared() bool {
	return m.clearedtarget_user
}

// TargetUserIDs returns the "target_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetUserID instead. It exists only for internal usage by the builders.
func (m *BillMutation) TargetUserIDs() (ids []int64) {
	if id := m.target_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetUser resets all changes to the "target_user" edge.
func (m *BillMutation) ResetTargetUser() {
	m.target_user = nil
	m.clearedtarget_user = false
}

// SetTransferOrderID sets the "transfer_order" edge to the TransferOrder entity by id.
func (m *BillMutation) SetTransferOrderID(id int64) {
	m.transfer_order = &id
}

// ClearTransferOrder clears the "transfer_order" edge to the TransferOrder entity.
func (m *BillMutation) ClearTransferOrder() {
	m.clearedtransfer_order = true
	m.clearedFields[bill.FieldOrderID] = struct{}{}
}

// TransferOrderCleared reports if the "transfer_order" edge to the TransferOrder entity was cleared.
func (m *BillMutation) TransferOrderCleared() bool {
	return m.OrderIDCleared() || m.clearedtransfer_order
}

// TransferOrderID returns the "transfer_order" edge ID in the mutation.
func (m *BillMutation) TransferOrderID() (id int64, exists bool) {
	if m.transfer_order != nil {
		return *m.transfer_order, true
	}
	return
}

// TransferOrderIDs returns the "transfer_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferOrderID instead. It exists only for internal usage by the builders.
func (m *BillMutation) TransferOrderIDs() (ids []int64) {
	if id := m.transfer_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransferOrder resets all changes to the "transfer_order" edge.
func (m *BillMutation) ResetTransferOrder() {
	m.transfer_order = nil
	m.clearedtransfer_order = false
}

// SetMissionOrderID sets the "mission_order" edge to the MissionOrder entity by id.
func (m *BillMutation) SetMissionOrderID(id int64) {
	m.mission_order = &id
}

// ClearMissionOrder clears the "mission_order" edge to the MissionOrder entity.
func (m *BillMutation) ClearMissionOrder() {
	m.clearedmission_order = true
	m.clearedFields[bill.FieldOrderID] = struct{}{}
}

// MissionOrderCleared reports if the "mission_order" edge to the MissionOrder entity was cleared.
func (m *BillMutation) MissionOrderCleared() bool {
	return m.OrderIDCleared() || m.clearedmission_order
}

// MissionOrderID returns the "mission_order" edge ID in the mutation.
func (m *BillMutation) MissionOrderID() (id int64, exists bool) {
	if m.mission_order != nil {
		return *m.mission_order, true
	}
	return
}

// MissionOrderIDs returns the "mission_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionOrderID instead. It exists only for internal usage by the builders.
func (m *BillMutation) MissionOrderIDs() (ids []int64) {
	if id := m.mission_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionOrder resets all changes to the "mission_order" edge.
func (m *BillMutation) ResetMissionOrder() {
	m.mission_order = nil
	m.clearedmission_order = false
}

// ClearInvite clears the "invite" edge to the Invite entity.
func (m *BillMutation) ClearInvite() {
	m.clearedinvite = true
	m.clearedFields[bill.FieldInviteID] = struct{}{}
}

// InviteCleared reports if the "invite" edge to the Invite entity was cleared.
func (m *BillMutation) InviteCleared() bool {
	return m.clearedinvite
}

// InviteIDs returns the "invite" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviteID instead. It exists only for internal usage by the builders.
func (m *BillMutation) InviteIDs() (ids []int64) {
	if id := m.invite; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvite resets all changes to the "invite" edge.
func (m *BillMutation) ResetInvite() {
	m.invite = nil
	m.clearedinvite = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *BillMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[bill.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *BillMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *BillMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *BillMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// Where appends a list predicates to the BillMutation builder.
func (m *BillMutation) Where(ps ...predicate.Bill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_by != nil {
		fields = append(fields, bill.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, bill.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, bill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, bill.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, bill.FieldType)
	}
	if m.transfer_order != nil {
		fields = append(fields, bill.FieldOrderID)
	}
	if m.way != nil {
		fields = append(fields, bill.FieldWay)
	}
	if m.symbol != nil {
		fields = append(fields, bill.FieldSymbolID)
	}
	if m.profit_symbol_id != nil {
		fields = append(fields, bill.FieldProfitSymbolID)
	}
	if m.amount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	if m.target_user != nil {
		fields = append(fields, bill.FieldTargetUserID)
	}
	if m.target_before_amount != nil {
		fields = append(fields, bill.FieldTargetBeforeAmount)
	}
	if m.target_after_amount != nil {
		fields = append(fields, bill.FieldTargetAfterAmount)
	}
	if m.source_user != nil {
		fields = append(fields, bill.FieldSourceUserID)
	}
	if m.source_before_amount != nil {
		fields = append(fields, bill.FieldSourceBeforeAmount)
	}
	if m.source_after_amount != nil {
		fields = append(fields, bill.FieldSourceAfterAmount)
	}
	if m.serial_number != nil {
		fields = append(fields, bill.FieldSerialNumber)
	}
	if m.invite != nil {
		fields = append(fields, bill.FieldInviteID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldCreatedBy:
		return m.CreatedBy()
	case bill.FieldUpdatedBy:
		return m.UpdatedBy()
	case bill.FieldCreatedAt:
		return m.CreatedAt()
	case bill.FieldUpdatedAt:
		return m.UpdatedAt()
	case bill.FieldDeletedAt:
		return m.DeletedAt()
	case bill.FieldType:
		return m.GetType()
	case bill.FieldOrderID:
		return m.OrderID()
	case bill.FieldWay:
		return m.Way()
	case bill.FieldSymbolID:
		return m.SymbolID()
	case bill.FieldProfitSymbolID:
		return m.ProfitSymbolID()
	case bill.FieldAmount:
		return m.Amount()
	case bill.FieldTargetUserID:
		return m.TargetUserID()
	case bill.FieldTargetBeforeAmount:
		return m.TargetBeforeAmount()
	case bill.FieldTargetAfterAmount:
		return m.TargetAfterAmount()
	case bill.FieldSourceUserID:
		return m.SourceUserID()
	case bill.FieldSourceBeforeAmount:
		return m.SourceBeforeAmount()
	case bill.FieldSourceAfterAmount:
		return m.SourceAfterAmount()
	case bill.FieldSerialNumber:
		return m.SerialNumber()
	case bill.FieldInviteID:
		return m.InviteID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case bill.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case bill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case bill.FieldType:
		return m.OldType(ctx)
	case bill.FieldOrderID:
		return m.OldOrderID(ctx)
	case bill.FieldWay:
		return m.OldWay(ctx)
	case bill.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case bill.FieldProfitSymbolID:
		return m.OldProfitSymbolID(ctx)
	case bill.FieldAmount:
		return m.OldAmount(ctx)
	case bill.FieldTargetUserID:
		return m.OldTargetUserID(ctx)
	case bill.FieldTargetBeforeAmount:
		return m.OldTargetBeforeAmount(ctx)
	case bill.FieldTargetAfterAmount:
		return m.OldTargetAfterAmount(ctx)
	case bill.FieldSourceUserID:
		return m.OldSourceUserID(ctx)
	case bill.FieldSourceBeforeAmount:
		return m.OldSourceBeforeAmount(ctx)
	case bill.FieldSourceAfterAmount:
		return m.OldSourceAfterAmount(ctx)
	case bill.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case bill.FieldInviteID:
		return m.OldInviteID(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case bill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case bill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case bill.FieldType:
		v, ok := value.(enums.BillType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case bill.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case bill.FieldWay:
		v, ok := value.(enums.BillWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWay(v)
		return nil
	case bill.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case bill.FieldProfitSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitSymbolID(v)
		return nil
	case bill.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case bill.FieldTargetUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetUserID(v)
		return nil
	case bill.FieldTargetBeforeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetBeforeAmount(v)
		return nil
	case bill.FieldTargetAfterAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetAfterAmount(v)
		return nil
	case bill.FieldSourceUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceUserID(v)
		return nil
	case bill.FieldSourceBeforeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceBeforeAmount(v)
		return nil
	case bill.FieldSourceAfterAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceAfterAmount(v)
		return nil
	case bill.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case bill.FieldInviteID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteID(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, bill.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, bill.FieldUpdatedBy)
	}
	if m.addprofit_symbol_id != nil {
		fields = append(fields, bill.FieldProfitSymbolID)
	}
	if m.addamount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	if m.addtarget_before_amount != nil {
		fields = append(fields, bill.FieldTargetBeforeAmount)
	}
	if m.addtarget_after_amount != nil {
		fields = append(fields, bill.FieldTargetAfterAmount)
	}
	if m.addsource_before_amount != nil {
		fields = append(fields, bill.FieldSourceBeforeAmount)
	}
	if m.addsource_after_amount != nil {
		fields = append(fields, bill.FieldSourceAfterAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldCreatedBy:
		return m.AddedCreatedBy()
	case bill.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case bill.FieldProfitSymbolID:
		return m.AddedProfitSymbolID()
	case bill.FieldAmount:
		return m.AddedAmount()
	case bill.FieldTargetBeforeAmount:
		return m.AddedTargetBeforeAmount()
	case bill.FieldTargetAfterAmount:
		return m.AddedTargetAfterAmount()
	case bill.FieldSourceBeforeAmount:
		return m.AddedSourceBeforeAmount()
	case bill.FieldSourceAfterAmount:
		return m.AddedSourceAfterAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case bill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case bill.FieldProfitSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitSymbolID(v)
		return nil
	case bill.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case bill.FieldTargetBeforeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetBeforeAmount(v)
		return nil
	case bill.FieldTargetAfterAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetAfterAmount(v)
		return nil
	case bill.FieldSourceBeforeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceBeforeAmount(v)
		return nil
	case bill.FieldSourceAfterAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceAfterAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bill.FieldOrderID) {
		fields = append(fields, bill.FieldOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	switch name {
	case bill.FieldOrderID:
		m.ClearOrderID()
		return nil
	}
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case bill.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case bill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case bill.FieldType:
		m.ResetType()
		return nil
	case bill.FieldOrderID:
		m.ResetOrderID()
		return nil
	case bill.FieldWay:
		m.ResetWay()
		return nil
	case bill.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case bill.FieldProfitSymbolID:
		m.ResetProfitSymbolID()
		return nil
	case bill.FieldAmount:
		m.ResetAmount()
		return nil
	case bill.FieldTargetUserID:
		m.ResetTargetUserID()
		return nil
	case bill.FieldTargetBeforeAmount:
		m.ResetTargetBeforeAmount()
		return nil
	case bill.FieldTargetAfterAmount:
		m.ResetTargetAfterAmount()
		return nil
	case bill.FieldSourceUserID:
		m.ResetSourceUserID()
		return nil
	case bill.FieldSourceBeforeAmount:
		m.ResetSourceBeforeAmount()
		return nil
	case bill.FieldSourceAfterAmount:
		m.ResetSourceAfterAmount()
		return nil
	case bill.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case bill.FieldInviteID:
		m.ResetInviteID()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.source_user != nil {
		edges = append(edges, bill.EdgeSourceUser)
	}
	if m.target_user != nil {
		edges = append(edges, bill.EdgeTargetUser)
	}
	if m.transfer_order != nil {
		edges = append(edges, bill.EdgeTransferOrder)
	}
	if m.mission_order != nil {
		edges = append(edges, bill.EdgeMissionOrder)
	}
	if m.invite != nil {
		edges = append(edges, bill.EdgeInvite)
	}
	if m.symbol != nil {
		edges = append(edges, bill.EdgeSymbol)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgeSourceUser:
		if id := m.source_user; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeTargetUser:
		if id := m.target_user; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeTransferOrder:
		if id := m.transfer_order; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeMissionOrder:
		if id := m.mission_order; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeInvite:
		if id := m.invite; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedsource_user {
		edges = append(edges, bill.EdgeSourceUser)
	}
	if m.clearedtarget_user {
		edges = append(edges, bill.EdgeTargetUser)
	}
	if m.clearedtransfer_order {
		edges = append(edges, bill.EdgeTransferOrder)
	}
	if m.clearedmission_order {
		edges = append(edges, bill.EdgeMissionOrder)
	}
	if m.clearedinvite {
		edges = append(edges, bill.EdgeInvite)
	}
	if m.clearedsymbol {
		edges = append(edges, bill.EdgeSymbol)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgeSourceUser:
		return m.clearedsource_user
	case bill.EdgeTargetUser:
		return m.clearedtarget_user
	case bill.EdgeTransferOrder:
		return m.clearedtransfer_order
	case bill.EdgeMissionOrder:
		return m.clearedmission_order
	case bill.EdgeInvite:
		return m.clearedinvite
	case bill.EdgeSymbol:
		return m.clearedsymbol
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgeSourceUser:
		m.ClearSourceUser()
		return nil
	case bill.EdgeTargetUser:
		m.ClearTargetUser()
		return nil
	case bill.EdgeTransferOrder:
		m.ClearTransferOrder()
		return nil
	case bill.EdgeMissionOrder:
		m.ClearMissionOrder()
		return nil
	case bill.EdgeInvite:
		m.ClearInvite()
		return nil
	case bill.EdgeSymbol:
		m.ClearSymbol()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgeSourceUser:
		m.ResetSourceUser()
		return nil
	case bill.EdgeTargetUser:
		m.ResetTargetUser()
		return nil
	case bill.EdgeTransferOrder:
		m.ResetTransferOrder()
		return nil
	case bill.EdgeMissionOrder:
		m.ResetMissionOrder()
		return nil
	case bill.EdgeInvite:
		m.ResetInvite()
		return nil
	case bill.EdgeSymbol:
		m.ResetSymbol()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// CDKInfoMutation represents an operation that mutates the CDKInfo nodes in the graph.
type CDKInfoMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	cdk_number        *string
	_type             *enums.CDKType
	get_cep           *int64
	addget_cep        *int64
	get_time          *int64
	addget_time       *int64
	billing_type      *enums.MissionBillingType
	expired_at        *time.Time
	use_times         *int64
	adduse_times      *int64
	status            *enums.CDKStatus
	used_at           *time.Time
	clearedFields     map[string]struct{}
	issue_user        *int64
	clearedissue_user bool
	use_user          *int64
	cleareduse_user   bool
	done              bool
	oldValue          func(context.Context) (*CDKInfo, error)
	predicates        []predicate.CDKInfo
}

var _ ent.Mutation = (*CDKInfoMutation)(nil)

// cdkinfoOption allows management of the mutation configuration using functional options.
type cdkinfoOption func(*CDKInfoMutation)

// newCDKInfoMutation creates new mutation for the CDKInfo entity.
func newCDKInfoMutation(c config, op Op, opts ...cdkinfoOption) *CDKInfoMutation {
	m := &CDKInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeCDKInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCDKInfoID sets the ID field of the mutation.
func withCDKInfoID(id int64) cdkinfoOption {
	return func(m *CDKInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *CDKInfo
		)
		m.oldValue = func(ctx context.Context) (*CDKInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CDKInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCDKInfo sets the old CDKInfo of the mutation.
func withCDKInfo(node *CDKInfo) cdkinfoOption {
	return func(m *CDKInfoMutation) {
		m.oldValue = func(context.Context) (*CDKInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CDKInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CDKInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CDKInfo entities.
func (m *CDKInfoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CDKInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CDKInfoMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CDKInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CDKInfoMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CDKInfoMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CDKInfoMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CDKInfoMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CDKInfoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CDKInfoMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CDKInfoMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CDKInfoMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CDKInfoMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CDKInfoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CDKInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CDKInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CDKInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CDKInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CDKInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CDKInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CDKInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CDKInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CDKInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetIssueUserID sets the "issue_user_id" field.
func (m *CDKInfoMutation) SetIssueUserID(i int64) {
	m.issue_user = &i
}

// IssueUserID returns the value of the "issue_user_id" field in the mutation.
func (m *CDKInfoMutation) IssueUserID() (r int64, exists bool) {
	v := m.issue_user
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueUserID returns the old "issue_user_id" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldIssueUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueUserID: %w", err)
	}
	return oldValue.IssueUserID, nil
}

// ResetIssueUserID resets all changes to the "issue_user_id" field.
func (m *CDKInfoMutation) ResetIssueUserID() {
	m.issue_user = nil
}

// SetCdkNumber sets the "cdk_number" field.
func (m *CDKInfoMutation) SetCdkNumber(s string) {
	m.cdk_number = &s
}

// CdkNumber returns the value of the "cdk_number" field in the mutation.
func (m *CDKInfoMutation) CdkNumber() (r string, exists bool) {
	v := m.cdk_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCdkNumber returns the old "cdk_number" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldCdkNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdkNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdkNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdkNumber: %w", err)
	}
	return oldValue.CdkNumber, nil
}

// ResetCdkNumber resets all changes to the "cdk_number" field.
func (m *CDKInfoMutation) ResetCdkNumber() {
	m.cdk_number = nil
}

// SetType sets the "type" field.
func (m *CDKInfoMutation) SetType(et enums.CDKType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *CDKInfoMutation) GetType() (r enums.CDKType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldType(ctx context.Context) (v enums.CDKType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CDKInfoMutation) ResetType() {
	m._type = nil
}

// SetGetCep sets the "get_cep" field.
func (m *CDKInfoMutation) SetGetCep(i int64) {
	m.get_cep = &i
	m.addget_cep = nil
}

// GetCep returns the value of the "get_cep" field in the mutation.
func (m *CDKInfoMutation) GetCep() (r int64, exists bool) {
	v := m.get_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGetCep returns the old "get_cep" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldGetCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGetCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGetCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGetCep: %w", err)
	}
	return oldValue.GetCep, nil
}

// AddGetCep adds i to the "get_cep" field.
func (m *CDKInfoMutation) AddGetCep(i int64) {
	if m.addget_cep != nil {
		*m.addget_cep += i
	} else {
		m.addget_cep = &i
	}
}

// AddedGetCep returns the value that was added to the "get_cep" field in this mutation.
func (m *CDKInfoMutation) AddedGetCep() (r int64, exists bool) {
	v := m.addget_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGetCep resets all changes to the "get_cep" field.
func (m *CDKInfoMutation) ResetGetCep() {
	m.get_cep = nil
	m.addget_cep = nil
}

// SetGetTime sets the "get_time" field.
func (m *CDKInfoMutation) SetGetTime(i int64) {
	m.get_time = &i
	m.addget_time = nil
}

// GetTime returns the value of the "get_time" field in the mutation.
func (m *CDKInfoMutation) GetTime() (r int64, exists bool) {
	v := m.get_time
	if v == nil {
		return
	}
	return *v, true
}

// OldGetTime returns the old "get_time" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldGetTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGetTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGetTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGetTime: %w", err)
	}
	return oldValue.GetTime, nil
}

// AddGetTime adds i to the "get_time" field.
func (m *CDKInfoMutation) AddGetTime(i int64) {
	if m.addget_time != nil {
		*m.addget_time += i
	} else {
		m.addget_time = &i
	}
}

// AddedGetTime returns the value that was added to the "get_time" field in this mutation.
func (m *CDKInfoMutation) AddedGetTime() (r int64, exists bool) {
	v := m.addget_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetGetTime resets all changes to the "get_time" field.
func (m *CDKInfoMutation) ResetGetTime() {
	m.get_time = nil
	m.addget_time = nil
}

// SetBillingType sets the "billing_type" field.
func (m *CDKInfoMutation) SetBillingType(ebt enums.MissionBillingType) {
	m.billing_type = &ebt
}

// BillingType returns the value of the "billing_type" field in the mutation.
func (m *CDKInfoMutation) BillingType() (r enums.MissionBillingType, exists bool) {
	v := m.billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingType returns the old "billing_type" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingType: %w", err)
	}
	return oldValue.BillingType, nil
}

// ResetBillingType resets all changes to the "billing_type" field.
func (m *CDKInfoMutation) ResetBillingType() {
	m.billing_type = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *CDKInfoMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *CDKInfoMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *CDKInfoMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[cdkinfo.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *CDKInfoMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[cdkinfo.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *CDKInfoMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, cdkinfo.FieldExpiredAt)
}

// SetUseTimes sets the "use_times" field.
func (m *CDKInfoMutation) SetUseTimes(i int64) {
	m.use_times = &i
	m.adduse_times = nil
}

// UseTimes returns the value of the "use_times" field in the mutation.
func (m *CDKInfoMutation) UseTimes() (r int64, exists bool) {
	v := m.use_times
	if v == nil {
		return
	}
	return *v, true
}

// OldUseTimes returns the old "use_times" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUseTimes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseTimes: %w", err)
	}
	return oldValue.UseTimes, nil
}

// AddUseTimes adds i to the "use_times" field.
func (m *CDKInfoMutation) AddUseTimes(i int64) {
	if m.adduse_times != nil {
		*m.adduse_times += i
	} else {
		m.adduse_times = &i
	}
}

// AddedUseTimes returns the value that was added to the "use_times" field in this mutation.
func (m *CDKInfoMutation) AddedUseTimes() (r int64, exists bool) {
	v := m.adduse_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetUseTimes resets all changes to the "use_times" field.
func (m *CDKInfoMutation) ResetUseTimes() {
	m.use_times = nil
	m.adduse_times = nil
}

// SetStatus sets the "status" field.
func (m *CDKInfoMutation) SetStatus(es enums.CDKStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *CDKInfoMutation) Status() (r enums.CDKStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldStatus(ctx context.Context) (v enums.CDKStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CDKInfoMutation) ResetStatus() {
	m.status = nil
}

// SetUseUserID sets the "use_user_id" field.
func (m *CDKInfoMutation) SetUseUserID(i int64) {
	m.use_user = &i
}

// UseUserID returns the value of the "use_user_id" field in the mutation.
func (m *CDKInfoMutation) UseUserID() (r int64, exists bool) {
	v := m.use_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUseUserID returns the old "use_user_id" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUseUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseUserID: %w", err)
	}
	return oldValue.UseUserID, nil
}

// ResetUseUserID resets all changes to the "use_user_id" field.
func (m *CDKInfoMutation) ResetUseUserID() {
	m.use_user = nil
}

// SetUsedAt sets the "used_at" field.
func (m *CDKInfoMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *CDKInfoMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the CDKInfo entity.
// If the CDKInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CDKInfoMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *CDKInfoMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[cdkinfo.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *CDKInfoMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[cdkinfo.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *CDKInfoMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, cdkinfo.FieldUsedAt)
}

// ClearIssueUser clears the "issue_user" edge to the User entity.
func (m *CDKInfoMutation) ClearIssueUser() {
	m.clearedissue_user = true
	m.clearedFields[cdkinfo.FieldIssueUserID] = struct{}{}
}

// IssueUserCleared reports if the "issue_user" edge to the User entity was cleared.
func (m *CDKInfoMutation) IssueUserCleared() bool {
	return m.clearedissue_user
}

// IssueUserIDs returns the "issue_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssueUserID instead. It exists only for internal usage by the builders.
func (m *CDKInfoMutation) IssueUserIDs() (ids []int64) {
	if id := m.issue_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssueUser resets all changes to the "issue_user" edge.
func (m *CDKInfoMutation) ResetIssueUser() {
	m.issue_user = nil
	m.clearedissue_user = false
}

// ClearUseUser clears the "use_user" edge to the User entity.
func (m *CDKInfoMutation) ClearUseUser() {
	m.cleareduse_user = true
	m.clearedFields[cdkinfo.FieldUseUserID] = struct{}{}
}

// UseUserCleared reports if the "use_user" edge to the User entity was cleared.
func (m *CDKInfoMutation) UseUserCleared() bool {
	return m.cleareduse_user
}

// UseUserIDs returns the "use_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UseUserID instead. It exists only for internal usage by the builders.
func (m *CDKInfoMutation) UseUserIDs() (ids []int64) {
	if id := m.use_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseUser resets all changes to the "use_user" edge.
func (m *CDKInfoMutation) ResetUseUser() {
	m.use_user = nil
	m.cleareduse_user = false
}

// Where appends a list predicates to the CDKInfoMutation builder.
func (m *CDKInfoMutation) Where(ps ...predicate.CDKInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CDKInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CDKInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CDKInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CDKInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CDKInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CDKInfo).
func (m *CDKInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CDKInfoMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, cdkinfo.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, cdkinfo.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, cdkinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cdkinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cdkinfo.FieldDeletedAt)
	}
	if m.issue_user != nil {
		fields = append(fields, cdkinfo.FieldIssueUserID)
	}
	if m.cdk_number != nil {
		fields = append(fields, cdkinfo.FieldCdkNumber)
	}
	if m._type != nil {
		fields = append(fields, cdkinfo.FieldType)
	}
	if m.get_cep != nil {
		fields = append(fields, cdkinfo.FieldGetCep)
	}
	if m.get_time != nil {
		fields = append(fields, cdkinfo.FieldGetTime)
	}
	if m.billing_type != nil {
		fields = append(fields, cdkinfo.FieldBillingType)
	}
	if m.expired_at != nil {
		fields = append(fields, cdkinfo.FieldExpiredAt)
	}
	if m.use_times != nil {
		fields = append(fields, cdkinfo.FieldUseTimes)
	}
	if m.status != nil {
		fields = append(fields, cdkinfo.FieldStatus)
	}
	if m.use_user != nil {
		fields = append(fields, cdkinfo.FieldUseUserID)
	}
	if m.used_at != nil {
		fields = append(fields, cdkinfo.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CDKInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cdkinfo.FieldCreatedBy:
		return m.CreatedBy()
	case cdkinfo.FieldUpdatedBy:
		return m.UpdatedBy()
	case cdkinfo.FieldCreatedAt:
		return m.CreatedAt()
	case cdkinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case cdkinfo.FieldDeletedAt:
		return m.DeletedAt()
	case cdkinfo.FieldIssueUserID:
		return m.IssueUserID()
	case cdkinfo.FieldCdkNumber:
		return m.CdkNumber()
	case cdkinfo.FieldType:
		return m.GetType()
	case cdkinfo.FieldGetCep:
		return m.GetCep()
	case cdkinfo.FieldGetTime:
		return m.GetTime()
	case cdkinfo.FieldBillingType:
		return m.BillingType()
	case cdkinfo.FieldExpiredAt:
		return m.ExpiredAt()
	case cdkinfo.FieldUseTimes:
		return m.UseTimes()
	case cdkinfo.FieldStatus:
		return m.Status()
	case cdkinfo.FieldUseUserID:
		return m.UseUserID()
	case cdkinfo.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CDKInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cdkinfo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case cdkinfo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case cdkinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cdkinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cdkinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cdkinfo.FieldIssueUserID:
		return m.OldIssueUserID(ctx)
	case cdkinfo.FieldCdkNumber:
		return m.OldCdkNumber(ctx)
	case cdkinfo.FieldType:
		return m.OldType(ctx)
	case cdkinfo.FieldGetCep:
		return m.OldGetCep(ctx)
	case cdkinfo.FieldGetTime:
		return m.OldGetTime(ctx)
	case cdkinfo.FieldBillingType:
		return m.OldBillingType(ctx)
	case cdkinfo.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case cdkinfo.FieldUseTimes:
		return m.OldUseTimes(ctx)
	case cdkinfo.FieldStatus:
		return m.OldStatus(ctx)
	case cdkinfo.FieldUseUserID:
		return m.OldUseUserID(ctx)
	case cdkinfo.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CDKInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CDKInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cdkinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case cdkinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case cdkinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cdkinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cdkinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cdkinfo.FieldIssueUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueUserID(v)
		return nil
	case cdkinfo.FieldCdkNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdkNumber(v)
		return nil
	case cdkinfo.FieldType:
		v, ok := value.(enums.CDKType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case cdkinfo.FieldGetCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGetCep(v)
		return nil
	case cdkinfo.FieldGetTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGetTime(v)
		return nil
	case cdkinfo.FieldBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingType(v)
		return nil
	case cdkinfo.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case cdkinfo.FieldUseTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseTimes(v)
		return nil
	case cdkinfo.FieldStatus:
		v, ok := value.(enums.CDKStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cdkinfo.FieldUseUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseUserID(v)
		return nil
	case cdkinfo.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CDKInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CDKInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, cdkinfo.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, cdkinfo.FieldUpdatedBy)
	}
	if m.addget_cep != nil {
		fields = append(fields, cdkinfo.FieldGetCep)
	}
	if m.addget_time != nil {
		fields = append(fields, cdkinfo.FieldGetTime)
	}
	if m.adduse_times != nil {
		fields = append(fields, cdkinfo.FieldUseTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CDKInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cdkinfo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case cdkinfo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case cdkinfo.FieldGetCep:
		return m.AddedGetCep()
	case cdkinfo.FieldGetTime:
		return m.AddedGetTime()
	case cdkinfo.FieldUseTimes:
		return m.AddedUseTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CDKInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cdkinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case cdkinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case cdkinfo.FieldGetCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGetCep(v)
		return nil
	case cdkinfo.FieldGetTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGetTime(v)
		return nil
	case cdkinfo.FieldUseTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseTimes(v)
		return nil
	}
	return fmt.Errorf("unknown CDKInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CDKInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cdkinfo.FieldExpiredAt) {
		fields = append(fields, cdkinfo.FieldExpiredAt)
	}
	if m.FieldCleared(cdkinfo.FieldUsedAt) {
		fields = append(fields, cdkinfo.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CDKInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CDKInfoMutation) ClearField(name string) error {
	switch name {
	case cdkinfo.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	case cdkinfo.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown CDKInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CDKInfoMutation) ResetField(name string) error {
	switch name {
	case cdkinfo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case cdkinfo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case cdkinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cdkinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cdkinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cdkinfo.FieldIssueUserID:
		m.ResetIssueUserID()
		return nil
	case cdkinfo.FieldCdkNumber:
		m.ResetCdkNumber()
		return nil
	case cdkinfo.FieldType:
		m.ResetType()
		return nil
	case cdkinfo.FieldGetCep:
		m.ResetGetCep()
		return nil
	case cdkinfo.FieldGetTime:
		m.ResetGetTime()
		return nil
	case cdkinfo.FieldBillingType:
		m.ResetBillingType()
		return nil
	case cdkinfo.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case cdkinfo.FieldUseTimes:
		m.ResetUseTimes()
		return nil
	case cdkinfo.FieldStatus:
		m.ResetStatus()
		return nil
	case cdkinfo.FieldUseUserID:
		m.ResetUseUserID()
		return nil
	case cdkinfo.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown CDKInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CDKInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.issue_user != nil {
		edges = append(edges, cdkinfo.EdgeIssueUser)
	}
	if m.use_user != nil {
		edges = append(edges, cdkinfo.EdgeUseUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CDKInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cdkinfo.EdgeIssueUser:
		if id := m.issue_user; id != nil {
			return []ent.Value{*id}
		}
	case cdkinfo.EdgeUseUser:
		if id := m.use_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CDKInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CDKInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CDKInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedissue_user {
		edges = append(edges, cdkinfo.EdgeIssueUser)
	}
	if m.cleareduse_user {
		edges = append(edges, cdkinfo.EdgeUseUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CDKInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case cdkinfo.EdgeIssueUser:
		return m.clearedissue_user
	case cdkinfo.EdgeUseUser:
		return m.cleareduse_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CDKInfoMutation) ClearEdge(name string) error {
	switch name {
	case cdkinfo.EdgeIssueUser:
		m.ClearIssueUser()
		return nil
	case cdkinfo.EdgeUseUser:
		m.ClearUseUser()
		return nil
	}
	return fmt.Errorf("unknown CDKInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CDKInfoMutation) ResetEdge(name string) error {
	switch name {
	case cdkinfo.EdgeIssueUser:
		m.ResetIssueUser()
		return nil
	case cdkinfo.EdgeUseUser:
		m.ResetUseUser()
		return nil
	}
	return fmt.Errorf("unknown CDKInfo edge %s", name)
}

// CampaignMutation represents an operation that mutates the Campaign nodes in the graph.
type CampaignMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_by             *int64
	addcreated_by          *int64
	updated_by             *int64
	addupdated_by          *int64
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	name                   *string
	_type                  *string
	started_at             *time.Time
	ended_at               *time.Time
	status                 *int
	addstatus              *int
	invite_id              *string
	clearedFields          map[string]struct{}
	invites                map[int64]struct{}
	removedinvites         map[int64]struct{}
	clearedinvites         bool
	campaign_orders        map[int64]struct{}
	removedcampaign_orders map[int64]struct{}
	clearedcampaign_orders bool
	done                   bool
	oldValue               func(context.Context) (*Campaign, error)
	predicates             []predicate.Campaign
}

var _ ent.Mutation = (*CampaignMutation)(nil)

// campaignOption allows management of the mutation configuration using functional options.
type campaignOption func(*CampaignMutation)

// newCampaignMutation creates new mutation for the Campaign entity.
func newCampaignMutation(c config, op Op, opts ...campaignOption) *CampaignMutation {
	m := &CampaignMutation{
		config:        c,
		op:            op,
		typ:           TypeCampaign,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCampaignID sets the ID field of the mutation.
func withCampaignID(id int64) campaignOption {
	return func(m *CampaignMutation) {
		var (
			err   error
			once  sync.Once
			value *Campaign
		)
		m.oldValue = func(ctx context.Context) (*Campaign, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Campaign.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCampaign sets the old Campaign of the mutation.
func withCampaign(node *Campaign) campaignOption {
	return func(m *CampaignMutation) {
		m.oldValue = func(context.Context) (*Campaign, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CampaignMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CampaignMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Campaign entities.
func (m *CampaignMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CampaignMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CampaignMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Campaign.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CampaignMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CampaignMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CampaignMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CampaignMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CampaignMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CampaignMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CampaignMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CampaignMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CampaignMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CampaignMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CampaignMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CampaignMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CampaignMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CampaignMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CampaignMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CampaignMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CampaignMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CampaignMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CampaignMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *CampaignMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CampaignMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CampaignMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *CampaignMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CampaignMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CampaignMutation) ResetType() {
	m._type = nil
}

// SetStartedAt sets the "started_at" field.
func (m *CampaignMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *CampaignMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *CampaignMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *CampaignMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *CampaignMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *CampaignMutation) ResetEndedAt() {
	m.ended_at = nil
}

// SetStatus sets the "status" field.
func (m *CampaignMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CampaignMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CampaignMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CampaignMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CampaignMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetInviteID sets the "invite_id" field.
func (m *CampaignMutation) SetInviteID(s string) {
	m.invite_id = &s
}

// InviteID returns the value of the "invite_id" field in the mutation.
func (m *CampaignMutation) InviteID() (r string, exists bool) {
	v := m.invite_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteID returns the old "invite_id" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldInviteID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteID: %w", err)
	}
	return oldValue.InviteID, nil
}

// ResetInviteID resets all changes to the "invite_id" field.
func (m *CampaignMutation) ResetInviteID() {
	m.invite_id = nil
}

// AddInviteIDs adds the "invites" edge to the Invite entity by ids.
func (m *CampaignMutation) AddInviteIDs(ids ...int64) {
	if m.invites == nil {
		m.invites = make(map[int64]struct{})
	}
	for i := range ids {
		m.invites[ids[i]] = struct{}{}
	}
}

// ClearInvites clears the "invites" edge to the Invite entity.
func (m *CampaignMutation) ClearInvites() {
	m.clearedinvites = true
}

// InvitesCleared reports if the "invites" edge to the Invite entity was cleared.
func (m *CampaignMutation) InvitesCleared() bool {
	return m.clearedinvites
}

// RemoveInviteIDs removes the "invites" edge to the Invite entity by IDs.
func (m *CampaignMutation) RemoveInviteIDs(ids ...int64) {
	if m.removedinvites == nil {
		m.removedinvites = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invites, ids[i])
		m.removedinvites[ids[i]] = struct{}{}
	}
}

// RemovedInvites returns the removed IDs of the "invites" edge to the Invite entity.
func (m *CampaignMutation) RemovedInvitesIDs() (ids []int64) {
	for id := range m.removedinvites {
		ids = append(ids, id)
	}
	return
}

// InvitesIDs returns the "invites" edge IDs in the mutation.
func (m *CampaignMutation) InvitesIDs() (ids []int64) {
	for id := range m.invites {
		ids = append(ids, id)
	}
	return
}

// ResetInvites resets all changes to the "invites" edge.
func (m *CampaignMutation) ResetInvites() {
	m.invites = nil
	m.clearedinvites = false
	m.removedinvites = nil
}

// AddCampaignOrderIDs adds the "campaign_orders" edge to the CampaignOrder entity by ids.
func (m *CampaignMutation) AddCampaignOrderIDs(ids ...int64) {
	if m.campaign_orders == nil {
		m.campaign_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.campaign_orders[ids[i]] = struct{}{}
	}
}

// ClearCampaignOrders clears the "campaign_orders" edge to the CampaignOrder entity.
func (m *CampaignMutation) ClearCampaignOrders() {
	m.clearedcampaign_orders = true
}

// CampaignOrdersCleared reports if the "campaign_orders" edge to the CampaignOrder entity was cleared.
func (m *CampaignMutation) CampaignOrdersCleared() bool {
	return m.clearedcampaign_orders
}

// RemoveCampaignOrderIDs removes the "campaign_orders" edge to the CampaignOrder entity by IDs.
func (m *CampaignMutation) RemoveCampaignOrderIDs(ids ...int64) {
	if m.removedcampaign_orders == nil {
		m.removedcampaign_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.campaign_orders, ids[i])
		m.removedcampaign_orders[ids[i]] = struct{}{}
	}
}

// RemovedCampaignOrders returns the removed IDs of the "campaign_orders" edge to the CampaignOrder entity.
func (m *CampaignMutation) RemovedCampaignOrdersIDs() (ids []int64) {
	for id := range m.removedcampaign_orders {
		ids = append(ids, id)
	}
	return
}

// CampaignOrdersIDs returns the "campaign_orders" edge IDs in the mutation.
func (m *CampaignMutation) CampaignOrdersIDs() (ids []int64) {
	for id := range m.campaign_orders {
		ids = append(ids, id)
	}
	return
}

// ResetCampaignOrders resets all changes to the "campaign_orders" edge.
func (m *CampaignMutation) ResetCampaignOrders() {
	m.campaign_orders = nil
	m.clearedcampaign_orders = false
	m.removedcampaign_orders = nil
}

// Where appends a list predicates to the CampaignMutation builder.
func (m *CampaignMutation) Where(ps ...predicate.Campaign) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CampaignMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CampaignMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Campaign, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CampaignMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CampaignMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Campaign).
func (m *CampaignMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CampaignMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, campaign.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, campaign.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, campaign.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, campaign.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, campaign.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, campaign.FieldName)
	}
	if m._type != nil {
		fields = append(fields, campaign.FieldType)
	}
	if m.started_at != nil {
		fields = append(fields, campaign.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, campaign.FieldEndedAt)
	}
	if m.status != nil {
		fields = append(fields, campaign.FieldStatus)
	}
	if m.invite_id != nil {
		fields = append(fields, campaign.FieldInviteID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CampaignMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case campaign.FieldCreatedBy:
		return m.CreatedBy()
	case campaign.FieldUpdatedBy:
		return m.UpdatedBy()
	case campaign.FieldCreatedAt:
		return m.CreatedAt()
	case campaign.FieldUpdatedAt:
		return m.UpdatedAt()
	case campaign.FieldDeletedAt:
		return m.DeletedAt()
	case campaign.FieldName:
		return m.Name()
	case campaign.FieldType:
		return m.GetType()
	case campaign.FieldStartedAt:
		return m.StartedAt()
	case campaign.FieldEndedAt:
		return m.EndedAt()
	case campaign.FieldStatus:
		return m.Status()
	case campaign.FieldInviteID:
		return m.InviteID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CampaignMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case campaign.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case campaign.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case campaign.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case campaign.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case campaign.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case campaign.FieldName:
		return m.OldName(ctx)
	case campaign.FieldType:
		return m.OldType(ctx)
	case campaign.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case campaign.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case campaign.FieldStatus:
		return m.OldStatus(ctx)
	case campaign.FieldInviteID:
		return m.OldInviteID(ctx)
	}
	return nil, fmt.Errorf("unknown Campaign field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignMutation) SetField(name string, value ent.Value) error {
	switch name {
	case campaign.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case campaign.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case campaign.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case campaign.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case campaign.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case campaign.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case campaign.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case campaign.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case campaign.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case campaign.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case campaign.FieldInviteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteID(v)
		return nil
	}
	return fmt.Errorf("unknown Campaign field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CampaignMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, campaign.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, campaign.FieldUpdatedBy)
	}
	if m.addstatus != nil {
		fields = append(fields, campaign.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CampaignMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case campaign.FieldCreatedBy:
		return m.AddedCreatedBy()
	case campaign.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case campaign.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignMutation) AddField(name string, value ent.Value) error {
	switch name {
	case campaign.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case campaign.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case campaign.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Campaign numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CampaignMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CampaignMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CampaignMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Campaign nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CampaignMutation) ResetField(name string) error {
	switch name {
	case campaign.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case campaign.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case campaign.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case campaign.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case campaign.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case campaign.FieldName:
		m.ResetName()
		return nil
	case campaign.FieldType:
		m.ResetType()
		return nil
	case campaign.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case campaign.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case campaign.FieldStatus:
		m.ResetStatus()
		return nil
	case campaign.FieldInviteID:
		m.ResetInviteID()
		return nil
	}
	return fmt.Errorf("unknown Campaign field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CampaignMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invites != nil {
		edges = append(edges, campaign.EdgeInvites)
	}
	if m.campaign_orders != nil {
		edges = append(edges, campaign.EdgeCampaignOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CampaignMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case campaign.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.invites))
		for id := range m.invites {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeCampaignOrders:
		ids := make([]ent.Value, 0, len(m.campaign_orders))
		for id := range m.campaign_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CampaignMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinvites != nil {
		edges = append(edges, campaign.EdgeInvites)
	}
	if m.removedcampaign_orders != nil {
		edges = append(edges, campaign.EdgeCampaignOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CampaignMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case campaign.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.removedinvites))
		for id := range m.removedinvites {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeCampaignOrders:
		ids := make([]ent.Value, 0, len(m.removedcampaign_orders))
		for id := range m.removedcampaign_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CampaignMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvites {
		edges = append(edges, campaign.EdgeInvites)
	}
	if m.clearedcampaign_orders {
		edges = append(edges, campaign.EdgeCampaignOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CampaignMutation) EdgeCleared(name string) bool {
	switch name {
	case campaign.EdgeInvites:
		return m.clearedinvites
	case campaign.EdgeCampaignOrders:
		return m.clearedcampaign_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CampaignMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Campaign unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CampaignMutation) ResetEdge(name string) error {
	switch name {
	case campaign.EdgeInvites:
		m.ResetInvites()
		return nil
	case campaign.EdgeCampaignOrders:
		m.ResetCampaignOrders()
		return nil
	}
	return fmt.Errorf("unknown Campaign edge %s", name)
}

// CampaignOrderMutation represents an operation that mutates the CampaignOrder nodes in the graph.
type CampaignOrderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	campaign              *int64
	clearedcampaign       bool
	cost_bills            map[int64]struct{}
	removedcost_bills     map[int64]struct{}
	clearedcost_bills     bool
	recharge_order        *int64
	clearedrecharge_order bool
	done                  bool
	oldValue              func(context.Context) (*CampaignOrder, error)
	predicates            []predicate.CampaignOrder
}

var _ ent.Mutation = (*CampaignOrderMutation)(nil)

// campaignorderOption allows management of the mutation configuration using functional options.
type campaignorderOption func(*CampaignOrderMutation)

// newCampaignOrderMutation creates new mutation for the CampaignOrder entity.
func newCampaignOrderMutation(c config, op Op, opts ...campaignorderOption) *CampaignOrderMutation {
	m := &CampaignOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeCampaignOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCampaignOrderID sets the ID field of the mutation.
func withCampaignOrderID(id int64) campaignorderOption {
	return func(m *CampaignOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *CampaignOrder
		)
		m.oldValue = func(ctx context.Context) (*CampaignOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CampaignOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCampaignOrder sets the old CampaignOrder of the mutation.
func withCampaignOrder(node *CampaignOrder) campaignorderOption {
	return func(m *CampaignOrderMutation) {
		m.oldValue = func(context.Context) (*CampaignOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CampaignOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CampaignOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CampaignOrder entities.
func (m *CampaignOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CampaignOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CampaignOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CampaignOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CampaignOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CampaignOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CampaignOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CampaignOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CampaignOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CampaignOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CampaignOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CampaignOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CampaignOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CampaignOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CampaignOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CampaignOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CampaignOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CampaignOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CampaignOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CampaignOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CampaignOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CampaignOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CampaignOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CampaignOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CampaignOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CampaignOrderMutation) ResetUserID() {
	m.user = nil
}

// SetCampaignID sets the "campaign_id" field.
func (m *CampaignOrderMutation) SetCampaignID(i int64) {
	m.campaign = &i
}

// CampaignID returns the value of the "campaign_id" field in the mutation.
func (m *CampaignOrderMutation) CampaignID() (r int64, exists bool) {
	v := m.campaign
	if v == nil {
		return
	}
	return *v, true
}

// OldCampaignID returns the old "campaign_id" field's value of the CampaignOrder entity.
// If the CampaignOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignOrderMutation) OldCampaignID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCampaignID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCampaignID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCampaignID: %w", err)
	}
	return oldValue.CampaignID, nil
}

// ResetCampaignID resets all changes to the "campaign_id" field.
func (m *CampaignOrderMutation) ResetCampaignID() {
	m.campaign = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CampaignOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[campaignorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CampaignOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CampaignOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CampaignOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCampaign clears the "campaign" edge to the Campaign entity.
func (m *CampaignOrderMutation) ClearCampaign() {
	m.clearedcampaign = true
	m.clearedFields[campaignorder.FieldCampaignID] = struct{}{}
}

// CampaignCleared reports if the "campaign" edge to the Campaign entity was cleared.
func (m *CampaignOrderMutation) CampaignCleared() bool {
	return m.clearedcampaign
}

// CampaignIDs returns the "campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignID instead. It exists only for internal usage by the builders.
func (m *CampaignOrderMutation) CampaignIDs() (ids []int64) {
	if id := m.campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaign resets all changes to the "campaign" edge.
func (m *CampaignOrderMutation) ResetCampaign() {
	m.campaign = nil
	m.clearedcampaign = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *CampaignOrderMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *CampaignOrderMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *CampaignOrderMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *CampaignOrderMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *CampaignOrderMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *CampaignOrderMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *CampaignOrderMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// SetRechargeOrderID sets the "recharge_order" edge to the RechargeOrder entity by id.
func (m *CampaignOrderMutation) SetRechargeOrderID(id int64) {
	m.recharge_order = &id
}

// ClearRechargeOrder clears the "recharge_order" edge to the RechargeOrder entity.
func (m *CampaignOrderMutation) ClearRechargeOrder() {
	m.clearedrecharge_order = true
}

// RechargeOrderCleared reports if the "recharge_order" edge to the RechargeOrder entity was cleared.
func (m *CampaignOrderMutation) RechargeOrderCleared() bool {
	return m.clearedrecharge_order
}

// RechargeOrderID returns the "recharge_order" edge ID in the mutation.
func (m *CampaignOrderMutation) RechargeOrderID() (id int64, exists bool) {
	if m.recharge_order != nil {
		return *m.recharge_order, true
	}
	return
}

// RechargeOrderIDs returns the "recharge_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RechargeOrderID instead. It exists only for internal usage by the builders.
func (m *CampaignOrderMutation) RechargeOrderIDs() (ids []int64) {
	if id := m.recharge_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRechargeOrder resets all changes to the "recharge_order" edge.
func (m *CampaignOrderMutation) ResetRechargeOrder() {
	m.recharge_order = nil
	m.clearedrecharge_order = false
}

// Where appends a list predicates to the CampaignOrderMutation builder.
func (m *CampaignOrderMutation) Where(ps ...predicate.CampaignOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CampaignOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CampaignOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CampaignOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CampaignOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CampaignOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CampaignOrder).
func (m *CampaignOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CampaignOrderMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, campaignorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, campaignorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, campaignorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, campaignorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, campaignorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, campaignorder.FieldUserID)
	}
	if m.campaign != nil {
		fields = append(fields, campaignorder.FieldCampaignID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CampaignOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case campaignorder.FieldCreatedBy:
		return m.CreatedBy()
	case campaignorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case campaignorder.FieldCreatedAt:
		return m.CreatedAt()
	case campaignorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case campaignorder.FieldDeletedAt:
		return m.DeletedAt()
	case campaignorder.FieldUserID:
		return m.UserID()
	case campaignorder.FieldCampaignID:
		return m.CampaignID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CampaignOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case campaignorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case campaignorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case campaignorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case campaignorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case campaignorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case campaignorder.FieldUserID:
		return m.OldUserID(ctx)
	case campaignorder.FieldCampaignID:
		return m.OldCampaignID(ctx)
	}
	return nil, fmt.Errorf("unknown CampaignOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case campaignorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case campaignorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case campaignorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case campaignorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case campaignorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case campaignorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case campaignorder.FieldCampaignID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCampaignID(v)
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CampaignOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, campaignorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, campaignorder.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CampaignOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case campaignorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case campaignorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case campaignorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case campaignorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CampaignOrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CampaignOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CampaignOrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CampaignOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CampaignOrderMutation) ResetField(name string) error {
	switch name {
	case campaignorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case campaignorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case campaignorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case campaignorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case campaignorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case campaignorder.FieldUserID:
		m.ResetUserID()
		return nil
	case campaignorder.FieldCampaignID:
		m.ResetCampaignID()
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CampaignOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, campaignorder.EdgeUser)
	}
	if m.campaign != nil {
		edges = append(edges, campaignorder.EdgeCampaign)
	}
	if m.cost_bills != nil {
		edges = append(edges, campaignorder.EdgeCostBills)
	}
	if m.recharge_order != nil {
		edges = append(edges, campaignorder.EdgeRechargeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CampaignOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case campaignorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case campaignorder.EdgeCampaign:
		if id := m.campaign; id != nil {
			return []ent.Value{*id}
		}
	case campaignorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case campaignorder.EdgeRechargeOrder:
		if id := m.recharge_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CampaignOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcost_bills != nil {
		edges = append(edges, campaignorder.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CampaignOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case campaignorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CampaignOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, campaignorder.EdgeUser)
	}
	if m.clearedcampaign {
		edges = append(edges, campaignorder.EdgeCampaign)
	}
	if m.clearedcost_bills {
		edges = append(edges, campaignorder.EdgeCostBills)
	}
	if m.clearedrecharge_order {
		edges = append(edges, campaignorder.EdgeRechargeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CampaignOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case campaignorder.EdgeUser:
		return m.cleareduser
	case campaignorder.EdgeCampaign:
		return m.clearedcampaign
	case campaignorder.EdgeCostBills:
		return m.clearedcost_bills
	case campaignorder.EdgeRechargeOrder:
		return m.clearedrecharge_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CampaignOrderMutation) ClearEdge(name string) error {
	switch name {
	case campaignorder.EdgeUser:
		m.ClearUser()
		return nil
	case campaignorder.EdgeCampaign:
		m.ClearCampaign()
		return nil
	case campaignorder.EdgeRechargeOrder:
		m.ClearRechargeOrder()
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CampaignOrderMutation) ResetEdge(name string) error {
	switch name {
	case campaignorder.EdgeUser:
		m.ResetUser()
		return nil
	case campaignorder.EdgeCampaign:
		m.ResetCampaign()
		return nil
	case campaignorder.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case campaignorder.EdgeRechargeOrder:
		m.ResetRechargeOrder()
		return nil
	}
	return fmt.Errorf("unknown CampaignOrder edge %s", name)
}

// CollectMutation represents an operation that mutates the Collect nodes in the graph.
type CollectMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	url           *string
	jpg_name      *int64
	addjpg_name   *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Collect, error)
	predicates    []predicate.Collect
}

var _ ent.Mutation = (*CollectMutation)(nil)

// collectOption allows management of the mutation configuration using functional options.
type collectOption func(*CollectMutation)

// newCollectMutation creates new mutation for the Collect entity.
func newCollectMutation(c config, op Op, opts ...collectOption) *CollectMutation {
	m := &CollectMutation{
		config:        c,
		op:            op,
		typ:           TypeCollect,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollectID sets the ID field of the mutation.
func withCollectID(id int64) collectOption {
	return func(m *CollectMutation) {
		var (
			err   error
			once  sync.Once
			value *Collect
		)
		m.oldValue = func(ctx context.Context) (*Collect, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collect.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollect sets the old Collect of the mutation.
func withCollect(node *Collect) collectOption {
	return func(m *CollectMutation) {
		m.oldValue = func(context.Context) (*Collect, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Collect entities.
func (m *CollectMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollectMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollectMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Collect.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CollectMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CollectMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CollectMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CollectMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CollectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CollectMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CollectMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CollectMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CollectMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CollectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CollectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CollectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CollectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CollectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CollectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CollectMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetURL sets the "url" field.
func (m *CollectMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CollectMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *CollectMutation) ResetURL() {
	m.url = nil
}

// SetUserID sets the "user_id" field.
func (m *CollectMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CollectMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CollectMutation) ResetUserID() {
	m.user = nil
}

// SetJpgName sets the "jpg_name" field.
func (m *CollectMutation) SetJpgName(i int64) {
	m.jpg_name = &i
	m.addjpg_name = nil
}

// JpgName returns the value of the "jpg_name" field in the mutation.
func (m *CollectMutation) JpgName() (r int64, exists bool) {
	v := m.jpg_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJpgName returns the old "jpg_name" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldJpgName(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJpgName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJpgName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJpgName: %w", err)
	}
	return oldValue.JpgName, nil
}

// AddJpgName adds i to the "jpg_name" field.
func (m *CollectMutation) AddJpgName(i int64) {
	if m.addjpg_name != nil {
		*m.addjpg_name += i
	} else {
		m.addjpg_name = &i
	}
}

// AddedJpgName returns the value that was added to the "jpg_name" field in this mutation.
func (m *CollectMutation) AddedJpgName() (r int64, exists bool) {
	v := m.addjpg_name
	if v == nil {
		return
	}
	return *v, true
}

// ResetJpgName resets all changes to the "jpg_name" field.
func (m *CollectMutation) ResetJpgName() {
	m.jpg_name = nil
	m.addjpg_name = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CollectMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[collect.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CollectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CollectMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CollectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CollectMutation builder.
func (m *CollectMutation) Where(ps ...predicate.Collect) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Collect, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Collect).
func (m *CollectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, collect.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, collect.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, collect.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, collect.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, collect.FieldDeletedAt)
	}
	if m.url != nil {
		fields = append(fields, collect.FieldURL)
	}
	if m.user != nil {
		fields = append(fields, collect.FieldUserID)
	}
	if m.jpg_name != nil {
		fields = append(fields, collect.FieldJpgName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collect.FieldCreatedBy:
		return m.CreatedBy()
	case collect.FieldUpdatedBy:
		return m.UpdatedBy()
	case collect.FieldCreatedAt:
		return m.CreatedAt()
	case collect.FieldUpdatedAt:
		return m.UpdatedAt()
	case collect.FieldDeletedAt:
		return m.DeletedAt()
	case collect.FieldURL:
		return m.URL()
	case collect.FieldUserID:
		return m.UserID()
	case collect.FieldJpgName:
		return m.JpgName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collect.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case collect.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case collect.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case collect.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case collect.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case collect.FieldURL:
		return m.OldURL(ctx)
	case collect.FieldUserID:
		return m.OldUserID(ctx)
	case collect.FieldJpgName:
		return m.OldJpgName(ctx)
	}
	return nil, fmt.Errorf("unknown Collect field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collect.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case collect.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case collect.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collect.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case collect.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case collect.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case collect.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case collect.FieldJpgName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJpgName(v)
		return nil
	}
	return fmt.Errorf("unknown Collect field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, collect.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, collect.FieldUpdatedBy)
	}
	if m.addjpg_name != nil {
		fields = append(fields, collect.FieldJpgName)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case collect.FieldCreatedBy:
		return m.AddedCreatedBy()
	case collect.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case collect.FieldJpgName:
		return m.AddedJpgName()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case collect.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case collect.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case collect.FieldJpgName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJpgName(v)
		return nil
	}
	return fmt.Errorf("unknown Collect numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Collect nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectMutation) ResetField(name string) error {
	switch name {
	case collect.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case collect.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case collect.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collect.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case collect.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case collect.FieldURL:
		m.ResetURL()
		return nil
	case collect.FieldUserID:
		m.ResetUserID()
		return nil
	case collect.FieldJpgName:
		m.ResetJpgName()
		return nil
	}
	return fmt.Errorf("unknown Collect field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, collect.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collect.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, collect.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectMutation) EdgeCleared(name string) bool {
	switch name {
	case collect.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectMutation) ClearEdge(name string) error {
	switch name {
	case collect.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Collect unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectMutation) ResetEdge(name string) error {
	switch name {
	case collect.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Collect edge %s", name)
}

// CostAccountMutation represents an operation that mutates the CostAccount nodes in the graph.
type CostAccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_by          *int64
	addcreated_by       *int64
	updated_by          *int64
	addupdated_by       *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	total_cep           *int64
	addtotal_cep        *int64
	sum_total_cep       *int64
	addsum_total_cep    *int64
	frozen_total_cep    *int64
	addfrozen_total_cep *int64
	pure_cep            *int64
	addpure_cep         *int64
	sum_pure_cep        *int64
	addsum_pure_cep     *int64
	frozen_pure_cep     *int64
	addfrozen_pure_cep  *int64
	gift_cep            *int64
	addgift_cep         *int64
	sum_gift_cep        *int64
	addsum_gift_cep     *int64
	frozen_gift_cep     *int64
	addfrozen_gift_cep  *int64
	clearedFields       map[string]struct{}
	user                *int64
	cleareduser         bool
	cost_bills          map[int64]struct{}
	removedcost_bills   map[int64]struct{}
	clearedcost_bills   bool
	done                bool
	oldValue            func(context.Context) (*CostAccount, error)
	predicates          []predicate.CostAccount
}

var _ ent.Mutation = (*CostAccountMutation)(nil)

// costaccountOption allows management of the mutation configuration using functional options.
type costaccountOption func(*CostAccountMutation)

// newCostAccountMutation creates new mutation for the CostAccount entity.
func newCostAccountMutation(c config, op Op, opts ...costaccountOption) *CostAccountMutation {
	m := &CostAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeCostAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostAccountID sets the ID field of the mutation.
func withCostAccountID(id int64) costaccountOption {
	return func(m *CostAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *CostAccount
		)
		m.oldValue = func(ctx context.Context) (*CostAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CostAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCostAccount sets the old CostAccount of the mutation.
func withCostAccount(node *CostAccount) costaccountOption {
	return func(m *CostAccountMutation) {
		m.oldValue = func(context.Context) (*CostAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CostAccount entities.
func (m *CostAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CostAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CostAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CostAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CostAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CostAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CostAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CostAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CostAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CostAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CostAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CostAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CostAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CostAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CostAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CostAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CostAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CostAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CostAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CostAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CostAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CostAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CostAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CostAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CostAccountMutation) ResetUserID() {
	m.user = nil
}

// SetTotalCep sets the "total_cep" field.
func (m *CostAccountMutation) SetTotalCep(i int64) {
	m.total_cep = &i
	m.addtotal_cep = nil
}

// TotalCep returns the value of the "total_cep" field in the mutation.
func (m *CostAccountMutation) TotalCep() (r int64, exists bool) {
	v := m.total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCep returns the old "total_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCep: %w", err)
	}
	return oldValue.TotalCep, nil
}

// AddTotalCep adds i to the "total_cep" field.
func (m *CostAccountMutation) AddTotalCep(i int64) {
	if m.addtotal_cep != nil {
		*m.addtotal_cep += i
	} else {
		m.addtotal_cep = &i
	}
}

// AddedTotalCep returns the value that was added to the "total_cep" field in this mutation.
func (m *CostAccountMutation) AddedTotalCep() (r int64, exists bool) {
	v := m.addtotal_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCep resets all changes to the "total_cep" field.
func (m *CostAccountMutation) ResetTotalCep() {
	m.total_cep = nil
	m.addtotal_cep = nil
}

// SetSumTotalCep sets the "sum_total_cep" field.
func (m *CostAccountMutation) SetSumTotalCep(i int64) {
	m.sum_total_cep = &i
	m.addsum_total_cep = nil
}

// SumTotalCep returns the value of the "sum_total_cep" field in the mutation.
func (m *CostAccountMutation) SumTotalCep() (r int64, exists bool) {
	v := m.sum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumTotalCep returns the old "sum_total_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldSumTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumTotalCep: %w", err)
	}
	return oldValue.SumTotalCep, nil
}

// AddSumTotalCep adds i to the "sum_total_cep" field.
func (m *CostAccountMutation) AddSumTotalCep(i int64) {
	if m.addsum_total_cep != nil {
		*m.addsum_total_cep += i
	} else {
		m.addsum_total_cep = &i
	}
}

// AddedSumTotalCep returns the value that was added to the "sum_total_cep" field in this mutation.
func (m *CostAccountMutation) AddedSumTotalCep() (r int64, exists bool) {
	v := m.addsum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumTotalCep resets all changes to the "sum_total_cep" field.
func (m *CostAccountMutation) ResetSumTotalCep() {
	m.sum_total_cep = nil
	m.addsum_total_cep = nil
}

// SetFrozenTotalCep sets the "frozen_total_cep" field.
func (m *CostAccountMutation) SetFrozenTotalCep(i int64) {
	m.frozen_total_cep = &i
	m.addfrozen_total_cep = nil
}

// FrozenTotalCep returns the value of the "frozen_total_cep" field in the mutation.
func (m *CostAccountMutation) FrozenTotalCep() (r int64, exists bool) {
	v := m.frozen_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenTotalCep returns the old "frozen_total_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldFrozenTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenTotalCep: %w", err)
	}
	return oldValue.FrozenTotalCep, nil
}

// AddFrozenTotalCep adds i to the "frozen_total_cep" field.
func (m *CostAccountMutation) AddFrozenTotalCep(i int64) {
	if m.addfrozen_total_cep != nil {
		*m.addfrozen_total_cep += i
	} else {
		m.addfrozen_total_cep = &i
	}
}

// AddedFrozenTotalCep returns the value that was added to the "frozen_total_cep" field in this mutation.
func (m *CostAccountMutation) AddedFrozenTotalCep() (r int64, exists bool) {
	v := m.addfrozen_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenTotalCep resets all changes to the "frozen_total_cep" field.
func (m *CostAccountMutation) ResetFrozenTotalCep() {
	m.frozen_total_cep = nil
	m.addfrozen_total_cep = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *CostAccountMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *CostAccountMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *CostAccountMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *CostAccountMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *CostAccountMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetSumPureCep sets the "sum_pure_cep" field.
func (m *CostAccountMutation) SetSumPureCep(i int64) {
	m.sum_pure_cep = &i
	m.addsum_pure_cep = nil
}

// SumPureCep returns the value of the "sum_pure_cep" field in the mutation.
func (m *CostAccountMutation) SumPureCep() (r int64, exists bool) {
	v := m.sum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumPureCep returns the old "sum_pure_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldSumPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumPureCep: %w", err)
	}
	return oldValue.SumPureCep, nil
}

// AddSumPureCep adds i to the "sum_pure_cep" field.
func (m *CostAccountMutation) AddSumPureCep(i int64) {
	if m.addsum_pure_cep != nil {
		*m.addsum_pure_cep += i
	} else {
		m.addsum_pure_cep = &i
	}
}

// AddedSumPureCep returns the value that was added to the "sum_pure_cep" field in this mutation.
func (m *CostAccountMutation) AddedSumPureCep() (r int64, exists bool) {
	v := m.addsum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumPureCep resets all changes to the "sum_pure_cep" field.
func (m *CostAccountMutation) ResetSumPureCep() {
	m.sum_pure_cep = nil
	m.addsum_pure_cep = nil
}

// SetFrozenPureCep sets the "frozen_pure_cep" field.
func (m *CostAccountMutation) SetFrozenPureCep(i int64) {
	m.frozen_pure_cep = &i
	m.addfrozen_pure_cep = nil
}

// FrozenPureCep returns the value of the "frozen_pure_cep" field in the mutation.
func (m *CostAccountMutation) FrozenPureCep() (r int64, exists bool) {
	v := m.frozen_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenPureCep returns the old "frozen_pure_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldFrozenPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenPureCep: %w", err)
	}
	return oldValue.FrozenPureCep, nil
}

// AddFrozenPureCep adds i to the "frozen_pure_cep" field.
func (m *CostAccountMutation) AddFrozenPureCep(i int64) {
	if m.addfrozen_pure_cep != nil {
		*m.addfrozen_pure_cep += i
	} else {
		m.addfrozen_pure_cep = &i
	}
}

// AddedFrozenPureCep returns the value that was added to the "frozen_pure_cep" field in this mutation.
func (m *CostAccountMutation) AddedFrozenPureCep() (r int64, exists bool) {
	v := m.addfrozen_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenPureCep resets all changes to the "frozen_pure_cep" field.
func (m *CostAccountMutation) ResetFrozenPureCep() {
	m.frozen_pure_cep = nil
	m.addfrozen_pure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *CostAccountMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *CostAccountMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *CostAccountMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *CostAccountMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *CostAccountMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetSumGiftCep sets the "sum_gift_cep" field.
func (m *CostAccountMutation) SetSumGiftCep(i int64) {
	m.sum_gift_cep = &i
	m.addsum_gift_cep = nil
}

// SumGiftCep returns the value of the "sum_gift_cep" field in the mutation.
func (m *CostAccountMutation) SumGiftCep() (r int64, exists bool) {
	v := m.sum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumGiftCep returns the old "sum_gift_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldSumGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumGiftCep: %w", err)
	}
	return oldValue.SumGiftCep, nil
}

// AddSumGiftCep adds i to the "sum_gift_cep" field.
func (m *CostAccountMutation) AddSumGiftCep(i int64) {
	if m.addsum_gift_cep != nil {
		*m.addsum_gift_cep += i
	} else {
		m.addsum_gift_cep = &i
	}
}

// AddedSumGiftCep returns the value that was added to the "sum_gift_cep" field in this mutation.
func (m *CostAccountMutation) AddedSumGiftCep() (r int64, exists bool) {
	v := m.addsum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumGiftCep resets all changes to the "sum_gift_cep" field.
func (m *CostAccountMutation) ResetSumGiftCep() {
	m.sum_gift_cep = nil
	m.addsum_gift_cep = nil
}

// SetFrozenGiftCep sets the "frozen_gift_cep" field.
func (m *CostAccountMutation) SetFrozenGiftCep(i int64) {
	m.frozen_gift_cep = &i
	m.addfrozen_gift_cep = nil
}

// FrozenGiftCep returns the value of the "frozen_gift_cep" field in the mutation.
func (m *CostAccountMutation) FrozenGiftCep() (r int64, exists bool) {
	v := m.frozen_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenGiftCep returns the old "frozen_gift_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldFrozenGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenGiftCep: %w", err)
	}
	return oldValue.FrozenGiftCep, nil
}

// AddFrozenGiftCep adds i to the "frozen_gift_cep" field.
func (m *CostAccountMutation) AddFrozenGiftCep(i int64) {
	if m.addfrozen_gift_cep != nil {
		*m.addfrozen_gift_cep += i
	} else {
		m.addfrozen_gift_cep = &i
	}
}

// AddedFrozenGiftCep returns the value that was added to the "frozen_gift_cep" field in this mutation.
func (m *CostAccountMutation) AddedFrozenGiftCep() (r int64, exists bool) {
	v := m.addfrozen_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenGiftCep resets all changes to the "frozen_gift_cep" field.
func (m *CostAccountMutation) ResetFrozenGiftCep() {
	m.frozen_gift_cep = nil
	m.addfrozen_gift_cep = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CostAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[costaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CostAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CostAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CostAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *CostAccountMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *CostAccountMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *CostAccountMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *CostAccountMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *CostAccountMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *CostAccountMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *CostAccountMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// Where appends a list predicates to the CostAccountMutation builder.
func (m *CostAccountMutation) Where(ps ...predicate.CostAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CostAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CostAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CostAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CostAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CostAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CostAccount).
func (m *CostAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostAccountMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, costaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, costaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, costaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, costaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, costaccount.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, costaccount.FieldUserID)
	}
	if m.total_cep != nil {
		fields = append(fields, costaccount.FieldTotalCep)
	}
	if m.sum_total_cep != nil {
		fields = append(fields, costaccount.FieldSumTotalCep)
	}
	if m.frozen_total_cep != nil {
		fields = append(fields, costaccount.FieldFrozenTotalCep)
	}
	if m.pure_cep != nil {
		fields = append(fields, costaccount.FieldPureCep)
	}
	if m.sum_pure_cep != nil {
		fields = append(fields, costaccount.FieldSumPureCep)
	}
	if m.frozen_pure_cep != nil {
		fields = append(fields, costaccount.FieldFrozenPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, costaccount.FieldGiftCep)
	}
	if m.sum_gift_cep != nil {
		fields = append(fields, costaccount.FieldSumGiftCep)
	}
	if m.frozen_gift_cep != nil {
		fields = append(fields, costaccount.FieldFrozenGiftCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case costaccount.FieldCreatedBy:
		return m.CreatedBy()
	case costaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case costaccount.FieldCreatedAt:
		return m.CreatedAt()
	case costaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case costaccount.FieldDeletedAt:
		return m.DeletedAt()
	case costaccount.FieldUserID:
		return m.UserID()
	case costaccount.FieldTotalCep:
		return m.TotalCep()
	case costaccount.FieldSumTotalCep:
		return m.SumTotalCep()
	case costaccount.FieldFrozenTotalCep:
		return m.FrozenTotalCep()
	case costaccount.FieldPureCep:
		return m.PureCep()
	case costaccount.FieldSumPureCep:
		return m.SumPureCep()
	case costaccount.FieldFrozenPureCep:
		return m.FrozenPureCep()
	case costaccount.FieldGiftCep:
		return m.GiftCep()
	case costaccount.FieldSumGiftCep:
		return m.SumGiftCep()
	case costaccount.FieldFrozenGiftCep:
		return m.FrozenGiftCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case costaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case costaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case costaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case costaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case costaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case costaccount.FieldUserID:
		return m.OldUserID(ctx)
	case costaccount.FieldTotalCep:
		return m.OldTotalCep(ctx)
	case costaccount.FieldSumTotalCep:
		return m.OldSumTotalCep(ctx)
	case costaccount.FieldFrozenTotalCep:
		return m.OldFrozenTotalCep(ctx)
	case costaccount.FieldPureCep:
		return m.OldPureCep(ctx)
	case costaccount.FieldSumPureCep:
		return m.OldSumPureCep(ctx)
	case costaccount.FieldFrozenPureCep:
		return m.OldFrozenPureCep(ctx)
	case costaccount.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case costaccount.FieldSumGiftCep:
		return m.OldSumGiftCep(ctx)
	case costaccount.FieldFrozenGiftCep:
		return m.OldFrozenGiftCep(ctx)
	}
	return nil, fmt.Errorf("unknown CostAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case costaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case costaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case costaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case costaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case costaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case costaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case costaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCep(v)
		return nil
	case costaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumTotalCep(v)
		return nil
	case costaccount.FieldFrozenTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenTotalCep(v)
		return nil
	case costaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case costaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumPureCep(v)
		return nil
	case costaccount.FieldFrozenPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenPureCep(v)
		return nil
	case costaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case costaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumGiftCep(v)
		return nil
	case costaccount.FieldFrozenGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown CostAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, costaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, costaccount.FieldUpdatedBy)
	}
	if m.addtotal_cep != nil {
		fields = append(fields, costaccount.FieldTotalCep)
	}
	if m.addsum_total_cep != nil {
		fields = append(fields, costaccount.FieldSumTotalCep)
	}
	if m.addfrozen_total_cep != nil {
		fields = append(fields, costaccount.FieldFrozenTotalCep)
	}
	if m.addpure_cep != nil {
		fields = append(fields, costaccount.FieldPureCep)
	}
	if m.addsum_pure_cep != nil {
		fields = append(fields, costaccount.FieldSumPureCep)
	}
	if m.addfrozen_pure_cep != nil {
		fields = append(fields, costaccount.FieldFrozenPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, costaccount.FieldGiftCep)
	}
	if m.addsum_gift_cep != nil {
		fields = append(fields, costaccount.FieldSumGiftCep)
	}
	if m.addfrozen_gift_cep != nil {
		fields = append(fields, costaccount.FieldFrozenGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case costaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case costaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case costaccount.FieldTotalCep:
		return m.AddedTotalCep()
	case costaccount.FieldSumTotalCep:
		return m.AddedSumTotalCep()
	case costaccount.FieldFrozenTotalCep:
		return m.AddedFrozenTotalCep()
	case costaccount.FieldPureCep:
		return m.AddedPureCep()
	case costaccount.FieldSumPureCep:
		return m.AddedSumPureCep()
	case costaccount.FieldFrozenPureCep:
		return m.AddedFrozenPureCep()
	case costaccount.FieldGiftCep:
		return m.AddedGiftCep()
	case costaccount.FieldSumGiftCep:
		return m.AddedSumGiftCep()
	case costaccount.FieldFrozenGiftCep:
		return m.AddedFrozenGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case costaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case costaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case costaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCep(v)
		return nil
	case costaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumTotalCep(v)
		return nil
	case costaccount.FieldFrozenTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenTotalCep(v)
		return nil
	case costaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case costaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumPureCep(v)
		return nil
	case costaccount.FieldFrozenPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenPureCep(v)
		return nil
	case costaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case costaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumGiftCep(v)
		return nil
	case costaccount.FieldFrozenGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown CostAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CostAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostAccountMutation) ResetField(name string) error {
	switch name {
	case costaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case costaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case costaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case costaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case costaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case costaccount.FieldUserID:
		m.ResetUserID()
		return nil
	case costaccount.FieldTotalCep:
		m.ResetTotalCep()
		return nil
	case costaccount.FieldSumTotalCep:
		m.ResetSumTotalCep()
		return nil
	case costaccount.FieldFrozenTotalCep:
		m.ResetFrozenTotalCep()
		return nil
	case costaccount.FieldPureCep:
		m.ResetPureCep()
		return nil
	case costaccount.FieldSumPureCep:
		m.ResetSumPureCep()
		return nil
	case costaccount.FieldFrozenPureCep:
		m.ResetFrozenPureCep()
		return nil
	case costaccount.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case costaccount.FieldSumGiftCep:
		m.ResetSumGiftCep()
		return nil
	case costaccount.FieldFrozenGiftCep:
		m.ResetFrozenGiftCep()
		return nil
	}
	return fmt.Errorf("unknown CostAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, costaccount.EdgeUser)
	}
	if m.cost_bills != nil {
		edges = append(edges, costaccount.EdgeCostBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case costaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case costaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcost_bills != nil {
		edges = append(edges, costaccount.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case costaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, costaccount.EdgeUser)
	}
	if m.clearedcost_bills {
		edges = append(edges, costaccount.EdgeCostBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case costaccount.EdgeUser:
		return m.cleareduser
	case costaccount.EdgeCostBills:
		return m.clearedcost_bills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostAccountMutation) ClearEdge(name string) error {
	switch name {
	case costaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CostAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostAccountMutation) ResetEdge(name string) error {
	switch name {
	case costaccount.EdgeUser:
		m.ResetUser()
		return nil
	case costaccount.EdgeCostBills:
		m.ResetCostBills()
		return nil
	}
	return fmt.Errorf("unknown CostAccount edge %s", name)
}

// CostBillMutation represents an operation that mutates the CostBill nodes in the graph.
type CostBillMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_by                   *int64
	addcreated_by                *int64
	updated_by                   *int64
	addupdated_by                *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	_type                        *costbill.Type
	way                          *costbill.Way
	is_add                       *bool
	serial_number                *string
	pure_cep                     *int64
	addpure_cep                  *int64
	gift_cep                     *int64
	addgift_cep                  *int64
	status                       *enums.BillStatus
	clearedFields                map[string]struct{}
	user                         *int64
	cleareduser                  bool
	cost_account                 *int64
	clearedcost_account          bool
	recharge_order               *int64
	clearedrecharge_order        bool
	mission_consume_order        *int64
	clearedmission_consume_order bool
	platform_account             *int64
	clearedplatform_account      bool
	campaign_order               *int64
	clearedcampaign_order        bool
	done                         bool
	oldValue                     func(context.Context) (*CostBill, error)
	predicates                   []predicate.CostBill
}

var _ ent.Mutation = (*CostBillMutation)(nil)

// costbillOption allows management of the mutation configuration using functional options.
type costbillOption func(*CostBillMutation)

// newCostBillMutation creates new mutation for the CostBill entity.
func newCostBillMutation(c config, op Op, opts ...costbillOption) *CostBillMutation {
	m := &CostBillMutation{
		config:        c,
		op:            op,
		typ:           TypeCostBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostBillID sets the ID field of the mutation.
func withCostBillID(id int64) costbillOption {
	return func(m *CostBillMutation) {
		var (
			err   error
			once  sync.Once
			value *CostBill
		)
		m.oldValue = func(ctx context.Context) (*CostBill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CostBill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCostBill sets the old CostBill of the mutation.
func withCostBill(node *CostBill) costbillOption {
	return func(m *CostBillMutation) {
		m.oldValue = func(context.Context) (*CostBill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostBillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostBillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CostBill entities.
func (m *CostBillMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostBillMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CostBillMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CostBill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CostBillMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CostBillMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CostBillMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CostBillMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CostBillMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CostBillMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CostBillMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CostBillMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CostBillMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CostBillMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CostBillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CostBillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CostBillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CostBillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CostBillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CostBillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CostBillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CostBillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CostBillMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *CostBillMutation) SetType(c costbill.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CostBillMutation) GetType() (r costbill.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldType(ctx context.Context) (v costbill.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CostBillMutation) ResetType() {
	m._type = nil
}

// SetWay sets the "way" field.
func (m *CostBillMutation) SetWay(c costbill.Way) {
	m.way = &c
}

// Way returns the value of the "way" field in the mutation.
func (m *CostBillMutation) Way() (r costbill.Way, exists bool) {
	v := m.way
	if v == nil {
		return
	}
	return *v, true
}

// OldWay returns the old "way" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldWay(ctx context.Context) (v costbill.Way, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWay: %w", err)
	}
	return oldValue.Way, nil
}

// ResetWay resets all changes to the "way" field.
func (m *CostBillMutation) ResetWay() {
	m.way = nil
}

// SetIsAdd sets the "is_add" field.
func (m *CostBillMutation) SetIsAdd(b bool) {
	m.is_add = &b
}

// IsAdd returns the value of the "is_add" field in the mutation.
func (m *CostBillMutation) IsAdd() (r bool, exists bool) {
	v := m.is_add
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdd returns the old "is_add" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldIsAdd(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdd: %w", err)
	}
	return oldValue.IsAdd, nil
}

// ResetIsAdd resets all changes to the "is_add" field.
func (m *CostBillMutation) ResetIsAdd() {
	m.is_add = nil
}

// SetUserID sets the "user_id" field.
func (m *CostBillMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CostBillMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CostBillMutation) ResetUserID() {
	m.user = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *CostBillMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *CostBillMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *CostBillMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetCostAccountID sets the "cost_account_id" field.
func (m *CostBillMutation) SetCostAccountID(i int64) {
	m.cost_account = &i
}

// CostAccountID returns the value of the "cost_account_id" field in the mutation.
func (m *CostBillMutation) CostAccountID() (r int64, exists bool) {
	v := m.cost_account
	if v == nil {
		return
	}
	return *v, true
}

// OldCostAccountID returns the old "cost_account_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCostAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostAccountID: %w", err)
	}
	return oldValue.CostAccountID, nil
}

// ResetCostAccountID resets all changes to the "cost_account_id" field.
func (m *CostBillMutation) ResetCostAccountID() {
	m.cost_account = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *CostBillMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *CostBillMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *CostBillMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *CostBillMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *CostBillMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *CostBillMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *CostBillMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *CostBillMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *CostBillMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *CostBillMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetReasonID sets the "reason_id" field.
func (m *CostBillMutation) SetReasonID(i int64) {
	m.recharge_order = &i
}

// ReasonID returns the value of the "reason_id" field in the mutation.
func (m *CostBillMutation) ReasonID() (r int64, exists bool) {
	v := m.recharge_order
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonID returns the old "reason_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldReasonID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonID: %w", err)
	}
	return oldValue.ReasonID, nil
}

// ClearReasonID clears the value of the "reason_id" field.
func (m *CostBillMutation) ClearReasonID() {
	m.recharge_order = nil
	m.clearedFields[costbill.FieldReasonID] = struct{}{}
}

// ReasonIDCleared returns if the "reason_id" field was cleared in this mutation.
func (m *CostBillMutation) ReasonIDCleared() bool {
	_, ok := m.clearedFields[costbill.FieldReasonID]
	return ok
}

// ResetReasonID resets all changes to the "reason_id" field.
func (m *CostBillMutation) ResetReasonID() {
	m.recharge_order = nil
	delete(m.clearedFields, costbill.FieldReasonID)
}

// SetStatus sets the "status" field.
func (m *CostBillMutation) SetStatus(es enums.BillStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *CostBillMutation) Status() (r enums.BillStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldStatus(ctx context.Context) (v enums.BillStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CostBillMutation) ResetStatus() {
	m.status = nil
}

// SetMarketAccountID sets the "market_account_id" field.
func (m *CostBillMutation) SetMarketAccountID(i int64) {
	m.platform_account = &i
}

// MarketAccountID returns the value of the "market_account_id" field in the mutation.
func (m *CostBillMutation) MarketAccountID() (r int64, exists bool) {
	v := m.platform_account
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketAccountID returns the old "market_account_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldMarketAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketAccountID: %w", err)
	}
	return oldValue.MarketAccountID, nil
}

// ResetMarketAccountID resets all changes to the "market_account_id" field.
func (m *CostBillMutation) ResetMarketAccountID() {
	m.platform_account = nil
}

// SetCampaignOrderID sets the "campaign_order_id" field.
func (m *CostBillMutation) SetCampaignOrderID(i int64) {
	m.campaign_order = &i
}

// CampaignOrderID returns the value of the "campaign_order_id" field in the mutation.
func (m *CostBillMutation) CampaignOrderID() (r int64, exists bool) {
	v := m.campaign_order
	if v == nil {
		return
	}
	return *v, true
}

// OldCampaignOrderID returns the old "campaign_order_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCampaignOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCampaignOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCampaignOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCampaignOrderID: %w", err)
	}
	return oldValue.CampaignOrderID, nil
}

// ResetCampaignOrderID resets all changes to the "campaign_order_id" field.
func (m *CostBillMutation) ResetCampaignOrderID() {
	m.campaign_order = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CostBillMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[costbill.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CostBillMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CostBillMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCostAccount clears the "cost_account" edge to the CostAccount entity.
func (m *CostBillMutation) ClearCostAccount() {
	m.clearedcost_account = true
	m.clearedFields[costbill.FieldCostAccountID] = struct{}{}
}

// CostAccountCleared reports if the "cost_account" edge to the CostAccount entity was cleared.
func (m *CostBillMutation) CostAccountCleared() bool {
	return m.clearedcost_account
}

// CostAccountIDs returns the "cost_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CostAccountID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) CostAccountIDs() (ids []int64) {
	if id := m.cost_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCostAccount resets all changes to the "cost_account" edge.
func (m *CostBillMutation) ResetCostAccount() {
	m.cost_account = nil
	m.clearedcost_account = false
}

// SetRechargeOrderID sets the "recharge_order" edge to the RechargeOrder entity by id.
func (m *CostBillMutation) SetRechargeOrderID(id int64) {
	m.recharge_order = &id
}

// ClearRechargeOrder clears the "recharge_order" edge to the RechargeOrder entity.
func (m *CostBillMutation) ClearRechargeOrder() {
	m.clearedrecharge_order = true
	m.clearedFields[costbill.FieldReasonID] = struct{}{}
}

// RechargeOrderCleared reports if the "recharge_order" edge to the RechargeOrder entity was cleared.
func (m *CostBillMutation) RechargeOrderCleared() bool {
	return m.ReasonIDCleared() || m.clearedrecharge_order
}

// RechargeOrderID returns the "recharge_order" edge ID in the mutation.
func (m *CostBillMutation) RechargeOrderID() (id int64, exists bool) {
	if m.recharge_order != nil {
		return *m.recharge_order, true
	}
	return
}

// RechargeOrderIDs returns the "recharge_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RechargeOrderID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) RechargeOrderIDs() (ids []int64) {
	if id := m.recharge_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRechargeOrder resets all changes to the "recharge_order" edge.
func (m *CostBillMutation) ResetRechargeOrder() {
	m.recharge_order = nil
	m.clearedrecharge_order = false
}

// SetMissionConsumeOrderID sets the "mission_consume_order" edge to the MissionConsumeOrder entity by id.
func (m *CostBillMutation) SetMissionConsumeOrderID(id int64) {
	m.mission_consume_order = &id
}

// ClearMissionConsumeOrder clears the "mission_consume_order" edge to the MissionConsumeOrder entity.
func (m *CostBillMutation) ClearMissionConsumeOrder() {
	m.clearedmission_consume_order = true
	m.clearedFields[costbill.FieldReasonID] = struct{}{}
}

// MissionConsumeOrderCleared reports if the "mission_consume_order" edge to the MissionConsumeOrder entity was cleared.
func (m *CostBillMutation) MissionConsumeOrderCleared() bool {
	return m.ReasonIDCleared() || m.clearedmission_consume_order
}

// MissionConsumeOrderID returns the "mission_consume_order" edge ID in the mutation.
func (m *CostBillMutation) MissionConsumeOrderID() (id int64, exists bool) {
	if m.mission_consume_order != nil {
		return *m.mission_consume_order, true
	}
	return
}

// MissionConsumeOrderIDs returns the "mission_consume_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionConsumeOrderID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) MissionConsumeOrderIDs() (ids []int64) {
	if id := m.mission_consume_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionConsumeOrder resets all changes to the "mission_consume_order" edge.
func (m *CostBillMutation) ResetMissionConsumeOrder() {
	m.mission_consume_order = nil
	m.clearedmission_consume_order = false
}

// SetPlatformAccountID sets the "platform_account" edge to the PlatformAccount entity by id.
func (m *CostBillMutation) SetPlatformAccountID(id int64) {
	m.platform_account = &id
}

// ClearPlatformAccount clears the "platform_account" edge to the PlatformAccount entity.
func (m *CostBillMutation) ClearPlatformAccount() {
	m.clearedplatform_account = true
	m.clearedFields[costbill.FieldMarketAccountID] = struct{}{}
}

// PlatformAccountCleared reports if the "platform_account" edge to the PlatformAccount entity was cleared.
func (m *CostBillMutation) PlatformAccountCleared() bool {
	return m.clearedplatform_account
}

// PlatformAccountID returns the "platform_account" edge ID in the mutation.
func (m *CostBillMutation) PlatformAccountID() (id int64, exists bool) {
	if m.platform_account != nil {
		return *m.platform_account, true
	}
	return
}

// PlatformAccountIDs returns the "platform_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlatformAccountID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) PlatformAccountIDs() (ids []int64) {
	if id := m.platform_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlatformAccount resets all changes to the "platform_account" edge.
func (m *CostBillMutation) ResetPlatformAccount() {
	m.platform_account = nil
	m.clearedplatform_account = false
}

// ClearCampaignOrder clears the "campaign_order" edge to the CampaignOrder entity.
func (m *CostBillMutation) ClearCampaignOrder() {
	m.clearedcampaign_order = true
	m.clearedFields[costbill.FieldCampaignOrderID] = struct{}{}
}

// CampaignOrderCleared reports if the "campaign_order" edge to the CampaignOrder entity was cleared.
func (m *CostBillMutation) CampaignOrderCleared() bool {
	return m.clearedcampaign_order
}

// CampaignOrderIDs returns the "campaign_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignOrderID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) CampaignOrderIDs() (ids []int64) {
	if id := m.campaign_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaignOrder resets all changes to the "campaign_order" edge.
func (m *CostBillMutation) ResetCampaignOrder() {
	m.campaign_order = nil
	m.clearedcampaign_order = false
}

// Where appends a list predicates to the CostBillMutation builder.
func (m *CostBillMutation) Where(ps ...predicate.CostBill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CostBillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CostBillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CostBill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CostBillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CostBillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CostBill).
func (m *CostBillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostBillMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, costbill.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, costbill.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, costbill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, costbill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, costbill.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, costbill.FieldType)
	}
	if m.way != nil {
		fields = append(fields, costbill.FieldWay)
	}
	if m.is_add != nil {
		fields = append(fields, costbill.FieldIsAdd)
	}
	if m.user != nil {
		fields = append(fields, costbill.FieldUserID)
	}
	if m.serial_number != nil {
		fields = append(fields, costbill.FieldSerialNumber)
	}
	if m.cost_account != nil {
		fields = append(fields, costbill.FieldCostAccountID)
	}
	if m.pure_cep != nil {
		fields = append(fields, costbill.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, costbill.FieldGiftCep)
	}
	if m.recharge_order != nil {
		fields = append(fields, costbill.FieldReasonID)
	}
	if m.status != nil {
		fields = append(fields, costbill.FieldStatus)
	}
	if m.platform_account != nil {
		fields = append(fields, costbill.FieldMarketAccountID)
	}
	if m.campaign_order != nil {
		fields = append(fields, costbill.FieldCampaignOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostBillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case costbill.FieldCreatedBy:
		return m.CreatedBy()
	case costbill.FieldUpdatedBy:
		return m.UpdatedBy()
	case costbill.FieldCreatedAt:
		return m.CreatedAt()
	case costbill.FieldUpdatedAt:
		return m.UpdatedAt()
	case costbill.FieldDeletedAt:
		return m.DeletedAt()
	case costbill.FieldType:
		return m.GetType()
	case costbill.FieldWay:
		return m.Way()
	case costbill.FieldIsAdd:
		return m.IsAdd()
	case costbill.FieldUserID:
		return m.UserID()
	case costbill.FieldSerialNumber:
		return m.SerialNumber()
	case costbill.FieldCostAccountID:
		return m.CostAccountID()
	case costbill.FieldPureCep:
		return m.PureCep()
	case costbill.FieldGiftCep:
		return m.GiftCep()
	case costbill.FieldReasonID:
		return m.ReasonID()
	case costbill.FieldStatus:
		return m.Status()
	case costbill.FieldMarketAccountID:
		return m.MarketAccountID()
	case costbill.FieldCampaignOrderID:
		return m.CampaignOrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostBillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case costbill.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case costbill.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case costbill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case costbill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case costbill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case costbill.FieldType:
		return m.OldType(ctx)
	case costbill.FieldWay:
		return m.OldWay(ctx)
	case costbill.FieldIsAdd:
		return m.OldIsAdd(ctx)
	case costbill.FieldUserID:
		return m.OldUserID(ctx)
	case costbill.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case costbill.FieldCostAccountID:
		return m.OldCostAccountID(ctx)
	case costbill.FieldPureCep:
		return m.OldPureCep(ctx)
	case costbill.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case costbill.FieldReasonID:
		return m.OldReasonID(ctx)
	case costbill.FieldStatus:
		return m.OldStatus(ctx)
	case costbill.FieldMarketAccountID:
		return m.OldMarketAccountID(ctx)
	case costbill.FieldCampaignOrderID:
		return m.OldCampaignOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown CostBill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostBillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case costbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case costbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case costbill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case costbill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case costbill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case costbill.FieldType:
		v, ok := value.(costbill.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case costbill.FieldWay:
		v, ok := value.(costbill.Way)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWay(v)
		return nil
	case costbill.FieldIsAdd:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdd(v)
		return nil
	case costbill.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case costbill.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case costbill.FieldCostAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostAccountID(v)
		return nil
	case costbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case costbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case costbill.FieldReasonID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonID(v)
		return nil
	case costbill.FieldStatus:
		v, ok := value.(enums.BillStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case costbill.FieldMarketAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketAccountID(v)
		return nil
	case costbill.FieldCampaignOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCampaignOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown CostBill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostBillMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, costbill.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, costbill.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, costbill.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, costbill.FieldGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostBillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case costbill.FieldCreatedBy:
		return m.AddedCreatedBy()
	case costbill.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case costbill.FieldPureCep:
		return m.AddedPureCep()
	case costbill.FieldGiftCep:
		return m.AddedGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostBillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case costbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case costbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case costbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case costbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown CostBill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostBillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(costbill.FieldReasonID) {
		fields = append(fields, costbill.FieldReasonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostBillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostBillMutation) ClearField(name string) error {
	switch name {
	case costbill.FieldReasonID:
		m.ClearReasonID()
		return nil
	}
	return fmt.Errorf("unknown CostBill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostBillMutation) ResetField(name string) error {
	switch name {
	case costbill.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case costbill.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case costbill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case costbill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case costbill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case costbill.FieldType:
		m.ResetType()
		return nil
	case costbill.FieldWay:
		m.ResetWay()
		return nil
	case costbill.FieldIsAdd:
		m.ResetIsAdd()
		return nil
	case costbill.FieldUserID:
		m.ResetUserID()
		return nil
	case costbill.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case costbill.FieldCostAccountID:
		m.ResetCostAccountID()
		return nil
	case costbill.FieldPureCep:
		m.ResetPureCep()
		return nil
	case costbill.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case costbill.FieldReasonID:
		m.ResetReasonID()
		return nil
	case costbill.FieldStatus:
		m.ResetStatus()
		return nil
	case costbill.FieldMarketAccountID:
		m.ResetMarketAccountID()
		return nil
	case costbill.FieldCampaignOrderID:
		m.ResetCampaignOrderID()
		return nil
	}
	return fmt.Errorf("unknown CostBill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostBillMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.user != nil {
		edges = append(edges, costbill.EdgeUser)
	}
	if m.cost_account != nil {
		edges = append(edges, costbill.EdgeCostAccount)
	}
	if m.recharge_order != nil {
		edges = append(edges, costbill.EdgeRechargeOrder)
	}
	if m.mission_consume_order != nil {
		edges = append(edges, costbill.EdgeMissionConsumeOrder)
	}
	if m.platform_account != nil {
		edges = append(edges, costbill.EdgePlatformAccount)
	}
	if m.campaign_order != nil {
		edges = append(edges, costbill.EdgeCampaignOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostBillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case costbill.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeCostAccount:
		if id := m.cost_account; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeRechargeOrder:
		if id := m.recharge_order; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeMissionConsumeOrder:
		if id := m.mission_consume_order; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgePlatformAccount:
		if id := m.platform_account; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeCampaignOrder:
		if id := m.campaign_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostBillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostBillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostBillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareduser {
		edges = append(edges, costbill.EdgeUser)
	}
	if m.clearedcost_account {
		edges = append(edges, costbill.EdgeCostAccount)
	}
	if m.clearedrecharge_order {
		edges = append(edges, costbill.EdgeRechargeOrder)
	}
	if m.clearedmission_consume_order {
		edges = append(edges, costbill.EdgeMissionConsumeOrder)
	}
	if m.clearedplatform_account {
		edges = append(edges, costbill.EdgePlatformAccount)
	}
	if m.clearedcampaign_order {
		edges = append(edges, costbill.EdgeCampaignOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostBillMutation) EdgeCleared(name string) bool {
	switch name {
	case costbill.EdgeUser:
		return m.cleareduser
	case costbill.EdgeCostAccount:
		return m.clearedcost_account
	case costbill.EdgeRechargeOrder:
		return m.clearedrecharge_order
	case costbill.EdgeMissionConsumeOrder:
		return m.clearedmission_consume_order
	case costbill.EdgePlatformAccount:
		return m.clearedplatform_account
	case costbill.EdgeCampaignOrder:
		return m.clearedcampaign_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostBillMutation) ClearEdge(name string) error {
	switch name {
	case costbill.EdgeUser:
		m.ClearUser()
		return nil
	case costbill.EdgeCostAccount:
		m.ClearCostAccount()
		return nil
	case costbill.EdgeRechargeOrder:
		m.ClearRechargeOrder()
		return nil
	case costbill.EdgeMissionConsumeOrder:
		m.ClearMissionConsumeOrder()
		return nil
	case costbill.EdgePlatformAccount:
		m.ClearPlatformAccount()
		return nil
	case costbill.EdgeCampaignOrder:
		m.ClearCampaignOrder()
		return nil
	}
	return fmt.Errorf("unknown CostBill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostBillMutation) ResetEdge(name string) error {
	switch name {
	case costbill.EdgeUser:
		m.ResetUser()
		return nil
	case costbill.EdgeCostAccount:
		m.ResetCostAccount()
		return nil
	case costbill.EdgeRechargeOrder:
		m.ResetRechargeOrder()
		return nil
	case costbill.EdgeMissionConsumeOrder:
		m.ResetMissionConsumeOrder()
		return nil
	case costbill.EdgePlatformAccount:
		m.ResetPlatformAccount()
		return nil
	case costbill.EdgeCampaignOrder:
		m.ResetCampaignOrder()
		return nil
	}
	return fmt.Errorf("unknown CostBill edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	serial_number                 *string
	state                         *device.State
	sum_cep                       *int64
	addsum_cep                    *int64
	linking                       *bool
	binding_status                *enums.DeviceBindingStatus
	status                        *device.Status
	name                          *string
	_type                         *enums.DeviceType
	cores_number                  *int64
	addcores_number               *int64
	cpu                           *string
	cpus                          *[]string
	memory                        *int64
	addmemory                     *int64
	disk                          *float32
	adddisk                       *float32
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	mission_produce_orders        map[int64]struct{}
	removedmission_produce_orders map[int64]struct{}
	clearedmission_produce_orders bool
	user_devices                  map[int64]struct{}
	removeduser_devices           map[int64]struct{}
	cleareduser_devices           bool
	device_gpu_missions           map[int64]struct{}
	removeddevice_gpu_missions    map[int64]struct{}
	cleareddevice_gpu_missions    bool
	frpc_infos                    map[int64]struct{}
	removedfrpc_infos             map[int64]struct{}
	clearedfrpc_infos             bool
	mission_orders                map[int64]struct{}
	removedmission_orders         map[int64]struct{}
	clearedmission_orders         bool
	mission_productions           map[int64]struct{}
	removedmission_productions    map[int64]struct{}
	clearedmission_productions    bool
	done                          bool
	oldValue                      func(context.Context) (*Device, error)
	predicates                    []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int64) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeviceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeviceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeviceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeviceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *DeviceMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceMutation) ResetUserID() {
	m.user = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *DeviceMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *DeviceMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *DeviceMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetState sets the "state" field.
func (m *DeviceMutation) SetState(d device.State) {
	m.state = &d
}

// State returns the value of the "state" field in the mutation.
func (m *DeviceMutation) State() (r device.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldState(ctx context.Context) (v device.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *DeviceMutation) ResetState() {
	m.state = nil
}

// SetSumCep sets the "sum_cep" field.
func (m *DeviceMutation) SetSumCep(i int64) {
	m.sum_cep = &i
	m.addsum_cep = nil
}

// SumCep returns the value of the "sum_cep" field in the mutation.
func (m *DeviceMutation) SumCep() (r int64, exists bool) {
	v := m.sum_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumCep returns the old "sum_cep" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSumCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumCep: %w", err)
	}
	return oldValue.SumCep, nil
}

// AddSumCep adds i to the "sum_cep" field.
func (m *DeviceMutation) AddSumCep(i int64) {
	if m.addsum_cep != nil {
		*m.addsum_cep += i
	} else {
		m.addsum_cep = &i
	}
}

// AddedSumCep returns the value that was added to the "sum_cep" field in this mutation.
func (m *DeviceMutation) AddedSumCep() (r int64, exists bool) {
	v := m.addsum_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumCep resets all changes to the "sum_cep" field.
func (m *DeviceMutation) ResetSumCep() {
	m.sum_cep = nil
	m.addsum_cep = nil
}

// SetLinking sets the "linking" field.
func (m *DeviceMutation) SetLinking(b bool) {
	m.linking = &b
}

// Linking returns the value of the "linking" field in the mutation.
func (m *DeviceMutation) Linking() (r bool, exists bool) {
	v := m.linking
	if v == nil {
		return
	}
	return *v, true
}

// OldLinking returns the old "linking" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldLinking(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinking: %w", err)
	}
	return oldValue.Linking, nil
}

// ResetLinking resets all changes to the "linking" field.
func (m *DeviceMutation) ResetLinking() {
	m.linking = nil
}

// SetBindingStatus sets the "binding_status" field.
func (m *DeviceMutation) SetBindingStatus(ebs enums.DeviceBindingStatus) {
	m.binding_status = &ebs
}

// BindingStatus returns the value of the "binding_status" field in the mutation.
func (m *DeviceMutation) BindingStatus() (r enums.DeviceBindingStatus, exists bool) {
	v := m.binding_status
	if v == nil {
		return
	}
	return *v, true
}

// OldBindingStatus returns the old "binding_status" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldBindingStatus(ctx context.Context) (v enums.DeviceBindingStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindingStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindingStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindingStatus: %w", err)
	}
	return oldValue.BindingStatus, nil
}

// ResetBindingStatus resets all changes to the "binding_status" field.
func (m *DeviceMutation) ResetBindingStatus() {
	m.binding_status = nil
}

// SetStatus sets the "status" field.
func (m *DeviceMutation) SetStatus(d device.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DeviceMutation) Status() (r device.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldStatus(ctx context.Context) (v device.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DeviceMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *DeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeviceMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *DeviceMutation) SetType(et enums.DeviceType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceMutation) GetType() (r enums.DeviceType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldType(ctx context.Context) (v enums.DeviceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DeviceMutation) ResetType() {
	m._type = nil
}

// SetCoresNumber sets the "cores_number" field.
func (m *DeviceMutation) SetCoresNumber(i int64) {
	m.cores_number = &i
	m.addcores_number = nil
}

// CoresNumber returns the value of the "cores_number" field in the mutation.
func (m *DeviceMutation) CoresNumber() (r int64, exists bool) {
	v := m.cores_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCoresNumber returns the old "cores_number" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCoresNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoresNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoresNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoresNumber: %w", err)
	}
	return oldValue.CoresNumber, nil
}

// AddCoresNumber adds i to the "cores_number" field.
func (m *DeviceMutation) AddCoresNumber(i int64) {
	if m.addcores_number != nil {
		*m.addcores_number += i
	} else {
		m.addcores_number = &i
	}
}

// AddedCoresNumber returns the value that was added to the "cores_number" field in this mutation.
func (m *DeviceMutation) AddedCoresNumber() (r int64, exists bool) {
	v := m.addcores_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoresNumber resets all changes to the "cores_number" field.
func (m *DeviceMutation) ResetCoresNumber() {
	m.cores_number = nil
	m.addcores_number = nil
}

// SetCPU sets the "cpu" field.
func (m *DeviceMutation) SetCPU(s string) {
	m.cpu = &s
}

// CPU returns the value of the "cpu" field in the mutation.
func (m *DeviceMutation) CPU() (r string, exists bool) {
	v := m.cpu
	if v == nil {
		return
	}
	return *v, true
}

// OldCPU returns the old "cpu" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCPU(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPU: %w", err)
	}
	return oldValue.CPU, nil
}

// ResetCPU resets all changes to the "cpu" field.
func (m *DeviceMutation) ResetCPU() {
	m.cpu = nil
}

// SetCpus sets the "cpus" field.
func (m *DeviceMutation) SetCpus(s []string) {
	m.cpus = &s
}

// Cpus returns the value of the "cpus" field in the mutation.
func (m *DeviceMutation) Cpus() (r []string, exists bool) {
	v := m.cpus
	if v == nil {
		return
	}
	return *v, true
}

// OldCpus returns the old "cpus" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCpus(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCpus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCpus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCpus: %w", err)
	}
	return oldValue.Cpus, nil
}

// ClearCpus clears the value of the "cpus" field.
func (m *DeviceMutation) ClearCpus() {
	m.cpus = nil
	m.clearedFields[device.FieldCpus] = struct{}{}
}

// CpusCleared returns if the "cpus" field was cleared in this mutation.
func (m *DeviceMutation) CpusCleared() bool {
	_, ok := m.clearedFields[device.FieldCpus]
	return ok
}

// ResetCpus resets all changes to the "cpus" field.
func (m *DeviceMutation) ResetCpus() {
	m.cpus = nil
	delete(m.clearedFields, device.FieldCpus)
}

// SetMemory sets the "memory" field.
func (m *DeviceMutation) SetMemory(i int64) {
	m.memory = &i
	m.addmemory = nil
}

// Memory returns the value of the "memory" field in the mutation.
func (m *DeviceMutation) Memory() (r int64, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldMemory(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// AddMemory adds i to the "memory" field.
func (m *DeviceMutation) AddMemory(i int64) {
	if m.addmemory != nil {
		*m.addmemory += i
	} else {
		m.addmemory = &i
	}
}

// AddedMemory returns the value that was added to the "memory" field in this mutation.
func (m *DeviceMutation) AddedMemory() (r int64, exists bool) {
	v := m.addmemory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemory resets all changes to the "memory" field.
func (m *DeviceMutation) ResetMemory() {
	m.memory = nil
	m.addmemory = nil
}

// SetDisk sets the "disk" field.
func (m *DeviceMutation) SetDisk(f float32) {
	m.disk = &f
	m.adddisk = nil
}

// Disk returns the value of the "disk" field in the mutation.
func (m *DeviceMutation) Disk() (r float32, exists bool) {
	v := m.disk
	if v == nil {
		return
	}
	return *v, true
}

// OldDisk returns the old "disk" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDisk(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisk: %w", err)
	}
	return oldValue.Disk, nil
}

// AddDisk adds f to the "disk" field.
func (m *DeviceMutation) AddDisk(f float32) {
	if m.adddisk != nil {
		*m.adddisk += f
	} else {
		m.adddisk = &f
	}
}

// AddedDisk returns the value that was added to the "disk" field in this mutation.
func (m *DeviceMutation) AddedDisk() (r float32, exists bool) {
	v := m.adddisk
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisk resets all changes to the "disk" field.
func (m *DeviceMutation) ResetDisk() {
	m.disk = nil
	m.adddisk = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[device.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *DeviceMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *DeviceMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *DeviceMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *DeviceMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *DeviceMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *DeviceMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *DeviceMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// AddUserDeviceIDs adds the "user_devices" edge to the UserDevice entity by ids.
func (m *DeviceMutation) AddUserDeviceIDs(ids ...int64) {
	if m.user_devices == nil {
		m.user_devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_devices[ids[i]] = struct{}{}
	}
}

// ClearUserDevices clears the "user_devices" edge to the UserDevice entity.
func (m *DeviceMutation) ClearUserDevices() {
	m.cleareduser_devices = true
}

// UserDevicesCleared reports if the "user_devices" edge to the UserDevice entity was cleared.
func (m *DeviceMutation) UserDevicesCleared() bool {
	return m.cleareduser_devices
}

// RemoveUserDeviceIDs removes the "user_devices" edge to the UserDevice entity by IDs.
func (m *DeviceMutation) RemoveUserDeviceIDs(ids ...int64) {
	if m.removeduser_devices == nil {
		m.removeduser_devices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_devices, ids[i])
		m.removeduser_devices[ids[i]] = struct{}{}
	}
}

// RemovedUserDevices returns the removed IDs of the "user_devices" edge to the UserDevice entity.
func (m *DeviceMutation) RemovedUserDevicesIDs() (ids []int64) {
	for id := range m.removeduser_devices {
		ids = append(ids, id)
	}
	return
}

// UserDevicesIDs returns the "user_devices" edge IDs in the mutation.
func (m *DeviceMutation) UserDevicesIDs() (ids []int64) {
	for id := range m.user_devices {
		ids = append(ids, id)
	}
	return
}

// ResetUserDevices resets all changes to the "user_devices" edge.
func (m *DeviceMutation) ResetUserDevices() {
	m.user_devices = nil
	m.cleareduser_devices = false
	m.removeduser_devices = nil
}

// AddDeviceGpuMissionIDs adds the "device_gpu_missions" edge to the DeviceGpuMission entity by ids.
func (m *DeviceMutation) AddDeviceGpuMissionIDs(ids ...int64) {
	if m.device_gpu_missions == nil {
		m.device_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_gpu_missions[ids[i]] = struct{}{}
	}
}

// ClearDeviceGpuMissions clears the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *DeviceMutation) ClearDeviceGpuMissions() {
	m.cleareddevice_gpu_missions = true
}

// DeviceGpuMissionsCleared reports if the "device_gpu_missions" edge to the DeviceGpuMission entity was cleared.
func (m *DeviceMutation) DeviceGpuMissionsCleared() bool {
	return m.cleareddevice_gpu_missions
}

// RemoveDeviceGpuMissionIDs removes the "device_gpu_missions" edge to the DeviceGpuMission entity by IDs.
func (m *DeviceMutation) RemoveDeviceGpuMissionIDs(ids ...int64) {
	if m.removeddevice_gpu_missions == nil {
		m.removeddevice_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_gpu_missions, ids[i])
		m.removeddevice_gpu_missions[ids[i]] = struct{}{}
	}
}

// RemovedDeviceGpuMissions returns the removed IDs of the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *DeviceMutation) RemovedDeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.removeddevice_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// DeviceGpuMissionsIDs returns the "device_gpu_missions" edge IDs in the mutation.
func (m *DeviceMutation) DeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.device_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceGpuMissions resets all changes to the "device_gpu_missions" edge.
func (m *DeviceMutation) ResetDeviceGpuMissions() {
	m.device_gpu_missions = nil
	m.cleareddevice_gpu_missions = false
	m.removeddevice_gpu_missions = nil
}

// AddFrpcInfoIDs adds the "frpc_infos" edge to the FrpcInfo entity by ids.
func (m *DeviceMutation) AddFrpcInfoIDs(ids ...int64) {
	if m.frpc_infos == nil {
		m.frpc_infos = make(map[int64]struct{})
	}
	for i := range ids {
		m.frpc_infos[ids[i]] = struct{}{}
	}
}

// ClearFrpcInfos clears the "frpc_infos" edge to the FrpcInfo entity.
func (m *DeviceMutation) ClearFrpcInfos() {
	m.clearedfrpc_infos = true
}

// FrpcInfosCleared reports if the "frpc_infos" edge to the FrpcInfo entity was cleared.
func (m *DeviceMutation) FrpcInfosCleared() bool {
	return m.clearedfrpc_infos
}

// RemoveFrpcInfoIDs removes the "frpc_infos" edge to the FrpcInfo entity by IDs.
func (m *DeviceMutation) RemoveFrpcInfoIDs(ids ...int64) {
	if m.removedfrpc_infos == nil {
		m.removedfrpc_infos = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.frpc_infos, ids[i])
		m.removedfrpc_infos[ids[i]] = struct{}{}
	}
}

// RemovedFrpcInfos returns the removed IDs of the "frpc_infos" edge to the FrpcInfo entity.
func (m *DeviceMutation) RemovedFrpcInfosIDs() (ids []int64) {
	for id := range m.removedfrpc_infos {
		ids = append(ids, id)
	}
	return
}

// FrpcInfosIDs returns the "frpc_infos" edge IDs in the mutation.
func (m *DeviceMutation) FrpcInfosIDs() (ids []int64) {
	for id := range m.frpc_infos {
		ids = append(ids, id)
	}
	return
}

// ResetFrpcInfos resets all changes to the "frpc_infos" edge.
func (m *DeviceMutation) ResetFrpcInfos() {
	m.frpc_infos = nil
	m.clearedfrpc_infos = false
	m.removedfrpc_infos = nil
}

// AddMissionOrderIDs adds the "mission_orders" edge to the MissionOrder entity by ids.
func (m *DeviceMutation) AddMissionOrderIDs(ids ...int64) {
	if m.mission_orders == nil {
		m.mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionOrders clears the "mission_orders" edge to the MissionOrder entity.
func (m *DeviceMutation) ClearMissionOrders() {
	m.clearedmission_orders = true
}

// MissionOrdersCleared reports if the "mission_orders" edge to the MissionOrder entity was cleared.
func (m *DeviceMutation) MissionOrdersCleared() bool {
	return m.clearedmission_orders
}

// RemoveMissionOrderIDs removes the "mission_orders" edge to the MissionOrder entity by IDs.
func (m *DeviceMutation) RemoveMissionOrderIDs(ids ...int64) {
	if m.removedmission_orders == nil {
		m.removedmission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_orders, ids[i])
		m.removedmission_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionOrders returns the removed IDs of the "mission_orders" edge to the MissionOrder entity.
func (m *DeviceMutation) RemovedMissionOrdersIDs() (ids []int64) {
	for id := range m.removedmission_orders {
		ids = append(ids, id)
	}
	return
}

// MissionOrdersIDs returns the "mission_orders" edge IDs in the mutation.
func (m *DeviceMutation) MissionOrdersIDs() (ids []int64) {
	for id := range m.mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionOrders resets all changes to the "mission_orders" edge.
func (m *DeviceMutation) ResetMissionOrders() {
	m.mission_orders = nil
	m.clearedmission_orders = false
	m.removedmission_orders = nil
}

// AddMissionProductionIDs adds the "mission_productions" edge to the MissionProduction entity by ids.
func (m *DeviceMutation) AddMissionProductionIDs(ids ...int64) {
	if m.mission_productions == nil {
		m.mission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_productions[ids[i]] = struct{}{}
	}
}

// ClearMissionProductions clears the "mission_productions" edge to the MissionProduction entity.
func (m *DeviceMutation) ClearMissionProductions() {
	m.clearedmission_productions = true
}

// MissionProductionsCleared reports if the "mission_productions" edge to the MissionProduction entity was cleared.
func (m *DeviceMutation) MissionProductionsCleared() bool {
	return m.clearedmission_productions
}

// RemoveMissionProductionIDs removes the "mission_productions" edge to the MissionProduction entity by IDs.
func (m *DeviceMutation) RemoveMissionProductionIDs(ids ...int64) {
	if m.removedmission_productions == nil {
		m.removedmission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_productions, ids[i])
		m.removedmission_productions[ids[i]] = struct{}{}
	}
}

// RemovedMissionProductions returns the removed IDs of the "mission_productions" edge to the MissionProduction entity.
func (m *DeviceMutation) RemovedMissionProductionsIDs() (ids []int64) {
	for id := range m.removedmission_productions {
		ids = append(ids, id)
	}
	return
}

// MissionProductionsIDs returns the "mission_productions" edge IDs in the mutation.
func (m *DeviceMutation) MissionProductionsIDs() (ids []int64) {
	for id := range m.mission_productions {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProductions resets all changes to the "mission_productions" edge.
func (m *DeviceMutation) ResetMissionProductions() {
	m.mission_productions = nil
	m.clearedmission_productions = false
	m.removedmission_productions = nil
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_by != nil {
		fields = append(fields, device.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, device.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, device.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, device.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, device.FieldUserID)
	}
	if m.serial_number != nil {
		fields = append(fields, device.FieldSerialNumber)
	}
	if m.state != nil {
		fields = append(fields, device.FieldState)
	}
	if m.sum_cep != nil {
		fields = append(fields, device.FieldSumCep)
	}
	if m.linking != nil {
		fields = append(fields, device.FieldLinking)
	}
	if m.binding_status != nil {
		fields = append(fields, device.FieldBindingStatus)
	}
	if m.status != nil {
		fields = append(fields, device.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, device.FieldName)
	}
	if m._type != nil {
		fields = append(fields, device.FieldType)
	}
	if m.cores_number != nil {
		fields = append(fields, device.FieldCoresNumber)
	}
	if m.cpu != nil {
		fields = append(fields, device.FieldCPU)
	}
	if m.cpus != nil {
		fields = append(fields, device.FieldCpus)
	}
	if m.memory != nil {
		fields = append(fields, device.FieldMemory)
	}
	if m.disk != nil {
		fields = append(fields, device.FieldDisk)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedBy:
		return m.CreatedBy()
	case device.FieldUpdatedBy:
		return m.UpdatedBy()
	case device.FieldCreatedAt:
		return m.CreatedAt()
	case device.FieldUpdatedAt:
		return m.UpdatedAt()
	case device.FieldDeletedAt:
		return m.DeletedAt()
	case device.FieldUserID:
		return m.UserID()
	case device.FieldSerialNumber:
		return m.SerialNumber()
	case device.FieldState:
		return m.State()
	case device.FieldSumCep:
		return m.SumCep()
	case device.FieldLinking:
		return m.Linking()
	case device.FieldBindingStatus:
		return m.BindingStatus()
	case device.FieldStatus:
		return m.Status()
	case device.FieldName:
		return m.Name()
	case device.FieldType:
		return m.GetType()
	case device.FieldCoresNumber:
		return m.CoresNumber()
	case device.FieldCPU:
		return m.CPU()
	case device.FieldCpus:
		return m.Cpus()
	case device.FieldMemory:
		return m.Memory()
	case device.FieldDisk:
		return m.Disk()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case device.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case device.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case device.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case device.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case device.FieldUserID:
		return m.OldUserID(ctx)
	case device.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case device.FieldState:
		return m.OldState(ctx)
	case device.FieldSumCep:
		return m.OldSumCep(ctx)
	case device.FieldLinking:
		return m.OldLinking(ctx)
	case device.FieldBindingStatus:
		return m.OldBindingStatus(ctx)
	case device.FieldStatus:
		return m.OldStatus(ctx)
	case device.FieldName:
		return m.OldName(ctx)
	case device.FieldType:
		return m.OldType(ctx)
	case device.FieldCoresNumber:
		return m.OldCoresNumber(ctx)
	case device.FieldCPU:
		return m.OldCPU(ctx)
	case device.FieldCpus:
		return m.OldCpus(ctx)
	case device.FieldMemory:
		return m.OldMemory(ctx)
	case device.FieldDisk:
		return m.OldDisk(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case device.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case device.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case device.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case device.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case device.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case device.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case device.FieldState:
		v, ok := value.(device.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case device.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumCep(v)
		return nil
	case device.FieldLinking:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinking(v)
		return nil
	case device.FieldBindingStatus:
		v, ok := value.(enums.DeviceBindingStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindingStatus(v)
		return nil
	case device.FieldStatus:
		v, ok := value.(device.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case device.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case device.FieldType:
		v, ok := value.(enums.DeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case device.FieldCoresNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoresNumber(v)
		return nil
	case device.FieldCPU:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPU(v)
		return nil
	case device.FieldCpus:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCpus(v)
		return nil
	case device.FieldMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case device.FieldDisk:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisk(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, device.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, device.FieldUpdatedBy)
	}
	if m.addsum_cep != nil {
		fields = append(fields, device.FieldSumCep)
	}
	if m.addcores_number != nil {
		fields = append(fields, device.FieldCoresNumber)
	}
	if m.addmemory != nil {
		fields = append(fields, device.FieldMemory)
	}
	if m.adddisk != nil {
		fields = append(fields, device.FieldDisk)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedBy:
		return m.AddedCreatedBy()
	case device.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case device.FieldSumCep:
		return m.AddedSumCep()
	case device.FieldCoresNumber:
		return m.AddedCoresNumber()
	case device.FieldMemory:
		return m.AddedMemory()
	case device.FieldDisk:
		return m.AddedDisk()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case device.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case device.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumCep(v)
		return nil
	case device.FieldCoresNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoresNumber(v)
		return nil
	case device.FieldMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemory(v)
		return nil
	case device.FieldDisk:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisk(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldCpus) {
		fields = append(fields, device.FieldCpus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldCpus:
		m.ClearCpus()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case device.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case device.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case device.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case device.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case device.FieldUserID:
		m.ResetUserID()
		return nil
	case device.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case device.FieldState:
		m.ResetState()
		return nil
	case device.FieldSumCep:
		m.ResetSumCep()
		return nil
	case device.FieldLinking:
		m.ResetLinking()
		return nil
	case device.FieldBindingStatus:
		m.ResetBindingStatus()
		return nil
	case device.FieldStatus:
		m.ResetStatus()
		return nil
	case device.FieldName:
		m.ResetName()
		return nil
	case device.FieldType:
		m.ResetType()
		return nil
	case device.FieldCoresNumber:
		m.ResetCoresNumber()
		return nil
	case device.FieldCPU:
		m.ResetCPU()
		return nil
	case device.FieldCpus:
		m.ResetCpus()
		return nil
	case device.FieldMemory:
		m.ResetMemory()
		return nil
	case device.FieldDisk:
		m.ResetDisk()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.user != nil {
		edges = append(edges, device.EdgeUser)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, device.EdgeMissionProduceOrders)
	}
	if m.user_devices != nil {
		edges = append(edges, device.EdgeUserDevices)
	}
	if m.device_gpu_missions != nil {
		edges = append(edges, device.EdgeDeviceGpuMissions)
	}
	if m.frpc_infos != nil {
		edges = append(edges, device.EdgeFrpcInfos)
	}
	if m.mission_orders != nil {
		edges = append(edges, device.EdgeMissionOrders)
	}
	if m.mission_productions != nil {
		edges = append(edges, device.EdgeMissionProductions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.user_devices))
		for id := range m.user_devices {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.device_gpu_missions))
		for id := range m.device_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeFrpcInfos:
		ids := make([]ent.Value, 0, len(m.frpc_infos))
		for id := range m.frpc_infos {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.mission_orders))
		for id := range m.mission_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.mission_productions))
		for id := range m.mission_productions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmission_produce_orders != nil {
		edges = append(edges, device.EdgeMissionProduceOrders)
	}
	if m.removeduser_devices != nil {
		edges = append(edges, device.EdgeUserDevices)
	}
	if m.removeddevice_gpu_missions != nil {
		edges = append(edges, device.EdgeDeviceGpuMissions)
	}
	if m.removedfrpc_infos != nil {
		edges = append(edges, device.EdgeFrpcInfos)
	}
	if m.removedmission_orders != nil {
		edges = append(edges, device.EdgeMissionOrders)
	}
	if m.removedmission_productions != nil {
		edges = append(edges, device.EdgeMissionProductions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.removeduser_devices))
		for id := range m.removeduser_devices {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.removeddevice_gpu_missions))
		for id := range m.removeddevice_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeFrpcInfos:
		ids := make([]ent.Value, 0, len(m.removedfrpc_infos))
		for id := range m.removedfrpc_infos {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_orders))
		for id := range m.removedmission_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.removedmission_productions))
		for id := range m.removedmission_productions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareduser {
		edges = append(edges, device.EdgeUser)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, device.EdgeMissionProduceOrders)
	}
	if m.cleareduser_devices {
		edges = append(edges, device.EdgeUserDevices)
	}
	if m.cleareddevice_gpu_missions {
		edges = append(edges, device.EdgeDeviceGpuMissions)
	}
	if m.clearedfrpc_infos {
		edges = append(edges, device.EdgeFrpcInfos)
	}
	if m.clearedmission_orders {
		edges = append(edges, device.EdgeMissionOrders)
	}
	if m.clearedmission_productions {
		edges = append(edges, device.EdgeMissionProductions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeUser:
		return m.cleareduser
	case device.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case device.EdgeUserDevices:
		return m.cleareduser_devices
	case device.EdgeDeviceGpuMissions:
		return m.cleareddevice_gpu_missions
	case device.EdgeFrpcInfos:
		return m.clearedfrpc_infos
	case device.EdgeMissionOrders:
		return m.clearedmission_orders
	case device.EdgeMissionProductions:
		return m.clearedmission_productions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ResetUser()
		return nil
	case device.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case device.EdgeUserDevices:
		m.ResetUserDevices()
		return nil
	case device.EdgeDeviceGpuMissions:
		m.ResetDeviceGpuMissions()
		return nil
	case device.EdgeFrpcInfos:
		m.ResetFrpcInfos()
		return nil
	case device.EdgeMissionOrders:
		m.ResetMissionOrders()
		return nil
	case device.EdgeMissionProductions:
		m.ResetMissionProductions()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DeviceGpuMissionMutation represents an operation that mutates the DeviceGpuMission nodes in the graph.
type DeviceGpuMissionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	able_mission_kind     *[]string
	device_slot           *int8
	adddevice_slot        *int8
	max_online_mission    *int8
	addmax_online_mission *int8
	gpu_status            *enums.GpuStatus
	mission_id            *[]int64
	clearedFields         map[string]struct{}
	device                *int64
	cleareddevice         bool
	gpu                   *int64
	clearedgpu            bool
	done                  bool
	oldValue              func(context.Context) (*DeviceGpuMission, error)
	predicates            []predicate.DeviceGpuMission
}

var _ ent.Mutation = (*DeviceGpuMissionMutation)(nil)

// devicegpumissionOption allows management of the mutation configuration using functional options.
type devicegpumissionOption func(*DeviceGpuMissionMutation)

// newDeviceGpuMissionMutation creates new mutation for the DeviceGpuMission entity.
func newDeviceGpuMissionMutation(c config, op Op, opts ...devicegpumissionOption) *DeviceGpuMissionMutation {
	m := &DeviceGpuMissionMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceGpuMission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceGpuMissionID sets the ID field of the mutation.
func withDeviceGpuMissionID(id int64) devicegpumissionOption {
	return func(m *DeviceGpuMissionMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceGpuMission
		)
		m.oldValue = func(ctx context.Context) (*DeviceGpuMission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceGpuMission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceGpuMission sets the old DeviceGpuMission of the mutation.
func withDeviceGpuMission(node *DeviceGpuMission) devicegpumissionOption {
	return func(m *DeviceGpuMissionMutation) {
		m.oldValue = func(context.Context) (*DeviceGpuMission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceGpuMissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceGpuMissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceGpuMission entities.
func (m *DeviceGpuMissionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceGpuMissionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceGpuMissionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceGpuMission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceGpuMissionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceGpuMissionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeviceGpuMissionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceGpuMissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceGpuMissionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceGpuMissionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeviceGpuMissionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceGpuMissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceGpuMissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceGpuMissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceGpuMissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceGpuMissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceGpuMissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceGpuMissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceGpuMissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceGpuMissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceGpuMissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceGpuMissionMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceGpuMissionMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceGpuMissionMutation) ResetDeviceID() {
	m.device = nil
}

// SetGpuID sets the "gpu_id" field.
func (m *DeviceGpuMissionMutation) SetGpuID(i int64) {
	m.gpu = &i
}

// GpuID returns the value of the "gpu_id" field in the mutation.
func (m *DeviceGpuMissionMutation) GpuID() (r int64, exists bool) {
	v := m.gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuID returns the old "gpu_id" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldGpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuID: %w", err)
	}
	return oldValue.GpuID, nil
}

// ResetGpuID resets all changes to the "gpu_id" field.
func (m *DeviceGpuMissionMutation) ResetGpuID() {
	m.gpu = nil
}

// SetAbleMissionKind sets the "able_mission_kind" field.
func (m *DeviceGpuMissionMutation) SetAbleMissionKind(s []string) {
	m.able_mission_kind = &s
}

// AbleMissionKind returns the value of the "able_mission_kind" field in the mutation.
func (m *DeviceGpuMissionMutation) AbleMissionKind() (r []string, exists bool) {
	v := m.able_mission_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldAbleMissionKind returns the old "able_mission_kind" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldAbleMissionKind(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbleMissionKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbleMissionKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbleMissionKind: %w", err)
	}
	return oldValue.AbleMissionKind, nil
}

// ClearAbleMissionKind clears the value of the "able_mission_kind" field.
func (m *DeviceGpuMissionMutation) ClearAbleMissionKind() {
	m.able_mission_kind = nil
	m.clearedFields[devicegpumission.FieldAbleMissionKind] = struct{}{}
}

// AbleMissionKindCleared returns if the "able_mission_kind" field was cleared in this mutation.
func (m *DeviceGpuMissionMutation) AbleMissionKindCleared() bool {
	_, ok := m.clearedFields[devicegpumission.FieldAbleMissionKind]
	return ok
}

// ResetAbleMissionKind resets all changes to the "able_mission_kind" field.
func (m *DeviceGpuMissionMutation) ResetAbleMissionKind() {
	m.able_mission_kind = nil
	delete(m.clearedFields, devicegpumission.FieldAbleMissionKind)
}

// SetDeviceSlot sets the "device_slot" field.
func (m *DeviceGpuMissionMutation) SetDeviceSlot(i int8) {
	m.device_slot = &i
	m.adddevice_slot = nil
}

// DeviceSlot returns the value of the "device_slot" field in the mutation.
func (m *DeviceGpuMissionMutation) DeviceSlot() (r int8, exists bool) {
	v := m.device_slot
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceSlot returns the old "device_slot" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldDeviceSlot(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceSlot: %w", err)
	}
	return oldValue.DeviceSlot, nil
}

// AddDeviceSlot adds i to the "device_slot" field.
func (m *DeviceGpuMissionMutation) AddDeviceSlot(i int8) {
	if m.adddevice_slot != nil {
		*m.adddevice_slot += i
	} else {
		m.adddevice_slot = &i
	}
}

// AddedDeviceSlot returns the value that was added to the "device_slot" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedDeviceSlot() (r int8, exists bool) {
	v := m.adddevice_slot
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceSlot resets all changes to the "device_slot" field.
func (m *DeviceGpuMissionMutation) ResetDeviceSlot() {
	m.device_slot = nil
	m.adddevice_slot = nil
}

// SetMaxOnlineMission sets the "max_online_mission" field.
func (m *DeviceGpuMissionMutation) SetMaxOnlineMission(i int8) {
	m.max_online_mission = &i
	m.addmax_online_mission = nil
}

// MaxOnlineMission returns the value of the "max_online_mission" field in the mutation.
func (m *DeviceGpuMissionMutation) MaxOnlineMission() (r int8, exists bool) {
	v := m.max_online_mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxOnlineMission returns the old "max_online_mission" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldMaxOnlineMission(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxOnlineMission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxOnlineMission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxOnlineMission: %w", err)
	}
	return oldValue.MaxOnlineMission, nil
}

// AddMaxOnlineMission adds i to the "max_online_mission" field.
func (m *DeviceGpuMissionMutation) AddMaxOnlineMission(i int8) {
	if m.addmax_online_mission != nil {
		*m.addmax_online_mission += i
	} else {
		m.addmax_online_mission = &i
	}
}

// AddedMaxOnlineMission returns the value that was added to the "max_online_mission" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedMaxOnlineMission() (r int8, exists bool) {
	v := m.addmax_online_mission
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxOnlineMission resets all changes to the "max_online_mission" field.
func (m *DeviceGpuMissionMutation) ResetMaxOnlineMission() {
	m.max_online_mission = nil
	m.addmax_online_mission = nil
}

// SetGpuStatus sets the "gpu_status" field.
func (m *DeviceGpuMissionMutation) SetGpuStatus(es enums.GpuStatus) {
	m.gpu_status = &es
}

// GpuStatus returns the value of the "gpu_status" field in the mutation.
func (m *DeviceGpuMissionMutation) GpuStatus() (r enums.GpuStatus, exists bool) {
	v := m.gpu_status
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuStatus returns the old "gpu_status" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldGpuStatus(ctx context.Context) (v enums.GpuStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuStatus: %w", err)
	}
	return oldValue.GpuStatus, nil
}

// ResetGpuStatus resets all changes to the "gpu_status" field.
func (m *DeviceGpuMissionMutation) ResetGpuStatus() {
	m.gpu_status = nil
}

// SetMissionID sets the "mission_id" field.
func (m *DeviceGpuMissionMutation) SetMissionID(i []int64) {
	m.mission_id = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *DeviceGpuMissionMutation) MissionID() (r []int64, exists bool) {
	v := m.mission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldMissionID(ctx context.Context) (v []int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ClearMissionID clears the value of the "mission_id" field.
func (m *DeviceGpuMissionMutation) ClearMissionID() {
	m.mission_id = nil
	m.clearedFields[devicegpumission.FieldMissionID] = struct{}{}
}

// MissionIDCleared returns if the "mission_id" field was cleared in this mutation.
func (m *DeviceGpuMissionMutation) MissionIDCleared() bool {
	_, ok := m.clearedFields[devicegpumission.FieldMissionID]
	return ok
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *DeviceGpuMissionMutation) ResetMissionID() {
	m.mission_id = nil
	delete(m.clearedFields, devicegpumission.FieldMissionID)
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *DeviceGpuMissionMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[devicegpumission.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *DeviceGpuMissionMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceGpuMissionMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceGpuMissionMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// ClearGpu clears the "gpu" edge to the Gpu entity.
func (m *DeviceGpuMissionMutation) ClearGpu() {
	m.clearedgpu = true
	m.clearedFields[devicegpumission.FieldGpuID] = struct{}{}
}

// GpuCleared reports if the "gpu" edge to the Gpu entity was cleared.
func (m *DeviceGpuMissionMutation) GpuCleared() bool {
	return m.clearedgpu
}

// GpuIDs returns the "gpu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GpuID instead. It exists only for internal usage by the builders.
func (m *DeviceGpuMissionMutation) GpuIDs() (ids []int64) {
	if id := m.gpu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGpu resets all changes to the "gpu" edge.
func (m *DeviceGpuMissionMutation) ResetGpu() {
	m.gpu = nil
	m.clearedgpu = false
}

// Where appends a list predicates to the DeviceGpuMissionMutation builder.
func (m *DeviceGpuMissionMutation) Where(ps ...predicate.DeviceGpuMission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceGpuMissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceGpuMissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceGpuMission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceGpuMissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceGpuMissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceGpuMission).
func (m *DeviceGpuMissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceGpuMissionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, devicegpumission.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, devicegpumission.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, devicegpumission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicegpumission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, devicegpumission.FieldDeletedAt)
	}
	if m.device != nil {
		fields = append(fields, devicegpumission.FieldDeviceID)
	}
	if m.gpu != nil {
		fields = append(fields, devicegpumission.FieldGpuID)
	}
	if m.able_mission_kind != nil {
		fields = append(fields, devicegpumission.FieldAbleMissionKind)
	}
	if m.device_slot != nil {
		fields = append(fields, devicegpumission.FieldDeviceSlot)
	}
	if m.max_online_mission != nil {
		fields = append(fields, devicegpumission.FieldMaxOnlineMission)
	}
	if m.gpu_status != nil {
		fields = append(fields, devicegpumission.FieldGpuStatus)
	}
	if m.mission_id != nil {
		fields = append(fields, devicegpumission.FieldMissionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceGpuMissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicegpumission.FieldCreatedBy:
		return m.CreatedBy()
	case devicegpumission.FieldUpdatedBy:
		return m.UpdatedBy()
	case devicegpumission.FieldCreatedAt:
		return m.CreatedAt()
	case devicegpumission.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicegpumission.FieldDeletedAt:
		return m.DeletedAt()
	case devicegpumission.FieldDeviceID:
		return m.DeviceID()
	case devicegpumission.FieldGpuID:
		return m.GpuID()
	case devicegpumission.FieldAbleMissionKind:
		return m.AbleMissionKind()
	case devicegpumission.FieldDeviceSlot:
		return m.DeviceSlot()
	case devicegpumission.FieldMaxOnlineMission:
		return m.MaxOnlineMission()
	case devicegpumission.FieldGpuStatus:
		return m.GpuStatus()
	case devicegpumission.FieldMissionID:
		return m.MissionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceGpuMissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicegpumission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case devicegpumission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case devicegpumission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicegpumission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicegpumission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case devicegpumission.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case devicegpumission.FieldGpuID:
		return m.OldGpuID(ctx)
	case devicegpumission.FieldAbleMissionKind:
		return m.OldAbleMissionKind(ctx)
	case devicegpumission.FieldDeviceSlot:
		return m.OldDeviceSlot(ctx)
	case devicegpumission.FieldMaxOnlineMission:
		return m.OldMaxOnlineMission(ctx)
	case devicegpumission.FieldGpuStatus:
		return m.OldGpuStatus(ctx)
	case devicegpumission.FieldMissionID:
		return m.OldMissionID(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceGpuMission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceGpuMissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicegpumission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case devicegpumission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case devicegpumission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicegpumission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicegpumission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case devicegpumission.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case devicegpumission.FieldGpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuID(v)
		return nil
	case devicegpumission.FieldAbleMissionKind:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbleMissionKind(v)
		return nil
	case devicegpumission.FieldDeviceSlot:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceSlot(v)
		return nil
	case devicegpumission.FieldMaxOnlineMission:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxOnlineMission(v)
		return nil
	case devicegpumission.FieldGpuStatus:
		v, ok := value.(enums.GpuStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuStatus(v)
		return nil
	case devicegpumission.FieldMissionID:
		v, ok := value.([]int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceGpuMissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, devicegpumission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, devicegpumission.FieldUpdatedBy)
	}
	if m.adddevice_slot != nil {
		fields = append(fields, devicegpumission.FieldDeviceSlot)
	}
	if m.addmax_online_mission != nil {
		fields = append(fields, devicegpumission.FieldMaxOnlineMission)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceGpuMissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicegpumission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case devicegpumission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case devicegpumission.FieldDeviceSlot:
		return m.AddedDeviceSlot()
	case devicegpumission.FieldMaxOnlineMission:
		return m.AddedMaxOnlineMission()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceGpuMissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicegpumission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case devicegpumission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case devicegpumission.FieldDeviceSlot:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceSlot(v)
		return nil
	case devicegpumission.FieldMaxOnlineMission:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxOnlineMission(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceGpuMissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicegpumission.FieldAbleMissionKind) {
		fields = append(fields, devicegpumission.FieldAbleMissionKind)
	}
	if m.FieldCleared(devicegpumission.FieldMissionID) {
		fields = append(fields, devicegpumission.FieldMissionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceGpuMissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceGpuMissionMutation) ClearField(name string) error {
	switch name {
	case devicegpumission.FieldAbleMissionKind:
		m.ClearAbleMissionKind()
		return nil
	case devicegpumission.FieldMissionID:
		m.ClearMissionID()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceGpuMissionMutation) ResetField(name string) error {
	switch name {
	case devicegpumission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case devicegpumission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case devicegpumission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicegpumission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicegpumission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case devicegpumission.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case devicegpumission.FieldGpuID:
		m.ResetGpuID()
		return nil
	case devicegpumission.FieldAbleMissionKind:
		m.ResetAbleMissionKind()
		return nil
	case devicegpumission.FieldDeviceSlot:
		m.ResetDeviceSlot()
		return nil
	case devicegpumission.FieldMaxOnlineMission:
		m.ResetMaxOnlineMission()
		return nil
	case devicegpumission.FieldGpuStatus:
		m.ResetGpuStatus()
		return nil
	case devicegpumission.FieldMissionID:
		m.ResetMissionID()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceGpuMissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.device != nil {
		edges = append(edges, devicegpumission.EdgeDevice)
	}
	if m.gpu != nil {
		edges = append(edges, devicegpumission.EdgeGpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceGpuMissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicegpumission.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case devicegpumission.EdgeGpu:
		if id := m.gpu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceGpuMissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceGpuMissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceGpuMissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddevice {
		edges = append(edges, devicegpumission.EdgeDevice)
	}
	if m.clearedgpu {
		edges = append(edges, devicegpumission.EdgeGpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceGpuMissionMutation) EdgeCleared(name string) bool {
	switch name {
	case devicegpumission.EdgeDevice:
		return m.cleareddevice
	case devicegpumission.EdgeGpu:
		return m.clearedgpu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceGpuMissionMutation) ClearEdge(name string) error {
	switch name {
	case devicegpumission.EdgeDevice:
		m.ClearDevice()
		return nil
	case devicegpumission.EdgeGpu:
		m.ClearGpu()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceGpuMissionMutation) ResetEdge(name string) error {
	switch name {
	case devicegpumission.EdgeDevice:
		m.ResetDevice()
		return nil
	case devicegpumission.EdgeGpu:
		m.ResetGpu()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission edge %s", name)
}

// EarnBillMutation represents an operation that mutates the EarnBill nodes in the graph.
type EarnBillMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	_type                         *earnbill.Type
	is_minus                      *bool
	serial_number                 *string
	pure_cep                      *int64
	addpure_cep                   *int64
	gift_cep                      *int64
	addgift_cep                   *int64
	platform_pure_cep             *int64
	addplatform_pure_cep          *int64
	platform_gift_cep             *int64
	addplatform_gift_cep          *int64
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	profit_account                *int64
	clearedprofit_account         bool
	platform_account              *int64
	clearedplatform_account       bool
	mission_produce_orders        *int64
	clearedmission_produce_orders bool
	done                          bool
	oldValue                      func(context.Context) (*EarnBill, error)
	predicates                    []predicate.EarnBill
}

var _ ent.Mutation = (*EarnBillMutation)(nil)

// earnbillOption allows management of the mutation configuration using functional options.
type earnbillOption func(*EarnBillMutation)

// newEarnBillMutation creates new mutation for the EarnBill entity.
func newEarnBillMutation(c config, op Op, opts ...earnbillOption) *EarnBillMutation {
	m := &EarnBillMutation{
		config:        c,
		op:            op,
		typ:           TypeEarnBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEarnBillID sets the ID field of the mutation.
func withEarnBillID(id int64) earnbillOption {
	return func(m *EarnBillMutation) {
		var (
			err   error
			once  sync.Once
			value *EarnBill
		)
		m.oldValue = func(ctx context.Context) (*EarnBill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EarnBill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEarnBill sets the old EarnBill of the mutation.
func withEarnBill(node *EarnBill) earnbillOption {
	return func(m *EarnBillMutation) {
		m.oldValue = func(context.Context) (*EarnBill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EarnBillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EarnBillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EarnBill entities.
func (m *EarnBillMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EarnBillMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EarnBillMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EarnBill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *EarnBillMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EarnBillMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EarnBillMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EarnBillMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EarnBillMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EarnBillMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EarnBillMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EarnBillMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EarnBillMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EarnBillMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EarnBillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EarnBillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EarnBillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EarnBillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EarnBillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EarnBillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EarnBillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EarnBillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EarnBillMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *EarnBillMutation) SetType(e earnbill.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *EarnBillMutation) GetType() (r earnbill.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldType(ctx context.Context) (v earnbill.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EarnBillMutation) ResetType() {
	m._type = nil
}

// SetIsMinus sets the "is_minus" field.
func (m *EarnBillMutation) SetIsMinus(b bool) {
	m.is_minus = &b
}

// IsMinus returns the value of the "is_minus" field in the mutation.
func (m *EarnBillMutation) IsMinus() (r bool, exists bool) {
	v := m.is_minus
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMinus returns the old "is_minus" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldIsMinus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMinus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMinus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMinus: %w", err)
	}
	return oldValue.IsMinus, nil
}

// ResetIsMinus resets all changes to the "is_minus" field.
func (m *EarnBillMutation) ResetIsMinus() {
	m.is_minus = nil
}

// SetUserID sets the "user_id" field.
func (m *EarnBillMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EarnBillMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EarnBillMutation) ResetUserID() {
	m.user = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *EarnBillMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *EarnBillMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *EarnBillMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetProfitAccountID sets the "profit_account_id" field.
func (m *EarnBillMutation) SetProfitAccountID(i int64) {
	m.profit_account = &i
}

// ProfitAccountID returns the value of the "profit_account_id" field in the mutation.
func (m *EarnBillMutation) ProfitAccountID() (r int64, exists bool) {
	v := m.profit_account
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAccountID returns the old "profit_account_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldProfitAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAccountID: %w", err)
	}
	return oldValue.ProfitAccountID, nil
}

// ResetProfitAccountID resets all changes to the "profit_account_id" field.
func (m *EarnBillMutation) ResetProfitAccountID() {
	m.profit_account = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *EarnBillMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *EarnBillMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *EarnBillMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *EarnBillMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *EarnBillMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *EarnBillMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *EarnBillMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *EarnBillMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *EarnBillMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *EarnBillMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetPlatformAccountID sets the "platform_account_id" field.
func (m *EarnBillMutation) SetPlatformAccountID(i int64) {
	m.platform_account = &i
}

// PlatformAccountID returns the value of the "platform_account_id" field in the mutation.
func (m *EarnBillMutation) PlatformAccountID() (r int64, exists bool) {
	v := m.platform_account
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformAccountID returns the old "platform_account_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPlatformAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformAccountID: %w", err)
	}
	return oldValue.PlatformAccountID, nil
}

// ResetPlatformAccountID resets all changes to the "platform_account_id" field.
func (m *EarnBillMutation) ResetPlatformAccountID() {
	m.platform_account = nil
}

// SetPlatformPureCep sets the "platform_pure_cep" field.
func (m *EarnBillMutation) SetPlatformPureCep(i int64) {
	m.platform_pure_cep = &i
	m.addplatform_pure_cep = nil
}

// PlatformPureCep returns the value of the "platform_pure_cep" field in the mutation.
func (m *EarnBillMutation) PlatformPureCep() (r int64, exists bool) {
	v := m.platform_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformPureCep returns the old "platform_pure_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPlatformPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformPureCep: %w", err)
	}
	return oldValue.PlatformPureCep, nil
}

// AddPlatformPureCep adds i to the "platform_pure_cep" field.
func (m *EarnBillMutation) AddPlatformPureCep(i int64) {
	if m.addplatform_pure_cep != nil {
		*m.addplatform_pure_cep += i
	} else {
		m.addplatform_pure_cep = &i
	}
}

// AddedPlatformPureCep returns the value that was added to the "platform_pure_cep" field in this mutation.
func (m *EarnBillMutation) AddedPlatformPureCep() (r int64, exists bool) {
	v := m.addplatform_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformPureCep resets all changes to the "platform_pure_cep" field.
func (m *EarnBillMutation) ResetPlatformPureCep() {
	m.platform_pure_cep = nil
	m.addplatform_pure_cep = nil
}

// SetPlatformGiftCep sets the "platform_gift_cep" field.
func (m *EarnBillMutation) SetPlatformGiftCep(i int64) {
	m.platform_gift_cep = &i
	m.addplatform_gift_cep = nil
}

// PlatformGiftCep returns the value of the "platform_gift_cep" field in the mutation.
func (m *EarnBillMutation) PlatformGiftCep() (r int64, exists bool) {
	v := m.platform_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformGiftCep returns the old "platform_gift_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPlatformGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformGiftCep: %w", err)
	}
	return oldValue.PlatformGiftCep, nil
}

// AddPlatformGiftCep adds i to the "platform_gift_cep" field.
func (m *EarnBillMutation) AddPlatformGiftCep(i int64) {
	if m.addplatform_gift_cep != nil {
		*m.addplatform_gift_cep += i
	} else {
		m.addplatform_gift_cep = &i
	}
}

// AddedPlatformGiftCep returns the value that was added to the "platform_gift_cep" field in this mutation.
func (m *EarnBillMutation) AddedPlatformGiftCep() (r int64, exists bool) {
	v := m.addplatform_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformGiftCep resets all changes to the "platform_gift_cep" field.
func (m *EarnBillMutation) ResetPlatformGiftCep() {
	m.platform_gift_cep = nil
	m.addplatform_gift_cep = nil
}

// SetReasonID sets the "reason_id" field.
func (m *EarnBillMutation) SetReasonID(i int64) {
	m.mission_produce_orders = &i
}

// ReasonID returns the value of the "reason_id" field in the mutation.
func (m *EarnBillMutation) ReasonID() (r int64, exists bool) {
	v := m.mission_produce_orders
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonID returns the old "reason_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldReasonID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonID: %w", err)
	}
	return oldValue.ReasonID, nil
}

// ClearReasonID clears the value of the "reason_id" field.
func (m *EarnBillMutation) ClearReasonID() {
	m.mission_produce_orders = nil
	m.clearedFields[earnbill.FieldReasonID] = struct{}{}
}

// ReasonIDCleared returns if the "reason_id" field was cleared in this mutation.
func (m *EarnBillMutation) ReasonIDCleared() bool {
	_, ok := m.clearedFields[earnbill.FieldReasonID]
	return ok
}

// ResetReasonID resets all changes to the "reason_id" field.
func (m *EarnBillMutation) ResetReasonID() {
	m.mission_produce_orders = nil
	delete(m.clearedFields, earnbill.FieldReasonID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *EarnBillMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[earnbill.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EarnBillMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EarnBillMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProfitAccount clears the "profit_account" edge to the ProfitAccount entity.
func (m *EarnBillMutation) ClearProfitAccount() {
	m.clearedprofit_account = true
	m.clearedFields[earnbill.FieldProfitAccountID] = struct{}{}
}

// ProfitAccountCleared reports if the "profit_account" edge to the ProfitAccount entity was cleared.
func (m *EarnBillMutation) ProfitAccountCleared() bool {
	return m.clearedprofit_account
}

// ProfitAccountIDs returns the "profit_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfitAccountID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) ProfitAccountIDs() (ids []int64) {
	if id := m.profit_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfitAccount resets all changes to the "profit_account" edge.
func (m *EarnBillMutation) ResetProfitAccount() {
	m.profit_account = nil
	m.clearedprofit_account = false
}

// ClearPlatformAccount clears the "platform_account" edge to the PlatformAccount entity.
func (m *EarnBillMutation) ClearPlatformAccount() {
	m.clearedplatform_account = true
	m.clearedFields[earnbill.FieldPlatformAccountID] = struct{}{}
}

// PlatformAccountCleared reports if the "platform_account" edge to the PlatformAccount entity was cleared.
func (m *EarnBillMutation) PlatformAccountCleared() bool {
	return m.clearedplatform_account
}

// PlatformAccountIDs returns the "platform_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlatformAccountID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) PlatformAccountIDs() (ids []int64) {
	if id := m.platform_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlatformAccount resets all changes to the "platform_account" edge.
func (m *EarnBillMutation) ResetPlatformAccount() {
	m.platform_account = nil
	m.clearedplatform_account = false
}

// SetMissionProduceOrdersID sets the "mission_produce_orders" edge to the MissionProduceOrder entity by id.
func (m *EarnBillMutation) SetMissionProduceOrdersID(id int64) {
	m.mission_produce_orders = &id
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *EarnBillMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
	m.clearedFields[earnbill.FieldReasonID] = struct{}{}
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *EarnBillMutation) MissionProduceOrdersCleared() bool {
	return m.ReasonIDCleared() || m.clearedmission_produce_orders
}

// MissionProduceOrdersID returns the "mission_produce_orders" edge ID in the mutation.
func (m *EarnBillMutation) MissionProduceOrdersID() (id int64, exists bool) {
	if m.mission_produce_orders != nil {
		return *m.mission_produce_orders, true
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionProduceOrdersID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) MissionProduceOrdersIDs() (ids []int64) {
	if id := m.mission_produce_orders; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *EarnBillMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
}

// Where appends a list predicates to the EarnBillMutation builder.
func (m *EarnBillMutation) Where(ps ...predicate.EarnBill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EarnBillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EarnBillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EarnBill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EarnBillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EarnBillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EarnBill).
func (m *EarnBillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EarnBillMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, earnbill.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, earnbill.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, earnbill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, earnbill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, earnbill.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, earnbill.FieldType)
	}
	if m.is_minus != nil {
		fields = append(fields, earnbill.FieldIsMinus)
	}
	if m.user != nil {
		fields = append(fields, earnbill.FieldUserID)
	}
	if m.serial_number != nil {
		fields = append(fields, earnbill.FieldSerialNumber)
	}
	if m.profit_account != nil {
		fields = append(fields, earnbill.FieldProfitAccountID)
	}
	if m.pure_cep != nil {
		fields = append(fields, earnbill.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, earnbill.FieldGiftCep)
	}
	if m.platform_account != nil {
		fields = append(fields, earnbill.FieldPlatformAccountID)
	}
	if m.platform_pure_cep != nil {
		fields = append(fields, earnbill.FieldPlatformPureCep)
	}
	if m.platform_gift_cep != nil {
		fields = append(fields, earnbill.FieldPlatformGiftCep)
	}
	if m.mission_produce_orders != nil {
		fields = append(fields, earnbill.FieldReasonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EarnBillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case earnbill.FieldCreatedBy:
		return m.CreatedBy()
	case earnbill.FieldUpdatedBy:
		return m.UpdatedBy()
	case earnbill.FieldCreatedAt:
		return m.CreatedAt()
	case earnbill.FieldUpdatedAt:
		return m.UpdatedAt()
	case earnbill.FieldDeletedAt:
		return m.DeletedAt()
	case earnbill.FieldType:
		return m.GetType()
	case earnbill.FieldIsMinus:
		return m.IsMinus()
	case earnbill.FieldUserID:
		return m.UserID()
	case earnbill.FieldSerialNumber:
		return m.SerialNumber()
	case earnbill.FieldProfitAccountID:
		return m.ProfitAccountID()
	case earnbill.FieldPureCep:
		return m.PureCep()
	case earnbill.FieldGiftCep:
		return m.GiftCep()
	case earnbill.FieldPlatformAccountID:
		return m.PlatformAccountID()
	case earnbill.FieldPlatformPureCep:
		return m.PlatformPureCep()
	case earnbill.FieldPlatformGiftCep:
		return m.PlatformGiftCep()
	case earnbill.FieldReasonID:
		return m.ReasonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EarnBillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case earnbill.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case earnbill.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case earnbill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case earnbill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case earnbill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case earnbill.FieldType:
		return m.OldType(ctx)
	case earnbill.FieldIsMinus:
		return m.OldIsMinus(ctx)
	case earnbill.FieldUserID:
		return m.OldUserID(ctx)
	case earnbill.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case earnbill.FieldProfitAccountID:
		return m.OldProfitAccountID(ctx)
	case earnbill.FieldPureCep:
		return m.OldPureCep(ctx)
	case earnbill.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case earnbill.FieldPlatformAccountID:
		return m.OldPlatformAccountID(ctx)
	case earnbill.FieldPlatformPureCep:
		return m.OldPlatformPureCep(ctx)
	case earnbill.FieldPlatformGiftCep:
		return m.OldPlatformGiftCep(ctx)
	case earnbill.FieldReasonID:
		return m.OldReasonID(ctx)
	}
	return nil, fmt.Errorf("unknown EarnBill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarnBillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case earnbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case earnbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case earnbill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case earnbill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case earnbill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case earnbill.FieldType:
		v, ok := value.(earnbill.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case earnbill.FieldIsMinus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMinus(v)
		return nil
	case earnbill.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case earnbill.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case earnbill.FieldProfitAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAccountID(v)
		return nil
	case earnbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case earnbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case earnbill.FieldPlatformAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformAccountID(v)
		return nil
	case earnbill.FieldPlatformPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformPureCep(v)
		return nil
	case earnbill.FieldPlatformGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformGiftCep(v)
		return nil
	case earnbill.FieldReasonID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonID(v)
		return nil
	}
	return fmt.Errorf("unknown EarnBill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EarnBillMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, earnbill.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, earnbill.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, earnbill.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, earnbill.FieldGiftCep)
	}
	if m.addplatform_pure_cep != nil {
		fields = append(fields, earnbill.FieldPlatformPureCep)
	}
	if m.addplatform_gift_cep != nil {
		fields = append(fields, earnbill.FieldPlatformGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EarnBillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case earnbill.FieldCreatedBy:
		return m.AddedCreatedBy()
	case earnbill.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case earnbill.FieldPureCep:
		return m.AddedPureCep()
	case earnbill.FieldGiftCep:
		return m.AddedGiftCep()
	case earnbill.FieldPlatformPureCep:
		return m.AddedPlatformPureCep()
	case earnbill.FieldPlatformGiftCep:
		return m.AddedPlatformGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarnBillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case earnbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case earnbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case earnbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case earnbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case earnbill.FieldPlatformPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatformPureCep(v)
		return nil
	case earnbill.FieldPlatformGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatformGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown EarnBill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EarnBillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(earnbill.FieldReasonID) {
		fields = append(fields, earnbill.FieldReasonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EarnBillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EarnBillMutation) ClearField(name string) error {
	switch name {
	case earnbill.FieldReasonID:
		m.ClearReasonID()
		return nil
	}
	return fmt.Errorf("unknown EarnBill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EarnBillMutation) ResetField(name string) error {
	switch name {
	case earnbill.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case earnbill.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case earnbill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case earnbill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case earnbill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case earnbill.FieldType:
		m.ResetType()
		return nil
	case earnbill.FieldIsMinus:
		m.ResetIsMinus()
		return nil
	case earnbill.FieldUserID:
		m.ResetUserID()
		return nil
	case earnbill.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case earnbill.FieldProfitAccountID:
		m.ResetProfitAccountID()
		return nil
	case earnbill.FieldPureCep:
		m.ResetPureCep()
		return nil
	case earnbill.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case earnbill.FieldPlatformAccountID:
		m.ResetPlatformAccountID()
		return nil
	case earnbill.FieldPlatformPureCep:
		m.ResetPlatformPureCep()
		return nil
	case earnbill.FieldPlatformGiftCep:
		m.ResetPlatformGiftCep()
		return nil
	case earnbill.FieldReasonID:
		m.ResetReasonID()
		return nil
	}
	return fmt.Errorf("unknown EarnBill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EarnBillMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, earnbill.EdgeUser)
	}
	if m.profit_account != nil {
		edges = append(edges, earnbill.EdgeProfitAccount)
	}
	if m.platform_account != nil {
		edges = append(edges, earnbill.EdgePlatformAccount)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, earnbill.EdgeMissionProduceOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EarnBillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case earnbill.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case earnbill.EdgeProfitAccount:
		if id := m.profit_account; id != nil {
			return []ent.Value{*id}
		}
	case earnbill.EdgePlatformAccount:
		if id := m.platform_account; id != nil {
			return []ent.Value{*id}
		}
	case earnbill.EdgeMissionProduceOrders:
		if id := m.mission_produce_orders; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EarnBillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EarnBillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EarnBillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, earnbill.EdgeUser)
	}
	if m.clearedprofit_account {
		edges = append(edges, earnbill.EdgeProfitAccount)
	}
	if m.clearedplatform_account {
		edges = append(edges, earnbill.EdgePlatformAccount)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, earnbill.EdgeMissionProduceOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EarnBillMutation) EdgeCleared(name string) bool {
	switch name {
	case earnbill.EdgeUser:
		return m.cleareduser
	case earnbill.EdgeProfitAccount:
		return m.clearedprofit_account
	case earnbill.EdgePlatformAccount:
		return m.clearedplatform_account
	case earnbill.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EarnBillMutation) ClearEdge(name string) error {
	switch name {
	case earnbill.EdgeUser:
		m.ClearUser()
		return nil
	case earnbill.EdgeProfitAccount:
		m.ClearProfitAccount()
		return nil
	case earnbill.EdgePlatformAccount:
		m.ClearPlatformAccount()
		return nil
	case earnbill.EdgeMissionProduceOrders:
		m.ClearMissionProduceOrders()
		return nil
	}
	return fmt.Errorf("unknown EarnBill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EarnBillMutation) ResetEdge(name string) error {
	switch name {
	case earnbill.EdgeUser:
		m.ResetUser()
		return nil
	case earnbill.EdgeProfitAccount:
		m.ResetProfitAccount()
		return nil
	case earnbill.EdgePlatformAccount:
		m.ResetPlatformAccount()
		return nil
	case earnbill.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	}
	return fmt.Errorf("unknown EarnBill edge %s", name)
}

// EnumConditionMutation represents an operation that mutates the EnumCondition nodes in the graph.
type EnumConditionMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_by       *int64
	addcreated_by    *int64
	updated_by       *int64
	addupdated_by    *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	front_type       *string
	mission_type     *string
	mission_call_way *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*EnumCondition, error)
	predicates       []predicate.EnumCondition
}

var _ ent.Mutation = (*EnumConditionMutation)(nil)

// enumconditionOption allows management of the mutation configuration using functional options.
type enumconditionOption func(*EnumConditionMutation)

// newEnumConditionMutation creates new mutation for the EnumCondition entity.
func newEnumConditionMutation(c config, op Op, opts ...enumconditionOption) *EnumConditionMutation {
	m := &EnumConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeEnumCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnumConditionID sets the ID field of the mutation.
func withEnumConditionID(id int64) enumconditionOption {
	return func(m *EnumConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *EnumCondition
		)
		m.oldValue = func(ctx context.Context) (*EnumCondition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnumCondition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnumCondition sets the old EnumCondition of the mutation.
func withEnumCondition(node *EnumCondition) enumconditionOption {
	return func(m *EnumConditionMutation) {
		m.oldValue = func(context.Context) (*EnumCondition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnumConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnumConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnumCondition entities.
func (m *EnumConditionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnumConditionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnumConditionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnumCondition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *EnumConditionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EnumConditionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EnumConditionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EnumConditionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EnumConditionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EnumConditionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EnumConditionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EnumConditionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EnumConditionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EnumConditionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EnumConditionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnumConditionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnumConditionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnumConditionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnumConditionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnumConditionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnumConditionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnumConditionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnumConditionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetFrontType sets the "front_type" field.
func (m *EnumConditionMutation) SetFrontType(s string) {
	m.front_type = &s
}

// FrontType returns the value of the "front_type" field in the mutation.
func (m *EnumConditionMutation) FrontType() (r string, exists bool) {
	v := m.front_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFrontType returns the old "front_type" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldFrontType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrontType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrontType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrontType: %w", err)
	}
	return oldValue.FrontType, nil
}

// ResetFrontType resets all changes to the "front_type" field.
func (m *EnumConditionMutation) ResetFrontType() {
	m.front_type = nil
}

// SetMissionType sets the "mission_type" field.
func (m *EnumConditionMutation) SetMissionType(s string) {
	m.mission_type = &s
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *EnumConditionMutation) MissionType() (r string, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldMissionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *EnumConditionMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionCallWay sets the "mission_call_way" field.
func (m *EnumConditionMutation) SetMissionCallWay(s string) {
	m.mission_call_way = &s
}

// MissionCallWay returns the value of the "mission_call_way" field in the mutation.
func (m *EnumConditionMutation) MissionCallWay() (r string, exists bool) {
	v := m.mission_call_way
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionCallWay returns the old "mission_call_way" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldMissionCallWay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionCallWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionCallWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionCallWay: %w", err)
	}
	return oldValue.MissionCallWay, nil
}

// ResetMissionCallWay resets all changes to the "mission_call_way" field.
func (m *EnumConditionMutation) ResetMissionCallWay() {
	m.mission_call_way = nil
}

// Where appends a list predicates to the EnumConditionMutation builder.
func (m *EnumConditionMutation) Where(ps ...predicate.EnumCondition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnumConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnumConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnumCondition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnumConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnumConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnumCondition).
func (m *EnumConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnumConditionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, enumcondition.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, enumcondition.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, enumcondition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enumcondition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enumcondition.FieldDeletedAt)
	}
	if m.front_type != nil {
		fields = append(fields, enumcondition.FieldFrontType)
	}
	if m.mission_type != nil {
		fields = append(fields, enumcondition.FieldMissionType)
	}
	if m.mission_call_way != nil {
		fields = append(fields, enumcondition.FieldMissionCallWay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnumConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enumcondition.FieldCreatedBy:
		return m.CreatedBy()
	case enumcondition.FieldUpdatedBy:
		return m.UpdatedBy()
	case enumcondition.FieldCreatedAt:
		return m.CreatedAt()
	case enumcondition.FieldUpdatedAt:
		return m.UpdatedAt()
	case enumcondition.FieldDeletedAt:
		return m.DeletedAt()
	case enumcondition.FieldFrontType:
		return m.FrontType()
	case enumcondition.FieldMissionType:
		return m.MissionType()
	case enumcondition.FieldMissionCallWay:
		return m.MissionCallWay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnumConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enumcondition.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case enumcondition.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case enumcondition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enumcondition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enumcondition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enumcondition.FieldFrontType:
		return m.OldFrontType(ctx)
	case enumcondition.FieldMissionType:
		return m.OldMissionType(ctx)
	case enumcondition.FieldMissionCallWay:
		return m.OldMissionCallWay(ctx)
	}
	return nil, fmt.Errorf("unknown EnumCondition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enumcondition.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case enumcondition.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case enumcondition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enumcondition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enumcondition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enumcondition.FieldFrontType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrontType(v)
		return nil
	case enumcondition.FieldMissionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case enumcondition.FieldMissionCallWay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionCallWay(v)
		return nil
	}
	return fmt.Errorf("unknown EnumCondition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnumConditionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, enumcondition.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, enumcondition.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnumConditionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enumcondition.FieldCreatedBy:
		return m.AddedCreatedBy()
	case enumcondition.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enumcondition.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case enumcondition.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown EnumCondition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnumConditionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnumConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnumConditionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnumCondition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnumConditionMutation) ResetField(name string) error {
	switch name {
	case enumcondition.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case enumcondition.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case enumcondition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enumcondition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enumcondition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enumcondition.FieldFrontType:
		m.ResetFrontType()
		return nil
	case enumcondition.FieldMissionType:
		m.ResetMissionType()
		return nil
	case enumcondition.FieldMissionCallWay:
		m.ResetMissionCallWay()
		return nil
	}
	return fmt.Errorf("unknown EnumCondition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnumConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnumConditionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnumConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnumConditionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnumConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnumConditionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnumConditionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EnumCondition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnumConditionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EnumCondition edge %s", name)
}

// EnumMissionStatusMutation represents an operation that mutates the EnumMissionStatus nodes in the graph.
type EnumMissionStatusMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_by     *int64
	addcreated_by  *int64
	updated_by     *int64
	addupdated_by  *int64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	front_status   *string
	mission_type   *string
	mission_status *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*EnumMissionStatus, error)
	predicates     []predicate.EnumMissionStatus
}

var _ ent.Mutation = (*EnumMissionStatusMutation)(nil)

// enummissionstatusOption allows management of the mutation configuration using functional options.
type enummissionstatusOption func(*EnumMissionStatusMutation)

// newEnumMissionStatusMutation creates new mutation for the EnumMissionStatus entity.
func newEnumMissionStatusMutation(c config, op Op, opts ...enummissionstatusOption) *EnumMissionStatusMutation {
	m := &EnumMissionStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeEnumMissionStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnumMissionStatusID sets the ID field of the mutation.
func withEnumMissionStatusID(id int64) enummissionstatusOption {
	return func(m *EnumMissionStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *EnumMissionStatus
		)
		m.oldValue = func(ctx context.Context) (*EnumMissionStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnumMissionStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnumMissionStatus sets the old EnumMissionStatus of the mutation.
func withEnumMissionStatus(node *EnumMissionStatus) enummissionstatusOption {
	return func(m *EnumMissionStatusMutation) {
		m.oldValue = func(context.Context) (*EnumMissionStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnumMissionStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnumMissionStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnumMissionStatus entities.
func (m *EnumMissionStatusMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnumMissionStatusMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnumMissionStatusMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnumMissionStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *EnumMissionStatusMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EnumMissionStatusMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EnumMissionStatusMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EnumMissionStatusMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EnumMissionStatusMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EnumMissionStatusMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EnumMissionStatusMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EnumMissionStatusMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EnumMissionStatusMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EnumMissionStatusMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EnumMissionStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnumMissionStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnumMissionStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnumMissionStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnumMissionStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnumMissionStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnumMissionStatusMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnumMissionStatusMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnumMissionStatusMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetFrontStatus sets the "front_status" field.
func (m *EnumMissionStatusMutation) SetFrontStatus(s string) {
	m.front_status = &s
}

// FrontStatus returns the value of the "front_status" field in the mutation.
func (m *EnumMissionStatusMutation) FrontStatus() (r string, exists bool) {
	v := m.front_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFrontStatus returns the old "front_status" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldFrontStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrontStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrontStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrontStatus: %w", err)
	}
	return oldValue.FrontStatus, nil
}

// ResetFrontStatus resets all changes to the "front_status" field.
func (m *EnumMissionStatusMutation) ResetFrontStatus() {
	m.front_status = nil
}

// SetMissionType sets the "mission_type" field.
func (m *EnumMissionStatusMutation) SetMissionType(s string) {
	m.mission_type = &s
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *EnumMissionStatusMutation) MissionType() (r string, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldMissionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *EnumMissionStatusMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionStatus sets the "mission_status" field.
func (m *EnumMissionStatusMutation) SetMissionStatus(s string) {
	m.mission_status = &s
}

// MissionStatus returns the value of the "mission_status" field in the mutation.
func (m *EnumMissionStatusMutation) MissionStatus() (r string, exists bool) {
	v := m.mission_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionStatus returns the old "mission_status" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldMissionStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionStatus: %w", err)
	}
	return oldValue.MissionStatus, nil
}

// ResetMissionStatus resets all changes to the "mission_status" field.
func (m *EnumMissionStatusMutation) ResetMissionStatus() {
	m.mission_status = nil
}

// Where appends a list predicates to the EnumMissionStatusMutation builder.
func (m *EnumMissionStatusMutation) Where(ps ...predicate.EnumMissionStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnumMissionStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnumMissionStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnumMissionStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnumMissionStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnumMissionStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnumMissionStatus).
func (m *EnumMissionStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnumMissionStatusMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, enummissionstatus.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, enummissionstatus.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, enummissionstatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enummissionstatus.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enummissionstatus.FieldDeletedAt)
	}
	if m.front_status != nil {
		fields = append(fields, enummissionstatus.FieldFrontStatus)
	}
	if m.mission_type != nil {
		fields = append(fields, enummissionstatus.FieldMissionType)
	}
	if m.mission_status != nil {
		fields = append(fields, enummissionstatus.FieldMissionStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnumMissionStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		return m.CreatedBy()
	case enummissionstatus.FieldUpdatedBy:
		return m.UpdatedBy()
	case enummissionstatus.FieldCreatedAt:
		return m.CreatedAt()
	case enummissionstatus.FieldUpdatedAt:
		return m.UpdatedAt()
	case enummissionstatus.FieldDeletedAt:
		return m.DeletedAt()
	case enummissionstatus.FieldFrontStatus:
		return m.FrontStatus()
	case enummissionstatus.FieldMissionType:
		return m.MissionType()
	case enummissionstatus.FieldMissionStatus:
		return m.MissionStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnumMissionStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case enummissionstatus.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case enummissionstatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enummissionstatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enummissionstatus.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enummissionstatus.FieldFrontStatus:
		return m.OldFrontStatus(ctx)
	case enummissionstatus.FieldMissionType:
		return m.OldMissionType(ctx)
	case enummissionstatus.FieldMissionStatus:
		return m.OldMissionStatus(ctx)
	}
	return nil, fmt.Errorf("unknown EnumMissionStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumMissionStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case enummissionstatus.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case enummissionstatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enummissionstatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enummissionstatus.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enummissionstatus.FieldFrontStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrontStatus(v)
		return nil
	case enummissionstatus.FieldMissionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case enummissionstatus.FieldMissionStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EnumMissionStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnumMissionStatusMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, enummissionstatus.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, enummissionstatus.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnumMissionStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		return m.AddedCreatedBy()
	case enummissionstatus.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumMissionStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case enummissionstatus.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown EnumMissionStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnumMissionStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnumMissionStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnumMissionStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnumMissionStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnumMissionStatusMutation) ResetField(name string) error {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case enummissionstatus.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case enummissionstatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enummissionstatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enummissionstatus.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enummissionstatus.FieldFrontStatus:
		m.ResetFrontStatus()
		return nil
	case enummissionstatus.FieldMissionType:
		m.ResetMissionType()
		return nil
	case enummissionstatus.FieldMissionStatus:
		m.ResetMissionStatus()
		return nil
	}
	return fmt.Errorf("unknown EnumMissionStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnumMissionStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnumMissionStatusMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnumMissionStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnumMissionStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnumMissionStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnumMissionStatusMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnumMissionStatusMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EnumMissionStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnumMissionStatusMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EnumMissionStatus edge %s", name)
}

// ExtraServiceMutation represents an operation that mutates the ExtraService nodes in the graph.
type ExtraServiceMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	name                          *string
	extra_service_type            *enums.ExtraServiceType
	started_at                    *time.Time
	finished_at                   *time.Time
	clearedFields                 map[string]struct{}
	missions                      map[int64]struct{}
	removedmissions               map[int64]struct{}
	clearedmissions               bool
	mission_extra_services        map[int64]struct{}
	removedmission_extra_services map[int64]struct{}
	clearedmission_extra_services bool
	extra_service_prices          map[int64]struct{}
	removedextra_service_prices   map[int64]struct{}
	clearedextra_service_prices   bool
	done                          bool
	oldValue                      func(context.Context) (*ExtraService, error)
	predicates                    []predicate.ExtraService
}

var _ ent.Mutation = (*ExtraServiceMutation)(nil)

// extraserviceOption allows management of the mutation configuration using functional options.
type extraserviceOption func(*ExtraServiceMutation)

// newExtraServiceMutation creates new mutation for the ExtraService entity.
func newExtraServiceMutation(c config, op Op, opts ...extraserviceOption) *ExtraServiceMutation {
	m := &ExtraServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeExtraService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtraServiceID sets the ID field of the mutation.
func withExtraServiceID(id int64) extraserviceOption {
	return func(m *ExtraServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *ExtraService
		)
		m.oldValue = func(ctx context.Context) (*ExtraService, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExtraService.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtraService sets the old ExtraService of the mutation.
func withExtraService(node *ExtraService) extraserviceOption {
	return func(m *ExtraServiceMutation) {
		m.oldValue = func(context.Context) (*ExtraService, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtraServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtraServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExtraService entities.
func (m *ExtraServiceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtraServiceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtraServiceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExtraService.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ExtraServiceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ExtraServiceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ExtraServiceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ExtraServiceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ExtraServiceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ExtraServiceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ExtraServiceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ExtraServiceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ExtraServiceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ExtraServiceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExtraServiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExtraServiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExtraServiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExtraServiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExtraServiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExtraServiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExtraServiceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExtraServiceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExtraServiceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *ExtraServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExtraServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExtraServiceMutation) ResetName() {
	m.name = nil
}

// SetExtraServiceType sets the "extra_service_type" field.
func (m *ExtraServiceMutation) SetExtraServiceType(est enums.ExtraServiceType) {
	m.extra_service_type = &est
}

// ExtraServiceType returns the value of the "extra_service_type" field in the mutation.
func (m *ExtraServiceMutation) ExtraServiceType() (r enums.ExtraServiceType, exists bool) {
	v := m.extra_service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceType returns the old "extra_service_type" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldExtraServiceType(ctx context.Context) (v enums.ExtraServiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceType: %w", err)
	}
	return oldValue.ExtraServiceType, nil
}

// ResetExtraServiceType resets all changes to the "extra_service_type" field.
func (m *ExtraServiceMutation) ResetExtraServiceType() {
	m.extra_service_type = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ExtraServiceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ExtraServiceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *ExtraServiceMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[extraservice.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *ExtraServiceMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[extraservice.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ExtraServiceMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, extraservice.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *ExtraServiceMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ExtraServiceMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ExtraService entity.
// If the ExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *ExtraServiceMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[extraservice.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *ExtraServiceMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[extraservice.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ExtraServiceMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, extraservice.FieldFinishedAt)
}

// AddMissionIDs adds the "missions" edge to the Mission entity by ids.
func (m *ExtraServiceMutation) AddMissionIDs(ids ...int64) {
	if m.missions == nil {
		m.missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.missions[ids[i]] = struct{}{}
	}
}

// ClearMissions clears the "missions" edge to the Mission entity.
func (m *ExtraServiceMutation) ClearMissions() {
	m.clearedmissions = true
}

// MissionsCleared reports if the "missions" edge to the Mission entity was cleared.
func (m *ExtraServiceMutation) MissionsCleared() bool {
	return m.clearedmissions
}

// RemoveMissionIDs removes the "missions" edge to the Mission entity by IDs.
func (m *ExtraServiceMutation) RemoveMissionIDs(ids ...int64) {
	if m.removedmissions == nil {
		m.removedmissions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.missions, ids[i])
		m.removedmissions[ids[i]] = struct{}{}
	}
}

// RemovedMissions returns the removed IDs of the "missions" edge to the Mission entity.
func (m *ExtraServiceMutation) RemovedMissionsIDs() (ids []int64) {
	for id := range m.removedmissions {
		ids = append(ids, id)
	}
	return
}

// MissionsIDs returns the "missions" edge IDs in the mutation.
func (m *ExtraServiceMutation) MissionsIDs() (ids []int64) {
	for id := range m.missions {
		ids = append(ids, id)
	}
	return
}

// ResetMissions resets all changes to the "missions" edge.
func (m *ExtraServiceMutation) ResetMissions() {
	m.missions = nil
	m.clearedmissions = false
	m.removedmissions = nil
}

// AddMissionExtraServiceIDs adds the "mission_extra_services" edge to the MissionExtraService entity by ids.
func (m *ExtraServiceMutation) AddMissionExtraServiceIDs(ids ...int64) {
	if m.mission_extra_services == nil {
		m.mission_extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_extra_services[ids[i]] = struct{}{}
	}
}

// ClearMissionExtraServices clears the "mission_extra_services" edge to the MissionExtraService entity.
func (m *ExtraServiceMutation) ClearMissionExtraServices() {
	m.clearedmission_extra_services = true
}

// MissionExtraServicesCleared reports if the "mission_extra_services" edge to the MissionExtraService entity was cleared.
func (m *ExtraServiceMutation) MissionExtraServicesCleared() bool {
	return m.clearedmission_extra_services
}

// RemoveMissionExtraServiceIDs removes the "mission_extra_services" edge to the MissionExtraService entity by IDs.
func (m *ExtraServiceMutation) RemoveMissionExtraServiceIDs(ids ...int64) {
	if m.removedmission_extra_services == nil {
		m.removedmission_extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_extra_services, ids[i])
		m.removedmission_extra_services[ids[i]] = struct{}{}
	}
}

// RemovedMissionExtraServices returns the removed IDs of the "mission_extra_services" edge to the MissionExtraService entity.
func (m *ExtraServiceMutation) RemovedMissionExtraServicesIDs() (ids []int64) {
	for id := range m.removedmission_extra_services {
		ids = append(ids, id)
	}
	return
}

// MissionExtraServicesIDs returns the "mission_extra_services" edge IDs in the mutation.
func (m *ExtraServiceMutation) MissionExtraServicesIDs() (ids []int64) {
	for id := range m.mission_extra_services {
		ids = append(ids, id)
	}
	return
}

// ResetMissionExtraServices resets all changes to the "mission_extra_services" edge.
func (m *ExtraServiceMutation) ResetMissionExtraServices() {
	m.mission_extra_services = nil
	m.clearedmission_extra_services = false
	m.removedmission_extra_services = nil
}

// AddExtraServicePriceIDs adds the "extra_service_prices" edge to the ExtraServicePrice entity by ids.
func (m *ExtraServiceMutation) AddExtraServicePriceIDs(ids ...int64) {
	if m.extra_service_prices == nil {
		m.extra_service_prices = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_prices[ids[i]] = struct{}{}
	}
}

// ClearExtraServicePrices clears the "extra_service_prices" edge to the ExtraServicePrice entity.
func (m *ExtraServiceMutation) ClearExtraServicePrices() {
	m.clearedextra_service_prices = true
}

// ExtraServicePricesCleared reports if the "extra_service_prices" edge to the ExtraServicePrice entity was cleared.
func (m *ExtraServiceMutation) ExtraServicePricesCleared() bool {
	return m.clearedextra_service_prices
}

// RemoveExtraServicePriceIDs removes the "extra_service_prices" edge to the ExtraServicePrice entity by IDs.
func (m *ExtraServiceMutation) RemoveExtraServicePriceIDs(ids ...int64) {
	if m.removedextra_service_prices == nil {
		m.removedextra_service_prices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_prices, ids[i])
		m.removedextra_service_prices[ids[i]] = struct{}{}
	}
}

// RemovedExtraServicePrices returns the removed IDs of the "extra_service_prices" edge to the ExtraServicePrice entity.
func (m *ExtraServiceMutation) RemovedExtraServicePricesIDs() (ids []int64) {
	for id := range m.removedextra_service_prices {
		ids = append(ids, id)
	}
	return
}

// ExtraServicePricesIDs returns the "extra_service_prices" edge IDs in the mutation.
func (m *ExtraServiceMutation) ExtraServicePricesIDs() (ids []int64) {
	for id := range m.extra_service_prices {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServicePrices resets all changes to the "extra_service_prices" edge.
func (m *ExtraServiceMutation) ResetExtraServicePrices() {
	m.extra_service_prices = nil
	m.clearedextra_service_prices = false
	m.removedextra_service_prices = nil
}

// Where appends a list predicates to the ExtraServiceMutation builder.
func (m *ExtraServiceMutation) Where(ps ...predicate.ExtraService) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExtraServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExtraServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExtraService, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExtraServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExtraServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExtraService).
func (m *ExtraServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtraServiceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, extraservice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, extraservice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, extraservice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, extraservice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, extraservice.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, extraservice.FieldName)
	}
	if m.extra_service_type != nil {
		fields = append(fields, extraservice.FieldExtraServiceType)
	}
	if m.started_at != nil {
		fields = append(fields, extraservice.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, extraservice.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtraServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extraservice.FieldCreatedBy:
		return m.CreatedBy()
	case extraservice.FieldUpdatedBy:
		return m.UpdatedBy()
	case extraservice.FieldCreatedAt:
		return m.CreatedAt()
	case extraservice.FieldUpdatedAt:
		return m.UpdatedAt()
	case extraservice.FieldDeletedAt:
		return m.DeletedAt()
	case extraservice.FieldName:
		return m.Name()
	case extraservice.FieldExtraServiceType:
		return m.ExtraServiceType()
	case extraservice.FieldStartedAt:
		return m.StartedAt()
	case extraservice.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtraServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extraservice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case extraservice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case extraservice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case extraservice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case extraservice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case extraservice.FieldName:
		return m.OldName(ctx)
	case extraservice.FieldExtraServiceType:
		return m.OldExtraServiceType(ctx)
	case extraservice.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case extraservice.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ExtraService field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extraservice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case extraservice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case extraservice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case extraservice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case extraservice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case extraservice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case extraservice.FieldExtraServiceType:
		v, ok := value.(enums.ExtraServiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceType(v)
		return nil
	case extraservice.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case extraservice.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraService field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtraServiceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, extraservice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, extraservice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtraServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case extraservice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case extraservice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case extraservice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case extraservice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraService numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtraServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extraservice.FieldStartedAt) {
		fields = append(fields, extraservice.FieldStartedAt)
	}
	if m.FieldCleared(extraservice.FieldFinishedAt) {
		fields = append(fields, extraservice.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtraServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtraServiceMutation) ClearField(name string) error {
	switch name {
	case extraservice.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case extraservice.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraService nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtraServiceMutation) ResetField(name string) error {
	switch name {
	case extraservice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case extraservice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case extraservice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case extraservice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case extraservice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case extraservice.FieldName:
		m.ResetName()
		return nil
	case extraservice.FieldExtraServiceType:
		m.ResetExtraServiceType()
		return nil
	case extraservice.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case extraservice.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraService field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtraServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.missions != nil {
		edges = append(edges, extraservice.EdgeMissions)
	}
	if m.mission_extra_services != nil {
		edges = append(edges, extraservice.EdgeMissionExtraServices)
	}
	if m.extra_service_prices != nil {
		edges = append(edges, extraservice.EdgeExtraServicePrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtraServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case extraservice.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.missions))
		for id := range m.missions {
			ids = append(ids, id)
		}
		return ids
	case extraservice.EdgeMissionExtraServices:
		ids := make([]ent.Value, 0, len(m.mission_extra_services))
		for id := range m.mission_extra_services {
			ids = append(ids, id)
		}
		return ids
	case extraservice.EdgeExtraServicePrices:
		ids := make([]ent.Value, 0, len(m.extra_service_prices))
		for id := range m.extra_service_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtraServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmissions != nil {
		edges = append(edges, extraservice.EdgeMissions)
	}
	if m.removedmission_extra_services != nil {
		edges = append(edges, extraservice.EdgeMissionExtraServices)
	}
	if m.removedextra_service_prices != nil {
		edges = append(edges, extraservice.EdgeExtraServicePrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtraServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case extraservice.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.removedmissions))
		for id := range m.removedmissions {
			ids = append(ids, id)
		}
		return ids
	case extraservice.EdgeMissionExtraServices:
		ids := make([]ent.Value, 0, len(m.removedmission_extra_services))
		for id := range m.removedmission_extra_services {
			ids = append(ids, id)
		}
		return ids
	case extraservice.EdgeExtraServicePrices:
		ids := make([]ent.Value, 0, len(m.removedextra_service_prices))
		for id := range m.removedextra_service_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtraServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmissions {
		edges = append(edges, extraservice.EdgeMissions)
	}
	if m.clearedmission_extra_services {
		edges = append(edges, extraservice.EdgeMissionExtraServices)
	}
	if m.clearedextra_service_prices {
		edges = append(edges, extraservice.EdgeExtraServicePrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtraServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case extraservice.EdgeMissions:
		return m.clearedmissions
	case extraservice.EdgeMissionExtraServices:
		return m.clearedmission_extra_services
	case extraservice.EdgeExtraServicePrices:
		return m.clearedextra_service_prices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtraServiceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ExtraService unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtraServiceMutation) ResetEdge(name string) error {
	switch name {
	case extraservice.EdgeMissions:
		m.ResetMissions()
		return nil
	case extraservice.EdgeMissionExtraServices:
		m.ResetMissionExtraServices()
		return nil
	case extraservice.EdgeExtraServicePrices:
		m.ResetExtraServicePrices()
		return nil
	}
	return fmt.Errorf("unknown ExtraService edge %s", name)
}

// ExtraServiceOrderMutation represents an operation that mutates the ExtraServiceOrder nodes in the graph.
type ExtraServiceOrderMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	extra_service_billing_type *enums.ExtraServiceBillingType
	amount                     *int64
	addamount                  *int64
	unit_cep                   *int64
	addunit_cep                *int64
	extra_service_type         *enums.ExtraServiceType
	buy_duration               *int64
	addbuy_duration            *int64
	started_at                 *time.Time
	finished_at                *time.Time
	plan_started_at            *time.Time
	plan_finished_at           *time.Time
	settled_amount             *int64
	addsettled_amount          *int64
	settled_count              *int64
	addsettled_count           *int64
	total_settle_count         *int64
	addtotal_settle_count      *int64
	lately_settled_at          *time.Time
	clearedFields              map[string]struct{}
	mission                    *int64
	clearedmission             bool
	mission_order              *int64
	clearedmission_order       bool
	symbol                     *int64
	clearedsymbol              bool
	mission_batch              *int64
	clearedmission_batch       bool
	done                       bool
	oldValue                   func(context.Context) (*ExtraServiceOrder, error)
	predicates                 []predicate.ExtraServiceOrder
}

var _ ent.Mutation = (*ExtraServiceOrderMutation)(nil)

// extraserviceorderOption allows management of the mutation configuration using functional options.
type extraserviceorderOption func(*ExtraServiceOrderMutation)

// newExtraServiceOrderMutation creates new mutation for the ExtraServiceOrder entity.
func newExtraServiceOrderMutation(c config, op Op, opts ...extraserviceorderOption) *ExtraServiceOrderMutation {
	m := &ExtraServiceOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeExtraServiceOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtraServiceOrderID sets the ID field of the mutation.
func withExtraServiceOrderID(id int64) extraserviceorderOption {
	return func(m *ExtraServiceOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *ExtraServiceOrder
		)
		m.oldValue = func(ctx context.Context) (*ExtraServiceOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExtraServiceOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtraServiceOrder sets the old ExtraServiceOrder of the mutation.
func withExtraServiceOrder(node *ExtraServiceOrder) extraserviceorderOption {
	return func(m *ExtraServiceOrderMutation) {
		m.oldValue = func(context.Context) (*ExtraServiceOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtraServiceOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtraServiceOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExtraServiceOrder entities.
func (m *ExtraServiceOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtraServiceOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtraServiceOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExtraServiceOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ExtraServiceOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ExtraServiceOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ExtraServiceOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ExtraServiceOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ExtraServiceOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ExtraServiceOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ExtraServiceOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ExtraServiceOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExtraServiceOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExtraServiceOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExtraServiceOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExtraServiceOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExtraServiceOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExtraServiceOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExtraServiceOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExtraServiceOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExtraServiceOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *ExtraServiceOrderMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *ExtraServiceOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *ExtraServiceOrderMutation) ResetMissionID() {
	m.mission = nil
}

// SetMissionOrderID sets the "mission_order_id" field.
func (m *ExtraServiceOrderMutation) SetMissionOrderID(i int64) {
	m.mission_order = &i
}

// MissionOrderID returns the value of the "mission_order_id" field in the mutation.
func (m *ExtraServiceOrderMutation) MissionOrderID() (r int64, exists bool) {
	v := m.mission_order
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionOrderID returns the old "mission_order_id" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldMissionOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionOrderID: %w", err)
	}
	return oldValue.MissionOrderID, nil
}

// ResetMissionOrderID resets all changes to the "mission_order_id" field.
func (m *ExtraServiceOrderMutation) ResetMissionOrderID() {
	m.mission_order = nil
}

// SetExtraServiceBillingType sets the "extra_service_billing_type" field.
func (m *ExtraServiceOrderMutation) SetExtraServiceBillingType(esbt enums.ExtraServiceBillingType) {
	m.extra_service_billing_type = &esbt
}

// ExtraServiceBillingType returns the value of the "extra_service_billing_type" field in the mutation.
func (m *ExtraServiceOrderMutation) ExtraServiceBillingType() (r enums.ExtraServiceBillingType, exists bool) {
	v := m.extra_service_billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceBillingType returns the old "extra_service_billing_type" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldExtraServiceBillingType(ctx context.Context) (v enums.ExtraServiceBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceBillingType: %w", err)
	}
	return oldValue.ExtraServiceBillingType, nil
}

// ResetExtraServiceBillingType resets all changes to the "extra_service_billing_type" field.
func (m *ExtraServiceOrderMutation) ResetExtraServiceBillingType() {
	m.extra_service_billing_type = nil
}

// SetAmount sets the "amount" field.
func (m *ExtraServiceOrderMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ExtraServiceOrderMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *ExtraServiceOrderMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *ExtraServiceOrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *ExtraServiceOrderMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *ExtraServiceOrderMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *ExtraServiceOrderMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetUnitCep sets the "unit_cep" field.
func (m *ExtraServiceOrderMutation) SetUnitCep(i int64) {
	m.unit_cep = &i
	m.addunit_cep = nil
}

// UnitCep returns the value of the "unit_cep" field in the mutation.
func (m *ExtraServiceOrderMutation) UnitCep() (r int64, exists bool) {
	v := m.unit_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCep returns the old "unit_cep" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldUnitCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCep: %w", err)
	}
	return oldValue.UnitCep, nil
}

// AddUnitCep adds i to the "unit_cep" field.
func (m *ExtraServiceOrderMutation) AddUnitCep(i int64) {
	if m.addunit_cep != nil {
		*m.addunit_cep += i
	} else {
		m.addunit_cep = &i
	}
}

// AddedUnitCep returns the value that was added to the "unit_cep" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedUnitCep() (r int64, exists bool) {
	v := m.addunit_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitCep resets all changes to the "unit_cep" field.
func (m *ExtraServiceOrderMutation) ResetUnitCep() {
	m.unit_cep = nil
	m.addunit_cep = nil
}

// SetExtraServiceType sets the "extra_service_type" field.
func (m *ExtraServiceOrderMutation) SetExtraServiceType(est enums.ExtraServiceType) {
	m.extra_service_type = &est
}

// ExtraServiceType returns the value of the "extra_service_type" field in the mutation.
func (m *ExtraServiceOrderMutation) ExtraServiceType() (r enums.ExtraServiceType, exists bool) {
	v := m.extra_service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceType returns the old "extra_service_type" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldExtraServiceType(ctx context.Context) (v enums.ExtraServiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceType: %w", err)
	}
	return oldValue.ExtraServiceType, nil
}

// ResetExtraServiceType resets all changes to the "extra_service_type" field.
func (m *ExtraServiceOrderMutation) ResetExtraServiceType() {
	m.extra_service_type = nil
}

// SetBuyDuration sets the "buy_duration" field.
func (m *ExtraServiceOrderMutation) SetBuyDuration(i int64) {
	m.buy_duration = &i
	m.addbuy_duration = nil
}

// BuyDuration returns the value of the "buy_duration" field in the mutation.
func (m *ExtraServiceOrderMutation) BuyDuration() (r int64, exists bool) {
	v := m.buy_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyDuration returns the old "buy_duration" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldBuyDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyDuration: %w", err)
	}
	return oldValue.BuyDuration, nil
}

// AddBuyDuration adds i to the "buy_duration" field.
func (m *ExtraServiceOrderMutation) AddBuyDuration(i int64) {
	if m.addbuy_duration != nil {
		*m.addbuy_duration += i
	} else {
		m.addbuy_duration = &i
	}
}

// AddedBuyDuration returns the value that was added to the "buy_duration" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedBuyDuration() (r int64, exists bool) {
	v := m.addbuy_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetBuyDuration resets all changes to the "buy_duration" field.
func (m *ExtraServiceOrderMutation) ResetBuyDuration() {
	m.buy_duration = nil
	m.addbuy_duration = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ExtraServiceOrderMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ExtraServiceOrderMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ExtraServiceOrderMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *ExtraServiceOrderMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ExtraServiceOrderMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ExtraServiceOrderMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetPlanStartedAt sets the "plan_started_at" field.
func (m *ExtraServiceOrderMutation) SetPlanStartedAt(t time.Time) {
	m.plan_started_at = &t
}

// PlanStartedAt returns the value of the "plan_started_at" field in the mutation.
func (m *ExtraServiceOrderMutation) PlanStartedAt() (r time.Time, exists bool) {
	v := m.plan_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanStartedAt returns the old "plan_started_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldPlanStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanStartedAt: %w", err)
	}
	return oldValue.PlanStartedAt, nil
}

// ClearPlanStartedAt clears the value of the "plan_started_at" field.
func (m *ExtraServiceOrderMutation) ClearPlanStartedAt() {
	m.plan_started_at = nil
	m.clearedFields[extraserviceorder.FieldPlanStartedAt] = struct{}{}
}

// PlanStartedAtCleared returns if the "plan_started_at" field was cleared in this mutation.
func (m *ExtraServiceOrderMutation) PlanStartedAtCleared() bool {
	_, ok := m.clearedFields[extraserviceorder.FieldPlanStartedAt]
	return ok
}

// ResetPlanStartedAt resets all changes to the "plan_started_at" field.
func (m *ExtraServiceOrderMutation) ResetPlanStartedAt() {
	m.plan_started_at = nil
	delete(m.clearedFields, extraserviceorder.FieldPlanStartedAt)
}

// SetPlanFinishedAt sets the "plan_finished_at" field.
func (m *ExtraServiceOrderMutation) SetPlanFinishedAt(t time.Time) {
	m.plan_finished_at = &t
}

// PlanFinishedAt returns the value of the "plan_finished_at" field in the mutation.
func (m *ExtraServiceOrderMutation) PlanFinishedAt() (r time.Time, exists bool) {
	v := m.plan_finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanFinishedAt returns the old "plan_finished_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldPlanFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanFinishedAt: %w", err)
	}
	return oldValue.PlanFinishedAt, nil
}

// ClearPlanFinishedAt clears the value of the "plan_finished_at" field.
func (m *ExtraServiceOrderMutation) ClearPlanFinishedAt() {
	m.plan_finished_at = nil
	m.clearedFields[extraserviceorder.FieldPlanFinishedAt] = struct{}{}
}

// PlanFinishedAtCleared returns if the "plan_finished_at" field was cleared in this mutation.
func (m *ExtraServiceOrderMutation) PlanFinishedAtCleared() bool {
	_, ok := m.clearedFields[extraserviceorder.FieldPlanFinishedAt]
	return ok
}

// ResetPlanFinishedAt resets all changes to the "plan_finished_at" field.
func (m *ExtraServiceOrderMutation) ResetPlanFinishedAt() {
	m.plan_finished_at = nil
	delete(m.clearedFields, extraserviceorder.FieldPlanFinishedAt)
}

// SetMissionBatchID sets the "mission_batch_id" field.
func (m *ExtraServiceOrderMutation) SetMissionBatchID(i int64) {
	m.mission_batch = &i
}

// MissionBatchID returns the value of the "mission_batch_id" field in the mutation.
func (m *ExtraServiceOrderMutation) MissionBatchID() (r int64, exists bool) {
	v := m.mission_batch
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchID returns the old "mission_batch_id" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldMissionBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchID: %w", err)
	}
	return oldValue.MissionBatchID, nil
}

// ResetMissionBatchID resets all changes to the "mission_batch_id" field.
func (m *ExtraServiceOrderMutation) ResetMissionBatchID() {
	m.mission_batch = nil
}

// SetSettledAmount sets the "settled_amount" field.
func (m *ExtraServiceOrderMutation) SetSettledAmount(i int64) {
	m.settled_amount = &i
	m.addsettled_amount = nil
}

// SettledAmount returns the value of the "settled_amount" field in the mutation.
func (m *ExtraServiceOrderMutation) SettledAmount() (r int64, exists bool) {
	v := m.settled_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledAmount returns the old "settled_amount" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldSettledAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledAmount: %w", err)
	}
	return oldValue.SettledAmount, nil
}

// AddSettledAmount adds i to the "settled_amount" field.
func (m *ExtraServiceOrderMutation) AddSettledAmount(i int64) {
	if m.addsettled_amount != nil {
		*m.addsettled_amount += i
	} else {
		m.addsettled_amount = &i
	}
}

// AddedSettledAmount returns the value that was added to the "settled_amount" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedSettledAmount() (r int64, exists bool) {
	v := m.addsettled_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettledAmount resets all changes to the "settled_amount" field.
func (m *ExtraServiceOrderMutation) ResetSettledAmount() {
	m.settled_amount = nil
	m.addsettled_amount = nil
}

// SetSettledCount sets the "settled_count" field.
func (m *ExtraServiceOrderMutation) SetSettledCount(i int64) {
	m.settled_count = &i
	m.addsettled_count = nil
}

// SettledCount returns the value of the "settled_count" field in the mutation.
func (m *ExtraServiceOrderMutation) SettledCount() (r int64, exists bool) {
	v := m.settled_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledCount returns the old "settled_count" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldSettledCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledCount: %w", err)
	}
	return oldValue.SettledCount, nil
}

// AddSettledCount adds i to the "settled_count" field.
func (m *ExtraServiceOrderMutation) AddSettledCount(i int64) {
	if m.addsettled_count != nil {
		*m.addsettled_count += i
	} else {
		m.addsettled_count = &i
	}
}

// AddedSettledCount returns the value that was added to the "settled_count" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedSettledCount() (r int64, exists bool) {
	v := m.addsettled_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettledCount resets all changes to the "settled_count" field.
func (m *ExtraServiceOrderMutation) ResetSettledCount() {
	m.settled_count = nil
	m.addsettled_count = nil
}

// SetTotalSettleCount sets the "total_settle_count" field.
func (m *ExtraServiceOrderMutation) SetTotalSettleCount(i int64) {
	m.total_settle_count = &i
	m.addtotal_settle_count = nil
}

// TotalSettleCount returns the value of the "total_settle_count" field in the mutation.
func (m *ExtraServiceOrderMutation) TotalSettleCount() (r int64, exists bool) {
	v := m.total_settle_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSettleCount returns the old "total_settle_count" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldTotalSettleCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSettleCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSettleCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSettleCount: %w", err)
	}
	return oldValue.TotalSettleCount, nil
}

// AddTotalSettleCount adds i to the "total_settle_count" field.
func (m *ExtraServiceOrderMutation) AddTotalSettleCount(i int64) {
	if m.addtotal_settle_count != nil {
		*m.addtotal_settle_count += i
	} else {
		m.addtotal_settle_count = &i
	}
}

// AddedTotalSettleCount returns the value that was added to the "total_settle_count" field in this mutation.
func (m *ExtraServiceOrderMutation) AddedTotalSettleCount() (r int64, exists bool) {
	v := m.addtotal_settle_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSettleCount resets all changes to the "total_settle_count" field.
func (m *ExtraServiceOrderMutation) ResetTotalSettleCount() {
	m.total_settle_count = nil
	m.addtotal_settle_count = nil
}

// SetLatelySettledAt sets the "lately_settled_at" field.
func (m *ExtraServiceOrderMutation) SetLatelySettledAt(t time.Time) {
	m.lately_settled_at = &t
}

// LatelySettledAt returns the value of the "lately_settled_at" field in the mutation.
func (m *ExtraServiceOrderMutation) LatelySettledAt() (r time.Time, exists bool) {
	v := m.lately_settled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLatelySettledAt returns the old "lately_settled_at" field's value of the ExtraServiceOrder entity.
// If the ExtraServiceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServiceOrderMutation) OldLatelySettledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatelySettledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatelySettledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatelySettledAt: %w", err)
	}
	return oldValue.LatelySettledAt, nil
}

// ResetLatelySettledAt resets all changes to the "lately_settled_at" field.
func (m *ExtraServiceOrderMutation) ResetLatelySettledAt() {
	m.lately_settled_at = nil
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *ExtraServiceOrderMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[extraserviceorder.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *ExtraServiceOrderMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *ExtraServiceOrderMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *ExtraServiceOrderMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearMissionOrder clears the "mission_order" edge to the MissionOrder entity.
func (m *ExtraServiceOrderMutation) ClearMissionOrder() {
	m.clearedmission_order = true
	m.clearedFields[extraserviceorder.FieldMissionOrderID] = struct{}{}
}

// MissionOrderCleared reports if the "mission_order" edge to the MissionOrder entity was cleared.
func (m *ExtraServiceOrderMutation) MissionOrderCleared() bool {
	return m.clearedmission_order
}

// MissionOrderIDs returns the "mission_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionOrderID instead. It exists only for internal usage by the builders.
func (m *ExtraServiceOrderMutation) MissionOrderIDs() (ids []int64) {
	if id := m.mission_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionOrder resets all changes to the "mission_order" edge.
func (m *ExtraServiceOrderMutation) ResetMissionOrder() {
	m.mission_order = nil
	m.clearedmission_order = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *ExtraServiceOrderMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[extraserviceorder.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *ExtraServiceOrderMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *ExtraServiceOrderMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *ExtraServiceOrderMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// ClearMissionBatch clears the "mission_batch" edge to the MissionBatch entity.
func (m *ExtraServiceOrderMutation) ClearMissionBatch() {
	m.clearedmission_batch = true
	m.clearedFields[extraserviceorder.FieldMissionBatchID] = struct{}{}
}

// MissionBatchCleared reports if the "mission_batch" edge to the MissionBatch entity was cleared.
func (m *ExtraServiceOrderMutation) MissionBatchCleared() bool {
	return m.clearedmission_batch
}

// MissionBatchIDs returns the "mission_batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionBatchID instead. It exists only for internal usage by the builders.
func (m *ExtraServiceOrderMutation) MissionBatchIDs() (ids []int64) {
	if id := m.mission_batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionBatch resets all changes to the "mission_batch" edge.
func (m *ExtraServiceOrderMutation) ResetMissionBatch() {
	m.mission_batch = nil
	m.clearedmission_batch = false
}

// Where appends a list predicates to the ExtraServiceOrderMutation builder.
func (m *ExtraServiceOrderMutation) Where(ps ...predicate.ExtraServiceOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExtraServiceOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExtraServiceOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExtraServiceOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExtraServiceOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExtraServiceOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExtraServiceOrder).
func (m *ExtraServiceOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtraServiceOrderMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_by != nil {
		fields = append(fields, extraserviceorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, extraserviceorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, extraserviceorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, extraserviceorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, extraserviceorder.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, extraserviceorder.FieldMissionID)
	}
	if m.mission_order != nil {
		fields = append(fields, extraserviceorder.FieldMissionOrderID)
	}
	if m.extra_service_billing_type != nil {
		fields = append(fields, extraserviceorder.FieldExtraServiceBillingType)
	}
	if m.amount != nil {
		fields = append(fields, extraserviceorder.FieldAmount)
	}
	if m.symbol != nil {
		fields = append(fields, extraserviceorder.FieldSymbolID)
	}
	if m.unit_cep != nil {
		fields = append(fields, extraserviceorder.FieldUnitCep)
	}
	if m.extra_service_type != nil {
		fields = append(fields, extraserviceorder.FieldExtraServiceType)
	}
	if m.buy_duration != nil {
		fields = append(fields, extraserviceorder.FieldBuyDuration)
	}
	if m.started_at != nil {
		fields = append(fields, extraserviceorder.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, extraserviceorder.FieldFinishedAt)
	}
	if m.plan_started_at != nil {
		fields = append(fields, extraserviceorder.FieldPlanStartedAt)
	}
	if m.plan_finished_at != nil {
		fields = append(fields, extraserviceorder.FieldPlanFinishedAt)
	}
	if m.mission_batch != nil {
		fields = append(fields, extraserviceorder.FieldMissionBatchID)
	}
	if m.settled_amount != nil {
		fields = append(fields, extraserviceorder.FieldSettledAmount)
	}
	if m.settled_count != nil {
		fields = append(fields, extraserviceorder.FieldSettledCount)
	}
	if m.total_settle_count != nil {
		fields = append(fields, extraserviceorder.FieldTotalSettleCount)
	}
	if m.lately_settled_at != nil {
		fields = append(fields, extraserviceorder.FieldLatelySettledAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtraServiceOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		return m.CreatedBy()
	case extraserviceorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case extraserviceorder.FieldCreatedAt:
		return m.CreatedAt()
	case extraserviceorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case extraserviceorder.FieldDeletedAt:
		return m.DeletedAt()
	case extraserviceorder.FieldMissionID:
		return m.MissionID()
	case extraserviceorder.FieldMissionOrderID:
		return m.MissionOrderID()
	case extraserviceorder.FieldExtraServiceBillingType:
		return m.ExtraServiceBillingType()
	case extraserviceorder.FieldAmount:
		return m.Amount()
	case extraserviceorder.FieldSymbolID:
		return m.SymbolID()
	case extraserviceorder.FieldUnitCep:
		return m.UnitCep()
	case extraserviceorder.FieldExtraServiceType:
		return m.ExtraServiceType()
	case extraserviceorder.FieldBuyDuration:
		return m.BuyDuration()
	case extraserviceorder.FieldStartedAt:
		return m.StartedAt()
	case extraserviceorder.FieldFinishedAt:
		return m.FinishedAt()
	case extraserviceorder.FieldPlanStartedAt:
		return m.PlanStartedAt()
	case extraserviceorder.FieldPlanFinishedAt:
		return m.PlanFinishedAt()
	case extraserviceorder.FieldMissionBatchID:
		return m.MissionBatchID()
	case extraserviceorder.FieldSettledAmount:
		return m.SettledAmount()
	case extraserviceorder.FieldSettledCount:
		return m.SettledCount()
	case extraserviceorder.FieldTotalSettleCount:
		return m.TotalSettleCount()
	case extraserviceorder.FieldLatelySettledAt:
		return m.LatelySettledAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtraServiceOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case extraserviceorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case extraserviceorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case extraserviceorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case extraserviceorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case extraserviceorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case extraserviceorder.FieldMissionOrderID:
		return m.OldMissionOrderID(ctx)
	case extraserviceorder.FieldExtraServiceBillingType:
		return m.OldExtraServiceBillingType(ctx)
	case extraserviceorder.FieldAmount:
		return m.OldAmount(ctx)
	case extraserviceorder.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case extraserviceorder.FieldUnitCep:
		return m.OldUnitCep(ctx)
	case extraserviceorder.FieldExtraServiceType:
		return m.OldExtraServiceType(ctx)
	case extraserviceorder.FieldBuyDuration:
		return m.OldBuyDuration(ctx)
	case extraserviceorder.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case extraserviceorder.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case extraserviceorder.FieldPlanStartedAt:
		return m.OldPlanStartedAt(ctx)
	case extraserviceorder.FieldPlanFinishedAt:
		return m.OldPlanFinishedAt(ctx)
	case extraserviceorder.FieldMissionBatchID:
		return m.OldMissionBatchID(ctx)
	case extraserviceorder.FieldSettledAmount:
		return m.OldSettledAmount(ctx)
	case extraserviceorder.FieldSettledCount:
		return m.OldSettledCount(ctx)
	case extraserviceorder.FieldTotalSettleCount:
		return m.OldTotalSettleCount(ctx)
	case extraserviceorder.FieldLatelySettledAt:
		return m.OldLatelySettledAt(ctx)
	}
	return nil, fmt.Errorf("unknown ExtraServiceOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServiceOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case extraserviceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case extraserviceorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case extraserviceorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case extraserviceorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case extraserviceorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case extraserviceorder.FieldMissionOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionOrderID(v)
		return nil
	case extraserviceorder.FieldExtraServiceBillingType:
		v, ok := value.(enums.ExtraServiceBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceBillingType(v)
		return nil
	case extraserviceorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case extraserviceorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case extraserviceorder.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCep(v)
		return nil
	case extraserviceorder.FieldExtraServiceType:
		v, ok := value.(enums.ExtraServiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceType(v)
		return nil
	case extraserviceorder.FieldBuyDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyDuration(v)
		return nil
	case extraserviceorder.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case extraserviceorder.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case extraserviceorder.FieldPlanStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanStartedAt(v)
		return nil
	case extraserviceorder.FieldPlanFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanFinishedAt(v)
		return nil
	case extraserviceorder.FieldMissionBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchID(v)
		return nil
	case extraserviceorder.FieldSettledAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledAmount(v)
		return nil
	case extraserviceorder.FieldSettledCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledCount(v)
		return nil
	case extraserviceorder.FieldTotalSettleCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSettleCount(v)
		return nil
	case extraserviceorder.FieldLatelySettledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatelySettledAt(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtraServiceOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, extraserviceorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, extraserviceorder.FieldUpdatedBy)
	}
	if m.addamount != nil {
		fields = append(fields, extraserviceorder.FieldAmount)
	}
	if m.addunit_cep != nil {
		fields = append(fields, extraserviceorder.FieldUnitCep)
	}
	if m.addbuy_duration != nil {
		fields = append(fields, extraserviceorder.FieldBuyDuration)
	}
	if m.addsettled_amount != nil {
		fields = append(fields, extraserviceorder.FieldSettledAmount)
	}
	if m.addsettled_count != nil {
		fields = append(fields, extraserviceorder.FieldSettledCount)
	}
	if m.addtotal_settle_count != nil {
		fields = append(fields, extraserviceorder.FieldTotalSettleCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtraServiceOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case extraserviceorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case extraserviceorder.FieldAmount:
		return m.AddedAmount()
	case extraserviceorder.FieldUnitCep:
		return m.AddedUnitCep()
	case extraserviceorder.FieldBuyDuration:
		return m.AddedBuyDuration()
	case extraserviceorder.FieldSettledAmount:
		return m.AddedSettledAmount()
	case extraserviceorder.FieldSettledCount:
		return m.AddedSettledCount()
	case extraserviceorder.FieldTotalSettleCount:
		return m.AddedTotalSettleCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServiceOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case extraserviceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case extraserviceorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case extraserviceorder.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCep(v)
		return nil
	case extraserviceorder.FieldBuyDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuyDuration(v)
		return nil
	case extraserviceorder.FieldSettledAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettledAmount(v)
		return nil
	case extraserviceorder.FieldSettledCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettledCount(v)
		return nil
	case extraserviceorder.FieldTotalSettleCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSettleCount(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtraServiceOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extraserviceorder.FieldPlanStartedAt) {
		fields = append(fields, extraserviceorder.FieldPlanStartedAt)
	}
	if m.FieldCleared(extraserviceorder.FieldPlanFinishedAt) {
		fields = append(fields, extraserviceorder.FieldPlanFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtraServiceOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtraServiceOrderMutation) ClearField(name string) error {
	switch name {
	case extraserviceorder.FieldPlanStartedAt:
		m.ClearPlanStartedAt()
		return nil
	case extraserviceorder.FieldPlanFinishedAt:
		m.ClearPlanFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtraServiceOrderMutation) ResetField(name string) error {
	switch name {
	case extraserviceorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case extraserviceorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case extraserviceorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case extraserviceorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case extraserviceorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case extraserviceorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case extraserviceorder.FieldMissionOrderID:
		m.ResetMissionOrderID()
		return nil
	case extraserviceorder.FieldExtraServiceBillingType:
		m.ResetExtraServiceBillingType()
		return nil
	case extraserviceorder.FieldAmount:
		m.ResetAmount()
		return nil
	case extraserviceorder.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case extraserviceorder.FieldUnitCep:
		m.ResetUnitCep()
		return nil
	case extraserviceorder.FieldExtraServiceType:
		m.ResetExtraServiceType()
		return nil
	case extraserviceorder.FieldBuyDuration:
		m.ResetBuyDuration()
		return nil
	case extraserviceorder.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case extraserviceorder.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case extraserviceorder.FieldPlanStartedAt:
		m.ResetPlanStartedAt()
		return nil
	case extraserviceorder.FieldPlanFinishedAt:
		m.ResetPlanFinishedAt()
		return nil
	case extraserviceorder.FieldMissionBatchID:
		m.ResetMissionBatchID()
		return nil
	case extraserviceorder.FieldSettledAmount:
		m.ResetSettledAmount()
		return nil
	case extraserviceorder.FieldSettledCount:
		m.ResetSettledCount()
		return nil
	case extraserviceorder.FieldTotalSettleCount:
		m.ResetTotalSettleCount()
		return nil
	case extraserviceorder.FieldLatelySettledAt:
		m.ResetLatelySettledAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtraServiceOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.mission != nil {
		edges = append(edges, extraserviceorder.EdgeMission)
	}
	if m.mission_order != nil {
		edges = append(edges, extraserviceorder.EdgeMissionOrder)
	}
	if m.symbol != nil {
		edges = append(edges, extraserviceorder.EdgeSymbol)
	}
	if m.mission_batch != nil {
		edges = append(edges, extraserviceorder.EdgeMissionBatch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtraServiceOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case extraserviceorder.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case extraserviceorder.EdgeMissionOrder:
		if id := m.mission_order; id != nil {
			return []ent.Value{*id}
		}
	case extraserviceorder.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	case extraserviceorder.EdgeMissionBatch:
		if id := m.mission_batch; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtraServiceOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtraServiceOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtraServiceOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmission {
		edges = append(edges, extraserviceorder.EdgeMission)
	}
	if m.clearedmission_order {
		edges = append(edges, extraserviceorder.EdgeMissionOrder)
	}
	if m.clearedsymbol {
		edges = append(edges, extraserviceorder.EdgeSymbol)
	}
	if m.clearedmission_batch {
		edges = append(edges, extraserviceorder.EdgeMissionBatch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtraServiceOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case extraserviceorder.EdgeMission:
		return m.clearedmission
	case extraserviceorder.EdgeMissionOrder:
		return m.clearedmission_order
	case extraserviceorder.EdgeSymbol:
		return m.clearedsymbol
	case extraserviceorder.EdgeMissionBatch:
		return m.clearedmission_batch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtraServiceOrderMutation) ClearEdge(name string) error {
	switch name {
	case extraserviceorder.EdgeMission:
		m.ClearMission()
		return nil
	case extraserviceorder.EdgeMissionOrder:
		m.ClearMissionOrder()
		return nil
	case extraserviceorder.EdgeSymbol:
		m.ClearSymbol()
		return nil
	case extraserviceorder.EdgeMissionBatch:
		m.ClearMissionBatch()
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtraServiceOrderMutation) ResetEdge(name string) error {
	switch name {
	case extraserviceorder.EdgeMission:
		m.ResetMission()
		return nil
	case extraserviceorder.EdgeMissionOrder:
		m.ResetMissionOrder()
		return nil
	case extraserviceorder.EdgeSymbol:
		m.ResetSymbol()
		return nil
	case extraserviceorder.EdgeMissionBatch:
		m.ResetMissionBatch()
		return nil
	}
	return fmt.Errorf("unknown ExtraServiceOrder edge %s", name)
}

// ExtraServicePriceMutation represents an operation that mutates the ExtraServicePrice nodes in the graph.
type ExtraServicePriceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	extra_service_type         *enums.ExtraServiceType
	extra_service_billing_type *enums.ExtraServiceBillingType
	cep                        *int64
	addcep                     *int64
	started_at                 *time.Time
	finished_at                *time.Time
	is_deprecated              *bool
	is_sensitive               *bool
	clearedFields              map[string]struct{}
	extra_service              *int64
	clearedextra_service       bool
	done                       bool
	oldValue                   func(context.Context) (*ExtraServicePrice, error)
	predicates                 []predicate.ExtraServicePrice
}

var _ ent.Mutation = (*ExtraServicePriceMutation)(nil)

// extraservicepriceOption allows management of the mutation configuration using functional options.
type extraservicepriceOption func(*ExtraServicePriceMutation)

// newExtraServicePriceMutation creates new mutation for the ExtraServicePrice entity.
func newExtraServicePriceMutation(c config, op Op, opts ...extraservicepriceOption) *ExtraServicePriceMutation {
	m := &ExtraServicePriceMutation{
		config:        c,
		op:            op,
		typ:           TypeExtraServicePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtraServicePriceID sets the ID field of the mutation.
func withExtraServicePriceID(id int64) extraservicepriceOption {
	return func(m *ExtraServicePriceMutation) {
		var (
			err   error
			once  sync.Once
			value *ExtraServicePrice
		)
		m.oldValue = func(ctx context.Context) (*ExtraServicePrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExtraServicePrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtraServicePrice sets the old ExtraServicePrice of the mutation.
func withExtraServicePrice(node *ExtraServicePrice) extraservicepriceOption {
	return func(m *ExtraServicePriceMutation) {
		m.oldValue = func(context.Context) (*ExtraServicePrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtraServicePriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtraServicePriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExtraServicePrice entities.
func (m *ExtraServicePriceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtraServicePriceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtraServicePriceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExtraServicePrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ExtraServicePriceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ExtraServicePriceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ExtraServicePriceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ExtraServicePriceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ExtraServicePriceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ExtraServicePriceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ExtraServicePriceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ExtraServicePriceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ExtraServicePriceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ExtraServicePriceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExtraServicePriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExtraServicePriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExtraServicePriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExtraServicePriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExtraServicePriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExtraServicePriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExtraServicePriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExtraServicePriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExtraServicePriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetExtraServiceType sets the "extra_service_type" field.
func (m *ExtraServicePriceMutation) SetExtraServiceType(est enums.ExtraServiceType) {
	m.extra_service_type = &est
}

// ExtraServiceType returns the value of the "extra_service_type" field in the mutation.
func (m *ExtraServicePriceMutation) ExtraServiceType() (r enums.ExtraServiceType, exists bool) {
	v := m.extra_service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceType returns the old "extra_service_type" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldExtraServiceType(ctx context.Context) (v enums.ExtraServiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceType: %w", err)
	}
	return oldValue.ExtraServiceType, nil
}

// ResetExtraServiceType resets all changes to the "extra_service_type" field.
func (m *ExtraServicePriceMutation) ResetExtraServiceType() {
	m.extra_service_type = nil
}

// SetExtraServiceBillingType sets the "extra_service_billing_type" field.
func (m *ExtraServicePriceMutation) SetExtraServiceBillingType(esbt enums.ExtraServiceBillingType) {
	m.extra_service_billing_type = &esbt
}

// ExtraServiceBillingType returns the value of the "extra_service_billing_type" field in the mutation.
func (m *ExtraServicePriceMutation) ExtraServiceBillingType() (r enums.ExtraServiceBillingType, exists bool) {
	v := m.extra_service_billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceBillingType returns the old "extra_service_billing_type" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldExtraServiceBillingType(ctx context.Context) (v enums.ExtraServiceBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceBillingType: %w", err)
	}
	return oldValue.ExtraServiceBillingType, nil
}

// ResetExtraServiceBillingType resets all changes to the "extra_service_billing_type" field.
func (m *ExtraServicePriceMutation) ResetExtraServiceBillingType() {
	m.extra_service_billing_type = nil
}

// SetExtraServiceID sets the "extra_service_id" field.
func (m *ExtraServicePriceMutation) SetExtraServiceID(i int64) {
	m.extra_service = &i
}

// ExtraServiceID returns the value of the "extra_service_id" field in the mutation.
func (m *ExtraServicePriceMutation) ExtraServiceID() (r int64, exists bool) {
	v := m.extra_service
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceID returns the old "extra_service_id" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldExtraServiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceID: %w", err)
	}
	return oldValue.ExtraServiceID, nil
}

// ResetExtraServiceID resets all changes to the "extra_service_id" field.
func (m *ExtraServicePriceMutation) ResetExtraServiceID() {
	m.extra_service = nil
}

// SetCep sets the "cep" field.
func (m *ExtraServicePriceMutation) SetCep(i int64) {
	m.cep = &i
	m.addcep = nil
}

// Cep returns the value of the "cep" field in the mutation.
func (m *ExtraServicePriceMutation) Cep() (r int64, exists bool) {
	v := m.cep
	if v == nil {
		return
	}
	return *v, true
}

// OldCep returns the old "cep" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCep: %w", err)
	}
	return oldValue.Cep, nil
}

// AddCep adds i to the "cep" field.
func (m *ExtraServicePriceMutation) AddCep(i int64) {
	if m.addcep != nil {
		*m.addcep += i
	} else {
		m.addcep = &i
	}
}

// AddedCep returns the value that was added to the "cep" field in this mutation.
func (m *ExtraServicePriceMutation) AddedCep() (r int64, exists bool) {
	v := m.addcep
	if v == nil {
		return
	}
	return *v, true
}

// ResetCep resets all changes to the "cep" field.
func (m *ExtraServicePriceMutation) ResetCep() {
	m.cep = nil
	m.addcep = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ExtraServicePriceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ExtraServicePriceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *ExtraServicePriceMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[extraserviceprice.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *ExtraServicePriceMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[extraserviceprice.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ExtraServicePriceMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, extraserviceprice.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *ExtraServicePriceMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ExtraServicePriceMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *ExtraServicePriceMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[extraserviceprice.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *ExtraServicePriceMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[extraserviceprice.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ExtraServicePriceMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, extraserviceprice.FieldFinishedAt)
}

// SetIsDeprecated sets the "is_deprecated" field.
func (m *ExtraServicePriceMutation) SetIsDeprecated(b bool) {
	m.is_deprecated = &b
}

// IsDeprecated returns the value of the "is_deprecated" field in the mutation.
func (m *ExtraServicePriceMutation) IsDeprecated() (r bool, exists bool) {
	v := m.is_deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeprecated returns the old "is_deprecated" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldIsDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeprecated: %w", err)
	}
	return oldValue.IsDeprecated, nil
}

// ResetIsDeprecated resets all changes to the "is_deprecated" field.
func (m *ExtraServicePriceMutation) ResetIsDeprecated() {
	m.is_deprecated = nil
}

// SetIsSensitive sets the "is_sensitive" field.
func (m *ExtraServicePriceMutation) SetIsSensitive(b bool) {
	m.is_sensitive = &b
}

// IsSensitive returns the value of the "is_sensitive" field in the mutation.
func (m *ExtraServicePriceMutation) IsSensitive() (r bool, exists bool) {
	v := m.is_sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSensitive returns the old "is_sensitive" field's value of the ExtraServicePrice entity.
// If the ExtraServicePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraServicePriceMutation) OldIsSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSensitive: %w", err)
	}
	return oldValue.IsSensitive, nil
}

// ResetIsSensitive resets all changes to the "is_sensitive" field.
func (m *ExtraServicePriceMutation) ResetIsSensitive() {
	m.is_sensitive = nil
}

// ClearExtraService clears the "extra_service" edge to the ExtraService entity.
func (m *ExtraServicePriceMutation) ClearExtraService() {
	m.clearedextra_service = true
	m.clearedFields[extraserviceprice.FieldExtraServiceID] = struct{}{}
}

// ExtraServiceCleared reports if the "extra_service" edge to the ExtraService entity was cleared.
func (m *ExtraServicePriceMutation) ExtraServiceCleared() bool {
	return m.clearedextra_service
}

// ExtraServiceIDs returns the "extra_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExtraServiceID instead. It exists only for internal usage by the builders.
func (m *ExtraServicePriceMutation) ExtraServiceIDs() (ids []int64) {
	if id := m.extra_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExtraService resets all changes to the "extra_service" edge.
func (m *ExtraServicePriceMutation) ResetExtraService() {
	m.extra_service = nil
	m.clearedextra_service = false
}

// Where appends a list predicates to the ExtraServicePriceMutation builder.
func (m *ExtraServicePriceMutation) Where(ps ...predicate.ExtraServicePrice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExtraServicePriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExtraServicePriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExtraServicePrice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExtraServicePriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExtraServicePriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExtraServicePrice).
func (m *ExtraServicePriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtraServicePriceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, extraserviceprice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, extraserviceprice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, extraserviceprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, extraserviceprice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, extraserviceprice.FieldDeletedAt)
	}
	if m.extra_service_type != nil {
		fields = append(fields, extraserviceprice.FieldExtraServiceType)
	}
	if m.extra_service_billing_type != nil {
		fields = append(fields, extraserviceprice.FieldExtraServiceBillingType)
	}
	if m.extra_service != nil {
		fields = append(fields, extraserviceprice.FieldExtraServiceID)
	}
	if m.cep != nil {
		fields = append(fields, extraserviceprice.FieldCep)
	}
	if m.started_at != nil {
		fields = append(fields, extraserviceprice.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, extraserviceprice.FieldFinishedAt)
	}
	if m.is_deprecated != nil {
		fields = append(fields, extraserviceprice.FieldIsDeprecated)
	}
	if m.is_sensitive != nil {
		fields = append(fields, extraserviceprice.FieldIsSensitive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtraServicePriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		return m.CreatedBy()
	case extraserviceprice.FieldUpdatedBy:
		return m.UpdatedBy()
	case extraserviceprice.FieldCreatedAt:
		return m.CreatedAt()
	case extraserviceprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case extraserviceprice.FieldDeletedAt:
		return m.DeletedAt()
	case extraserviceprice.FieldExtraServiceType:
		return m.ExtraServiceType()
	case extraserviceprice.FieldExtraServiceBillingType:
		return m.ExtraServiceBillingType()
	case extraserviceprice.FieldExtraServiceID:
		return m.ExtraServiceID()
	case extraserviceprice.FieldCep:
		return m.Cep()
	case extraserviceprice.FieldStartedAt:
		return m.StartedAt()
	case extraserviceprice.FieldFinishedAt:
		return m.FinishedAt()
	case extraserviceprice.FieldIsDeprecated:
		return m.IsDeprecated()
	case extraserviceprice.FieldIsSensitive:
		return m.IsSensitive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtraServicePriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case extraserviceprice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case extraserviceprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case extraserviceprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case extraserviceprice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case extraserviceprice.FieldExtraServiceType:
		return m.OldExtraServiceType(ctx)
	case extraserviceprice.FieldExtraServiceBillingType:
		return m.OldExtraServiceBillingType(ctx)
	case extraserviceprice.FieldExtraServiceID:
		return m.OldExtraServiceID(ctx)
	case extraserviceprice.FieldCep:
		return m.OldCep(ctx)
	case extraserviceprice.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case extraserviceprice.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case extraserviceprice.FieldIsDeprecated:
		return m.OldIsDeprecated(ctx)
	case extraserviceprice.FieldIsSensitive:
		return m.OldIsSensitive(ctx)
	}
	return nil, fmt.Errorf("unknown ExtraServicePrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServicePriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case extraserviceprice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case extraserviceprice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case extraserviceprice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case extraserviceprice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case extraserviceprice.FieldExtraServiceType:
		v, ok := value.(enums.ExtraServiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceType(v)
		return nil
	case extraserviceprice.FieldExtraServiceBillingType:
		v, ok := value.(enums.ExtraServiceBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceBillingType(v)
		return nil
	case extraserviceprice.FieldExtraServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceID(v)
		return nil
	case extraserviceprice.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCep(v)
		return nil
	case extraserviceprice.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case extraserviceprice.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case extraserviceprice.FieldIsDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeprecated(v)
		return nil
	case extraserviceprice.FieldIsSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSensitive(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtraServicePriceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, extraserviceprice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, extraserviceprice.FieldUpdatedBy)
	}
	if m.addcep != nil {
		fields = append(fields, extraserviceprice.FieldCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtraServicePriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case extraserviceprice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case extraserviceprice.FieldCep:
		return m.AddedCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraServicePriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case extraserviceprice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case extraserviceprice.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCep(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtraServicePriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extraserviceprice.FieldStartedAt) {
		fields = append(fields, extraserviceprice.FieldStartedAt)
	}
	if m.FieldCleared(extraserviceprice.FieldFinishedAt) {
		fields = append(fields, extraserviceprice.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtraServicePriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtraServicePriceMutation) ClearField(name string) error {
	switch name {
	case extraserviceprice.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case extraserviceprice.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtraServicePriceMutation) ResetField(name string) error {
	switch name {
	case extraserviceprice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case extraserviceprice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case extraserviceprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case extraserviceprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case extraserviceprice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case extraserviceprice.FieldExtraServiceType:
		m.ResetExtraServiceType()
		return nil
	case extraserviceprice.FieldExtraServiceBillingType:
		m.ResetExtraServiceBillingType()
		return nil
	case extraserviceprice.FieldExtraServiceID:
		m.ResetExtraServiceID()
		return nil
	case extraserviceprice.FieldCep:
		m.ResetCep()
		return nil
	case extraserviceprice.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case extraserviceprice.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case extraserviceprice.FieldIsDeprecated:
		m.ResetIsDeprecated()
		return nil
	case extraserviceprice.FieldIsSensitive:
		m.ResetIsSensitive()
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtraServicePriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.extra_service != nil {
		edges = append(edges, extraserviceprice.EdgeExtraService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtraServicePriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case extraserviceprice.EdgeExtraService:
		if id := m.extra_service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtraServicePriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtraServicePriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtraServicePriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedextra_service {
		edges = append(edges, extraserviceprice.EdgeExtraService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtraServicePriceMutation) EdgeCleared(name string) bool {
	switch name {
	case extraserviceprice.EdgeExtraService:
		return m.clearedextra_service
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtraServicePriceMutation) ClearEdge(name string) error {
	switch name {
	case extraserviceprice.EdgeExtraService:
		m.ClearExtraService()
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtraServicePriceMutation) ResetEdge(name string) error {
	switch name {
	case extraserviceprice.EdgeExtraService:
		m.ResetExtraService()
		return nil
	}
	return fmt.Errorf("unknown ExtraServicePrice edge %s", name)
}

// FrpcInfoMutation represents an operation that mutates the FrpcInfo nodes in the graph.
type FrpcInfoMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_by       *int64
	addcreated_by    *int64
	updated_by       *int64
	addupdated_by    *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	tag              *string
	_type            *string
	local_ip         *string
	local_port       *int
	addlocal_port    *int
	remote_port      *int
	addremote_port   *int
	is_using         *bool
	clearedFields    map[string]struct{}
	frps_info        *int64
	clearedfrps_info bool
	device           *int64
	cleareddevice    bool
	done             bool
	oldValue         func(context.Context) (*FrpcInfo, error)
	predicates       []predicate.FrpcInfo
}

var _ ent.Mutation = (*FrpcInfoMutation)(nil)

// frpcinfoOption allows management of the mutation configuration using functional options.
type frpcinfoOption func(*FrpcInfoMutation)

// newFrpcInfoMutation creates new mutation for the FrpcInfo entity.
func newFrpcInfoMutation(c config, op Op, opts ...frpcinfoOption) *FrpcInfoMutation {
	m := &FrpcInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeFrpcInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFrpcInfoID sets the ID field of the mutation.
func withFrpcInfoID(id int64) frpcinfoOption {
	return func(m *FrpcInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *FrpcInfo
		)
		m.oldValue = func(ctx context.Context) (*FrpcInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FrpcInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFrpcInfo sets the old FrpcInfo of the mutation.
func withFrpcInfo(node *FrpcInfo) frpcinfoOption {
	return func(m *FrpcInfoMutation) {
		m.oldValue = func(context.Context) (*FrpcInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FrpcInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FrpcInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FrpcInfo entities.
func (m *FrpcInfoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FrpcInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FrpcInfoMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FrpcInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *FrpcInfoMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FrpcInfoMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FrpcInfoMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FrpcInfoMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FrpcInfoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FrpcInfoMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FrpcInfoMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FrpcInfoMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FrpcInfoMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FrpcInfoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FrpcInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FrpcInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FrpcInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FrpcInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FrpcInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FrpcInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FrpcInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FrpcInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FrpcInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTag sets the "tag" field.
func (m *FrpcInfoMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *FrpcInfoMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *FrpcInfoMutation) ResetTag() {
	m.tag = nil
}

// SetType sets the "type" field.
func (m *FrpcInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FrpcInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FrpcInfoMutation) ResetType() {
	m._type = nil
}

// SetLocalIP sets the "local_ip" field.
func (m *FrpcInfoMutation) SetLocalIP(s string) {
	m.local_ip = &s
}

// LocalIP returns the value of the "local_ip" field in the mutation.
func (m *FrpcInfoMutation) LocalIP() (r string, exists bool) {
	v := m.local_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalIP returns the old "local_ip" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldLocalIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalIP: %w", err)
	}
	return oldValue.LocalIP, nil
}

// ResetLocalIP resets all changes to the "local_ip" field.
func (m *FrpcInfoMutation) ResetLocalIP() {
	m.local_ip = nil
}

// SetLocalPort sets the "local_port" field.
func (m *FrpcInfoMutation) SetLocalPort(i int) {
	m.local_port = &i
	m.addlocal_port = nil
}

// LocalPort returns the value of the "local_port" field in the mutation.
func (m *FrpcInfoMutation) LocalPort() (r int, exists bool) {
	v := m.local_port
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalPort returns the old "local_port" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldLocalPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalPort: %w", err)
	}
	return oldValue.LocalPort, nil
}

// AddLocalPort adds i to the "local_port" field.
func (m *FrpcInfoMutation) AddLocalPort(i int) {
	if m.addlocal_port != nil {
		*m.addlocal_port += i
	} else {
		m.addlocal_port = &i
	}
}

// AddedLocalPort returns the value that was added to the "local_port" field in this mutation.
func (m *FrpcInfoMutation) AddedLocalPort() (r int, exists bool) {
	v := m.addlocal_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocalPort resets all changes to the "local_port" field.
func (m *FrpcInfoMutation) ResetLocalPort() {
	m.local_port = nil
	m.addlocal_port = nil
}

// SetRemotePort sets the "remote_port" field.
func (m *FrpcInfoMutation) SetRemotePort(i int) {
	m.remote_port = &i
	m.addremote_port = nil
}

// RemotePort returns the value of the "remote_port" field in the mutation.
func (m *FrpcInfoMutation) RemotePort() (r int, exists bool) {
	v := m.remote_port
	if v == nil {
		return
	}
	return *v, true
}

// OldRemotePort returns the old "remote_port" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldRemotePort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemotePort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemotePort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemotePort: %w", err)
	}
	return oldValue.RemotePort, nil
}

// AddRemotePort adds i to the "remote_port" field.
func (m *FrpcInfoMutation) AddRemotePort(i int) {
	if m.addremote_port != nil {
		*m.addremote_port += i
	} else {
		m.addremote_port = &i
	}
}

// AddedRemotePort returns the value that was added to the "remote_port" field in this mutation.
func (m *FrpcInfoMutation) AddedRemotePort() (r int, exists bool) {
	v := m.addremote_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemotePort resets all changes to the "remote_port" field.
func (m *FrpcInfoMutation) ResetRemotePort() {
	m.remote_port = nil
	m.addremote_port = nil
}

// SetIsUsing sets the "is_using" field.
func (m *FrpcInfoMutation) SetIsUsing(b bool) {
	m.is_using = &b
}

// IsUsing returns the value of the "is_using" field in the mutation.
func (m *FrpcInfoMutation) IsUsing() (r bool, exists bool) {
	v := m.is_using
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUsing returns the old "is_using" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldIsUsing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUsing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUsing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUsing: %w", err)
	}
	return oldValue.IsUsing, nil
}

// ResetIsUsing resets all changes to the "is_using" field.
func (m *FrpcInfoMutation) ResetIsUsing() {
	m.is_using = nil
}

// SetFrpsID sets the "frps_id" field.
func (m *FrpcInfoMutation) SetFrpsID(i int64) {
	m.frps_info = &i
}

// FrpsID returns the value of the "frps_id" field in the mutation.
func (m *FrpcInfoMutation) FrpsID() (r int64, exists bool) {
	v := m.frps_info
	if v == nil {
		return
	}
	return *v, true
}

// OldFrpsID returns the old "frps_id" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldFrpsID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrpsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrpsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrpsID: %w", err)
	}
	return oldValue.FrpsID, nil
}

// ResetFrpsID resets all changes to the "frps_id" field.
func (m *FrpcInfoMutation) ResetFrpsID() {
	m.frps_info = nil
}

// SetDeviceID sets the "device_id" field.
func (m *FrpcInfoMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *FrpcInfoMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the FrpcInfo entity.
// If the FrpcInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpcInfoMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *FrpcInfoMutation) ResetDeviceID() {
	m.device = nil
}

// SetFrpsInfoID sets the "frps_info" edge to the FrpsInfo entity by id.
func (m *FrpcInfoMutation) SetFrpsInfoID(id int64) {
	m.frps_info = &id
}

// ClearFrpsInfo clears the "frps_info" edge to the FrpsInfo entity.
func (m *FrpcInfoMutation) ClearFrpsInfo() {
	m.clearedfrps_info = true
	m.clearedFields[frpcinfo.FieldFrpsID] = struct{}{}
}

// FrpsInfoCleared reports if the "frps_info" edge to the FrpsInfo entity was cleared.
func (m *FrpcInfoMutation) FrpsInfoCleared() bool {
	return m.clearedfrps_info
}

// FrpsInfoID returns the "frps_info" edge ID in the mutation.
func (m *FrpcInfoMutation) FrpsInfoID() (id int64, exists bool) {
	if m.frps_info != nil {
		return *m.frps_info, true
	}
	return
}

// FrpsInfoIDs returns the "frps_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FrpsInfoID instead. It exists only for internal usage by the builders.
func (m *FrpcInfoMutation) FrpsInfoIDs() (ids []int64) {
	if id := m.frps_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFrpsInfo resets all changes to the "frps_info" edge.
func (m *FrpcInfoMutation) ResetFrpsInfo() {
	m.frps_info = nil
	m.clearedfrps_info = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *FrpcInfoMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[frpcinfo.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *FrpcInfoMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *FrpcInfoMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *FrpcInfoMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the FrpcInfoMutation builder.
func (m *FrpcInfoMutation) Where(ps ...predicate.FrpcInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FrpcInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FrpcInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FrpcInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FrpcInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FrpcInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FrpcInfo).
func (m *FrpcInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FrpcInfoMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, frpcinfo.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, frpcinfo.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, frpcinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, frpcinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, frpcinfo.FieldDeletedAt)
	}
	if m.tag != nil {
		fields = append(fields, frpcinfo.FieldTag)
	}
	if m._type != nil {
		fields = append(fields, frpcinfo.FieldType)
	}
	if m.local_ip != nil {
		fields = append(fields, frpcinfo.FieldLocalIP)
	}
	if m.local_port != nil {
		fields = append(fields, frpcinfo.FieldLocalPort)
	}
	if m.remote_port != nil {
		fields = append(fields, frpcinfo.FieldRemotePort)
	}
	if m.is_using != nil {
		fields = append(fields, frpcinfo.FieldIsUsing)
	}
	if m.frps_info != nil {
		fields = append(fields, frpcinfo.FieldFrpsID)
	}
	if m.device != nil {
		fields = append(fields, frpcinfo.FieldDeviceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FrpcInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case frpcinfo.FieldCreatedBy:
		return m.CreatedBy()
	case frpcinfo.FieldUpdatedBy:
		return m.UpdatedBy()
	case frpcinfo.FieldCreatedAt:
		return m.CreatedAt()
	case frpcinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case frpcinfo.FieldDeletedAt:
		return m.DeletedAt()
	case frpcinfo.FieldTag:
		return m.Tag()
	case frpcinfo.FieldType:
		return m.GetType()
	case frpcinfo.FieldLocalIP:
		return m.LocalIP()
	case frpcinfo.FieldLocalPort:
		return m.LocalPort()
	case frpcinfo.FieldRemotePort:
		return m.RemotePort()
	case frpcinfo.FieldIsUsing:
		return m.IsUsing()
	case frpcinfo.FieldFrpsID:
		return m.FrpsID()
	case frpcinfo.FieldDeviceID:
		return m.DeviceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FrpcInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case frpcinfo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case frpcinfo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case frpcinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case frpcinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case frpcinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case frpcinfo.FieldTag:
		return m.OldTag(ctx)
	case frpcinfo.FieldType:
		return m.OldType(ctx)
	case frpcinfo.FieldLocalIP:
		return m.OldLocalIP(ctx)
	case frpcinfo.FieldLocalPort:
		return m.OldLocalPort(ctx)
	case frpcinfo.FieldRemotePort:
		return m.OldRemotePort(ctx)
	case frpcinfo.FieldIsUsing:
		return m.OldIsUsing(ctx)
	case frpcinfo.FieldFrpsID:
		return m.OldFrpsID(ctx)
	case frpcinfo.FieldDeviceID:
		return m.OldDeviceID(ctx)
	}
	return nil, fmt.Errorf("unknown FrpcInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrpcInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case frpcinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case frpcinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case frpcinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case frpcinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case frpcinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case frpcinfo.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case frpcinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case frpcinfo.FieldLocalIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalIP(v)
		return nil
	case frpcinfo.FieldLocalPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalPort(v)
		return nil
	case frpcinfo.FieldRemotePort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemotePort(v)
		return nil
	case frpcinfo.FieldIsUsing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUsing(v)
		return nil
	case frpcinfo.FieldFrpsID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrpsID(v)
		return nil
	case frpcinfo.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FrpcInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, frpcinfo.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, frpcinfo.FieldUpdatedBy)
	}
	if m.addlocal_port != nil {
		fields = append(fields, frpcinfo.FieldLocalPort)
	}
	if m.addremote_port != nil {
		fields = append(fields, frpcinfo.FieldRemotePort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FrpcInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case frpcinfo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case frpcinfo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case frpcinfo.FieldLocalPort:
		return m.AddedLocalPort()
	case frpcinfo.FieldRemotePort:
		return m.AddedRemotePort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrpcInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case frpcinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case frpcinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case frpcinfo.FieldLocalPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocalPort(v)
		return nil
	case frpcinfo.FieldRemotePort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemotePort(v)
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FrpcInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FrpcInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FrpcInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FrpcInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FrpcInfoMutation) ResetField(name string) error {
	switch name {
	case frpcinfo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case frpcinfo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case frpcinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case frpcinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case frpcinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case frpcinfo.FieldTag:
		m.ResetTag()
		return nil
	case frpcinfo.FieldType:
		m.ResetType()
		return nil
	case frpcinfo.FieldLocalIP:
		m.ResetLocalIP()
		return nil
	case frpcinfo.FieldLocalPort:
		m.ResetLocalPort()
		return nil
	case frpcinfo.FieldRemotePort:
		m.ResetRemotePort()
		return nil
	case frpcinfo.FieldIsUsing:
		m.ResetIsUsing()
		return nil
	case frpcinfo.FieldFrpsID:
		m.ResetFrpsID()
		return nil
	case frpcinfo.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FrpcInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.frps_info != nil {
		edges = append(edges, frpcinfo.EdgeFrpsInfo)
	}
	if m.device != nil {
		edges = append(edges, frpcinfo.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FrpcInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case frpcinfo.EdgeFrpsInfo:
		if id := m.frps_info; id != nil {
			return []ent.Value{*id}
		}
	case frpcinfo.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FrpcInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FrpcInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FrpcInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrps_info {
		edges = append(edges, frpcinfo.EdgeFrpsInfo)
	}
	if m.cleareddevice {
		edges = append(edges, frpcinfo.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FrpcInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case frpcinfo.EdgeFrpsInfo:
		return m.clearedfrps_info
	case frpcinfo.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FrpcInfoMutation) ClearEdge(name string) error {
	switch name {
	case frpcinfo.EdgeFrpsInfo:
		m.ClearFrpsInfo()
		return nil
	case frpcinfo.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FrpcInfoMutation) ResetEdge(name string) error {
	switch name {
	case frpcinfo.EdgeFrpsInfo:
		m.ResetFrpsInfo()
		return nil
	case frpcinfo.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown FrpcInfo edge %s", name)
}

// FrpsInfoMutation represents an operation that mutates the FrpsInfo nodes in the graph.
type FrpsInfoMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	tag                   *string
	server_addr           *string
	server_port           *int
	addserver_port        *int
	authentication_method *string
	token                 *string
	_type                 *string
	clearedFields         map[string]struct{}
	frpc_infos            map[int64]struct{}
	removedfrpc_infos     map[int64]struct{}
	clearedfrpc_infos     bool
	done                  bool
	oldValue              func(context.Context) (*FrpsInfo, error)
	predicates            []predicate.FrpsInfo
}

var _ ent.Mutation = (*FrpsInfoMutation)(nil)

// frpsinfoOption allows management of the mutation configuration using functional options.
type frpsinfoOption func(*FrpsInfoMutation)

// newFrpsInfoMutation creates new mutation for the FrpsInfo entity.
func newFrpsInfoMutation(c config, op Op, opts ...frpsinfoOption) *FrpsInfoMutation {
	m := &FrpsInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeFrpsInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFrpsInfoID sets the ID field of the mutation.
func withFrpsInfoID(id int64) frpsinfoOption {
	return func(m *FrpsInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *FrpsInfo
		)
		m.oldValue = func(ctx context.Context) (*FrpsInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FrpsInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFrpsInfo sets the old FrpsInfo of the mutation.
func withFrpsInfo(node *FrpsInfo) frpsinfoOption {
	return func(m *FrpsInfoMutation) {
		m.oldValue = func(context.Context) (*FrpsInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FrpsInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FrpsInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FrpsInfo entities.
func (m *FrpsInfoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FrpsInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FrpsInfoMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FrpsInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *FrpsInfoMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FrpsInfoMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FrpsInfoMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FrpsInfoMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FrpsInfoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FrpsInfoMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FrpsInfoMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FrpsInfoMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FrpsInfoMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FrpsInfoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FrpsInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FrpsInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FrpsInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FrpsInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FrpsInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FrpsInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FrpsInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FrpsInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FrpsInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTag sets the "tag" field.
func (m *FrpsInfoMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *FrpsInfoMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *FrpsInfoMutation) ResetTag() {
	m.tag = nil
}

// SetServerAddr sets the "server_addr" field.
func (m *FrpsInfoMutation) SetServerAddr(s string) {
	m.server_addr = &s
}

// ServerAddr returns the value of the "server_addr" field in the mutation.
func (m *FrpsInfoMutation) ServerAddr() (r string, exists bool) {
	v := m.server_addr
	if v == nil {
		return
	}
	return *v, true
}

// OldServerAddr returns the old "server_addr" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldServerAddr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerAddr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerAddr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerAddr: %w", err)
	}
	return oldValue.ServerAddr, nil
}

// ResetServerAddr resets all changes to the "server_addr" field.
func (m *FrpsInfoMutation) ResetServerAddr() {
	m.server_addr = nil
}

// SetServerPort sets the "server_port" field.
func (m *FrpsInfoMutation) SetServerPort(i int) {
	m.server_port = &i
	m.addserver_port = nil
}

// ServerPort returns the value of the "server_port" field in the mutation.
func (m *FrpsInfoMutation) ServerPort() (r int, exists bool) {
	v := m.server_port
	if v == nil {
		return
	}
	return *v, true
}

// OldServerPort returns the old "server_port" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldServerPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerPort: %w", err)
	}
	return oldValue.ServerPort, nil
}

// AddServerPort adds i to the "server_port" field.
func (m *FrpsInfoMutation) AddServerPort(i int) {
	if m.addserver_port != nil {
		*m.addserver_port += i
	} else {
		m.addserver_port = &i
	}
}

// AddedServerPort returns the value that was added to the "server_port" field in this mutation.
func (m *FrpsInfoMutation) AddedServerPort() (r int, exists bool) {
	v := m.addserver_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetServerPort resets all changes to the "server_port" field.
func (m *FrpsInfoMutation) ResetServerPort() {
	m.server_port = nil
	m.addserver_port = nil
}

// SetAuthenticationMethod sets the "authentication_method" field.
func (m *FrpsInfoMutation) SetAuthenticationMethod(s string) {
	m.authentication_method = &s
}

// AuthenticationMethod returns the value of the "authentication_method" field in the mutation.
func (m *FrpsInfoMutation) AuthenticationMethod() (r string, exists bool) {
	v := m.authentication_method
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthenticationMethod returns the old "authentication_method" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldAuthenticationMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthenticationMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthenticationMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthenticationMethod: %w", err)
	}
	return oldValue.AuthenticationMethod, nil
}

// ResetAuthenticationMethod resets all changes to the "authentication_method" field.
func (m *FrpsInfoMutation) ResetAuthenticationMethod() {
	m.authentication_method = nil
}

// SetToken sets the "token" field.
func (m *FrpsInfoMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *FrpsInfoMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *FrpsInfoMutation) ResetToken() {
	m.token = nil
}

// SetType sets the "type" field.
func (m *FrpsInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FrpsInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FrpsInfo entity.
// If the FrpsInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrpsInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FrpsInfoMutation) ResetType() {
	m._type = nil
}

// AddFrpcInfoIDs adds the "frpc_infos" edge to the FrpcInfo entity by ids.
func (m *FrpsInfoMutation) AddFrpcInfoIDs(ids ...int64) {
	if m.frpc_infos == nil {
		m.frpc_infos = make(map[int64]struct{})
	}
	for i := range ids {
		m.frpc_infos[ids[i]] = struct{}{}
	}
}

// ClearFrpcInfos clears the "frpc_infos" edge to the FrpcInfo entity.
func (m *FrpsInfoMutation) ClearFrpcInfos() {
	m.clearedfrpc_infos = true
}

// FrpcInfosCleared reports if the "frpc_infos" edge to the FrpcInfo entity was cleared.
func (m *FrpsInfoMutation) FrpcInfosCleared() bool {
	return m.clearedfrpc_infos
}

// RemoveFrpcInfoIDs removes the "frpc_infos" edge to the FrpcInfo entity by IDs.
func (m *FrpsInfoMutation) RemoveFrpcInfoIDs(ids ...int64) {
	if m.removedfrpc_infos == nil {
		m.removedfrpc_infos = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.frpc_infos, ids[i])
		m.removedfrpc_infos[ids[i]] = struct{}{}
	}
}

// RemovedFrpcInfos returns the removed IDs of the "frpc_infos" edge to the FrpcInfo entity.
func (m *FrpsInfoMutation) RemovedFrpcInfosIDs() (ids []int64) {
	for id := range m.removedfrpc_infos {
		ids = append(ids, id)
	}
	return
}

// FrpcInfosIDs returns the "frpc_infos" edge IDs in the mutation.
func (m *FrpsInfoMutation) FrpcInfosIDs() (ids []int64) {
	for id := range m.frpc_infos {
		ids = append(ids, id)
	}
	return
}

// ResetFrpcInfos resets all changes to the "frpc_infos" edge.
func (m *FrpsInfoMutation) ResetFrpcInfos() {
	m.frpc_infos = nil
	m.clearedfrpc_infos = false
	m.removedfrpc_infos = nil
}

// Where appends a list predicates to the FrpsInfoMutation builder.
func (m *FrpsInfoMutation) Where(ps ...predicate.FrpsInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FrpsInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FrpsInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FrpsInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FrpsInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FrpsInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FrpsInfo).
func (m *FrpsInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FrpsInfoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, frpsinfo.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, frpsinfo.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, frpsinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, frpsinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, frpsinfo.FieldDeletedAt)
	}
	if m.tag != nil {
		fields = append(fields, frpsinfo.FieldTag)
	}
	if m.server_addr != nil {
		fields = append(fields, frpsinfo.FieldServerAddr)
	}
	if m.server_port != nil {
		fields = append(fields, frpsinfo.FieldServerPort)
	}
	if m.authentication_method != nil {
		fields = append(fields, frpsinfo.FieldAuthenticationMethod)
	}
	if m.token != nil {
		fields = append(fields, frpsinfo.FieldToken)
	}
	if m._type != nil {
		fields = append(fields, frpsinfo.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FrpsInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case frpsinfo.FieldCreatedBy:
		return m.CreatedBy()
	case frpsinfo.FieldUpdatedBy:
		return m.UpdatedBy()
	case frpsinfo.FieldCreatedAt:
		return m.CreatedAt()
	case frpsinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case frpsinfo.FieldDeletedAt:
		return m.DeletedAt()
	case frpsinfo.FieldTag:
		return m.Tag()
	case frpsinfo.FieldServerAddr:
		return m.ServerAddr()
	case frpsinfo.FieldServerPort:
		return m.ServerPort()
	case frpsinfo.FieldAuthenticationMethod:
		return m.AuthenticationMethod()
	case frpsinfo.FieldToken:
		return m.Token()
	case frpsinfo.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FrpsInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case frpsinfo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case frpsinfo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case frpsinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case frpsinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case frpsinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case frpsinfo.FieldTag:
		return m.OldTag(ctx)
	case frpsinfo.FieldServerAddr:
		return m.OldServerAddr(ctx)
	case frpsinfo.FieldServerPort:
		return m.OldServerPort(ctx)
	case frpsinfo.FieldAuthenticationMethod:
		return m.OldAuthenticationMethod(ctx)
	case frpsinfo.FieldToken:
		return m.OldToken(ctx)
	case frpsinfo.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown FrpsInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrpsInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case frpsinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case frpsinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case frpsinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case frpsinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case frpsinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case frpsinfo.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case frpsinfo.FieldServerAddr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerAddr(v)
		return nil
	case frpsinfo.FieldServerPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerPort(v)
		return nil
	case frpsinfo.FieldAuthenticationMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthenticationMethod(v)
		return nil
	case frpsinfo.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case frpsinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown FrpsInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FrpsInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, frpsinfo.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, frpsinfo.FieldUpdatedBy)
	}
	if m.addserver_port != nil {
		fields = append(fields, frpsinfo.FieldServerPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FrpsInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case frpsinfo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case frpsinfo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case frpsinfo.FieldServerPort:
		return m.AddedServerPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrpsInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case frpsinfo.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case frpsinfo.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case frpsinfo.FieldServerPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServerPort(v)
		return nil
	}
	return fmt.Errorf("unknown FrpsInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FrpsInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FrpsInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FrpsInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FrpsInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FrpsInfoMutation) ResetField(name string) error {
	switch name {
	case frpsinfo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case frpsinfo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case frpsinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case frpsinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case frpsinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case frpsinfo.FieldTag:
		m.ResetTag()
		return nil
	case frpsinfo.FieldServerAddr:
		m.ResetServerAddr()
		return nil
	case frpsinfo.FieldServerPort:
		m.ResetServerPort()
		return nil
	case frpsinfo.FieldAuthenticationMethod:
		m.ResetAuthenticationMethod()
		return nil
	case frpsinfo.FieldToken:
		m.ResetToken()
		return nil
	case frpsinfo.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown FrpsInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FrpsInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.frpc_infos != nil {
		edges = append(edges, frpsinfo.EdgeFrpcInfos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FrpsInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case frpsinfo.EdgeFrpcInfos:
		ids := make([]ent.Value, 0, len(m.frpc_infos))
		for id := range m.frpc_infos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FrpsInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfrpc_infos != nil {
		edges = append(edges, frpsinfo.EdgeFrpcInfos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FrpsInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case frpsinfo.EdgeFrpcInfos:
		ids := make([]ent.Value, 0, len(m.removedfrpc_infos))
		for id := range m.removedfrpc_infos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FrpsInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfrpc_infos {
		edges = append(edges, frpsinfo.EdgeFrpcInfos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FrpsInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case frpsinfo.EdgeFrpcInfos:
		return m.clearedfrpc_infos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FrpsInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FrpsInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FrpsInfoMutation) ResetEdge(name string) error {
	switch name {
	case frpsinfo.EdgeFrpcInfos:
		m.ResetFrpcInfos()
		return nil
	}
	return fmt.Errorf("unknown FrpsInfo edge %s", name)
}

// GpuMutation represents an operation that mutates the Gpu nodes in the graph.
type GpuMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	version                    *enums.GpuVersion
	power                      *int
	addpower                   *int
	video_memory               *int
	addvideo_memory            *int
	cpu                        *int
	addcpu                     *int
	memory                     *int
	addmemory                  *int
	lowest_earn_month          *int64
	addlowest_earn_month       *int64
	highest_earn_month         *int64
	addhighest_earn_month      *int64
	clearedFields              map[string]struct{}
	device_gpu_missions        map[int64]struct{}
	removeddevice_gpu_missions map[int64]struct{}
	cleareddevice_gpu_missions bool
	prices                     map[int64]struct{}
	removedprices              map[int64]struct{}
	clearedprices              bool
	done                       bool
	oldValue                   func(context.Context) (*Gpu, error)
	predicates                 []predicate.Gpu
}

var _ ent.Mutation = (*GpuMutation)(nil)

// gpuOption allows management of the mutation configuration using functional options.
type gpuOption func(*GpuMutation)

// newGpuMutation creates new mutation for the Gpu entity.
func newGpuMutation(c config, op Op, opts ...gpuOption) *GpuMutation {
	m := &GpuMutation{
		config:        c,
		op:            op,
		typ:           TypeGpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGpuID sets the ID field of the mutation.
func withGpuID(id int64) gpuOption {
	return func(m *GpuMutation) {
		var (
			err   error
			once  sync.Once
			value *Gpu
		)
		m.oldValue = func(ctx context.Context) (*Gpu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gpu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGpu sets the old Gpu of the mutation.
func withGpu(node *Gpu) gpuOption {
	return func(m *GpuMutation) {
		m.oldValue = func(context.Context) (*Gpu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GpuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GpuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Gpu entities.
func (m *GpuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GpuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GpuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Gpu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *GpuMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GpuMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *GpuMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *GpuMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GpuMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GpuMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GpuMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *GpuMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *GpuMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GpuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GpuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GpuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GpuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GpuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GpuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GpuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GpuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GpuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GpuMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetVersion sets the "version" field.
func (m *GpuMutation) SetVersion(ev enums.GpuVersion) {
	m.version = &ev
}

// Version returns the value of the "version" field in the mutation.
func (m *GpuMutation) Version() (r enums.GpuVersion, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *GpuMutation) ResetVersion() {
	m.version = nil
}

// SetPower sets the "power" field.
func (m *GpuMutation) SetPower(i int) {
	m.power = &i
	m.addpower = nil
}

// Power returns the value of the "power" field in the mutation.
func (m *GpuMutation) Power() (r int, exists bool) {
	v := m.power
	if v == nil {
		return
	}
	return *v, true
}

// OldPower returns the old "power" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldPower(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPower is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPower requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPower: %w", err)
	}
	return oldValue.Power, nil
}

// AddPower adds i to the "power" field.
func (m *GpuMutation) AddPower(i int) {
	if m.addpower != nil {
		*m.addpower += i
	} else {
		m.addpower = &i
	}
}

// AddedPower returns the value that was added to the "power" field in this mutation.
func (m *GpuMutation) AddedPower() (r int, exists bool) {
	v := m.addpower
	if v == nil {
		return
	}
	return *v, true
}

// ResetPower resets all changes to the "power" field.
func (m *GpuMutation) ResetPower() {
	m.power = nil
	m.addpower = nil
}

// SetVideoMemory sets the "video_memory" field.
func (m *GpuMutation) SetVideoMemory(i int) {
	m.video_memory = &i
	m.addvideo_memory = nil
}

// VideoMemory returns the value of the "video_memory" field in the mutation.
func (m *GpuMutation) VideoMemory() (r int, exists bool) {
	v := m.video_memory
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoMemory returns the old "video_memory" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldVideoMemory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoMemory: %w", err)
	}
	return oldValue.VideoMemory, nil
}

// AddVideoMemory adds i to the "video_memory" field.
func (m *GpuMutation) AddVideoMemory(i int) {
	if m.addvideo_memory != nil {
		*m.addvideo_memory += i
	} else {
		m.addvideo_memory = &i
	}
}

// AddedVideoMemory returns the value that was added to the "video_memory" field in this mutation.
func (m *GpuMutation) AddedVideoMemory() (r int, exists bool) {
	v := m.addvideo_memory
	if v == nil {
		return
	}
	return *v, true
}

// ResetVideoMemory resets all changes to the "video_memory" field.
func (m *GpuMutation) ResetVideoMemory() {
	m.video_memory = nil
	m.addvideo_memory = nil
}

// SetCPU sets the "cpu" field.
func (m *GpuMutation) SetCPU(i int) {
	m.cpu = &i
	m.addcpu = nil
}

// CPU returns the value of the "cpu" field in the mutation.
func (m *GpuMutation) CPU() (r int, exists bool) {
	v := m.cpu
	if v == nil {
		return
	}
	return *v, true
}

// OldCPU returns the old "cpu" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldCPU(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPU: %w", err)
	}
	return oldValue.CPU, nil
}

// AddCPU adds i to the "cpu" field.
func (m *GpuMutation) AddCPU(i int) {
	if m.addcpu != nil {
		*m.addcpu += i
	} else {
		m.addcpu = &i
	}
}

// AddedCPU returns the value that was added to the "cpu" field in this mutation.
func (m *GpuMutation) AddedCPU() (r int, exists bool) {
	v := m.addcpu
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPU resets all changes to the "cpu" field.
func (m *GpuMutation) ResetCPU() {
	m.cpu = nil
	m.addcpu = nil
}

// SetMemory sets the "memory" field.
func (m *GpuMutation) SetMemory(i int) {
	m.memory = &i
	m.addmemory = nil
}

// Memory returns the value of the "memory" field in the mutation.
func (m *GpuMutation) Memory() (r int, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldMemory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// AddMemory adds i to the "memory" field.
func (m *GpuMutation) AddMemory(i int) {
	if m.addmemory != nil {
		*m.addmemory += i
	} else {
		m.addmemory = &i
	}
}

// AddedMemory returns the value that was added to the "memory" field in this mutation.
func (m *GpuMutation) AddedMemory() (r int, exists bool) {
	v := m.addmemory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemory resets all changes to the "memory" field.
func (m *GpuMutation) ResetMemory() {
	m.memory = nil
	m.addmemory = nil
}

// SetLowestEarnMonth sets the "lowest_earn_month" field.
func (m *GpuMutation) SetLowestEarnMonth(i int64) {
	m.lowest_earn_month = &i
	m.addlowest_earn_month = nil
}

// LowestEarnMonth returns the value of the "lowest_earn_month" field in the mutation.
func (m *GpuMutation) LowestEarnMonth() (r int64, exists bool) {
	v := m.lowest_earn_month
	if v == nil {
		return
	}
	return *v, true
}

// OldLowestEarnMonth returns the old "lowest_earn_month" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldLowestEarnMonth(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowestEarnMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowestEarnMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowestEarnMonth: %w", err)
	}
	return oldValue.LowestEarnMonth, nil
}

// AddLowestEarnMonth adds i to the "lowest_earn_month" field.
func (m *GpuMutation) AddLowestEarnMonth(i int64) {
	if m.addlowest_earn_month != nil {
		*m.addlowest_earn_month += i
	} else {
		m.addlowest_earn_month = &i
	}
}

// AddedLowestEarnMonth returns the value that was added to the "lowest_earn_month" field in this mutation.
func (m *GpuMutation) AddedLowestEarnMonth() (r int64, exists bool) {
	v := m.addlowest_earn_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetLowestEarnMonth resets all changes to the "lowest_earn_month" field.
func (m *GpuMutation) ResetLowestEarnMonth() {
	m.lowest_earn_month = nil
	m.addlowest_earn_month = nil
}

// SetHighestEarnMonth sets the "highest_earn_month" field.
func (m *GpuMutation) SetHighestEarnMonth(i int64) {
	m.highest_earn_month = &i
	m.addhighest_earn_month = nil
}

// HighestEarnMonth returns the value of the "highest_earn_month" field in the mutation.
func (m *GpuMutation) HighestEarnMonth() (r int64, exists bool) {
	v := m.highest_earn_month
	if v == nil {
		return
	}
	return *v, true
}

// OldHighestEarnMonth returns the old "highest_earn_month" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldHighestEarnMonth(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighestEarnMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighestEarnMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighestEarnMonth: %w", err)
	}
	return oldValue.HighestEarnMonth, nil
}

// AddHighestEarnMonth adds i to the "highest_earn_month" field.
func (m *GpuMutation) AddHighestEarnMonth(i int64) {
	if m.addhighest_earn_month != nil {
		*m.addhighest_earn_month += i
	} else {
		m.addhighest_earn_month = &i
	}
}

// AddedHighestEarnMonth returns the value that was added to the "highest_earn_month" field in this mutation.
func (m *GpuMutation) AddedHighestEarnMonth() (r int64, exists bool) {
	v := m.addhighest_earn_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetHighestEarnMonth resets all changes to the "highest_earn_month" field.
func (m *GpuMutation) ResetHighestEarnMonth() {
	m.highest_earn_month = nil
	m.addhighest_earn_month = nil
}

// AddDeviceGpuMissionIDs adds the "device_gpu_missions" edge to the DeviceGpuMission entity by ids.
func (m *GpuMutation) AddDeviceGpuMissionIDs(ids ...int64) {
	if m.device_gpu_missions == nil {
		m.device_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_gpu_missions[ids[i]] = struct{}{}
	}
}

// ClearDeviceGpuMissions clears the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *GpuMutation) ClearDeviceGpuMissions() {
	m.cleareddevice_gpu_missions = true
}

// DeviceGpuMissionsCleared reports if the "device_gpu_missions" edge to the DeviceGpuMission entity was cleared.
func (m *GpuMutation) DeviceGpuMissionsCleared() bool {
	return m.cleareddevice_gpu_missions
}

// RemoveDeviceGpuMissionIDs removes the "device_gpu_missions" edge to the DeviceGpuMission entity by IDs.
func (m *GpuMutation) RemoveDeviceGpuMissionIDs(ids ...int64) {
	if m.removeddevice_gpu_missions == nil {
		m.removeddevice_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_gpu_missions, ids[i])
		m.removeddevice_gpu_missions[ids[i]] = struct{}{}
	}
}

// RemovedDeviceGpuMissions returns the removed IDs of the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *GpuMutation) RemovedDeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.removeddevice_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// DeviceGpuMissionsIDs returns the "device_gpu_missions" edge IDs in the mutation.
func (m *GpuMutation) DeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.device_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceGpuMissions resets all changes to the "device_gpu_missions" edge.
func (m *GpuMutation) ResetDeviceGpuMissions() {
	m.device_gpu_missions = nil
	m.cleareddevice_gpu_missions = false
	m.removeddevice_gpu_missions = nil
}

// AddPriceIDs adds the "prices" edge to the Price entity by ids.
func (m *GpuMutation) AddPriceIDs(ids ...int64) {
	if m.prices == nil {
		m.prices = make(map[int64]struct{})
	}
	for i := range ids {
		m.prices[ids[i]] = struct{}{}
	}
}

// ClearPrices clears the "prices" edge to the Price entity.
func (m *GpuMutation) ClearPrices() {
	m.clearedprices = true
}

// PricesCleared reports if the "prices" edge to the Price entity was cleared.
func (m *GpuMutation) PricesCleared() bool {
	return m.clearedprices
}

// RemovePriceIDs removes the "prices" edge to the Price entity by IDs.
func (m *GpuMutation) RemovePriceIDs(ids ...int64) {
	if m.removedprices == nil {
		m.removedprices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.prices, ids[i])
		m.removedprices[ids[i]] = struct{}{}
	}
}

// RemovedPrices returns the removed IDs of the "prices" edge to the Price entity.
func (m *GpuMutation) RemovedPricesIDs() (ids []int64) {
	for id := range m.removedprices {
		ids = append(ids, id)
	}
	return
}

// PricesIDs returns the "prices" edge IDs in the mutation.
func (m *GpuMutation) PricesIDs() (ids []int64) {
	for id := range m.prices {
		ids = append(ids, id)
	}
	return
}

// ResetPrices resets all changes to the "prices" edge.
func (m *GpuMutation) ResetPrices() {
	m.prices = nil
	m.clearedprices = false
	m.removedprices = nil
}

// Where appends a list predicates to the GpuMutation builder.
func (m *GpuMutation) Where(ps ...predicate.Gpu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GpuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GpuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Gpu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GpuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GpuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Gpu).
func (m *GpuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GpuMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, gpu.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, gpu.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, gpu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gpu.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, gpu.FieldDeletedAt)
	}
	if m.version != nil {
		fields = append(fields, gpu.FieldVersion)
	}
	if m.power != nil {
		fields = append(fields, gpu.FieldPower)
	}
	if m.video_memory != nil {
		fields = append(fields, gpu.FieldVideoMemory)
	}
	if m.cpu != nil {
		fields = append(fields, gpu.FieldCPU)
	}
	if m.memory != nil {
		fields = append(fields, gpu.FieldMemory)
	}
	if m.lowest_earn_month != nil {
		fields = append(fields, gpu.FieldLowestEarnMonth)
	}
	if m.highest_earn_month != nil {
		fields = append(fields, gpu.FieldHighestEarnMonth)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GpuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gpu.FieldCreatedBy:
		return m.CreatedBy()
	case gpu.FieldUpdatedBy:
		return m.UpdatedBy()
	case gpu.FieldCreatedAt:
		return m.CreatedAt()
	case gpu.FieldUpdatedAt:
		return m.UpdatedAt()
	case gpu.FieldDeletedAt:
		return m.DeletedAt()
	case gpu.FieldVersion:
		return m.Version()
	case gpu.FieldPower:
		return m.Power()
	case gpu.FieldVideoMemory:
		return m.VideoMemory()
	case gpu.FieldCPU:
		return m.CPU()
	case gpu.FieldMemory:
		return m.Memory()
	case gpu.FieldLowestEarnMonth:
		return m.LowestEarnMonth()
	case gpu.FieldHighestEarnMonth:
		return m.HighestEarnMonth()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GpuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gpu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case gpu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case gpu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gpu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case gpu.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case gpu.FieldVersion:
		return m.OldVersion(ctx)
	case gpu.FieldPower:
		return m.OldPower(ctx)
	case gpu.FieldVideoMemory:
		return m.OldVideoMemory(ctx)
	case gpu.FieldCPU:
		return m.OldCPU(ctx)
	case gpu.FieldMemory:
		return m.OldMemory(ctx)
	case gpu.FieldLowestEarnMonth:
		return m.OldLowestEarnMonth(ctx)
	case gpu.FieldHighestEarnMonth:
		return m.OldHighestEarnMonth(ctx)
	}
	return nil, fmt.Errorf("unknown Gpu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GpuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gpu.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case gpu.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case gpu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gpu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case gpu.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case gpu.FieldVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case gpu.FieldPower:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPower(v)
		return nil
	case gpu.FieldVideoMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoMemory(v)
		return nil
	case gpu.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPU(v)
		return nil
	case gpu.FieldMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case gpu.FieldLowestEarnMonth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowestEarnMonth(v)
		return nil
	case gpu.FieldHighestEarnMonth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighestEarnMonth(v)
		return nil
	}
	return fmt.Errorf("unknown Gpu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GpuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, gpu.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, gpu.FieldUpdatedBy)
	}
	if m.addpower != nil {
		fields = append(fields, gpu.FieldPower)
	}
	if m.addvideo_memory != nil {
		fields = append(fields, gpu.FieldVideoMemory)
	}
	if m.addcpu != nil {
		fields = append(fields, gpu.FieldCPU)
	}
	if m.addmemory != nil {
		fields = append(fields, gpu.FieldMemory)
	}
	if m.addlowest_earn_month != nil {
		fields = append(fields, gpu.FieldLowestEarnMonth)
	}
	if m.addhighest_earn_month != nil {
		fields = append(fields, gpu.FieldHighestEarnMonth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GpuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gpu.FieldCreatedBy:
		return m.AddedCreatedBy()
	case gpu.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case gpu.FieldPower:
		return m.AddedPower()
	case gpu.FieldVideoMemory:
		return m.AddedVideoMemory()
	case gpu.FieldCPU:
		return m.AddedCPU()
	case gpu.FieldMemory:
		return m.AddedMemory()
	case gpu.FieldLowestEarnMonth:
		return m.AddedLowestEarnMonth()
	case gpu.FieldHighestEarnMonth:
		return m.AddedHighestEarnMonth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GpuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gpu.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case gpu.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case gpu.FieldPower:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPower(v)
		return nil
	case gpu.FieldVideoMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoMemory(v)
		return nil
	case gpu.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPU(v)
		return nil
	case gpu.FieldMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemory(v)
		return nil
	case gpu.FieldLowestEarnMonth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowestEarnMonth(v)
		return nil
	case gpu.FieldHighestEarnMonth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighestEarnMonth(v)
		return nil
	}
	return fmt.Errorf("unknown Gpu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GpuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GpuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GpuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gpu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GpuMutation) ResetField(name string) error {
	switch name {
	case gpu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case gpu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case gpu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gpu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case gpu.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case gpu.FieldVersion:
		m.ResetVersion()
		return nil
	case gpu.FieldPower:
		m.ResetPower()
		return nil
	case gpu.FieldVideoMemory:
		m.ResetVideoMemory()
		return nil
	case gpu.FieldCPU:
		m.ResetCPU()
		return nil
	case gpu.FieldMemory:
		m.ResetMemory()
		return nil
	case gpu.FieldLowestEarnMonth:
		m.ResetLowestEarnMonth()
		return nil
	case gpu.FieldHighestEarnMonth:
		m.ResetHighestEarnMonth()
		return nil
	}
	return fmt.Errorf("unknown Gpu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GpuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.device_gpu_missions != nil {
		edges = append(edges, gpu.EdgeDeviceGpuMissions)
	}
	if m.prices != nil {
		edges = append(edges, gpu.EdgePrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GpuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.device_gpu_missions))
		for id := range m.device_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	case gpu.EdgePrices:
		ids := make([]ent.Value, 0, len(m.prices))
		for id := range m.prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GpuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddevice_gpu_missions != nil {
		edges = append(edges, gpu.EdgeDeviceGpuMissions)
	}
	if m.removedprices != nil {
		edges = append(edges, gpu.EdgePrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GpuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.removeddevice_gpu_missions))
		for id := range m.removeddevice_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	case gpu.EdgePrices:
		ids := make([]ent.Value, 0, len(m.removedprices))
		for id := range m.removedprices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GpuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddevice_gpu_missions {
		edges = append(edges, gpu.EdgeDeviceGpuMissions)
	}
	if m.clearedprices {
		edges = append(edges, gpu.EdgePrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GpuMutation) EdgeCleared(name string) bool {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		return m.cleareddevice_gpu_missions
	case gpu.EdgePrices:
		return m.clearedprices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GpuMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gpu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GpuMutation) ResetEdge(name string) error {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		m.ResetDeviceGpuMissions()
		return nil
	case gpu.EdgePrices:
		m.ResetPrices()
		return nil
	}
	return fmt.Errorf("unknown Gpu edge %s", name)
}

// HmacKeyPairMutation represents an operation that mutates the HmacKeyPair nodes in the graph.
type HmacKeyPairMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_by               *int64
	addcreated_by            *int64
	updated_by               *int64
	addupdated_by            *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	key                      *string
	secret                   *string
	caller                   *string
	clearedFields            map[string]struct{}
	mission_key_pairs        map[int64]struct{}
	removedmission_key_pairs map[int64]struct{}
	clearedmission_key_pairs bool
	created_missions         map[int64]struct{}
	removedcreated_missions  map[int64]struct{}
	clearedcreated_missions  bool
	done                     bool
	oldValue                 func(context.Context) (*HmacKeyPair, error)
	predicates               []predicate.HmacKeyPair
}

var _ ent.Mutation = (*HmacKeyPairMutation)(nil)

// hmackeypairOption allows management of the mutation configuration using functional options.
type hmackeypairOption func(*HmacKeyPairMutation)

// newHmacKeyPairMutation creates new mutation for the HmacKeyPair entity.
func newHmacKeyPairMutation(c config, op Op, opts ...hmackeypairOption) *HmacKeyPairMutation {
	m := &HmacKeyPairMutation{
		config:        c,
		op:            op,
		typ:           TypeHmacKeyPair,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHmacKeyPairID sets the ID field of the mutation.
func withHmacKeyPairID(id int64) hmackeypairOption {
	return func(m *HmacKeyPairMutation) {
		var (
			err   error
			once  sync.Once
			value *HmacKeyPair
		)
		m.oldValue = func(ctx context.Context) (*HmacKeyPair, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HmacKeyPair.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHmacKeyPair sets the old HmacKeyPair of the mutation.
func withHmacKeyPair(node *HmacKeyPair) hmackeypairOption {
	return func(m *HmacKeyPairMutation) {
		m.oldValue = func(context.Context) (*HmacKeyPair, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HmacKeyPairMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HmacKeyPairMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HmacKeyPair entities.
func (m *HmacKeyPairMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HmacKeyPairMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HmacKeyPairMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HmacKeyPair.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *HmacKeyPairMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HmacKeyPairMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *HmacKeyPairMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *HmacKeyPairMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HmacKeyPairMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HmacKeyPairMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HmacKeyPairMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *HmacKeyPairMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *HmacKeyPairMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HmacKeyPairMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HmacKeyPairMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HmacKeyPairMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HmacKeyPairMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HmacKeyPairMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HmacKeyPairMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HmacKeyPairMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HmacKeyPairMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HmacKeyPairMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HmacKeyPairMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetKey sets the "key" field.
func (m *HmacKeyPairMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *HmacKeyPairMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *HmacKeyPairMutation) ResetKey() {
	m.key = nil
}

// SetSecret sets the "secret" field.
func (m *HmacKeyPairMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *HmacKeyPairMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *HmacKeyPairMutation) ResetSecret() {
	m.secret = nil
}

// SetCaller sets the "caller" field.
func (m *HmacKeyPairMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *HmacKeyPairMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *HmacKeyPairMutation) ResetCaller() {
	m.caller = nil
}

// AddMissionKeyPairIDs adds the "mission_key_pairs" edge to the MissionKeyPair entity by ids.
func (m *HmacKeyPairMutation) AddMissionKeyPairIDs(ids ...int64) {
	if m.mission_key_pairs == nil {
		m.mission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_key_pairs[ids[i]] = struct{}{}
	}
}

// ClearMissionKeyPairs clears the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *HmacKeyPairMutation) ClearMissionKeyPairs() {
	m.clearedmission_key_pairs = true
}

// MissionKeyPairsCleared reports if the "mission_key_pairs" edge to the MissionKeyPair entity was cleared.
func (m *HmacKeyPairMutation) MissionKeyPairsCleared() bool {
	return m.clearedmission_key_pairs
}

// RemoveMissionKeyPairIDs removes the "mission_key_pairs" edge to the MissionKeyPair entity by IDs.
func (m *HmacKeyPairMutation) RemoveMissionKeyPairIDs(ids ...int64) {
	if m.removedmission_key_pairs == nil {
		m.removedmission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_key_pairs, ids[i])
		m.removedmission_key_pairs[ids[i]] = struct{}{}
	}
}

// RemovedMissionKeyPairs returns the removed IDs of the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *HmacKeyPairMutation) RemovedMissionKeyPairsIDs() (ids []int64) {
	for id := range m.removedmission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// MissionKeyPairsIDs returns the "mission_key_pairs" edge IDs in the mutation.
func (m *HmacKeyPairMutation) MissionKeyPairsIDs() (ids []int64) {
	for id := range m.mission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// ResetMissionKeyPairs resets all changes to the "mission_key_pairs" edge.
func (m *HmacKeyPairMutation) ResetMissionKeyPairs() {
	m.mission_key_pairs = nil
	m.clearedmission_key_pairs = false
	m.removedmission_key_pairs = nil
}

// AddCreatedMissionIDs adds the "created_missions" edge to the Mission entity by ids.
func (m *HmacKeyPairMutation) AddCreatedMissionIDs(ids ...int64) {
	if m.created_missions == nil {
		m.created_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.created_missions[ids[i]] = struct{}{}
	}
}

// ClearCreatedMissions clears the "created_missions" edge to the Mission entity.
func (m *HmacKeyPairMutation) ClearCreatedMissions() {
	m.clearedcreated_missions = true
}

// CreatedMissionsCleared reports if the "created_missions" edge to the Mission entity was cleared.
func (m *HmacKeyPairMutation) CreatedMissionsCleared() bool {
	return m.clearedcreated_missions
}

// RemoveCreatedMissionIDs removes the "created_missions" edge to the Mission entity by IDs.
func (m *HmacKeyPairMutation) RemoveCreatedMissionIDs(ids ...int64) {
	if m.removedcreated_missions == nil {
		m.removedcreated_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.created_missions, ids[i])
		m.removedcreated_missions[ids[i]] = struct{}{}
	}
}

// RemovedCreatedMissions returns the removed IDs of the "created_missions" edge to the Mission entity.
func (m *HmacKeyPairMutation) RemovedCreatedMissionsIDs() (ids []int64) {
	for id := range m.removedcreated_missions {
		ids = append(ids, id)
	}
	return
}

// CreatedMissionsIDs returns the "created_missions" edge IDs in the mutation.
func (m *HmacKeyPairMutation) CreatedMissionsIDs() (ids []int64) {
	for id := range m.created_missions {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedMissions resets all changes to the "created_missions" edge.
func (m *HmacKeyPairMutation) ResetCreatedMissions() {
	m.created_missions = nil
	m.clearedcreated_missions = false
	m.removedcreated_missions = nil
}

// Where appends a list predicates to the HmacKeyPairMutation builder.
func (m *HmacKeyPairMutation) Where(ps ...predicate.HmacKeyPair) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HmacKeyPairMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HmacKeyPairMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HmacKeyPair, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HmacKeyPairMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HmacKeyPairMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HmacKeyPair).
func (m *HmacKeyPairMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HmacKeyPairMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, hmackeypair.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, hmackeypair.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, hmackeypair.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hmackeypair.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hmackeypair.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, hmackeypair.FieldKey)
	}
	if m.secret != nil {
		fields = append(fields, hmackeypair.FieldSecret)
	}
	if m.caller != nil {
		fields = append(fields, hmackeypair.FieldCaller)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HmacKeyPairMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hmackeypair.FieldCreatedBy:
		return m.CreatedBy()
	case hmackeypair.FieldUpdatedBy:
		return m.UpdatedBy()
	case hmackeypair.FieldCreatedAt:
		return m.CreatedAt()
	case hmackeypair.FieldUpdatedAt:
		return m.UpdatedAt()
	case hmackeypair.FieldDeletedAt:
		return m.DeletedAt()
	case hmackeypair.FieldKey:
		return m.Key()
	case hmackeypair.FieldSecret:
		return m.Secret()
	case hmackeypair.FieldCaller:
		return m.Caller()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HmacKeyPairMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hmackeypair.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hmackeypair.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case hmackeypair.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hmackeypair.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hmackeypair.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hmackeypair.FieldKey:
		return m.OldKey(ctx)
	case hmackeypair.FieldSecret:
		return m.OldSecret(ctx)
	case hmackeypair.FieldCaller:
		return m.OldCaller(ctx)
	}
	return nil, fmt.Errorf("unknown HmacKeyPair field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HmacKeyPairMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hmackeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hmackeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case hmackeypair.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hmackeypair.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hmackeypair.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hmackeypair.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case hmackeypair.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case hmackeypair.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HmacKeyPairMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, hmackeypair.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, hmackeypair.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HmacKeyPairMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hmackeypair.FieldCreatedBy:
		return m.AddedCreatedBy()
	case hmackeypair.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HmacKeyPairMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hmackeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case hmackeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HmacKeyPairMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HmacKeyPairMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HmacKeyPairMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HmacKeyPair nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HmacKeyPairMutation) ResetField(name string) error {
	switch name {
	case hmackeypair.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hmackeypair.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case hmackeypair.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hmackeypair.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hmackeypair.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hmackeypair.FieldKey:
		m.ResetKey()
		return nil
	case hmackeypair.FieldSecret:
		m.ResetSecret()
		return nil
	case hmackeypair.FieldCaller:
		m.ResetCaller()
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HmacKeyPairMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mission_key_pairs != nil {
		edges = append(edges, hmackeypair.EdgeMissionKeyPairs)
	}
	if m.created_missions != nil {
		edges = append(edges, hmackeypair.EdgeCreatedMissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HmacKeyPairMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.mission_key_pairs))
		for id := range m.mission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case hmackeypair.EdgeCreatedMissions:
		ids := make([]ent.Value, 0, len(m.created_missions))
		for id := range m.created_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HmacKeyPairMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmission_key_pairs != nil {
		edges = append(edges, hmackeypair.EdgeMissionKeyPairs)
	}
	if m.removedcreated_missions != nil {
		edges = append(edges, hmackeypair.EdgeCreatedMissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HmacKeyPairMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.removedmission_key_pairs))
		for id := range m.removedmission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case hmackeypair.EdgeCreatedMissions:
		ids := make([]ent.Value, 0, len(m.removedcreated_missions))
		for id := range m.removedcreated_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HmacKeyPairMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmission_key_pairs {
		edges = append(edges, hmackeypair.EdgeMissionKeyPairs)
	}
	if m.clearedcreated_missions {
		edges = append(edges, hmackeypair.EdgeCreatedMissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HmacKeyPairMutation) EdgeCleared(name string) bool {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		return m.clearedmission_key_pairs
	case hmackeypair.EdgeCreatedMissions:
		return m.clearedcreated_missions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HmacKeyPairMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HmacKeyPair unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HmacKeyPairMutation) ResetEdge(name string) error {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		m.ResetMissionKeyPairs()
		return nil
	case hmackeypair.EdgeCreatedMissions:
		m.ResetCreatedMissions()
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair edge %s", name)
}

// InputLogMutation represents an operation that mutates the InputLog nodes in the graph.
type InputLogMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	trace_id      *int64
	addtrace_id   *int64
	headers       *string
	body          *string
	query         *string
	url           *string
	ip            *string
	caller        *string
	method        *inputlog.Method
	hmac_key      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*InputLog, error)
	predicates    []predicate.InputLog
}

var _ ent.Mutation = (*InputLogMutation)(nil)

// inputlogOption allows management of the mutation configuration using functional options.
type inputlogOption func(*InputLogMutation)

// newInputLogMutation creates new mutation for the InputLog entity.
func newInputLogMutation(c config, op Op, opts ...inputlogOption) *InputLogMutation {
	m := &InputLogMutation{
		config:        c,
		op:            op,
		typ:           TypeInputLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInputLogID sets the ID field of the mutation.
func withInputLogID(id int64) inputlogOption {
	return func(m *InputLogMutation) {
		var (
			err   error
			once  sync.Once
			value *InputLog
		)
		m.oldValue = func(ctx context.Context) (*InputLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InputLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInputLog sets the old InputLog of the mutation.
func withInputLog(node *InputLog) inputlogOption {
	return func(m *InputLogMutation) {
		m.oldValue = func(context.Context) (*InputLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InputLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InputLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InputLog entities.
func (m *InputLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InputLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InputLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InputLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *InputLogMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InputLogMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *InputLogMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *InputLogMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InputLogMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InputLogMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InputLogMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *InputLogMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *InputLogMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InputLogMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InputLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InputLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InputLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InputLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InputLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InputLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InputLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InputLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InputLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTraceID sets the "trace_id" field.
func (m *InputLogMutation) SetTraceID(i int64) {
	m.trace_id = &i
	m.addtrace_id = nil
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *InputLogMutation) TraceID() (r int64, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldTraceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// AddTraceID adds i to the "trace_id" field.
func (m *InputLogMutation) AddTraceID(i int64) {
	if m.addtrace_id != nil {
		*m.addtrace_id += i
	} else {
		m.addtrace_id = &i
	}
}

// AddedTraceID returns the value that was added to the "trace_id" field in this mutation.
func (m *InputLogMutation) AddedTraceID() (r int64, exists bool) {
	v := m.addtrace_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *InputLogMutation) ResetTraceID() {
	m.trace_id = nil
	m.addtrace_id = nil
}

// SetHeaders sets the "headers" field.
func (m *InputLogMutation) SetHeaders(s string) {
	m.headers = &s
}

// Headers returns the value of the "headers" field in the mutation.
func (m *InputLogMutation) Headers() (r string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldHeaders(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ResetHeaders resets all changes to the "headers" field.
func (m *InputLogMutation) ResetHeaders() {
	m.headers = nil
}

// SetBody sets the "body" field.
func (m *InputLogMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *InputLogMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *InputLogMutation) ClearBody() {
	m.body = nil
	m.clearedFields[inputlog.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *InputLogMutation) BodyCleared() bool {
	_, ok := m.clearedFields[inputlog.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *InputLogMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, inputlog.FieldBody)
}

// SetQuery sets the "query" field.
func (m *InputLogMutation) SetQuery(s string) {
	m.query = &s
}

// Query returns the value of the "query" field in the mutation.
func (m *InputLogMutation) Query() (r string, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ClearQuery clears the value of the "query" field.
func (m *InputLogMutation) ClearQuery() {
	m.query = nil
	m.clearedFields[inputlog.FieldQuery] = struct{}{}
}

// QueryCleared returns if the "query" field was cleared in this mutation.
func (m *InputLogMutation) QueryCleared() bool {
	_, ok := m.clearedFields[inputlog.FieldQuery]
	return ok
}

// ResetQuery resets all changes to the "query" field.
func (m *InputLogMutation) ResetQuery() {
	m.query = nil
	delete(m.clearedFields, inputlog.FieldQuery)
}

// SetURL sets the "url" field.
func (m *InputLogMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *InputLogMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *InputLogMutation) ResetURL() {
	m.url = nil
}

// SetIP sets the "ip" field.
func (m *InputLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *InputLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *InputLogMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[inputlog.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *InputLogMutation) IPCleared() bool {
	_, ok := m.clearedFields[inputlog.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *InputLogMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, inputlog.FieldIP)
}

// SetCaller sets the "caller" field.
func (m *InputLogMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *InputLogMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *InputLogMutation) ResetCaller() {
	m.caller = nil
}

// SetMethod sets the "method" field.
func (m *InputLogMutation) SetMethod(i inputlog.Method) {
	m.method = &i
}

// Method returns the value of the "method" field in the mutation.
func (m *InputLogMutation) Method() (r inputlog.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldMethod(ctx context.Context) (v inputlog.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *InputLogMutation) ResetMethod() {
	m.method = nil
}

// SetHmacKey sets the "hmac_key" field.
func (m *InputLogMutation) SetHmacKey(s string) {
	m.hmac_key = &s
}

// HmacKey returns the value of the "hmac_key" field in the mutation.
func (m *InputLogMutation) HmacKey() (r string, exists bool) {
	v := m.hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHmacKey returns the old "hmac_key" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHmacKey: %w", err)
	}
	return oldValue.HmacKey, nil
}

// ResetHmacKey resets all changes to the "hmac_key" field.
func (m *InputLogMutation) ResetHmacKey() {
	m.hmac_key = nil
}

// Where appends a list predicates to the InputLogMutation builder.
func (m *InputLogMutation) Where(ps ...predicate.InputLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InputLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InputLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InputLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InputLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InputLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InputLog).
func (m *InputLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InputLogMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, inputlog.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, inputlog.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, inputlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inputlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inputlog.FieldDeletedAt)
	}
	if m.trace_id != nil {
		fields = append(fields, inputlog.FieldTraceID)
	}
	if m.headers != nil {
		fields = append(fields, inputlog.FieldHeaders)
	}
	if m.body != nil {
		fields = append(fields, inputlog.FieldBody)
	}
	if m.query != nil {
		fields = append(fields, inputlog.FieldQuery)
	}
	if m.url != nil {
		fields = append(fields, inputlog.FieldURL)
	}
	if m.ip != nil {
		fields = append(fields, inputlog.FieldIP)
	}
	if m.caller != nil {
		fields = append(fields, inputlog.FieldCaller)
	}
	if m.method != nil {
		fields = append(fields, inputlog.FieldMethod)
	}
	if m.hmac_key != nil {
		fields = append(fields, inputlog.FieldHmacKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InputLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inputlog.FieldCreatedBy:
		return m.CreatedBy()
	case inputlog.FieldUpdatedBy:
		return m.UpdatedBy()
	case inputlog.FieldCreatedAt:
		return m.CreatedAt()
	case inputlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case inputlog.FieldDeletedAt:
		return m.DeletedAt()
	case inputlog.FieldTraceID:
		return m.TraceID()
	case inputlog.FieldHeaders:
		return m.Headers()
	case inputlog.FieldBody:
		return m.Body()
	case inputlog.FieldQuery:
		return m.Query()
	case inputlog.FieldURL:
		return m.URL()
	case inputlog.FieldIP:
		return m.IP()
	case inputlog.FieldCaller:
		return m.Caller()
	case inputlog.FieldMethod:
		return m.Method()
	case inputlog.FieldHmacKey:
		return m.HmacKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InputLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inputlog.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case inputlog.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case inputlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inputlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inputlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inputlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case inputlog.FieldHeaders:
		return m.OldHeaders(ctx)
	case inputlog.FieldBody:
		return m.OldBody(ctx)
	case inputlog.FieldQuery:
		return m.OldQuery(ctx)
	case inputlog.FieldURL:
		return m.OldURL(ctx)
	case inputlog.FieldIP:
		return m.OldIP(ctx)
	case inputlog.FieldCaller:
		return m.OldCaller(ctx)
	case inputlog.FieldMethod:
		return m.OldMethod(ctx)
	case inputlog.FieldHmacKey:
		return m.OldHmacKey(ctx)
	}
	return nil, fmt.Errorf("unknown InputLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InputLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case inputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case inputlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inputlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inputlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case inputlog.FieldHeaders:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case inputlog.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case inputlog.FieldQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case inputlog.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case inputlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case inputlog.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case inputlog.FieldMethod:
		v, ok := value.(inputlog.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case inputlog.FieldHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHmacKey(v)
		return nil
	}
	return fmt.Errorf("unknown InputLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InputLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, inputlog.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, inputlog.FieldUpdatedBy)
	}
	if m.addtrace_id != nil {
		fields = append(fields, inputlog.FieldTraceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InputLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inputlog.FieldCreatedBy:
		return m.AddedCreatedBy()
	case inputlog.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case inputlog.FieldTraceID:
		return m.AddedTraceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InputLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case inputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case inputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraceID(v)
		return nil
	}
	return fmt.Errorf("unknown InputLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InputLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inputlog.FieldBody) {
		fields = append(fields, inputlog.FieldBody)
	}
	if m.FieldCleared(inputlog.FieldQuery) {
		fields = append(fields, inputlog.FieldQuery)
	}
	if m.FieldCleared(inputlog.FieldIP) {
		fields = append(fields, inputlog.FieldIP)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InputLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InputLogMutation) ClearField(name string) error {
	switch name {
	case inputlog.FieldBody:
		m.ClearBody()
		return nil
	case inputlog.FieldQuery:
		m.ClearQuery()
		return nil
	case inputlog.FieldIP:
		m.ClearIP()
		return nil
	}
	return fmt.Errorf("unknown InputLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InputLogMutation) ResetField(name string) error {
	switch name {
	case inputlog.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case inputlog.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case inputlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inputlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inputlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inputlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case inputlog.FieldHeaders:
		m.ResetHeaders()
		return nil
	case inputlog.FieldBody:
		m.ResetBody()
		return nil
	case inputlog.FieldQuery:
		m.ResetQuery()
		return nil
	case inputlog.FieldURL:
		m.ResetURL()
		return nil
	case inputlog.FieldIP:
		m.ResetIP()
		return nil
	case inputlog.FieldCaller:
		m.ResetCaller()
		return nil
	case inputlog.FieldMethod:
		m.ResetMethod()
		return nil
	case inputlog.FieldHmacKey:
		m.ResetHmacKey()
		return nil
	}
	return fmt.Errorf("unknown InputLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InputLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InputLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InputLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InputLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InputLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InputLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InputLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InputLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InputLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InputLog edge %s", name)
}

// InviteMutation represents an operation that mutates the Invite nodes in the graph.
type InviteMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	invite_code           *string
	share_cep             *int64
	addshare_cep          *int64
	reg_cep               *int64
	addreg_cep            *int64
	first_recharge_cep    *int64
	addfirst_recharge_cep *int64
	_type                 *string
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	campaign              *int64
	clearedcampaign       bool
	bills                 map[int64]struct{}
	removedbills          map[int64]struct{}
	clearedbills          bool
	done                  bool
	oldValue              func(context.Context) (*Invite, error)
	predicates            []predicate.Invite
}

var _ ent.Mutation = (*InviteMutation)(nil)

// inviteOption allows management of the mutation configuration using functional options.
type inviteOption func(*InviteMutation)

// newInviteMutation creates new mutation for the Invite entity.
func newInviteMutation(c config, op Op, opts ...inviteOption) *InviteMutation {
	m := &InviteMutation{
		config:        c,
		op:            op,
		typ:           TypeInvite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInviteID sets the ID field of the mutation.
func withInviteID(id int64) inviteOption {
	return func(m *InviteMutation) {
		var (
			err   error
			once  sync.Once
			value *Invite
		)
		m.oldValue = func(ctx context.Context) (*Invite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvite sets the old Invite of the mutation.
func withInvite(node *Invite) inviteOption {
	return func(m *InviteMutation) {
		m.oldValue = func(context.Context) (*Invite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invite entities.
func (m *InviteMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InviteMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InviteMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *InviteMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InviteMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *InviteMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *InviteMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InviteMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InviteMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InviteMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *InviteMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *InviteMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InviteMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InviteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InviteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InviteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InviteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InviteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InviteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InviteMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InviteMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InviteMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetInviteCode sets the "invite_code" field.
func (m *InviteMutation) SetInviteCode(s string) {
	m.invite_code = &s
}

// InviteCode returns the value of the "invite_code" field in the mutation.
func (m *InviteMutation) InviteCode() (r string, exists bool) {
	v := m.invite_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteCode returns the old "invite_code" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldInviteCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteCode: %w", err)
	}
	return oldValue.InviteCode, nil
}

// ResetInviteCode resets all changes to the "invite_code" field.
func (m *InviteMutation) ResetInviteCode() {
	m.invite_code = nil
}

// SetShareCep sets the "share_cep" field.
func (m *InviteMutation) SetShareCep(i int64) {
	m.share_cep = &i
	m.addshare_cep = nil
}

// ShareCep returns the value of the "share_cep" field in the mutation.
func (m *InviteMutation) ShareCep() (r int64, exists bool) {
	v := m.share_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldShareCep returns the old "share_cep" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldShareCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareCep: %w", err)
	}
	return oldValue.ShareCep, nil
}

// AddShareCep adds i to the "share_cep" field.
func (m *InviteMutation) AddShareCep(i int64) {
	if m.addshare_cep != nil {
		*m.addshare_cep += i
	} else {
		m.addshare_cep = &i
	}
}

// AddedShareCep returns the value that was added to the "share_cep" field in this mutation.
func (m *InviteMutation) AddedShareCep() (r int64, exists bool) {
	v := m.addshare_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetShareCep resets all changes to the "share_cep" field.
func (m *InviteMutation) ResetShareCep() {
	m.share_cep = nil
	m.addshare_cep = nil
}

// SetRegCep sets the "reg_cep" field.
func (m *InviteMutation) SetRegCep(i int64) {
	m.reg_cep = &i
	m.addreg_cep = nil
}

// RegCep returns the value of the "reg_cep" field in the mutation.
func (m *InviteMutation) RegCep() (r int64, exists bool) {
	v := m.reg_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldRegCep returns the old "reg_cep" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldRegCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegCep: %w", err)
	}
	return oldValue.RegCep, nil
}

// AddRegCep adds i to the "reg_cep" field.
func (m *InviteMutation) AddRegCep(i int64) {
	if m.addreg_cep != nil {
		*m.addreg_cep += i
	} else {
		m.addreg_cep = &i
	}
}

// AddedRegCep returns the value that was added to the "reg_cep" field in this mutation.
func (m *InviteMutation) AddedRegCep() (r int64, exists bool) {
	v := m.addreg_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegCep resets all changes to the "reg_cep" field.
func (m *InviteMutation) ResetRegCep() {
	m.reg_cep = nil
	m.addreg_cep = nil
}

// SetFirstRechargeCep sets the "first_recharge_cep" field.
func (m *InviteMutation) SetFirstRechargeCep(i int64) {
	m.first_recharge_cep = &i
	m.addfirst_recharge_cep = nil
}

// FirstRechargeCep returns the value of the "first_recharge_cep" field in the mutation.
func (m *InviteMutation) FirstRechargeCep() (r int64, exists bool) {
	v := m.first_recharge_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstRechargeCep returns the old "first_recharge_cep" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldFirstRechargeCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstRechargeCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstRechargeCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstRechargeCep: %w", err)
	}
	return oldValue.FirstRechargeCep, nil
}

// AddFirstRechargeCep adds i to the "first_recharge_cep" field.
func (m *InviteMutation) AddFirstRechargeCep(i int64) {
	if m.addfirst_recharge_cep != nil {
		*m.addfirst_recharge_cep += i
	} else {
		m.addfirst_recharge_cep = &i
	}
}

// AddedFirstRechargeCep returns the value that was added to the "first_recharge_cep" field in this mutation.
func (m *InviteMutation) AddedFirstRechargeCep() (r int64, exists bool) {
	v := m.addfirst_recharge_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstRechargeCep resets all changes to the "first_recharge_cep" field.
func (m *InviteMutation) ResetFirstRechargeCep() {
	m.first_recharge_cep = nil
	m.addfirst_recharge_cep = nil
}

// SetType sets the "type" field.
func (m *InviteMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *InviteMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InviteMutation) ResetType() {
	m._type = nil
}

// SetUserID sets the "user_id" field.
func (m *InviteMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InviteMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InviteMutation) ResetUserID() {
	m.user = nil
}

// SetCampaignID sets the "campaign_id" field.
func (m *InviteMutation) SetCampaignID(i int64) {
	m.campaign = &i
}

// CampaignID returns the value of the "campaign_id" field in the mutation.
func (m *InviteMutation) CampaignID() (r int64, exists bool) {
	v := m.campaign
	if v == nil {
		return
	}
	return *v, true
}

// OldCampaignID returns the old "campaign_id" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCampaignID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCampaignID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCampaignID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCampaignID: %w", err)
	}
	return oldValue.CampaignID, nil
}

// ResetCampaignID resets all changes to the "campaign_id" field.
func (m *InviteMutation) ResetCampaignID() {
	m.campaign = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InviteMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[invite.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InviteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InviteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCampaign clears the "campaign" edge to the Campaign entity.
func (m *InviteMutation) ClearCampaign() {
	m.clearedcampaign = true
	m.clearedFields[invite.FieldCampaignID] = struct{}{}
}

// CampaignCleared reports if the "campaign" edge to the Campaign entity was cleared.
func (m *InviteMutation) CampaignCleared() bool {
	return m.clearedcampaign
}

// CampaignIDs returns the "campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) CampaignIDs() (ids []int64) {
	if id := m.campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaign resets all changes to the "campaign" edge.
func (m *InviteMutation) ResetCampaign() {
	m.campaign = nil
	m.clearedcampaign = false
}

// AddBillIDs adds the "bills" edge to the Bill entity by ids.
func (m *InviteMutation) AddBillIDs(ids ...int64) {
	if m.bills == nil {
		m.bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the Bill entity.
func (m *InviteMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the Bill entity was cleared.
func (m *InviteMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the Bill entity by IDs.
func (m *InviteMutation) RemoveBillIDs(ids ...int64) {
	if m.removedbills == nil {
		m.removedbills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the Bill entity.
func (m *InviteMutation) RemovedBillsIDs() (ids []int64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *InviteMutation) BillsIDs() (ids []int64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *InviteMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// Where appends a list predicates to the InviteMutation builder.
func (m *InviteMutation) Where(ps ...predicate.Invite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InviteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InviteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InviteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InviteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invite).
func (m *InviteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, invite.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, invite.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, invite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invite.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, invite.FieldDeletedAt)
	}
	if m.invite_code != nil {
		fields = append(fields, invite.FieldInviteCode)
	}
	if m.share_cep != nil {
		fields = append(fields, invite.FieldShareCep)
	}
	if m.reg_cep != nil {
		fields = append(fields, invite.FieldRegCep)
	}
	if m.first_recharge_cep != nil {
		fields = append(fields, invite.FieldFirstRechargeCep)
	}
	if m._type != nil {
		fields = append(fields, invite.FieldType)
	}
	if m.user != nil {
		fields = append(fields, invite.FieldUserID)
	}
	if m.campaign != nil {
		fields = append(fields, invite.FieldCampaignID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldCreatedBy:
		return m.CreatedBy()
	case invite.FieldUpdatedBy:
		return m.UpdatedBy()
	case invite.FieldCreatedAt:
		return m.CreatedAt()
	case invite.FieldUpdatedAt:
		return m.UpdatedAt()
	case invite.FieldDeletedAt:
		return m.DeletedAt()
	case invite.FieldInviteCode:
		return m.InviteCode()
	case invite.FieldShareCep:
		return m.ShareCep()
	case invite.FieldRegCep:
		return m.RegCep()
	case invite.FieldFirstRechargeCep:
		return m.FirstRechargeCep()
	case invite.FieldType:
		return m.GetType()
	case invite.FieldUserID:
		return m.UserID()
	case invite.FieldCampaignID:
		return m.CampaignID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invite.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case invite.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case invite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invite.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invite.FieldInviteCode:
		return m.OldInviteCode(ctx)
	case invite.FieldShareCep:
		return m.OldShareCep(ctx)
	case invite.FieldRegCep:
		return m.OldRegCep(ctx)
	case invite.FieldFirstRechargeCep:
		return m.OldFirstRechargeCep(ctx)
	case invite.FieldType:
		return m.OldType(ctx)
	case invite.FieldUserID:
		return m.OldUserID(ctx)
	case invite.FieldCampaignID:
		return m.OldCampaignID(ctx)
	}
	return nil, fmt.Errorf("unknown Invite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invite.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case invite.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case invite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invite.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invite.FieldInviteCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteCode(v)
		return nil
	case invite.FieldShareCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareCep(v)
		return nil
	case invite.FieldRegCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegCep(v)
		return nil
	case invite.FieldFirstRechargeCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstRechargeCep(v)
		return nil
	case invite.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case invite.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invite.FieldCampaignID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCampaignID(v)
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, invite.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, invite.FieldUpdatedBy)
	}
	if m.addshare_cep != nil {
		fields = append(fields, invite.FieldShareCep)
	}
	if m.addreg_cep != nil {
		fields = append(fields, invite.FieldRegCep)
	}
	if m.addfirst_recharge_cep != nil {
		fields = append(fields, invite.FieldFirstRechargeCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldCreatedBy:
		return m.AddedCreatedBy()
	case invite.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case invite.FieldShareCep:
		return m.AddedShareCep()
	case invite.FieldRegCep:
		return m.AddedRegCep()
	case invite.FieldFirstRechargeCep:
		return m.AddedFirstRechargeCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invite.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case invite.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case invite.FieldShareCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShareCep(v)
		return nil
	case invite.FieldRegCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegCep(v)
		return nil
	case invite.FieldFirstRechargeCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstRechargeCep(v)
		return nil
	}
	return fmt.Errorf("unknown Invite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Invite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteMutation) ResetField(name string) error {
	switch name {
	case invite.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case invite.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case invite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invite.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invite.FieldInviteCode:
		m.ResetInviteCode()
		return nil
	case invite.FieldShareCep:
		m.ResetShareCep()
		return nil
	case invite.FieldRegCep:
		m.ResetRegCep()
		return nil
	case invite.FieldFirstRechargeCep:
		m.ResetFirstRechargeCep()
		return nil
	case invite.FieldType:
		m.ResetType()
		return nil
	case invite.FieldUserID:
		m.ResetUserID()
		return nil
	case invite.FieldCampaignID:
		m.ResetCampaignID()
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, invite.EdgeUser)
	}
	if m.campaign != nil {
		edges = append(edges, invite.EdgeCampaign)
	}
	if m.bills != nil {
		edges = append(edges, invite.EdgeBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invite.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeCampaign:
		if id := m.campaign; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbills != nil {
		edges = append(edges, invite.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invite.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, invite.EdgeUser)
	}
	if m.clearedcampaign {
		edges = append(edges, invite.EdgeCampaign)
	}
	if m.clearedbills {
		edges = append(edges, invite.EdgeBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteMutation) EdgeCleared(name string) bool {
	switch name {
	case invite.EdgeUser:
		return m.cleareduser
	case invite.EdgeCampaign:
		return m.clearedcampaign
	case invite.EdgeBills:
		return m.clearedbills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteMutation) ClearEdge(name string) error {
	switch name {
	case invite.EdgeUser:
		m.ClearUser()
		return nil
	case invite.EdgeCampaign:
		m.ClearCampaign()
		return nil
	}
	return fmt.Errorf("unknown Invite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteMutation) ResetEdge(name string) error {
	switch name {
	case invite.EdgeUser:
		m.ResetUser()
		return nil
	case invite.EdgeCampaign:
		m.ResetCampaign()
		return nil
	case invite.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown Invite edge %s", name)
}

// LoginRecordMutation represents an operation that mutates the LoginRecord nodes in the graph.
type LoginRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	ua            *string
	ip            *string
	way           *string
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*LoginRecord, error)
	predicates    []predicate.LoginRecord
}

var _ ent.Mutation = (*LoginRecordMutation)(nil)

// loginrecordOption allows management of the mutation configuration using functional options.
type loginrecordOption func(*LoginRecordMutation)

// newLoginRecordMutation creates new mutation for the LoginRecord entity.
func newLoginRecordMutation(c config, op Op, opts ...loginrecordOption) *LoginRecordMutation {
	m := &LoginRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginRecordID sets the ID field of the mutation.
func withLoginRecordID(id int64) loginrecordOption {
	return func(m *LoginRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginRecord
		)
		m.oldValue = func(ctx context.Context) (*LoginRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginRecord sets the old LoginRecord of the mutation.
func withLoginRecord(node *LoginRecord) loginrecordOption {
	return func(m *LoginRecordMutation) {
		m.oldValue = func(context.Context) (*LoginRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginRecord entities.
func (m *LoginRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *LoginRecordMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LoginRecordMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *LoginRecordMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LoginRecordMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LoginRecordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LoginRecordMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LoginRecordMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *LoginRecordMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LoginRecordMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LoginRecordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LoginRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoginRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoginRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoginRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoginRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoginRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LoginRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LoginRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LoginRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUa sets the "ua" field.
func (m *LoginRecordMutation) SetUa(s string) {
	m.ua = &s
}

// Ua returns the value of the "ua" field in the mutation.
func (m *LoginRecordMutation) Ua() (r string, exists bool) {
	v := m.ua
	if v == nil {
		return
	}
	return *v, true
}

// OldUa returns the old "ua" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldUa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUa: %w", err)
	}
	return oldValue.Ua, nil
}

// ResetUa resets all changes to the "ua" field.
func (m *LoginRecordMutation) ResetUa() {
	m.ua = nil
}

// SetIP sets the "ip" field.
func (m *LoginRecordMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LoginRecordMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *LoginRecordMutation) ResetIP() {
	m.ip = nil
}

// SetWay sets the "way" field.
func (m *LoginRecordMutation) SetWay(s string) {
	m.way = &s
}

// Way returns the value of the "way" field in the mutation.
func (m *LoginRecordMutation) Way() (r string, exists bool) {
	v := m.way
	if v == nil {
		return
	}
	return *v, true
}

// OldWay returns the old "way" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldWay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWay: %w", err)
	}
	return oldValue.Way, nil
}

// ResetWay resets all changes to the "way" field.
func (m *LoginRecordMutation) ResetWay() {
	m.way = nil
}

// SetUserID sets the "user_id" field.
func (m *LoginRecordMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LoginRecordMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LoginRecord entity.
// If the LoginRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginRecordMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LoginRecordMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *LoginRecordMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[loginrecord.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LoginRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LoginRecordMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LoginRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the LoginRecordMutation builder.
func (m *LoginRecordMutation) Where(ps ...predicate.LoginRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginRecord).
func (m *LoginRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginRecordMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, loginrecord.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, loginrecord.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, loginrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, loginrecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, loginrecord.FieldDeletedAt)
	}
	if m.ua != nil {
		fields = append(fields, loginrecord.FieldUa)
	}
	if m.ip != nil {
		fields = append(fields, loginrecord.FieldIP)
	}
	if m.way != nil {
		fields = append(fields, loginrecord.FieldWay)
	}
	if m.user != nil {
		fields = append(fields, loginrecord.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginrecord.FieldCreatedBy:
		return m.CreatedBy()
	case loginrecord.FieldUpdatedBy:
		return m.UpdatedBy()
	case loginrecord.FieldCreatedAt:
		return m.CreatedAt()
	case loginrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case loginrecord.FieldDeletedAt:
		return m.DeletedAt()
	case loginrecord.FieldUa:
		return m.Ua()
	case loginrecord.FieldIP:
		return m.IP()
	case loginrecord.FieldWay:
		return m.Way()
	case loginrecord.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginrecord.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case loginrecord.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case loginrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loginrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case loginrecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case loginrecord.FieldUa:
		return m.OldUa(ctx)
	case loginrecord.FieldIP:
		return m.OldIP(ctx)
	case loginrecord.FieldWay:
		return m.OldWay(ctx)
	case loginrecord.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown LoginRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginrecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case loginrecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case loginrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loginrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case loginrecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case loginrecord.FieldUa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUa(v)
		return nil
	case loginrecord.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case loginrecord.FieldWay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWay(v)
		return nil
	case loginrecord.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown LoginRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, loginrecord.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, loginrecord.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loginrecord.FieldCreatedBy:
		return m.AddedCreatedBy()
	case loginrecord.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loginrecord.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case loginrecord.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown LoginRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LoginRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginRecordMutation) ResetField(name string) error {
	switch name {
	case loginrecord.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case loginrecord.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case loginrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loginrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case loginrecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case loginrecord.FieldUa:
		m.ResetUa()
		return nil
	case loginrecord.FieldIP:
		m.ResetIP()
		return nil
	case loginrecord.FieldWay:
		m.ResetWay()
		return nil
	case loginrecord.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown LoginRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, loginrecord.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case loginrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, loginrecord.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case loginrecord.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginRecordMutation) ClearEdge(name string) error {
	switch name {
	case loginrecord.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown LoginRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginRecordMutation) ResetEdge(name string) error {
	switch name {
	case loginrecord.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown LoginRecord edge %s", name)
}

// MissionMutation represents an operation that mutates the Mission nodes in the graph.
type MissionMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	_type                         *enums.MissionType
	body                          *string
	call_back_url                 *string
	call_back_info                *string
	call_back_data                *[]byte
	status                        *enums.MissionStatus
	result                        *enums.MissionResult
	state                         *enums.MissionState
	result_urls                   *[]string
	appendresult_urls             []string
	urls                          *string
	mission_batch_number          *string
	gpu_version                   *enums.GpuVersion
	unit_cep                      *int64
	addunit_cep                   *int64
	resp_status_code              *int32
	addresp_status_code           *int32
	resp_body                     *string
	inner_uri                     *string
	inner_method                  *enums.InnerMethod
	temp_hmac_key                 *string
	temp_hmac_secret              *string
	second_hmac_key               *string
	username                      *string
	password                      *string
	white_device_ids              *[]string
	black_device_ids              *[]string
	started_at                    *time.Time
	finished_at                   *time.Time
	expired_at                    *time.Time
	free_at                       *time.Time
	close_way                     *enums.CloseWay
	closed_at                     *time.Time
	warning_times                 *int64
	addwarning_times              *int64
	clearedFields                 map[string]struct{}
	mission_kind                  *int64
	clearedmission_kind           bool
	user                          *int64
	cleareduser                   bool
	mission_key_pairs             map[int64]struct{}
	removedmission_key_pairs      map[int64]struct{}
	clearedmission_key_pairs      bool
	key_pair                      *int64
	clearedkey_pair               bool
	mission_consume_order         *int64
	clearedmission_consume_order  bool
	mission_produce_orders        map[int64]struct{}
	removedmission_produce_orders map[int64]struct{}
	clearedmission_produce_orders bool
	mission_batch                 *int64
	clearedmission_batch          bool
	mission_productions           map[int64]struct{}
	removedmission_productions    map[int64]struct{}
	clearedmission_productions    bool
	mission_orders                map[int64]struct{}
	removedmission_orders         map[int64]struct{}
	clearedmission_orders         bool
	renewal_agreements            map[int64]struct{}
	removedrenewal_agreements     map[int64]struct{}
	clearedrenewal_agreements     bool
	mission_extra_services        map[int64]struct{}
	removedmission_extra_services map[int64]struct{}
	clearedmission_extra_services bool
	extra_services                map[int64]struct{}
	removedextra_services         map[int64]struct{}
	clearedextra_services         bool
	extra_service_orders          map[int64]struct{}
	removedextra_service_orders   map[int64]struct{}
	clearedextra_service_orders   bool
	done                          bool
	oldValue                      func(context.Context) (*Mission, error)
	predicates                    []predicate.Mission
}

var _ ent.Mutation = (*MissionMutation)(nil)

// missionOption allows management of the mutation configuration using functional options.
type missionOption func(*MissionMutation)

// newMissionMutation creates new mutation for the Mission entity.
func newMissionMutation(c config, op Op, opts ...missionOption) *MissionMutation {
	m := &MissionMutation{
		config:        c,
		op:            op,
		typ:           TypeMission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionID sets the ID field of the mutation.
func withMissionID(id int64) missionOption {
	return func(m *MissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Mission
		)
		m.oldValue = func(ctx context.Context) (*Mission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMission sets the old Mission of the mutation.
func withMission(node *Mission) missionOption {
	return func(m *MissionMutation) {
		m.oldValue = func(context.Context) (*Mission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mission entities.
func (m *MissionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *MissionMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionMutation) ResetType() {
	m._type = nil
}

// SetMissionKindID sets the "mission_kind_id" field.
func (m *MissionMutation) SetMissionKindID(i int64) {
	m.mission_kind = &i
}

// MissionKindID returns the value of the "mission_kind_id" field in the mutation.
func (m *MissionMutation) MissionKindID() (r int64, exists bool) {
	v := m.mission_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionKindID returns the old "mission_kind_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldMissionKindID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionKindID: %w", err)
	}
	return oldValue.MissionKindID, nil
}

// ResetMissionKindID resets all changes to the "mission_kind_id" field.
func (m *MissionMutation) ResetMissionKindID() {
	m.mission_kind = nil
}

// SetBody sets the "body" field.
func (m *MissionMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *MissionMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *MissionMutation) ResetBody() {
	m.body = nil
}

// SetCallBackURL sets the "call_back_url" field.
func (m *MissionMutation) SetCallBackURL(s string) {
	m.call_back_url = &s
}

// CallBackURL returns the value of the "call_back_url" field in the mutation.
func (m *MissionMutation) CallBackURL() (r string, exists bool) {
	v := m.call_back_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCallBackURL returns the old "call_back_url" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCallBackURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallBackURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallBackURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallBackURL: %w", err)
	}
	return oldValue.CallBackURL, nil
}

// ResetCallBackURL resets all changes to the "call_back_url" field.
func (m *MissionMutation) ResetCallBackURL() {
	m.call_back_url = nil
}

// SetCallBackInfo sets the "call_back_info" field.
func (m *MissionMutation) SetCallBackInfo(s string) {
	m.call_back_info = &s
}

// CallBackInfo returns the value of the "call_back_info" field in the mutation.
func (m *MissionMutation) CallBackInfo() (r string, exists bool) {
	v := m.call_back_info
	if v == nil {
		return
	}
	return *v, true
}

// OldCallBackInfo returns the old "call_back_info" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCallBackInfo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallBackInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallBackInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallBackInfo: %w", err)
	}
	return oldValue.CallBackInfo, nil
}

// ClearCallBackInfo clears the value of the "call_back_info" field.
func (m *MissionMutation) ClearCallBackInfo() {
	m.call_back_info = nil
	m.clearedFields[mission.FieldCallBackInfo] = struct{}{}
}

// CallBackInfoCleared returns if the "call_back_info" field was cleared in this mutation.
func (m *MissionMutation) CallBackInfoCleared() bool {
	_, ok := m.clearedFields[mission.FieldCallBackInfo]
	return ok
}

// ResetCallBackInfo resets all changes to the "call_back_info" field.
func (m *MissionMutation) ResetCallBackInfo() {
	m.call_back_info = nil
	delete(m.clearedFields, mission.FieldCallBackInfo)
}

// SetCallBackData sets the "call_back_data" field.
func (m *MissionMutation) SetCallBackData(b []byte) {
	m.call_back_data = &b
}

// CallBackData returns the value of the "call_back_data" field in the mutation.
func (m *MissionMutation) CallBackData() (r []byte, exists bool) {
	v := m.call_back_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCallBackData returns the old "call_back_data" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCallBackData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallBackData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallBackData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallBackData: %w", err)
	}
	return oldValue.CallBackData, nil
}

// ClearCallBackData clears the value of the "call_back_data" field.
func (m *MissionMutation) ClearCallBackData() {
	m.call_back_data = nil
	m.clearedFields[mission.FieldCallBackData] = struct{}{}
}

// CallBackDataCleared returns if the "call_back_data" field was cleared in this mutation.
func (m *MissionMutation) CallBackDataCleared() bool {
	_, ok := m.clearedFields[mission.FieldCallBackData]
	return ok
}

// ResetCallBackData resets all changes to the "call_back_data" field.
func (m *MissionMutation) ResetCallBackData() {
	m.call_back_data = nil
	delete(m.clearedFields, mission.FieldCallBackData)
}

// SetStatus sets the "status" field.
func (m *MissionMutation) SetStatus(es enums.MissionStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionMutation) Status() (r enums.MissionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldStatus(ctx context.Context) (v enums.MissionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionMutation) ResetStatus() {
	m.status = nil
}

// SetResult sets the "result" field.
func (m *MissionMutation) SetResult(er enums.MissionResult) {
	m.result = &er
}

// Result returns the value of the "result" field in the mutation.
func (m *MissionMutation) Result() (r enums.MissionResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldResult(ctx context.Context) (v enums.MissionResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *MissionMutation) ResetResult() {
	m.result = nil
}

// SetState sets the "state" field.
func (m *MissionMutation) SetState(es enums.MissionState) {
	m.state = &es
}

// State returns the value of the "state" field in the mutation.
func (m *MissionMutation) State() (r enums.MissionState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldState(ctx context.Context) (v enums.MissionState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *MissionMutation) ResetState() {
	m.state = nil
}

// SetResultUrls sets the "result_urls" field.
func (m *MissionMutation) SetResultUrls(s []string) {
	m.result_urls = &s
	m.appendresult_urls = nil
}

// ResultUrls returns the value of the "result_urls" field in the mutation.
func (m *MissionMutation) ResultUrls() (r []string, exists bool) {
	v := m.result_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldResultUrls returns the old "result_urls" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldResultUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultUrls: %w", err)
	}
	return oldValue.ResultUrls, nil
}

// AppendResultUrls adds s to the "result_urls" field.
func (m *MissionMutation) AppendResultUrls(s []string) {
	m.appendresult_urls = append(m.appendresult_urls, s...)
}

// AppendedResultUrls returns the list of values that were appended to the "result_urls" field in this mutation.
func (m *MissionMutation) AppendedResultUrls() ([]string, bool) {
	if len(m.appendresult_urls) == 0 {
		return nil, false
	}
	return m.appendresult_urls, true
}

// ClearResultUrls clears the value of the "result_urls" field.
func (m *MissionMutation) ClearResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	m.clearedFields[mission.FieldResultUrls] = struct{}{}
}

// ResultUrlsCleared returns if the "result_urls" field was cleared in this mutation.
func (m *MissionMutation) ResultUrlsCleared() bool {
	_, ok := m.clearedFields[mission.FieldResultUrls]
	return ok
}

// ResetResultUrls resets all changes to the "result_urls" field.
func (m *MissionMutation) ResetResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	delete(m.clearedFields, mission.FieldResultUrls)
}

// SetUrls sets the "urls" field.
func (m *MissionMutation) SetUrls(s string) {
	m.urls = &s
}

// Urls returns the value of the "urls" field in the mutation.
func (m *MissionMutation) Urls() (r string, exists bool) {
	v := m.urls
	if v == nil {
		return
	}
	return *v, true
}

// OldUrls returns the old "urls" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUrls(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrls: %w", err)
	}
	return oldValue.Urls, nil
}

// ResetUrls resets all changes to the "urls" field.
func (m *MissionMutation) ResetUrls() {
	m.urls = nil
}

// SetKeyPairID sets the "key_pair_id" field.
func (m *MissionMutation) SetKeyPairID(i int64) {
	m.key_pair = &i
}

// KeyPairID returns the value of the "key_pair_id" field in the mutation.
func (m *MissionMutation) KeyPairID() (r int64, exists bool) {
	v := m.key_pair
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPairID returns the old "key_pair_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldKeyPairID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPairID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPairID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPairID: %w", err)
	}
	return oldValue.KeyPairID, nil
}

// ResetKeyPairID resets all changes to the "key_pair_id" field.
func (m *MissionMutation) ResetKeyPairID() {
	m.key_pair = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionMutation) ResetUserID() {
	m.user = nil
}

// SetMissionBatchID sets the "mission_batch_id" field.
func (m *MissionMutation) SetMissionBatchID(i int64) {
	m.mission_batch = &i
}

// MissionBatchID returns the value of the "mission_batch_id" field in the mutation.
func (m *MissionMutation) MissionBatchID() (r int64, exists bool) {
	v := m.mission_batch
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchID returns the old "mission_batch_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldMissionBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchID: %w", err)
	}
	return oldValue.MissionBatchID, nil
}

// ResetMissionBatchID resets all changes to the "mission_batch_id" field.
func (m *MissionMutation) ResetMissionBatchID() {
	m.mission_batch = nil
}

// SetMissionBatchNumber sets the "mission_batch_number" field.
func (m *MissionMutation) SetMissionBatchNumber(s string) {
	m.mission_batch_number = &s
}

// MissionBatchNumber returns the value of the "mission_batch_number" field in the mutation.
func (m *MissionMutation) MissionBatchNumber() (r string, exists bool) {
	v := m.mission_batch_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchNumber returns the old "mission_batch_number" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldMissionBatchNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchNumber: %w", err)
	}
	return oldValue.MissionBatchNumber, nil
}

// ResetMissionBatchNumber resets all changes to the "mission_batch_number" field.
func (m *MissionMutation) ResetMissionBatchNumber() {
	m.mission_batch_number = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *MissionMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *MissionMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *MissionMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetUnitCep sets the "unit_cep" field.
func (m *MissionMutation) SetUnitCep(i int64) {
	m.unit_cep = &i
	m.addunit_cep = nil
}

// UnitCep returns the value of the "unit_cep" field in the mutation.
func (m *MissionMutation) UnitCep() (r int64, exists bool) {
	v := m.unit_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCep returns the old "unit_cep" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUnitCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCep: %w", err)
	}
	return oldValue.UnitCep, nil
}

// AddUnitCep adds i to the "unit_cep" field.
func (m *MissionMutation) AddUnitCep(i int64) {
	if m.addunit_cep != nil {
		*m.addunit_cep += i
	} else {
		m.addunit_cep = &i
	}
}

// AddedUnitCep returns the value that was added to the "unit_cep" field in this mutation.
func (m *MissionMutation) AddedUnitCep() (r int64, exists bool) {
	v := m.addunit_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitCep resets all changes to the "unit_cep" field.
func (m *MissionMutation) ResetUnitCep() {
	m.unit_cep = nil
	m.addunit_cep = nil
}

// SetRespStatusCode sets the "resp_status_code" field.
func (m *MissionMutation) SetRespStatusCode(i int32) {
	m.resp_status_code = &i
	m.addresp_status_code = nil
}

// RespStatusCode returns the value of the "resp_status_code" field in the mutation.
func (m *MissionMutation) RespStatusCode() (r int32, exists bool) {
	v := m.resp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRespStatusCode returns the old "resp_status_code" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldRespStatusCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespStatusCode: %w", err)
	}
	return oldValue.RespStatusCode, nil
}

// AddRespStatusCode adds i to the "resp_status_code" field.
func (m *MissionMutation) AddRespStatusCode(i int32) {
	if m.addresp_status_code != nil {
		*m.addresp_status_code += i
	} else {
		m.addresp_status_code = &i
	}
}

// AddedRespStatusCode returns the value that was added to the "resp_status_code" field in this mutation.
func (m *MissionMutation) AddedRespStatusCode() (r int32, exists bool) {
	v := m.addresp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetRespStatusCode resets all changes to the "resp_status_code" field.
func (m *MissionMutation) ResetRespStatusCode() {
	m.resp_status_code = nil
	m.addresp_status_code = nil
}

// SetRespBody sets the "resp_body" field.
func (m *MissionMutation) SetRespBody(s string) {
	m.resp_body = &s
}

// RespBody returns the value of the "resp_body" field in the mutation.
func (m *MissionMutation) RespBody() (r string, exists bool) {
	v := m.resp_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRespBody returns the old "resp_body" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldRespBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespBody: %w", err)
	}
	return oldValue.RespBody, nil
}

// ResetRespBody resets all changes to the "resp_body" field.
func (m *MissionMutation) ResetRespBody() {
	m.resp_body = nil
}

// SetInnerURI sets the "inner_uri" field.
func (m *MissionMutation) SetInnerURI(s string) {
	m.inner_uri = &s
}

// InnerURI returns the value of the "inner_uri" field in the mutation.
func (m *MissionMutation) InnerURI() (r string, exists bool) {
	v := m.inner_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldInnerURI returns the old "inner_uri" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldInnerURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnerURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnerURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnerURI: %w", err)
	}
	return oldValue.InnerURI, nil
}

// ResetInnerURI resets all changes to the "inner_uri" field.
func (m *MissionMutation) ResetInnerURI() {
	m.inner_uri = nil
}

// SetInnerMethod sets the "inner_method" field.
func (m *MissionMutation) SetInnerMethod(em enums.InnerMethod) {
	m.inner_method = &em
}

// InnerMethod returns the value of the "inner_method" field in the mutation.
func (m *MissionMutation) InnerMethod() (r enums.InnerMethod, exists bool) {
	v := m.inner_method
	if v == nil {
		return
	}
	return *v, true
}

// OldInnerMethod returns the old "inner_method" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldInnerMethod(ctx context.Context) (v enums.InnerMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnerMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnerMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnerMethod: %w", err)
	}
	return oldValue.InnerMethod, nil
}

// ResetInnerMethod resets all changes to the "inner_method" field.
func (m *MissionMutation) ResetInnerMethod() {
	m.inner_method = nil
}

// SetTempHmacKey sets the "temp_hmac_key" field.
func (m *MissionMutation) SetTempHmacKey(s string) {
	m.temp_hmac_key = &s
}

// TempHmacKey returns the value of the "temp_hmac_key" field in the mutation.
func (m *MissionMutation) TempHmacKey() (r string, exists bool) {
	v := m.temp_hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTempHmacKey returns the old "temp_hmac_key" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldTempHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTempHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTempHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTempHmacKey: %w", err)
	}
	return oldValue.TempHmacKey, nil
}

// ResetTempHmacKey resets all changes to the "temp_hmac_key" field.
func (m *MissionMutation) ResetTempHmacKey() {
	m.temp_hmac_key = nil
}

// SetTempHmacSecret sets the "temp_hmac_secret" field.
func (m *MissionMutation) SetTempHmacSecret(s string) {
	m.temp_hmac_secret = &s
}

// TempHmacSecret returns the value of the "temp_hmac_secret" field in the mutation.
func (m *MissionMutation) TempHmacSecret() (r string, exists bool) {
	v := m.temp_hmac_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTempHmacSecret returns the old "temp_hmac_secret" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldTempHmacSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTempHmacSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTempHmacSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTempHmacSecret: %w", err)
	}
	return oldValue.TempHmacSecret, nil
}

// ResetTempHmacSecret resets all changes to the "temp_hmac_secret" field.
func (m *MissionMutation) ResetTempHmacSecret() {
	m.temp_hmac_secret = nil
}

// SetSecondHmacKey sets the "second_hmac_key" field.
func (m *MissionMutation) SetSecondHmacKey(s string) {
	m.second_hmac_key = &s
}

// SecondHmacKey returns the value of the "second_hmac_key" field in the mutation.
func (m *MissionMutation) SecondHmacKey() (r string, exists bool) {
	v := m.second_hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondHmacKey returns the old "second_hmac_key" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldSecondHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondHmacKey: %w", err)
	}
	return oldValue.SecondHmacKey, nil
}

// ResetSecondHmacKey resets all changes to the "second_hmac_key" field.
func (m *MissionMutation) ResetSecondHmacKey() {
	m.second_hmac_key = nil
}

// SetUsername sets the "username" field.
func (m *MissionMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *MissionMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *MissionMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *MissionMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MissionMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MissionMutation) ResetPassword() {
	m.password = nil
}

// SetWhiteDeviceIds sets the "white_device_ids" field.
func (m *MissionMutation) SetWhiteDeviceIds(s []string) {
	m.white_device_ids = &s
}

// WhiteDeviceIds returns the value of the "white_device_ids" field in the mutation.
func (m *MissionMutation) WhiteDeviceIds() (r []string, exists bool) {
	v := m.white_device_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldWhiteDeviceIds returns the old "white_device_ids" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldWhiteDeviceIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhiteDeviceIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhiteDeviceIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhiteDeviceIds: %w", err)
	}
	return oldValue.WhiteDeviceIds, nil
}

// ClearWhiteDeviceIds clears the value of the "white_device_ids" field.
func (m *MissionMutation) ClearWhiteDeviceIds() {
	m.white_device_ids = nil
	m.clearedFields[mission.FieldWhiteDeviceIds] = struct{}{}
}

// WhiteDeviceIdsCleared returns if the "white_device_ids" field was cleared in this mutation.
func (m *MissionMutation) WhiteDeviceIdsCleared() bool {
	_, ok := m.clearedFields[mission.FieldWhiteDeviceIds]
	return ok
}

// ResetWhiteDeviceIds resets all changes to the "white_device_ids" field.
func (m *MissionMutation) ResetWhiteDeviceIds() {
	m.white_device_ids = nil
	delete(m.clearedFields, mission.FieldWhiteDeviceIds)
}

// SetBlackDeviceIds sets the "black_device_ids" field.
func (m *MissionMutation) SetBlackDeviceIds(s []string) {
	m.black_device_ids = &s
}

// BlackDeviceIds returns the value of the "black_device_ids" field in the mutation.
func (m *MissionMutation) BlackDeviceIds() (r []string, exists bool) {
	v := m.black_device_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldBlackDeviceIds returns the old "black_device_ids" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldBlackDeviceIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlackDeviceIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlackDeviceIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlackDeviceIds: %w", err)
	}
	return oldValue.BlackDeviceIds, nil
}

// ClearBlackDeviceIds clears the value of the "black_device_ids" field.
func (m *MissionMutation) ClearBlackDeviceIds() {
	m.black_device_ids = nil
	m.clearedFields[mission.FieldBlackDeviceIds] = struct{}{}
}

// BlackDeviceIdsCleared returns if the "black_device_ids" field was cleared in this mutation.
func (m *MissionMutation) BlackDeviceIdsCleared() bool {
	_, ok := m.clearedFields[mission.FieldBlackDeviceIds]
	return ok
}

// ResetBlackDeviceIds resets all changes to the "black_device_ids" field.
func (m *MissionMutation) ResetBlackDeviceIds() {
	m.black_device_ids = nil
	delete(m.clearedFields, mission.FieldBlackDeviceIds)
}

// SetStartedAt sets the "started_at" field.
func (m *MissionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *MissionMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[mission.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *MissionMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[mission.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, mission.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *MissionMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[mission.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *MissionMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[mission.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, mission.FieldFinishedAt)
}

// SetExpiredAt sets the "expired_at" field.
func (m *MissionMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *MissionMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *MissionMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[mission.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *MissionMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[mission.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *MissionMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, mission.FieldExpiredAt)
}

// SetFreeAt sets the "free_at" field.
func (m *MissionMutation) SetFreeAt(t time.Time) {
	m.free_at = &t
}

// FreeAt returns the value of the "free_at" field in the mutation.
func (m *MissionMutation) FreeAt() (r time.Time, exists bool) {
	v := m.free_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeAt returns the old "free_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldFreeAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeAt: %w", err)
	}
	return oldValue.FreeAt, nil
}

// ResetFreeAt resets all changes to the "free_at" field.
func (m *MissionMutation) ResetFreeAt() {
	m.free_at = nil
}

// SetCloseWay sets the "close_way" field.
func (m *MissionMutation) SetCloseWay(ew enums.CloseWay) {
	m.close_way = &ew
}

// CloseWay returns the value of the "close_way" field in the mutation.
func (m *MissionMutation) CloseWay() (r enums.CloseWay, exists bool) {
	v := m.close_way
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseWay returns the old "close_way" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCloseWay(ctx context.Context) (v enums.CloseWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseWay: %w", err)
	}
	return oldValue.CloseWay, nil
}

// ResetCloseWay resets all changes to the "close_way" field.
func (m *MissionMutation) ResetCloseWay() {
	m.close_way = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *MissionMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *MissionMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldClosedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ClearClosedAt clears the value of the "closed_at" field.
func (m *MissionMutation) ClearClosedAt() {
	m.closed_at = nil
	m.clearedFields[mission.FieldClosedAt] = struct{}{}
}

// ClosedAtCleared returns if the "closed_at" field was cleared in this mutation.
func (m *MissionMutation) ClosedAtCleared() bool {
	_, ok := m.clearedFields[mission.FieldClosedAt]
	return ok
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *MissionMutation) ResetClosedAt() {
	m.closed_at = nil
	delete(m.clearedFields, mission.FieldClosedAt)
}

// SetWarningTimes sets the "warning_times" field.
func (m *MissionMutation) SetWarningTimes(i int64) {
	m.warning_times = &i
	m.addwarning_times = nil
}

// WarningTimes returns the value of the "warning_times" field in the mutation.
func (m *MissionMutation) WarningTimes() (r int64, exists bool) {
	v := m.warning_times
	if v == nil {
		return
	}
	return *v, true
}

// OldWarningTimes returns the old "warning_times" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldWarningTimes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarningTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarningTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarningTimes: %w", err)
	}
	return oldValue.WarningTimes, nil
}

// AddWarningTimes adds i to the "warning_times" field.
func (m *MissionMutation) AddWarningTimes(i int64) {
	if m.addwarning_times != nil {
		*m.addwarning_times += i
	} else {
		m.addwarning_times = &i
	}
}

// AddedWarningTimes returns the value that was added to the "warning_times" field in this mutation.
func (m *MissionMutation) AddedWarningTimes() (r int64, exists bool) {
	v := m.addwarning_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetWarningTimes resets all changes to the "warning_times" field.
func (m *MissionMutation) ResetWarningTimes() {
	m.warning_times = nil
	m.addwarning_times = nil
}

// ClearMissionKind clears the "mission_kind" edge to the MissionKind entity.
func (m *MissionMutation) ClearMissionKind() {
	m.clearedmission_kind = true
	m.clearedFields[mission.FieldMissionKindID] = struct{}{}
}

// MissionKindCleared reports if the "mission_kind" edge to the MissionKind entity was cleared.
func (m *MissionMutation) MissionKindCleared() bool {
	return m.clearedmission_kind
}

// MissionKindIDs returns the "mission_kind" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionKindID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) MissionKindIDs() (ids []int64) {
	if id := m.mission_kind; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionKind resets all changes to the "mission_kind" edge.
func (m *MissionMutation) ResetMissionKind() {
	m.mission_kind = nil
	m.clearedmission_kind = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[mission.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMissionKeyPairIDs adds the "mission_key_pairs" edge to the MissionKeyPair entity by ids.
func (m *MissionMutation) AddMissionKeyPairIDs(ids ...int64) {
	if m.mission_key_pairs == nil {
		m.mission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_key_pairs[ids[i]] = struct{}{}
	}
}

// ClearMissionKeyPairs clears the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *MissionMutation) ClearMissionKeyPairs() {
	m.clearedmission_key_pairs = true
}

// MissionKeyPairsCleared reports if the "mission_key_pairs" edge to the MissionKeyPair entity was cleared.
func (m *MissionMutation) MissionKeyPairsCleared() bool {
	return m.clearedmission_key_pairs
}

// RemoveMissionKeyPairIDs removes the "mission_key_pairs" edge to the MissionKeyPair entity by IDs.
func (m *MissionMutation) RemoveMissionKeyPairIDs(ids ...int64) {
	if m.removedmission_key_pairs == nil {
		m.removedmission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_key_pairs, ids[i])
		m.removedmission_key_pairs[ids[i]] = struct{}{}
	}
}

// RemovedMissionKeyPairs returns the removed IDs of the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *MissionMutation) RemovedMissionKeyPairsIDs() (ids []int64) {
	for id := range m.removedmission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// MissionKeyPairsIDs returns the "mission_key_pairs" edge IDs in the mutation.
func (m *MissionMutation) MissionKeyPairsIDs() (ids []int64) {
	for id := range m.mission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// ResetMissionKeyPairs resets all changes to the "mission_key_pairs" edge.
func (m *MissionMutation) ResetMissionKeyPairs() {
	m.mission_key_pairs = nil
	m.clearedmission_key_pairs = false
	m.removedmission_key_pairs = nil
}

// ClearKeyPair clears the "key_pair" edge to the HmacKeyPair entity.
func (m *MissionMutation) ClearKeyPair() {
	m.clearedkey_pair = true
	m.clearedFields[mission.FieldKeyPairID] = struct{}{}
}

// KeyPairCleared reports if the "key_pair" edge to the HmacKeyPair entity was cleared.
func (m *MissionMutation) KeyPairCleared() bool {
	return m.clearedkey_pair
}

// KeyPairIDs returns the "key_pair" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeyPairID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) KeyPairIDs() (ids []int64) {
	if id := m.key_pair; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeyPair resets all changes to the "key_pair" edge.
func (m *MissionMutation) ResetKeyPair() {
	m.key_pair = nil
	m.clearedkey_pair = false
}

// SetMissionConsumeOrderID sets the "mission_consume_order" edge to the MissionConsumeOrder entity by id.
func (m *MissionMutation) SetMissionConsumeOrderID(id int64) {
	m.mission_consume_order = &id
}

// ClearMissionConsumeOrder clears the "mission_consume_order" edge to the MissionConsumeOrder entity.
func (m *MissionMutation) ClearMissionConsumeOrder() {
	m.clearedmission_consume_order = true
}

// MissionConsumeOrderCleared reports if the "mission_consume_order" edge to the MissionConsumeOrder entity was cleared.
func (m *MissionMutation) MissionConsumeOrderCleared() bool {
	return m.clearedmission_consume_order
}

// MissionConsumeOrderID returns the "mission_consume_order" edge ID in the mutation.
func (m *MissionMutation) MissionConsumeOrderID() (id int64, exists bool) {
	if m.mission_consume_order != nil {
		return *m.mission_consume_order, true
	}
	return
}

// MissionConsumeOrderIDs returns the "mission_consume_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionConsumeOrderID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) MissionConsumeOrderIDs() (ids []int64) {
	if id := m.mission_consume_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionConsumeOrder resets all changes to the "mission_consume_order" edge.
func (m *MissionMutation) ResetMissionConsumeOrder() {
	m.mission_consume_order = nil
	m.clearedmission_consume_order = false
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *MissionMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *MissionMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *MissionMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *MissionMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *MissionMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// ClearMissionBatch clears the "mission_batch" edge to the MissionBatch entity.
func (m *MissionMutation) ClearMissionBatch() {
	m.clearedmission_batch = true
	m.clearedFields[mission.FieldMissionBatchID] = struct{}{}
}

// MissionBatchCleared reports if the "mission_batch" edge to the MissionBatch entity was cleared.
func (m *MissionMutation) MissionBatchCleared() bool {
	return m.clearedmission_batch
}

// MissionBatchIDs returns the "mission_batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionBatchID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) MissionBatchIDs() (ids []int64) {
	if id := m.mission_batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionBatch resets all changes to the "mission_batch" edge.
func (m *MissionMutation) ResetMissionBatch() {
	m.mission_batch = nil
	m.clearedmission_batch = false
}

// AddMissionProductionIDs adds the "mission_productions" edge to the MissionProduction entity by ids.
func (m *MissionMutation) AddMissionProductionIDs(ids ...int64) {
	if m.mission_productions == nil {
		m.mission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_productions[ids[i]] = struct{}{}
	}
}

// ClearMissionProductions clears the "mission_productions" edge to the MissionProduction entity.
func (m *MissionMutation) ClearMissionProductions() {
	m.clearedmission_productions = true
}

// MissionProductionsCleared reports if the "mission_productions" edge to the MissionProduction entity was cleared.
func (m *MissionMutation) MissionProductionsCleared() bool {
	return m.clearedmission_productions
}

// RemoveMissionProductionIDs removes the "mission_productions" edge to the MissionProduction entity by IDs.
func (m *MissionMutation) RemoveMissionProductionIDs(ids ...int64) {
	if m.removedmission_productions == nil {
		m.removedmission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_productions, ids[i])
		m.removedmission_productions[ids[i]] = struct{}{}
	}
}

// RemovedMissionProductions returns the removed IDs of the "mission_productions" edge to the MissionProduction entity.
func (m *MissionMutation) RemovedMissionProductionsIDs() (ids []int64) {
	for id := range m.removedmission_productions {
		ids = append(ids, id)
	}
	return
}

// MissionProductionsIDs returns the "mission_productions" edge IDs in the mutation.
func (m *MissionMutation) MissionProductionsIDs() (ids []int64) {
	for id := range m.mission_productions {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProductions resets all changes to the "mission_productions" edge.
func (m *MissionMutation) ResetMissionProductions() {
	m.mission_productions = nil
	m.clearedmission_productions = false
	m.removedmission_productions = nil
}

// AddMissionOrderIDs adds the "mission_orders" edge to the MissionOrder entity by ids.
func (m *MissionMutation) AddMissionOrderIDs(ids ...int64) {
	if m.mission_orders == nil {
		m.mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionOrders clears the "mission_orders" edge to the MissionOrder entity.
func (m *MissionMutation) ClearMissionOrders() {
	m.clearedmission_orders = true
}

// MissionOrdersCleared reports if the "mission_orders" edge to the MissionOrder entity was cleared.
func (m *MissionMutation) MissionOrdersCleared() bool {
	return m.clearedmission_orders
}

// RemoveMissionOrderIDs removes the "mission_orders" edge to the MissionOrder entity by IDs.
func (m *MissionMutation) RemoveMissionOrderIDs(ids ...int64) {
	if m.removedmission_orders == nil {
		m.removedmission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_orders, ids[i])
		m.removedmission_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionOrders returns the removed IDs of the "mission_orders" edge to the MissionOrder entity.
func (m *MissionMutation) RemovedMissionOrdersIDs() (ids []int64) {
	for id := range m.removedmission_orders {
		ids = append(ids, id)
	}
	return
}

// MissionOrdersIDs returns the "mission_orders" edge IDs in the mutation.
func (m *MissionMutation) MissionOrdersIDs() (ids []int64) {
	for id := range m.mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionOrders resets all changes to the "mission_orders" edge.
func (m *MissionMutation) ResetMissionOrders() {
	m.mission_orders = nil
	m.clearedmission_orders = false
	m.removedmission_orders = nil
}

// AddRenewalAgreementIDs adds the "renewal_agreements" edge to the RenewalAgreement entity by ids.
func (m *MissionMutation) AddRenewalAgreementIDs(ids ...int64) {
	if m.renewal_agreements == nil {
		m.renewal_agreements = make(map[int64]struct{})
	}
	for i := range ids {
		m.renewal_agreements[ids[i]] = struct{}{}
	}
}

// ClearRenewalAgreements clears the "renewal_agreements" edge to the RenewalAgreement entity.
func (m *MissionMutation) ClearRenewalAgreements() {
	m.clearedrenewal_agreements = true
}

// RenewalAgreementsCleared reports if the "renewal_agreements" edge to the RenewalAgreement entity was cleared.
func (m *MissionMutation) RenewalAgreementsCleared() bool {
	return m.clearedrenewal_agreements
}

// RemoveRenewalAgreementIDs removes the "renewal_agreements" edge to the RenewalAgreement entity by IDs.
func (m *MissionMutation) RemoveRenewalAgreementIDs(ids ...int64) {
	if m.removedrenewal_agreements == nil {
		m.removedrenewal_agreements = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.renewal_agreements, ids[i])
		m.removedrenewal_agreements[ids[i]] = struct{}{}
	}
}

// RemovedRenewalAgreements returns the removed IDs of the "renewal_agreements" edge to the RenewalAgreement entity.
func (m *MissionMutation) RemovedRenewalAgreementsIDs() (ids []int64) {
	for id := range m.removedrenewal_agreements {
		ids = append(ids, id)
	}
	return
}

// RenewalAgreementsIDs returns the "renewal_agreements" edge IDs in the mutation.
func (m *MissionMutation) RenewalAgreementsIDs() (ids []int64) {
	for id := range m.renewal_agreements {
		ids = append(ids, id)
	}
	return
}

// ResetRenewalAgreements resets all changes to the "renewal_agreements" edge.
func (m *MissionMutation) ResetRenewalAgreements() {
	m.renewal_agreements = nil
	m.clearedrenewal_agreements = false
	m.removedrenewal_agreements = nil
}

// AddMissionExtraServiceIDs adds the "mission_extra_services" edge to the MissionExtraService entity by ids.
func (m *MissionMutation) AddMissionExtraServiceIDs(ids ...int64) {
	if m.mission_extra_services == nil {
		m.mission_extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_extra_services[ids[i]] = struct{}{}
	}
}

// ClearMissionExtraServices clears the "mission_extra_services" edge to the MissionExtraService entity.
func (m *MissionMutation) ClearMissionExtraServices() {
	m.clearedmission_extra_services = true
}

// MissionExtraServicesCleared reports if the "mission_extra_services" edge to the MissionExtraService entity was cleared.
func (m *MissionMutation) MissionExtraServicesCleared() bool {
	return m.clearedmission_extra_services
}

// RemoveMissionExtraServiceIDs removes the "mission_extra_services" edge to the MissionExtraService entity by IDs.
func (m *MissionMutation) RemoveMissionExtraServiceIDs(ids ...int64) {
	if m.removedmission_extra_services == nil {
		m.removedmission_extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_extra_services, ids[i])
		m.removedmission_extra_services[ids[i]] = struct{}{}
	}
}

// RemovedMissionExtraServices returns the removed IDs of the "mission_extra_services" edge to the MissionExtraService entity.
func (m *MissionMutation) RemovedMissionExtraServicesIDs() (ids []int64) {
	for id := range m.removedmission_extra_services {
		ids = append(ids, id)
	}
	return
}

// MissionExtraServicesIDs returns the "mission_extra_services" edge IDs in the mutation.
func (m *MissionMutation) MissionExtraServicesIDs() (ids []int64) {
	for id := range m.mission_extra_services {
		ids = append(ids, id)
	}
	return
}

// ResetMissionExtraServices resets all changes to the "mission_extra_services" edge.
func (m *MissionMutation) ResetMissionExtraServices() {
	m.mission_extra_services = nil
	m.clearedmission_extra_services = false
	m.removedmission_extra_services = nil
}

// AddExtraServiceIDs adds the "extra_services" edge to the ExtraService entity by ids.
func (m *MissionMutation) AddExtraServiceIDs(ids ...int64) {
	if m.extra_services == nil {
		m.extra_services = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_services[ids[i]] = struct{}{}
	}
}

// ClearExtraServices clears the "extra_services" edge to the ExtraService entity.
func (m *MissionMutation) ClearExtraServices() {
	m.clearedextra_services = true
}

// ExtraServicesCleared reports if the "extra_services" edge to the ExtraService entity was cleared.
func (m *MissionMutation) ExtraServicesCleared() bool {
	return m.clearedextra_services
}

// RemoveExtraServiceIDs removes the "extra_services" edge to the ExtraService entity by IDs.
func (m *MissionMutation) RemoveExtraServiceIDs(ids ...int64) {
	if m.removedextra_services == nil {
		m.removedextra_services = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_services, ids[i])
		m.removedextra_services[ids[i]] = struct{}{}
	}
}

// RemovedExtraServices returns the removed IDs of the "extra_services" edge to the ExtraService entity.
func (m *MissionMutation) RemovedExtraServicesIDs() (ids []int64) {
	for id := range m.removedextra_services {
		ids = append(ids, id)
	}
	return
}

// ExtraServicesIDs returns the "extra_services" edge IDs in the mutation.
func (m *MissionMutation) ExtraServicesIDs() (ids []int64) {
	for id := range m.extra_services {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServices resets all changes to the "extra_services" edge.
func (m *MissionMutation) ResetExtraServices() {
	m.extra_services = nil
	m.clearedextra_services = false
	m.removedextra_services = nil
}

// AddExtraServiceOrderIDs adds the "extra_service_orders" edge to the ExtraServiceOrder entity by ids.
func (m *MissionMutation) AddExtraServiceOrderIDs(ids ...int64) {
	if m.extra_service_orders == nil {
		m.extra_service_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_orders[ids[i]] = struct{}{}
	}
}

// ClearExtraServiceOrders clears the "extra_service_orders" edge to the ExtraServiceOrder entity.
func (m *MissionMutation) ClearExtraServiceOrders() {
	m.clearedextra_service_orders = true
}

// ExtraServiceOrdersCleared reports if the "extra_service_orders" edge to the ExtraServiceOrder entity was cleared.
func (m *MissionMutation) ExtraServiceOrdersCleared() bool {
	return m.clearedextra_service_orders
}

// RemoveExtraServiceOrderIDs removes the "extra_service_orders" edge to the ExtraServiceOrder entity by IDs.
func (m *MissionMutation) RemoveExtraServiceOrderIDs(ids ...int64) {
	if m.removedextra_service_orders == nil {
		m.removedextra_service_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_orders, ids[i])
		m.removedextra_service_orders[ids[i]] = struct{}{}
	}
}

// RemovedExtraServiceOrders returns the removed IDs of the "extra_service_orders" edge to the ExtraServiceOrder entity.
func (m *MissionMutation) RemovedExtraServiceOrdersIDs() (ids []int64) {
	for id := range m.removedextra_service_orders {
		ids = append(ids, id)
	}
	return
}

// ExtraServiceOrdersIDs returns the "extra_service_orders" edge IDs in the mutation.
func (m *MissionMutation) ExtraServiceOrdersIDs() (ids []int64) {
	for id := range m.extra_service_orders {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServiceOrders resets all changes to the "extra_service_orders" edge.
func (m *MissionMutation) ResetExtraServiceOrders() {
	m.extra_service_orders = nil
	m.clearedextra_service_orders = false
	m.removedextra_service_orders = nil
}

// Where appends a list predicates to the MissionMutation builder.
func (m *MissionMutation) Where(ps ...predicate.Mission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mission).
func (m *MissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionMutation) Fields() []string {
	fields := make([]string, 0, 40)
	if m.created_by != nil {
		fields = append(fields, mission.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, mission.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, mission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, mission.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, mission.FieldType)
	}
	if m.mission_kind != nil {
		fields = append(fields, mission.FieldMissionKindID)
	}
	if m.body != nil {
		fields = append(fields, mission.FieldBody)
	}
	if m.call_back_url != nil {
		fields = append(fields, mission.FieldCallBackURL)
	}
	if m.call_back_info != nil {
		fields = append(fields, mission.FieldCallBackInfo)
	}
	if m.call_back_data != nil {
		fields = append(fields, mission.FieldCallBackData)
	}
	if m.status != nil {
		fields = append(fields, mission.FieldStatus)
	}
	if m.result != nil {
		fields = append(fields, mission.FieldResult)
	}
	if m.state != nil {
		fields = append(fields, mission.FieldState)
	}
	if m.result_urls != nil {
		fields = append(fields, mission.FieldResultUrls)
	}
	if m.urls != nil {
		fields = append(fields, mission.FieldUrls)
	}
	if m.key_pair != nil {
		fields = append(fields, mission.FieldKeyPairID)
	}
	if m.user != nil {
		fields = append(fields, mission.FieldUserID)
	}
	if m.mission_batch != nil {
		fields = append(fields, mission.FieldMissionBatchID)
	}
	if m.mission_batch_number != nil {
		fields = append(fields, mission.FieldMissionBatchNumber)
	}
	if m.gpu_version != nil {
		fields = append(fields, mission.FieldGpuVersion)
	}
	if m.unit_cep != nil {
		fields = append(fields, mission.FieldUnitCep)
	}
	if m.resp_status_code != nil {
		fields = append(fields, mission.FieldRespStatusCode)
	}
	if m.resp_body != nil {
		fields = append(fields, mission.FieldRespBody)
	}
	if m.inner_uri != nil {
		fields = append(fields, mission.FieldInnerURI)
	}
	if m.inner_method != nil {
		fields = append(fields, mission.FieldInnerMethod)
	}
	if m.temp_hmac_key != nil {
		fields = append(fields, mission.FieldTempHmacKey)
	}
	if m.temp_hmac_secret != nil {
		fields = append(fields, mission.FieldTempHmacSecret)
	}
	if m.second_hmac_key != nil {
		fields = append(fields, mission.FieldSecondHmacKey)
	}
	if m.username != nil {
		fields = append(fields, mission.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, mission.FieldPassword)
	}
	if m.white_device_ids != nil {
		fields = append(fields, mission.FieldWhiteDeviceIds)
	}
	if m.black_device_ids != nil {
		fields = append(fields, mission.FieldBlackDeviceIds)
	}
	if m.started_at != nil {
		fields = append(fields, mission.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, mission.FieldFinishedAt)
	}
	if m.expired_at != nil {
		fields = append(fields, mission.FieldExpiredAt)
	}
	if m.free_at != nil {
		fields = append(fields, mission.FieldFreeAt)
	}
	if m.close_way != nil {
		fields = append(fields, mission.FieldCloseWay)
	}
	if m.closed_at != nil {
		fields = append(fields, mission.FieldClosedAt)
	}
	if m.warning_times != nil {
		fields = append(fields, mission.FieldWarningTimes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mission.FieldCreatedBy:
		return m.CreatedBy()
	case mission.FieldUpdatedBy:
		return m.UpdatedBy()
	case mission.FieldCreatedAt:
		return m.CreatedAt()
	case mission.FieldUpdatedAt:
		return m.UpdatedAt()
	case mission.FieldDeletedAt:
		return m.DeletedAt()
	case mission.FieldType:
		return m.GetType()
	case mission.FieldMissionKindID:
		return m.MissionKindID()
	case mission.FieldBody:
		return m.Body()
	case mission.FieldCallBackURL:
		return m.CallBackURL()
	case mission.FieldCallBackInfo:
		return m.CallBackInfo()
	case mission.FieldCallBackData:
		return m.CallBackData()
	case mission.FieldStatus:
		return m.Status()
	case mission.FieldResult:
		return m.Result()
	case mission.FieldState:
		return m.State()
	case mission.FieldResultUrls:
		return m.ResultUrls()
	case mission.FieldUrls:
		return m.Urls()
	case mission.FieldKeyPairID:
		return m.KeyPairID()
	case mission.FieldUserID:
		return m.UserID()
	case mission.FieldMissionBatchID:
		return m.MissionBatchID()
	case mission.FieldMissionBatchNumber:
		return m.MissionBatchNumber()
	case mission.FieldGpuVersion:
		return m.GpuVersion()
	case mission.FieldUnitCep:
		return m.UnitCep()
	case mission.FieldRespStatusCode:
		return m.RespStatusCode()
	case mission.FieldRespBody:
		return m.RespBody()
	case mission.FieldInnerURI:
		return m.InnerURI()
	case mission.FieldInnerMethod:
		return m.InnerMethod()
	case mission.FieldTempHmacKey:
		return m.TempHmacKey()
	case mission.FieldTempHmacSecret:
		return m.TempHmacSecret()
	case mission.FieldSecondHmacKey:
		return m.SecondHmacKey()
	case mission.FieldUsername:
		return m.Username()
	case mission.FieldPassword:
		return m.Password()
	case mission.FieldWhiteDeviceIds:
		return m.WhiteDeviceIds()
	case mission.FieldBlackDeviceIds:
		return m.BlackDeviceIds()
	case mission.FieldStartedAt:
		return m.StartedAt()
	case mission.FieldFinishedAt:
		return m.FinishedAt()
	case mission.FieldExpiredAt:
		return m.ExpiredAt()
	case mission.FieldFreeAt:
		return m.FreeAt()
	case mission.FieldCloseWay:
		return m.CloseWay()
	case mission.FieldClosedAt:
		return m.ClosedAt()
	case mission.FieldWarningTimes:
		return m.WarningTimes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case mission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case mission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mission.FieldType:
		return m.OldType(ctx)
	case mission.FieldMissionKindID:
		return m.OldMissionKindID(ctx)
	case mission.FieldBody:
		return m.OldBody(ctx)
	case mission.FieldCallBackURL:
		return m.OldCallBackURL(ctx)
	case mission.FieldCallBackInfo:
		return m.OldCallBackInfo(ctx)
	case mission.FieldCallBackData:
		return m.OldCallBackData(ctx)
	case mission.FieldStatus:
		return m.OldStatus(ctx)
	case mission.FieldResult:
		return m.OldResult(ctx)
	case mission.FieldState:
		return m.OldState(ctx)
	case mission.FieldResultUrls:
		return m.OldResultUrls(ctx)
	case mission.FieldUrls:
		return m.OldUrls(ctx)
	case mission.FieldKeyPairID:
		return m.OldKeyPairID(ctx)
	case mission.FieldUserID:
		return m.OldUserID(ctx)
	case mission.FieldMissionBatchID:
		return m.OldMissionBatchID(ctx)
	case mission.FieldMissionBatchNumber:
		return m.OldMissionBatchNumber(ctx)
	case mission.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case mission.FieldUnitCep:
		return m.OldUnitCep(ctx)
	case mission.FieldRespStatusCode:
		return m.OldRespStatusCode(ctx)
	case mission.FieldRespBody:
		return m.OldRespBody(ctx)
	case mission.FieldInnerURI:
		return m.OldInnerURI(ctx)
	case mission.FieldInnerMethod:
		return m.OldInnerMethod(ctx)
	case mission.FieldTempHmacKey:
		return m.OldTempHmacKey(ctx)
	case mission.FieldTempHmacSecret:
		return m.OldTempHmacSecret(ctx)
	case mission.FieldSecondHmacKey:
		return m.OldSecondHmacKey(ctx)
	case mission.FieldUsername:
		return m.OldUsername(ctx)
	case mission.FieldPassword:
		return m.OldPassword(ctx)
	case mission.FieldWhiteDeviceIds:
		return m.OldWhiteDeviceIds(ctx)
	case mission.FieldBlackDeviceIds:
		return m.OldBlackDeviceIds(ctx)
	case mission.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case mission.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case mission.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case mission.FieldFreeAt:
		return m.OldFreeAt(ctx)
	case mission.FieldCloseWay:
		return m.OldCloseWay(ctx)
	case mission.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case mission.FieldWarningTimes:
		return m.OldWarningTimes(ctx)
	}
	return nil, fmt.Errorf("unknown Mission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case mission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case mission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mission.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case mission.FieldMissionKindID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionKindID(v)
		return nil
	case mission.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case mission.FieldCallBackURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallBackURL(v)
		return nil
	case mission.FieldCallBackInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallBackInfo(v)
		return nil
	case mission.FieldCallBackData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallBackData(v)
		return nil
	case mission.FieldStatus:
		v, ok := value.(enums.MissionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mission.FieldResult:
		v, ok := value.(enums.MissionResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case mission.FieldState:
		v, ok := value.(enums.MissionState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case mission.FieldResultUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultUrls(v)
		return nil
	case mission.FieldUrls:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrls(v)
		return nil
	case mission.FieldKeyPairID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPairID(v)
		return nil
	case mission.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case mission.FieldMissionBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchID(v)
		return nil
	case mission.FieldMissionBatchNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchNumber(v)
		return nil
	case mission.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case mission.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCep(v)
		return nil
	case mission.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespStatusCode(v)
		return nil
	case mission.FieldRespBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespBody(v)
		return nil
	case mission.FieldInnerURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnerURI(v)
		return nil
	case mission.FieldInnerMethod:
		v, ok := value.(enums.InnerMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnerMethod(v)
		return nil
	case mission.FieldTempHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTempHmacKey(v)
		return nil
	case mission.FieldTempHmacSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTempHmacSecret(v)
		return nil
	case mission.FieldSecondHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondHmacKey(v)
		return nil
	case mission.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case mission.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case mission.FieldWhiteDeviceIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhiteDeviceIds(v)
		return nil
	case mission.FieldBlackDeviceIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlackDeviceIds(v)
		return nil
	case mission.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case mission.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case mission.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case mission.FieldFreeAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeAt(v)
		return nil
	case mission.FieldCloseWay:
		v, ok := value.(enums.CloseWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseWay(v)
		return nil
	case mission.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case mission.FieldWarningTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarningTimes(v)
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, mission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, mission.FieldUpdatedBy)
	}
	if m.addunit_cep != nil {
		fields = append(fields, mission.FieldUnitCep)
	}
	if m.addresp_status_code != nil {
		fields = append(fields, mission.FieldRespStatusCode)
	}
	if m.addwarning_times != nil {
		fields = append(fields, mission.FieldWarningTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case mission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case mission.FieldUnitCep:
		return m.AddedUnitCep()
	case mission.FieldRespStatusCode:
		return m.AddedRespStatusCode()
	case mission.FieldWarningTimes:
		return m.AddedWarningTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case mission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case mission.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCep(v)
		return nil
	case mission.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRespStatusCode(v)
		return nil
	case mission.FieldWarningTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarningTimes(v)
		return nil
	}
	return fmt.Errorf("unknown Mission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mission.FieldCallBackInfo) {
		fields = append(fields, mission.FieldCallBackInfo)
	}
	if m.FieldCleared(mission.FieldCallBackData) {
		fields = append(fields, mission.FieldCallBackData)
	}
	if m.FieldCleared(mission.FieldResultUrls) {
		fields = append(fields, mission.FieldResultUrls)
	}
	if m.FieldCleared(mission.FieldWhiteDeviceIds) {
		fields = append(fields, mission.FieldWhiteDeviceIds)
	}
	if m.FieldCleared(mission.FieldBlackDeviceIds) {
		fields = append(fields, mission.FieldBlackDeviceIds)
	}
	if m.FieldCleared(mission.FieldStartedAt) {
		fields = append(fields, mission.FieldStartedAt)
	}
	if m.FieldCleared(mission.FieldFinishedAt) {
		fields = append(fields, mission.FieldFinishedAt)
	}
	if m.FieldCleared(mission.FieldExpiredAt) {
		fields = append(fields, mission.FieldExpiredAt)
	}
	if m.FieldCleared(mission.FieldClosedAt) {
		fields = append(fields, mission.FieldClosedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionMutation) ClearField(name string) error {
	switch name {
	case mission.FieldCallBackInfo:
		m.ClearCallBackInfo()
		return nil
	case mission.FieldCallBackData:
		m.ClearCallBackData()
		return nil
	case mission.FieldResultUrls:
		m.ClearResultUrls()
		return nil
	case mission.FieldWhiteDeviceIds:
		m.ClearWhiteDeviceIds()
		return nil
	case mission.FieldBlackDeviceIds:
		m.ClearBlackDeviceIds()
		return nil
	case mission.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case mission.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case mission.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	case mission.FieldClosedAt:
		m.ClearClosedAt()
		return nil
	}
	return fmt.Errorf("unknown Mission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionMutation) ResetField(name string) error {
	switch name {
	case mission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case mission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case mission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mission.FieldType:
		m.ResetType()
		return nil
	case mission.FieldMissionKindID:
		m.ResetMissionKindID()
		return nil
	case mission.FieldBody:
		m.ResetBody()
		return nil
	case mission.FieldCallBackURL:
		m.ResetCallBackURL()
		return nil
	case mission.FieldCallBackInfo:
		m.ResetCallBackInfo()
		return nil
	case mission.FieldCallBackData:
		m.ResetCallBackData()
		return nil
	case mission.FieldStatus:
		m.ResetStatus()
		return nil
	case mission.FieldResult:
		m.ResetResult()
		return nil
	case mission.FieldState:
		m.ResetState()
		return nil
	case mission.FieldResultUrls:
		m.ResetResultUrls()
		return nil
	case mission.FieldUrls:
		m.ResetUrls()
		return nil
	case mission.FieldKeyPairID:
		m.ResetKeyPairID()
		return nil
	case mission.FieldUserID:
		m.ResetUserID()
		return nil
	case mission.FieldMissionBatchID:
		m.ResetMissionBatchID()
		return nil
	case mission.FieldMissionBatchNumber:
		m.ResetMissionBatchNumber()
		return nil
	case mission.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case mission.FieldUnitCep:
		m.ResetUnitCep()
		return nil
	case mission.FieldRespStatusCode:
		m.ResetRespStatusCode()
		return nil
	case mission.FieldRespBody:
		m.ResetRespBody()
		return nil
	case mission.FieldInnerURI:
		m.ResetInnerURI()
		return nil
	case mission.FieldInnerMethod:
		m.ResetInnerMethod()
		return nil
	case mission.FieldTempHmacKey:
		m.ResetTempHmacKey()
		return nil
	case mission.FieldTempHmacSecret:
		m.ResetTempHmacSecret()
		return nil
	case mission.FieldSecondHmacKey:
		m.ResetSecondHmacKey()
		return nil
	case mission.FieldUsername:
		m.ResetUsername()
		return nil
	case mission.FieldPassword:
		m.ResetPassword()
		return nil
	case mission.FieldWhiteDeviceIds:
		m.ResetWhiteDeviceIds()
		return nil
	case mission.FieldBlackDeviceIds:
		m.ResetBlackDeviceIds()
		return nil
	case mission.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case mission.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case mission.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case mission.FieldFreeAt:
		m.ResetFreeAt()
		return nil
	case mission.FieldCloseWay:
		m.ResetCloseWay()
		return nil
	case mission.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case mission.FieldWarningTimes:
		m.ResetWarningTimes()
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.mission_kind != nil {
		edges = append(edges, mission.EdgeMissionKind)
	}
	if m.user != nil {
		edges = append(edges, mission.EdgeUser)
	}
	if m.mission_key_pairs != nil {
		edges = append(edges, mission.EdgeMissionKeyPairs)
	}
	if m.key_pair != nil {
		edges = append(edges, mission.EdgeKeyPair)
	}
	if m.mission_consume_order != nil {
		edges = append(edges, mission.EdgeMissionConsumeOrder)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, mission.EdgeMissionProduceOrders)
	}
	if m.mission_batch != nil {
		edges = append(edges, mission.EdgeMissionBatch)
	}
	if m.mission_productions != nil {
		edges = append(edges, mission.EdgeMissionProductions)
	}
	if m.mission_orders != nil {
		edges = append(edges, mission.EdgeMissionOrders)
	}
	if m.renewal_agreements != nil {
		edges = append(edges, mission.EdgeRenewalAgreements)
	}
	if m.mission_extra_services != nil {
		edges = append(edges, mission.EdgeMissionExtraServices)
	}
	if m.extra_services != nil {
		edges = append(edges, mission.EdgeExtraServices)
	}
	if m.extra_service_orders != nil {
		edges = append(edges, mission.EdgeExtraServiceOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeMissionKind:
		if id := m.mission_kind; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.mission_key_pairs))
		for id := range m.mission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeKeyPair:
		if id := m.key_pair; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeMissionConsumeOrder:
		if id := m.mission_consume_order; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionBatch:
		if id := m.mission_batch; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.mission_productions))
		for id := range m.mission_productions {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.mission_orders))
		for id := range m.mission_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeRenewalAgreements:
		ids := make([]ent.Value, 0, len(m.renewal_agreements))
		for id := range m.renewal_agreements {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionExtraServices:
		ids := make([]ent.Value, 0, len(m.mission_extra_services))
		for id := range m.mission_extra_services {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeExtraServices:
		ids := make([]ent.Value, 0, len(m.extra_services))
		for id := range m.extra_services {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeExtraServiceOrders:
		ids := make([]ent.Value, 0, len(m.extra_service_orders))
		for id := range m.extra_service_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedmission_key_pairs != nil {
		edges = append(edges, mission.EdgeMissionKeyPairs)
	}
	if m.removedmission_produce_orders != nil {
		edges = append(edges, mission.EdgeMissionProduceOrders)
	}
	if m.removedmission_productions != nil {
		edges = append(edges, mission.EdgeMissionProductions)
	}
	if m.removedmission_orders != nil {
		edges = append(edges, mission.EdgeMissionOrders)
	}
	if m.removedrenewal_agreements != nil {
		edges = append(edges, mission.EdgeRenewalAgreements)
	}
	if m.removedmission_extra_services != nil {
		edges = append(edges, mission.EdgeMissionExtraServices)
	}
	if m.removedextra_services != nil {
		edges = append(edges, mission.EdgeExtraServices)
	}
	if m.removedextra_service_orders != nil {
		edges = append(edges, mission.EdgeExtraServiceOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.removedmission_key_pairs))
		for id := range m.removedmission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.removedmission_productions))
		for id := range m.removedmission_productions {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_orders))
		for id := range m.removedmission_orders {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeRenewalAgreements:
		ids := make([]ent.Value, 0, len(m.removedrenewal_agreements))
		for id := range m.removedrenewal_agreements {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeMissionExtraServices:
		ids := make([]ent.Value, 0, len(m.removedmission_extra_services))
		for id := range m.removedmission_extra_services {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeExtraServices:
		ids := make([]ent.Value, 0, len(m.removedextra_services))
		for id := range m.removedextra_services {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeExtraServiceOrders:
		ids := make([]ent.Value, 0, len(m.removedextra_service_orders))
		for id := range m.removedextra_service_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedmission_kind {
		edges = append(edges, mission.EdgeMissionKind)
	}
	if m.cleareduser {
		edges = append(edges, mission.EdgeUser)
	}
	if m.clearedmission_key_pairs {
		edges = append(edges, mission.EdgeMissionKeyPairs)
	}
	if m.clearedkey_pair {
		edges = append(edges, mission.EdgeKeyPair)
	}
	if m.clearedmission_consume_order {
		edges = append(edges, mission.EdgeMissionConsumeOrder)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, mission.EdgeMissionProduceOrders)
	}
	if m.clearedmission_batch {
		edges = append(edges, mission.EdgeMissionBatch)
	}
	if m.clearedmission_productions {
		edges = append(edges, mission.EdgeMissionProductions)
	}
	if m.clearedmission_orders {
		edges = append(edges, mission.EdgeMissionOrders)
	}
	if m.clearedrenewal_agreements {
		edges = append(edges, mission.EdgeRenewalAgreements)
	}
	if m.clearedmission_extra_services {
		edges = append(edges, mission.EdgeMissionExtraServices)
	}
	if m.clearedextra_services {
		edges = append(edges, mission.EdgeExtraServices)
	}
	if m.clearedextra_service_orders {
		edges = append(edges, mission.EdgeExtraServiceOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionMutation) EdgeCleared(name string) bool {
	switch name {
	case mission.EdgeMissionKind:
		return m.clearedmission_kind
	case mission.EdgeUser:
		return m.cleareduser
	case mission.EdgeMissionKeyPairs:
		return m.clearedmission_key_pairs
	case mission.EdgeKeyPair:
		return m.clearedkey_pair
	case mission.EdgeMissionConsumeOrder:
		return m.clearedmission_consume_order
	case mission.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case mission.EdgeMissionBatch:
		return m.clearedmission_batch
	case mission.EdgeMissionProductions:
		return m.clearedmission_productions
	case mission.EdgeMissionOrders:
		return m.clearedmission_orders
	case mission.EdgeRenewalAgreements:
		return m.clearedrenewal_agreements
	case mission.EdgeMissionExtraServices:
		return m.clearedmission_extra_services
	case mission.EdgeExtraServices:
		return m.clearedextra_services
	case mission.EdgeExtraServiceOrders:
		return m.clearedextra_service_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionMutation) ClearEdge(name string) error {
	switch name {
	case mission.EdgeMissionKind:
		m.ClearMissionKind()
		return nil
	case mission.EdgeUser:
		m.ClearUser()
		return nil
	case mission.EdgeKeyPair:
		m.ClearKeyPair()
		return nil
	case mission.EdgeMissionConsumeOrder:
		m.ClearMissionConsumeOrder()
		return nil
	case mission.EdgeMissionBatch:
		m.ClearMissionBatch()
		return nil
	}
	return fmt.Errorf("unknown Mission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionMutation) ResetEdge(name string) error {
	switch name {
	case mission.EdgeMissionKind:
		m.ResetMissionKind()
		return nil
	case mission.EdgeUser:
		m.ResetUser()
		return nil
	case mission.EdgeMissionKeyPairs:
		m.ResetMissionKeyPairs()
		return nil
	case mission.EdgeKeyPair:
		m.ResetKeyPair()
		return nil
	case mission.EdgeMissionConsumeOrder:
		m.ResetMissionConsumeOrder()
		return nil
	case mission.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case mission.EdgeMissionBatch:
		m.ResetMissionBatch()
		return nil
	case mission.EdgeMissionProductions:
		m.ResetMissionProductions()
		return nil
	case mission.EdgeMissionOrders:
		m.ResetMissionOrders()
		return nil
	case mission.EdgeRenewalAgreements:
		m.ResetRenewalAgreements()
		return nil
	case mission.EdgeMissionExtraServices:
		m.ResetMissionExtraServices()
		return nil
	case mission.EdgeExtraServices:
		m.ResetExtraServices()
		return nil
	case mission.EdgeExtraServiceOrders:
		m.ResetExtraServiceOrders()
		return nil
	}
	return fmt.Errorf("unknown Mission edge %s", name)
}

// MissionBatchMutation represents an operation that mutates the MissionBatch nodes in the graph.
type MissionBatchMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	number                        *string
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	mission_consume_orders        map[int64]struct{}
	removedmission_consume_orders map[int64]struct{}
	clearedmission_consume_orders bool
	missions                      map[int64]struct{}
	removedmissions               map[int64]struct{}
	clearedmissions               bool
	mission_orders                map[int64]struct{}
	removedmission_orders         map[int64]struct{}
	clearedmission_orders         bool
	extra_service_order           map[int64]struct{}
	removedextra_service_order    map[int64]struct{}
	clearedextra_service_order    bool
	done                          bool
	oldValue                      func(context.Context) (*MissionBatch, error)
	predicates                    []predicate.MissionBatch
}

var _ ent.Mutation = (*MissionBatchMutation)(nil)

// missionbatchOption allows management of the mutation configuration using functional options.
type missionbatchOption func(*MissionBatchMutation)

// newMissionBatchMutation creates new mutation for the MissionBatch entity.
func newMissionBatchMutation(c config, op Op, opts ...missionbatchOption) *MissionBatchMutation {
	m := &MissionBatchMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionBatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionBatchID sets the ID field of the mutation.
func withMissionBatchID(id int64) missionbatchOption {
	return func(m *MissionBatchMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionBatch
		)
		m.oldValue = func(ctx context.Context) (*MissionBatch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionBatch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionBatch sets the old MissionBatch of the mutation.
func withMissionBatch(node *MissionBatch) missionbatchOption {
	return func(m *MissionBatchMutation) {
		m.oldValue = func(context.Context) (*MissionBatch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionBatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionBatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionBatch entities.
func (m *MissionBatchMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionBatchMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionBatchMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionBatch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionBatchMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionBatchMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionBatchMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionBatchMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionBatchMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionBatchMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionBatchMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionBatchMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionBatchMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionBatchMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionBatchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionBatchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionBatchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionBatchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionBatchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionBatchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionBatchMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionBatchMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionBatchMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetNumber sets the "number" field.
func (m *MissionBatchMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *MissionBatchMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *MissionBatchMutation) ResetNumber() {
	m.number = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionBatchMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionBatchMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionBatchMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionBatchMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionbatch.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionBatchMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionBatchMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionBatchMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMissionConsumeOrderIDs adds the "mission_consume_orders" edge to the MissionConsumeOrder entity by ids.
func (m *MissionBatchMutation) AddMissionConsumeOrderIDs(ids ...int64) {
	if m.mission_consume_orders == nil {
		m.mission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_consume_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionConsumeOrders clears the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *MissionBatchMutation) ClearMissionConsumeOrders() {
	m.clearedmission_consume_orders = true
}

// MissionConsumeOrdersCleared reports if the "mission_consume_orders" edge to the MissionConsumeOrder entity was cleared.
func (m *MissionBatchMutation) MissionConsumeOrdersCleared() bool {
	return m.clearedmission_consume_orders
}

// RemoveMissionConsumeOrderIDs removes the "mission_consume_orders" edge to the MissionConsumeOrder entity by IDs.
func (m *MissionBatchMutation) RemoveMissionConsumeOrderIDs(ids ...int64) {
	if m.removedmission_consume_orders == nil {
		m.removedmission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_consume_orders, ids[i])
		m.removedmission_consume_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionConsumeOrders returns the removed IDs of the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *MissionBatchMutation) RemovedMissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.removedmission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// MissionConsumeOrdersIDs returns the "mission_consume_orders" edge IDs in the mutation.
func (m *MissionBatchMutation) MissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.mission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionConsumeOrders resets all changes to the "mission_consume_orders" edge.
func (m *MissionBatchMutation) ResetMissionConsumeOrders() {
	m.mission_consume_orders = nil
	m.clearedmission_consume_orders = false
	m.removedmission_consume_orders = nil
}

// AddMissionIDs adds the "missions" edge to the Mission entity by ids.
func (m *MissionBatchMutation) AddMissionIDs(ids ...int64) {
	if m.missions == nil {
		m.missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.missions[ids[i]] = struct{}{}
	}
}

// ClearMissions clears the "missions" edge to the Mission entity.
func (m *MissionBatchMutation) ClearMissions() {
	m.clearedmissions = true
}

// MissionsCleared reports if the "missions" edge to the Mission entity was cleared.
func (m *MissionBatchMutation) MissionsCleared() bool {
	return m.clearedmissions
}

// RemoveMissionIDs removes the "missions" edge to the Mission entity by IDs.
func (m *MissionBatchMutation) RemoveMissionIDs(ids ...int64) {
	if m.removedmissions == nil {
		m.removedmissions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.missions, ids[i])
		m.removedmissions[ids[i]] = struct{}{}
	}
}

// RemovedMissions returns the removed IDs of the "missions" edge to the Mission entity.
func (m *MissionBatchMutation) RemovedMissionsIDs() (ids []int64) {
	for id := range m.removedmissions {
		ids = append(ids, id)
	}
	return
}

// MissionsIDs returns the "missions" edge IDs in the mutation.
func (m *MissionBatchMutation) MissionsIDs() (ids []int64) {
	for id := range m.missions {
		ids = append(ids, id)
	}
	return
}

// ResetMissions resets all changes to the "missions" edge.
func (m *MissionBatchMutation) ResetMissions() {
	m.missions = nil
	m.clearedmissions = false
	m.removedmissions = nil
}

// AddMissionOrderIDs adds the "mission_orders" edge to the MissionOrder entity by ids.
func (m *MissionBatchMutation) AddMissionOrderIDs(ids ...int64) {
	if m.mission_orders == nil {
		m.mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionOrders clears the "mission_orders" edge to the MissionOrder entity.
func (m *MissionBatchMutation) ClearMissionOrders() {
	m.clearedmission_orders = true
}

// MissionOrdersCleared reports if the "mission_orders" edge to the MissionOrder entity was cleared.
func (m *MissionBatchMutation) MissionOrdersCleared() bool {
	return m.clearedmission_orders
}

// RemoveMissionOrderIDs removes the "mission_orders" edge to the MissionOrder entity by IDs.
func (m *MissionBatchMutation) RemoveMissionOrderIDs(ids ...int64) {
	if m.removedmission_orders == nil {
		m.removedmission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_orders, ids[i])
		m.removedmission_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionOrders returns the removed IDs of the "mission_orders" edge to the MissionOrder entity.
func (m *MissionBatchMutation) RemovedMissionOrdersIDs() (ids []int64) {
	for id := range m.removedmission_orders {
		ids = append(ids, id)
	}
	return
}

// MissionOrdersIDs returns the "mission_orders" edge IDs in the mutation.
func (m *MissionBatchMutation) MissionOrdersIDs() (ids []int64) {
	for id := range m.mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionOrders resets all changes to the "mission_orders" edge.
func (m *MissionBatchMutation) ResetMissionOrders() {
	m.mission_orders = nil
	m.clearedmission_orders = false
	m.removedmission_orders = nil
}

// AddExtraServiceOrderIDs adds the "extra_service_order" edge to the ExtraServiceOrder entity by ids.
func (m *MissionBatchMutation) AddExtraServiceOrderIDs(ids ...int64) {
	if m.extra_service_order == nil {
		m.extra_service_order = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_order[ids[i]] = struct{}{}
	}
}

// ClearExtraServiceOrder clears the "extra_service_order" edge to the ExtraServiceOrder entity.
func (m *MissionBatchMutation) ClearExtraServiceOrder() {
	m.clearedextra_service_order = true
}

// ExtraServiceOrderCleared reports if the "extra_service_order" edge to the ExtraServiceOrder entity was cleared.
func (m *MissionBatchMutation) ExtraServiceOrderCleared() bool {
	return m.clearedextra_service_order
}

// RemoveExtraServiceOrderIDs removes the "extra_service_order" edge to the ExtraServiceOrder entity by IDs.
func (m *MissionBatchMutation) RemoveExtraServiceOrderIDs(ids ...int64) {
	if m.removedextra_service_order == nil {
		m.removedextra_service_order = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_order, ids[i])
		m.removedextra_service_order[ids[i]] = struct{}{}
	}
}

// RemovedExtraServiceOrder returns the removed IDs of the "extra_service_order" edge to the ExtraServiceOrder entity.
func (m *MissionBatchMutation) RemovedExtraServiceOrderIDs() (ids []int64) {
	for id := range m.removedextra_service_order {
		ids = append(ids, id)
	}
	return
}

// ExtraServiceOrderIDs returns the "extra_service_order" edge IDs in the mutation.
func (m *MissionBatchMutation) ExtraServiceOrderIDs() (ids []int64) {
	for id := range m.extra_service_order {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServiceOrder resets all changes to the "extra_service_order" edge.
func (m *MissionBatchMutation) ResetExtraServiceOrder() {
	m.extra_service_order = nil
	m.clearedextra_service_order = false
	m.removedextra_service_order = nil
}

// Where appends a list predicates to the MissionBatchMutation builder.
func (m *MissionBatchMutation) Where(ps ...predicate.MissionBatch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionBatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionBatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionBatch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionBatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionBatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionBatch).
func (m *MissionBatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionBatchMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, missionbatch.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionbatch.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionbatch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionbatch.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionbatch.FieldDeletedAt)
	}
	if m.number != nil {
		fields = append(fields, missionbatch.FieldNumber)
	}
	if m.user != nil {
		fields = append(fields, missionbatch.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionBatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionbatch.FieldCreatedBy:
		return m.CreatedBy()
	case missionbatch.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionbatch.FieldCreatedAt:
		return m.CreatedAt()
	case missionbatch.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionbatch.FieldDeletedAt:
		return m.DeletedAt()
	case missionbatch.FieldNumber:
		return m.Number()
	case missionbatch.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionBatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionbatch.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionbatch.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionbatch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionbatch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionbatch.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionbatch.FieldNumber:
		return m.OldNumber(ctx)
	case missionbatch.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown MissionBatch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionBatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionbatch.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionbatch.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionbatch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionbatch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionbatch.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionbatch.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case missionbatch.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionBatch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionBatchMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionbatch.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionbatch.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionBatchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionbatch.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionbatch.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionBatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionbatch.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionbatch.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MissionBatch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionBatchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionBatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionBatchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionBatch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionBatchMutation) ResetField(name string) error {
	switch name {
	case missionbatch.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionbatch.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionbatch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionbatch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionbatch.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionbatch.FieldNumber:
		m.ResetNumber()
		return nil
	case missionbatch.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown MissionBatch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionBatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, missionbatch.EdgeUser)
	}
	if m.mission_consume_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionConsumeOrders)
	}
	if m.missions != nil {
		edges = append(edges, missionbatch.EdgeMissions)
	}
	if m.mission_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionOrders)
	}
	if m.extra_service_order != nil {
		edges = append(edges, missionbatch.EdgeExtraServiceOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionBatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionbatch.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionbatch.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.mission_consume_orders))
		for id := range m.mission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.missions))
		for id := range m.missions {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.mission_orders))
		for id := range m.mission_orders {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeExtraServiceOrder:
		ids := make([]ent.Value, 0, len(m.extra_service_order))
		for id := range m.extra_service_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionBatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmission_consume_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionConsumeOrders)
	}
	if m.removedmissions != nil {
		edges = append(edges, missionbatch.EdgeMissions)
	}
	if m.removedmission_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionOrders)
	}
	if m.removedextra_service_order != nil {
		edges = append(edges, missionbatch.EdgeExtraServiceOrder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionBatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionbatch.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_consume_orders))
		for id := range m.removedmission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.removedmissions))
		for id := range m.removedmissions {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_orders))
		for id := range m.removedmission_orders {
			ids = append(ids, id)
		}
		return ids
	case missionbatch.EdgeExtraServiceOrder:
		ids := make([]ent.Value, 0, len(m.removedextra_service_order))
		for id := range m.removedextra_service_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionBatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, missionbatch.EdgeUser)
	}
	if m.clearedmission_consume_orders {
		edges = append(edges, missionbatch.EdgeMissionConsumeOrders)
	}
	if m.clearedmissions {
		edges = append(edges, missionbatch.EdgeMissions)
	}
	if m.clearedmission_orders {
		edges = append(edges, missionbatch.EdgeMissionOrders)
	}
	if m.clearedextra_service_order {
		edges = append(edges, missionbatch.EdgeExtraServiceOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionBatchMutation) EdgeCleared(name string) bool {
	switch name {
	case missionbatch.EdgeUser:
		return m.cleareduser
	case missionbatch.EdgeMissionConsumeOrders:
		return m.clearedmission_consume_orders
	case missionbatch.EdgeMissions:
		return m.clearedmissions
	case missionbatch.EdgeMissionOrders:
		return m.clearedmission_orders
	case missionbatch.EdgeExtraServiceOrder:
		return m.clearedextra_service_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionBatchMutation) ClearEdge(name string) error {
	switch name {
	case missionbatch.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown MissionBatch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionBatchMutation) ResetEdge(name string) error {
	switch name {
	case missionbatch.EdgeUser:
		m.ResetUser()
		return nil
	case missionbatch.EdgeMissionConsumeOrders:
		m.ResetMissionConsumeOrders()
		return nil
	case missionbatch.EdgeMissions:
		m.ResetMissions()
		return nil
	case missionbatch.EdgeMissionOrders:
		m.ResetMissionOrders()
		return nil
	case missionbatch.EdgeExtraServiceOrder:
		m.ResetExtraServiceOrder()
		return nil
	}
	return fmt.Errorf("unknown MissionBatch edge %s", name)
}

// MissionConsumeOrderMutation represents an operation that mutates the MissionConsumeOrder nodes in the graph.
type MissionConsumeOrderMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	status                        *enums.MissionOrderStatus
	pure_cep                      *int64
	addpure_cep                   *int64
	gift_cep                      *int64
	addgift_cep                   *int64
	_type                         *enums.MissionType
	is_time                       *bool
	call_way                      *enums.MissionCallWay
	serial_number                 *string
	started_at                    *time.Time
	finished_at                   *time.Time
	mission_batch_number          *string
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	cost_bills                    map[int64]struct{}
	removedcost_bills             map[int64]struct{}
	clearedcost_bills             bool
	mission_produce_orders        map[int64]struct{}
	removedmission_produce_orders map[int64]struct{}
	clearedmission_produce_orders bool
	mission_batch                 *int64
	clearedmission_batch          bool
	mission                       *int64
	clearedmission                bool
	done                          bool
	oldValue                      func(context.Context) (*MissionConsumeOrder, error)
	predicates                    []predicate.MissionConsumeOrder
}

var _ ent.Mutation = (*MissionConsumeOrderMutation)(nil)

// missionconsumeorderOption allows management of the mutation configuration using functional options.
type missionconsumeorderOption func(*MissionConsumeOrderMutation)

// newMissionConsumeOrderMutation creates new mutation for the MissionConsumeOrder entity.
func newMissionConsumeOrderMutation(c config, op Op, opts ...missionconsumeorderOption) *MissionConsumeOrderMutation {
	m := &MissionConsumeOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionConsumeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionConsumeOrderID sets the ID field of the mutation.
func withMissionConsumeOrderID(id int64) missionconsumeorderOption {
	return func(m *MissionConsumeOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionConsumeOrder
		)
		m.oldValue = func(ctx context.Context) (*MissionConsumeOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionConsumeOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionConsumeOrder sets the old MissionConsumeOrder of the mutation.
func withMissionConsumeOrder(node *MissionConsumeOrder) missionconsumeorderOption {
	return func(m *MissionConsumeOrderMutation) {
		m.oldValue = func(context.Context) (*MissionConsumeOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionConsumeOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionConsumeOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionConsumeOrder entities.
func (m *MissionConsumeOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionConsumeOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionConsumeOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionConsumeOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionConsumeOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionConsumeOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionConsumeOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionConsumeOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionConsumeOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionConsumeOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionConsumeOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionConsumeOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionConsumeOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionConsumeOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionConsumeOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionConsumeOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionConsumeOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionConsumeOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionConsumeOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionConsumeOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionConsumeOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionConsumeOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionConsumeOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionConsumeOrderMutation) ResetUserID() {
	m.user = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionConsumeOrderMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionConsumeOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionConsumeOrderMutation) ResetMissionID() {
	m.mission = nil
}

// SetStatus sets the "status" field.
func (m *MissionConsumeOrderMutation) SetStatus(eos enums.MissionOrderStatus) {
	m.status = &eos
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionConsumeOrderMutation) Status() (r enums.MissionOrderStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldStatus(ctx context.Context) (v enums.MissionOrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionConsumeOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *MissionConsumeOrderMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *MissionConsumeOrderMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *MissionConsumeOrderMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *MissionConsumeOrderMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *MissionConsumeOrderMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *MissionConsumeOrderMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *MissionConsumeOrderMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *MissionConsumeOrderMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetType sets the "type" field.
func (m *MissionConsumeOrderMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionConsumeOrderMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionConsumeOrderMutation) ResetType() {
	m._type = nil
}

// SetIsTime sets the "is_time" field.
func (m *MissionConsumeOrderMutation) SetIsTime(b bool) {
	m.is_time = &b
}

// IsTime returns the value of the "is_time" field in the mutation.
func (m *MissionConsumeOrderMutation) IsTime() (r bool, exists bool) {
	v := m.is_time
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTime returns the old "is_time" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldIsTime(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTime: %w", err)
	}
	return oldValue.IsTime, nil
}

// ResetIsTime resets all changes to the "is_time" field.
func (m *MissionConsumeOrderMutation) ResetIsTime() {
	m.is_time = nil
}

// SetCallWay sets the "call_way" field.
func (m *MissionConsumeOrderMutation) SetCallWay(ecw enums.MissionCallWay) {
	m.call_way = &ecw
}

// CallWay returns the value of the "call_way" field in the mutation.
func (m *MissionConsumeOrderMutation) CallWay() (r enums.MissionCallWay, exists bool) {
	v := m.call_way
	if v == nil {
		return
	}
	return *v, true
}

// OldCallWay returns the old "call_way" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldCallWay(ctx context.Context) (v enums.MissionCallWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallWay: %w", err)
	}
	return oldValue.CallWay, nil
}

// ResetCallWay resets all changes to the "call_way" field.
func (m *MissionConsumeOrderMutation) ResetCallWay() {
	m.call_way = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *MissionConsumeOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MissionConsumeOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MissionConsumeOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionConsumeOrderMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionConsumeOrderMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionConsumeOrderMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionConsumeOrderMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionConsumeOrderMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionConsumeOrderMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetMissionBatchID sets the "mission_batch_id" field.
func (m *MissionConsumeOrderMutation) SetMissionBatchID(i int64) {
	m.mission_batch = &i
}

// MissionBatchID returns the value of the "mission_batch_id" field in the mutation.
func (m *MissionConsumeOrderMutation) MissionBatchID() (r int64, exists bool) {
	v := m.mission_batch
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchID returns the old "mission_batch_id" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldMissionBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchID: %w", err)
	}
	return oldValue.MissionBatchID, nil
}

// ResetMissionBatchID resets all changes to the "mission_batch_id" field.
func (m *MissionConsumeOrderMutation) ResetMissionBatchID() {
	m.mission_batch = nil
}

// SetMissionBatchNumber sets the "mission_batch_number" field.
func (m *MissionConsumeOrderMutation) SetMissionBatchNumber(s string) {
	m.mission_batch_number = &s
}

// MissionBatchNumber returns the value of the "mission_batch_number" field in the mutation.
func (m *MissionConsumeOrderMutation) MissionBatchNumber() (r string, exists bool) {
	v := m.mission_batch_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchNumber returns the old "mission_batch_number" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldMissionBatchNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchNumber: %w", err)
	}
	return oldValue.MissionBatchNumber, nil
}

// ResetMissionBatchNumber resets all changes to the "mission_batch_number" field.
func (m *MissionConsumeOrderMutation) ResetMissionBatchNumber() {
	m.mission_batch_number = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionConsumeOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionconsumeorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionConsumeOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionConsumeOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionConsumeOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *MissionConsumeOrderMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *MissionConsumeOrderMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *MissionConsumeOrderMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *MissionConsumeOrderMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *MissionConsumeOrderMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *MissionConsumeOrderMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *MissionConsumeOrderMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *MissionConsumeOrderMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionConsumeOrderMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *MissionConsumeOrderMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *MissionConsumeOrderMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionConsumeOrderMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *MissionConsumeOrderMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *MissionConsumeOrderMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// ClearMissionBatch clears the "mission_batch" edge to the MissionBatch entity.
func (m *MissionConsumeOrderMutation) ClearMissionBatch() {
	m.clearedmission_batch = true
	m.clearedFields[missionconsumeorder.FieldMissionBatchID] = struct{}{}
}

// MissionBatchCleared reports if the "mission_batch" edge to the MissionBatch entity was cleared.
func (m *MissionConsumeOrderMutation) MissionBatchCleared() bool {
	return m.clearedmission_batch
}

// MissionBatchIDs returns the "mission_batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionBatchID instead. It exists only for internal usage by the builders.
func (m *MissionConsumeOrderMutation) MissionBatchIDs() (ids []int64) {
	if id := m.mission_batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionBatch resets all changes to the "mission_batch" edge.
func (m *MissionConsumeOrderMutation) ResetMissionBatch() {
	m.mission_batch = nil
	m.clearedmission_batch = false
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionConsumeOrderMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionconsumeorder.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionConsumeOrderMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionConsumeOrderMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionConsumeOrderMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// Where appends a list predicates to the MissionConsumeOrderMutation builder.
func (m *MissionConsumeOrderMutation) Where(ps ...predicate.MissionConsumeOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionConsumeOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionConsumeOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionConsumeOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionConsumeOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionConsumeOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionConsumeOrder).
func (m *MissionConsumeOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionConsumeOrderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_by != nil {
		fields = append(fields, missionconsumeorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionconsumeorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionconsumeorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionconsumeorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionconsumeorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, missionconsumeorder.FieldUserID)
	}
	if m.mission != nil {
		fields = append(fields, missionconsumeorder.FieldMissionID)
	}
	if m.status != nil {
		fields = append(fields, missionconsumeorder.FieldStatus)
	}
	if m.pure_cep != nil {
		fields = append(fields, missionconsumeorder.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, missionconsumeorder.FieldGiftCep)
	}
	if m._type != nil {
		fields = append(fields, missionconsumeorder.FieldType)
	}
	if m.is_time != nil {
		fields = append(fields, missionconsumeorder.FieldIsTime)
	}
	if m.call_way != nil {
		fields = append(fields, missionconsumeorder.FieldCallWay)
	}
	if m.serial_number != nil {
		fields = append(fields, missionconsumeorder.FieldSerialNumber)
	}
	if m.started_at != nil {
		fields = append(fields, missionconsumeorder.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionconsumeorder.FieldFinishedAt)
	}
	if m.mission_batch != nil {
		fields = append(fields, missionconsumeorder.FieldMissionBatchID)
	}
	if m.mission_batch_number != nil {
		fields = append(fields, missionconsumeorder.FieldMissionBatchNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionConsumeOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		return m.CreatedBy()
	case missionconsumeorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionconsumeorder.FieldCreatedAt:
		return m.CreatedAt()
	case missionconsumeorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionconsumeorder.FieldDeletedAt:
		return m.DeletedAt()
	case missionconsumeorder.FieldUserID:
		return m.UserID()
	case missionconsumeorder.FieldMissionID:
		return m.MissionID()
	case missionconsumeorder.FieldStatus:
		return m.Status()
	case missionconsumeorder.FieldPureCep:
		return m.PureCep()
	case missionconsumeorder.FieldGiftCep:
		return m.GiftCep()
	case missionconsumeorder.FieldType:
		return m.GetType()
	case missionconsumeorder.FieldIsTime:
		return m.IsTime()
	case missionconsumeorder.FieldCallWay:
		return m.CallWay()
	case missionconsumeorder.FieldSerialNumber:
		return m.SerialNumber()
	case missionconsumeorder.FieldStartedAt:
		return m.StartedAt()
	case missionconsumeorder.FieldFinishedAt:
		return m.FinishedAt()
	case missionconsumeorder.FieldMissionBatchID:
		return m.MissionBatchID()
	case missionconsumeorder.FieldMissionBatchNumber:
		return m.MissionBatchNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionConsumeOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionconsumeorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionconsumeorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionconsumeorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionconsumeorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionconsumeorder.FieldUserID:
		return m.OldUserID(ctx)
	case missionconsumeorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionconsumeorder.FieldStatus:
		return m.OldStatus(ctx)
	case missionconsumeorder.FieldPureCep:
		return m.OldPureCep(ctx)
	case missionconsumeorder.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case missionconsumeorder.FieldType:
		return m.OldType(ctx)
	case missionconsumeorder.FieldIsTime:
		return m.OldIsTime(ctx)
	case missionconsumeorder.FieldCallWay:
		return m.OldCallWay(ctx)
	case missionconsumeorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case missionconsumeorder.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionconsumeorder.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionconsumeorder.FieldMissionBatchID:
		return m.OldMissionBatchID(ctx)
	case missionconsumeorder.FieldMissionBatchNumber:
		return m.OldMissionBatchNumber(ctx)
	}
	return nil, fmt.Errorf("unknown MissionConsumeOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionConsumeOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionconsumeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionconsumeorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionconsumeorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionconsumeorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionconsumeorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case missionconsumeorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionconsumeorder.FieldStatus:
		v, ok := value.(enums.MissionOrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case missionconsumeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case missionconsumeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case missionconsumeorder.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionconsumeorder.FieldIsTime:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTime(v)
		return nil
	case missionconsumeorder.FieldCallWay:
		v, ok := value.(enums.MissionCallWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallWay(v)
		return nil
	case missionconsumeorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case missionconsumeorder.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionconsumeorder.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionconsumeorder.FieldMissionBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchID(v)
		return nil
	case missionconsumeorder.FieldMissionBatchNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchNumber(v)
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionConsumeOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionconsumeorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionconsumeorder.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, missionconsumeorder.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, missionconsumeorder.FieldGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionConsumeOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionconsumeorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionconsumeorder.FieldPureCep:
		return m.AddedPureCep()
	case missionconsumeorder.FieldGiftCep:
		return m.AddedGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionConsumeOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionconsumeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionconsumeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case missionconsumeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionConsumeOrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionConsumeOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionConsumeOrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionConsumeOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionConsumeOrderMutation) ResetField(name string) error {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionconsumeorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionconsumeorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionconsumeorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionconsumeorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionconsumeorder.FieldUserID:
		m.ResetUserID()
		return nil
	case missionconsumeorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionconsumeorder.FieldStatus:
		m.ResetStatus()
		return nil
	case missionconsumeorder.FieldPureCep:
		m.ResetPureCep()
		return nil
	case missionconsumeorder.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case missionconsumeorder.FieldType:
		m.ResetType()
		return nil
	case missionconsumeorder.FieldIsTime:
		m.ResetIsTime()
		return nil
	case missionconsumeorder.FieldCallWay:
		m.ResetCallWay()
		return nil
	case missionconsumeorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case missionconsumeorder.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionconsumeorder.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionconsumeorder.FieldMissionBatchID:
		m.ResetMissionBatchID()
		return nil
	case missionconsumeorder.FieldMissionBatchNumber:
		m.ResetMissionBatchNumber()
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionConsumeOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, missionconsumeorder.EdgeUser)
	}
	if m.cost_bills != nil {
		edges = append(edges, missionconsumeorder.EdgeCostBills)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, missionconsumeorder.EdgeMissionProduceOrders)
	}
	if m.mission_batch != nil {
		edges = append(edges, missionconsumeorder.EdgeMissionBatch)
	}
	if m.mission != nil {
		edges = append(edges, missionconsumeorder.EdgeMission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionConsumeOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionconsumeorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionconsumeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case missionconsumeorder.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case missionconsumeorder.EdgeMissionBatch:
		if id := m.mission_batch; id != nil {
			return []ent.Value{*id}
		}
	case missionconsumeorder.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionConsumeOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcost_bills != nil {
		edges = append(edges, missionconsumeorder.EdgeCostBills)
	}
	if m.removedmission_produce_orders != nil {
		edges = append(edges, missionconsumeorder.EdgeMissionProduceOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionConsumeOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionconsumeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	case missionconsumeorder.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionConsumeOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, missionconsumeorder.EdgeUser)
	}
	if m.clearedcost_bills {
		edges = append(edges, missionconsumeorder.EdgeCostBills)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, missionconsumeorder.EdgeMissionProduceOrders)
	}
	if m.clearedmission_batch {
		edges = append(edges, missionconsumeorder.EdgeMissionBatch)
	}
	if m.clearedmission {
		edges = append(edges, missionconsumeorder.EdgeMission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionConsumeOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case missionconsumeorder.EdgeUser:
		return m.cleareduser
	case missionconsumeorder.EdgeCostBills:
		return m.clearedcost_bills
	case missionconsumeorder.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case missionconsumeorder.EdgeMissionBatch:
		return m.clearedmission_batch
	case missionconsumeorder.EdgeMission:
		return m.clearedmission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionConsumeOrderMutation) ClearEdge(name string) error {
	switch name {
	case missionconsumeorder.EdgeUser:
		m.ClearUser()
		return nil
	case missionconsumeorder.EdgeMissionBatch:
		m.ClearMissionBatch()
		return nil
	case missionconsumeorder.EdgeMission:
		m.ClearMission()
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionConsumeOrderMutation) ResetEdge(name string) error {
	switch name {
	case missionconsumeorder.EdgeUser:
		m.ResetUser()
		return nil
	case missionconsumeorder.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case missionconsumeorder.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case missionconsumeorder.EdgeMissionBatch:
		m.ResetMissionBatch()
		return nil
	case missionconsumeorder.EdgeMission:
		m.ResetMission()
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder edge %s", name)
}

// MissionExtraServiceMutation represents an operation that mutates the MissionExtraService nodes in the graph.
type MissionExtraServiceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_by           *int64
	addcreated_by        *int64
	updated_by           *int64
	addupdated_by        *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	clearedFields        map[string]struct{}
	mission              *int64
	clearedmission       bool
	extra_service        *int64
	clearedextra_service bool
	done                 bool
	oldValue             func(context.Context) (*MissionExtraService, error)
	predicates           []predicate.MissionExtraService
}

var _ ent.Mutation = (*MissionExtraServiceMutation)(nil)

// missionextraserviceOption allows management of the mutation configuration using functional options.
type missionextraserviceOption func(*MissionExtraServiceMutation)

// newMissionExtraServiceMutation creates new mutation for the MissionExtraService entity.
func newMissionExtraServiceMutation(c config, op Op, opts ...missionextraserviceOption) *MissionExtraServiceMutation {
	m := &MissionExtraServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionExtraService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionExtraServiceID sets the ID field of the mutation.
func withMissionExtraServiceID(id int64) missionextraserviceOption {
	return func(m *MissionExtraServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionExtraService
		)
		m.oldValue = func(ctx context.Context) (*MissionExtraService, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionExtraService.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionExtraService sets the old MissionExtraService of the mutation.
func withMissionExtraService(node *MissionExtraService) missionextraserviceOption {
	return func(m *MissionExtraServiceMutation) {
		m.oldValue = func(context.Context) (*MissionExtraService, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionExtraServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionExtraServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionExtraService entities.
func (m *MissionExtraServiceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionExtraServiceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionExtraServiceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionExtraService.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionExtraServiceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionExtraServiceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionExtraServiceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionExtraServiceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionExtraServiceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionExtraServiceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionExtraServiceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionExtraServiceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionExtraServiceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionExtraServiceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionExtraServiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionExtraServiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionExtraServiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionExtraServiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionExtraServiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionExtraServiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionExtraServiceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionExtraServiceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionExtraServiceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionExtraServiceMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionExtraServiceMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionExtraServiceMutation) ResetMissionID() {
	m.mission = nil
}

// SetExtraServiceID sets the "extra_service_id" field.
func (m *MissionExtraServiceMutation) SetExtraServiceID(i int64) {
	m.extra_service = &i
}

// ExtraServiceID returns the value of the "extra_service_id" field in the mutation.
func (m *MissionExtraServiceMutation) ExtraServiceID() (r int64, exists bool) {
	v := m.extra_service
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraServiceID returns the old "extra_service_id" field's value of the MissionExtraService entity.
// If the MissionExtraService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionExtraServiceMutation) OldExtraServiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraServiceID: %w", err)
	}
	return oldValue.ExtraServiceID, nil
}

// ResetExtraServiceID resets all changes to the "extra_service_id" field.
func (m *MissionExtraServiceMutation) ResetExtraServiceID() {
	m.extra_service = nil
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionExtraServiceMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionextraservice.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionExtraServiceMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionExtraServiceMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionExtraServiceMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearExtraService clears the "extra_service" edge to the ExtraService entity.
func (m *MissionExtraServiceMutation) ClearExtraService() {
	m.clearedextra_service = true
	m.clearedFields[missionextraservice.FieldExtraServiceID] = struct{}{}
}

// ExtraServiceCleared reports if the "extra_service" edge to the ExtraService entity was cleared.
func (m *MissionExtraServiceMutation) ExtraServiceCleared() bool {
	return m.clearedextra_service
}

// ExtraServiceIDs returns the "extra_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExtraServiceID instead. It exists only for internal usage by the builders.
func (m *MissionExtraServiceMutation) ExtraServiceIDs() (ids []int64) {
	if id := m.extra_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExtraService resets all changes to the "extra_service" edge.
func (m *MissionExtraServiceMutation) ResetExtraService() {
	m.extra_service = nil
	m.clearedextra_service = false
}

// Where appends a list predicates to the MissionExtraServiceMutation builder.
func (m *MissionExtraServiceMutation) Where(ps ...predicate.MissionExtraService) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionExtraServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionExtraServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionExtraService, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionExtraServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionExtraServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionExtraService).
func (m *MissionExtraServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionExtraServiceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, missionextraservice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionextraservice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionextraservice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionextraservice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionextraservice.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, missionextraservice.FieldMissionID)
	}
	if m.extra_service != nil {
		fields = append(fields, missionextraservice.FieldExtraServiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionExtraServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionextraservice.FieldCreatedBy:
		return m.CreatedBy()
	case missionextraservice.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionextraservice.FieldCreatedAt:
		return m.CreatedAt()
	case missionextraservice.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionextraservice.FieldDeletedAt:
		return m.DeletedAt()
	case missionextraservice.FieldMissionID:
		return m.MissionID()
	case missionextraservice.FieldExtraServiceID:
		return m.ExtraServiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionExtraServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionextraservice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionextraservice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionextraservice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionextraservice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionextraservice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionextraservice.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionextraservice.FieldExtraServiceID:
		return m.OldExtraServiceID(ctx)
	}
	return nil, fmt.Errorf("unknown MissionExtraService field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionExtraServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionextraservice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionextraservice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionextraservice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionextraservice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionextraservice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionextraservice.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionextraservice.FieldExtraServiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraServiceID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionExtraServiceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionextraservice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionextraservice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionExtraServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionextraservice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionextraservice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionExtraServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionextraservice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionextraservice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionExtraServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionExtraServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionExtraServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionExtraService nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionExtraServiceMutation) ResetField(name string) error {
	switch name {
	case missionextraservice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionextraservice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionextraservice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionextraservice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionextraservice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionextraservice.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionextraservice.FieldExtraServiceID:
		m.ResetExtraServiceID()
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionExtraServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mission != nil {
		edges = append(edges, missionextraservice.EdgeMission)
	}
	if m.extra_service != nil {
		edges = append(edges, missionextraservice.EdgeExtraService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionExtraServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionextraservice.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case missionextraservice.EdgeExtraService:
		if id := m.extra_service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionExtraServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionExtraServiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionExtraServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmission {
		edges = append(edges, missionextraservice.EdgeMission)
	}
	if m.clearedextra_service {
		edges = append(edges, missionextraservice.EdgeExtraService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionExtraServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case missionextraservice.EdgeMission:
		return m.clearedmission
	case missionextraservice.EdgeExtraService:
		return m.clearedextra_service
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionExtraServiceMutation) ClearEdge(name string) error {
	switch name {
	case missionextraservice.EdgeMission:
		m.ClearMission()
		return nil
	case missionextraservice.EdgeExtraService:
		m.ClearExtraService()
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionExtraServiceMutation) ResetEdge(name string) error {
	switch name {
	case missionextraservice.EdgeMission:
		m.ResetMission()
		return nil
	case missionextraservice.EdgeExtraService:
		m.ResetExtraService()
		return nil
	}
	return fmt.Errorf("unknown MissionExtraService edge %s", name)
}

// MissionKeyPairMutation represents an operation that mutates the MissionKeyPair nodes in the graph.
type MissionKeyPairMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	started_at        *time.Time
	finished_at       *time.Time
	result            *enums.MissionResult
	device_id         *int64
	adddevice_id      *int64
	result_urls       *[]string
	appendresult_urls []string
	clearedFields     map[string]struct{}
	mission           *int64
	clearedmission    bool
	key_pair          *int64
	clearedkey_pair   bool
	done              bool
	oldValue          func(context.Context) (*MissionKeyPair, error)
	predicates        []predicate.MissionKeyPair
}

var _ ent.Mutation = (*MissionKeyPairMutation)(nil)

// missionkeypairOption allows management of the mutation configuration using functional options.
type missionkeypairOption func(*MissionKeyPairMutation)

// newMissionKeyPairMutation creates new mutation for the MissionKeyPair entity.
func newMissionKeyPairMutation(c config, op Op, opts ...missionkeypairOption) *MissionKeyPairMutation {
	m := &MissionKeyPairMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionKeyPair,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionKeyPairID sets the ID field of the mutation.
func withMissionKeyPairID(id int64) missionkeypairOption {
	return func(m *MissionKeyPairMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionKeyPair
		)
		m.oldValue = func(ctx context.Context) (*MissionKeyPair, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionKeyPair.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionKeyPair sets the old MissionKeyPair of the mutation.
func withMissionKeyPair(node *MissionKeyPair) missionkeypairOption {
	return func(m *MissionKeyPairMutation) {
		m.oldValue = func(context.Context) (*MissionKeyPair, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionKeyPairMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionKeyPairMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionKeyPair entities.
func (m *MissionKeyPairMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionKeyPairMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionKeyPairMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionKeyPair.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionKeyPairMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionKeyPairMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionKeyPairMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionKeyPairMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionKeyPairMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionKeyPairMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionKeyPairMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionKeyPairMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionKeyPairMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionKeyPairMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionKeyPairMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionKeyPairMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionKeyPairMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionKeyPairMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionKeyPairMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionKeyPairMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionKeyPairMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionKeyPairMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionKeyPairMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionKeyPairMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionKeyPairMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionKeyPairMutation) ResetMissionID() {
	m.mission = nil
}

// SetKeyPairID sets the "key_pair_id" field.
func (m *MissionKeyPairMutation) SetKeyPairID(i int64) {
	m.key_pair = &i
}

// KeyPairID returns the value of the "key_pair_id" field in the mutation.
func (m *MissionKeyPairMutation) KeyPairID() (r int64, exists bool) {
	v := m.key_pair
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPairID returns the old "key_pair_id" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldKeyPairID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPairID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPairID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPairID: %w", err)
	}
	return oldValue.KeyPairID, nil
}

// ResetKeyPairID resets all changes to the "key_pair_id" field.
func (m *MissionKeyPairMutation) ResetKeyPairID() {
	m.key_pair = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionKeyPairMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionKeyPairMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionKeyPairMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionKeyPairMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionKeyPairMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionKeyPairMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetResult sets the "result" field.
func (m *MissionKeyPairMutation) SetResult(er enums.MissionResult) {
	m.result = &er
}

// Result returns the value of the "result" field in the mutation.
func (m *MissionKeyPairMutation) Result() (r enums.MissionResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldResult(ctx context.Context) (v enums.MissionResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *MissionKeyPairMutation) ResetResult() {
	m.result = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionKeyPairMutation) SetDeviceID(i int64) {
	m.device_id = &i
	m.adddevice_id = nil
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionKeyPairMutation) DeviceID() (r int64, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// AddDeviceID adds i to the "device_id" field.
func (m *MissionKeyPairMutation) AddDeviceID(i int64) {
	if m.adddevice_id != nil {
		*m.adddevice_id += i
	} else {
		m.adddevice_id = &i
	}
}

// AddedDeviceID returns the value that was added to the "device_id" field in this mutation.
func (m *MissionKeyPairMutation) AddedDeviceID() (r int64, exists bool) {
	v := m.adddevice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionKeyPairMutation) ResetDeviceID() {
	m.device_id = nil
	m.adddevice_id = nil
}

// SetResultUrls sets the "result_urls" field.
func (m *MissionKeyPairMutation) SetResultUrls(s []string) {
	m.result_urls = &s
	m.appendresult_urls = nil
}

// ResultUrls returns the value of the "result_urls" field in the mutation.
func (m *MissionKeyPairMutation) ResultUrls() (r []string, exists bool) {
	v := m.result_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldResultUrls returns the old "result_urls" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldResultUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultUrls: %w", err)
	}
	return oldValue.ResultUrls, nil
}

// AppendResultUrls adds s to the "result_urls" field.
func (m *MissionKeyPairMutation) AppendResultUrls(s []string) {
	m.appendresult_urls = append(m.appendresult_urls, s...)
}

// AppendedResultUrls returns the list of values that were appended to the "result_urls" field in this mutation.
func (m *MissionKeyPairMutation) AppendedResultUrls() ([]string, bool) {
	if len(m.appendresult_urls) == 0 {
		return nil, false
	}
	return m.appendresult_urls, true
}

// ClearResultUrls clears the value of the "result_urls" field.
func (m *MissionKeyPairMutation) ClearResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	m.clearedFields[missionkeypair.FieldResultUrls] = struct{}{}
}

// ResultUrlsCleared returns if the "result_urls" field was cleared in this mutation.
func (m *MissionKeyPairMutation) ResultUrlsCleared() bool {
	_, ok := m.clearedFields[missionkeypair.FieldResultUrls]
	return ok
}

// ResetResultUrls resets all changes to the "result_urls" field.
func (m *MissionKeyPairMutation) ResetResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	delete(m.clearedFields, missionkeypair.FieldResultUrls)
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionKeyPairMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionkeypair.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionKeyPairMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionKeyPairMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionKeyPairMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearKeyPair clears the "key_pair" edge to the HmacKeyPair entity.
func (m *MissionKeyPairMutation) ClearKeyPair() {
	m.clearedkey_pair = true
	m.clearedFields[missionkeypair.FieldKeyPairID] = struct{}{}
}

// KeyPairCleared reports if the "key_pair" edge to the HmacKeyPair entity was cleared.
func (m *MissionKeyPairMutation) KeyPairCleared() bool {
	return m.clearedkey_pair
}

// KeyPairIDs returns the "key_pair" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeyPairID instead. It exists only for internal usage by the builders.
func (m *MissionKeyPairMutation) KeyPairIDs() (ids []int64) {
	if id := m.key_pair; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeyPair resets all changes to the "key_pair" edge.
func (m *MissionKeyPairMutation) ResetKeyPair() {
	m.key_pair = nil
	m.clearedkey_pair = false
}

// Where appends a list predicates to the MissionKeyPairMutation builder.
func (m *MissionKeyPairMutation) Where(ps ...predicate.MissionKeyPair) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionKeyPairMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionKeyPairMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionKeyPair, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionKeyPairMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionKeyPairMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionKeyPair).
func (m *MissionKeyPairMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionKeyPairMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, missionkeypair.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionkeypair.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionkeypair.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionkeypair.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionkeypair.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, missionkeypair.FieldMissionID)
	}
	if m.key_pair != nil {
		fields = append(fields, missionkeypair.FieldKeyPairID)
	}
	if m.started_at != nil {
		fields = append(fields, missionkeypair.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionkeypair.FieldFinishedAt)
	}
	if m.result != nil {
		fields = append(fields, missionkeypair.FieldResult)
	}
	if m.device_id != nil {
		fields = append(fields, missionkeypair.FieldDeviceID)
	}
	if m.result_urls != nil {
		fields = append(fields, missionkeypair.FieldResultUrls)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionKeyPairMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionkeypair.FieldCreatedBy:
		return m.CreatedBy()
	case missionkeypair.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionkeypair.FieldCreatedAt:
		return m.CreatedAt()
	case missionkeypair.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionkeypair.FieldDeletedAt:
		return m.DeletedAt()
	case missionkeypair.FieldMissionID:
		return m.MissionID()
	case missionkeypair.FieldKeyPairID:
		return m.KeyPairID()
	case missionkeypair.FieldStartedAt:
		return m.StartedAt()
	case missionkeypair.FieldFinishedAt:
		return m.FinishedAt()
	case missionkeypair.FieldResult:
		return m.Result()
	case missionkeypair.FieldDeviceID:
		return m.DeviceID()
	case missionkeypair.FieldResultUrls:
		return m.ResultUrls()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionKeyPairMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionkeypair.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionkeypair.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionkeypair.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionkeypair.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionkeypair.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionkeypair.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionkeypair.FieldKeyPairID:
		return m.OldKeyPairID(ctx)
	case missionkeypair.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionkeypair.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionkeypair.FieldResult:
		return m.OldResult(ctx)
	case missionkeypair.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionkeypair.FieldResultUrls:
		return m.OldResultUrls(ctx)
	}
	return nil, fmt.Errorf("unknown MissionKeyPair field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKeyPairMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionkeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionkeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionkeypair.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionkeypair.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionkeypair.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionkeypair.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionkeypair.FieldKeyPairID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPairID(v)
		return nil
	case missionkeypair.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionkeypair.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionkeypair.FieldResult:
		v, ok := value.(enums.MissionResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case missionkeypair.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionkeypair.FieldResultUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultUrls(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionKeyPairMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionkeypair.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionkeypair.FieldUpdatedBy)
	}
	if m.adddevice_id != nil {
		fields = append(fields, missionkeypair.FieldDeviceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionKeyPairMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionkeypair.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionkeypair.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionkeypair.FieldDeviceID:
		return m.AddedDeviceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKeyPairMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionkeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionkeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionkeypair.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionKeyPairMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(missionkeypair.FieldResultUrls) {
		fields = append(fields, missionkeypair.FieldResultUrls)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionKeyPairMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionKeyPairMutation) ClearField(name string) error {
	switch name {
	case missionkeypair.FieldResultUrls:
		m.ClearResultUrls()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionKeyPairMutation) ResetField(name string) error {
	switch name {
	case missionkeypair.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionkeypair.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionkeypair.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionkeypair.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionkeypair.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionkeypair.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionkeypair.FieldKeyPairID:
		m.ResetKeyPairID()
		return nil
	case missionkeypair.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionkeypair.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionkeypair.FieldResult:
		m.ResetResult()
		return nil
	case missionkeypair.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionkeypair.FieldResultUrls:
		m.ResetResultUrls()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionKeyPairMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mission != nil {
		edges = append(edges, missionkeypair.EdgeMission)
	}
	if m.key_pair != nil {
		edges = append(edges, missionkeypair.EdgeKeyPair)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionKeyPairMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionkeypair.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case missionkeypair.EdgeKeyPair:
		if id := m.key_pair; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionKeyPairMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionKeyPairMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionKeyPairMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmission {
		edges = append(edges, missionkeypair.EdgeMission)
	}
	if m.clearedkey_pair {
		edges = append(edges, missionkeypair.EdgeKeyPair)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionKeyPairMutation) EdgeCleared(name string) bool {
	switch name {
	case missionkeypair.EdgeMission:
		return m.clearedmission
	case missionkeypair.EdgeKeyPair:
		return m.clearedkey_pair
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionKeyPairMutation) ClearEdge(name string) error {
	switch name {
	case missionkeypair.EdgeMission:
		m.ClearMission()
		return nil
	case missionkeypair.EdgeKeyPair:
		m.ClearKeyPair()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionKeyPairMutation) ResetEdge(name string) error {
	switch name {
	case missionkeypair.EdgeMission:
		m.ResetMission()
		return nil
	case missionkeypair.EdgeKeyPair:
		m.ResetKeyPair()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair edge %s", name)
}

// MissionKindMutation represents an operation that mutates the MissionKind nodes in the graph.
type MissionKindMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_by      *int64
	addcreated_by   *int64
	updated_by      *int64
	addupdated_by   *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	_type           *enums.MissionType
	category        *enums.MissionCategory
	billing_type    *enums.MissionBillingType
	clearedFields   map[string]struct{}
	missions        map[int64]struct{}
	removedmissions map[int64]struct{}
	clearedmissions bool
	done            bool
	oldValue        func(context.Context) (*MissionKind, error)
	predicates      []predicate.MissionKind
}

var _ ent.Mutation = (*MissionKindMutation)(nil)

// missionkindOption allows management of the mutation configuration using functional options.
type missionkindOption func(*MissionKindMutation)

// newMissionKindMutation creates new mutation for the MissionKind entity.
func newMissionKindMutation(c config, op Op, opts ...missionkindOption) *MissionKindMutation {
	m := &MissionKindMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionKind,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionKindID sets the ID field of the mutation.
func withMissionKindID(id int64) missionkindOption {
	return func(m *MissionKindMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionKind
		)
		m.oldValue = func(ctx context.Context) (*MissionKind, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionKind.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionKind sets the old MissionKind of the mutation.
func withMissionKind(node *MissionKind) missionkindOption {
	return func(m *MissionKindMutation) {
		m.oldValue = func(context.Context) (*MissionKind, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionKindMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionKindMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionKind entities.
func (m *MissionKindMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionKindMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionKindMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionKind.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionKindMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionKindMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionKindMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionKindMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionKindMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionKindMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionKindMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionKindMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionKindMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionKindMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionKindMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionKindMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionKindMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionKindMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionKindMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionKindMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionKindMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionKindMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionKindMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *MissionKindMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionKindMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionKindMutation) ResetType() {
	m._type = nil
}

// SetCategory sets the "category" field.
func (m *MissionKindMutation) SetCategory(ec enums.MissionCategory) {
	m.category = &ec
}

// Category returns the value of the "category" field in the mutation.
func (m *MissionKindMutation) Category() (r enums.MissionCategory, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldCategory(ctx context.Context) (v enums.MissionCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MissionKindMutation) ResetCategory() {
	m.category = nil
}

// SetBillingType sets the "billing_type" field.
func (m *MissionKindMutation) SetBillingType(ebt enums.MissionBillingType) {
	m.billing_type = &ebt
}

// BillingType returns the value of the "billing_type" field in the mutation.
func (m *MissionKindMutation) BillingType() (r enums.MissionBillingType, exists bool) {
	v := m.billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingType returns the old "billing_type" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingType: %w", err)
	}
	return oldValue.BillingType, nil
}

// ResetBillingType resets all changes to the "billing_type" field.
func (m *MissionKindMutation) ResetBillingType() {
	m.billing_type = nil
}

// AddMissionIDs adds the "missions" edge to the Mission entity by ids.
func (m *MissionKindMutation) AddMissionIDs(ids ...int64) {
	if m.missions == nil {
		m.missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.missions[ids[i]] = struct{}{}
	}
}

// ClearMissions clears the "missions" edge to the Mission entity.
func (m *MissionKindMutation) ClearMissions() {
	m.clearedmissions = true
}

// MissionsCleared reports if the "missions" edge to the Mission entity was cleared.
func (m *MissionKindMutation) MissionsCleared() bool {
	return m.clearedmissions
}

// RemoveMissionIDs removes the "missions" edge to the Mission entity by IDs.
func (m *MissionKindMutation) RemoveMissionIDs(ids ...int64) {
	if m.removedmissions == nil {
		m.removedmissions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.missions, ids[i])
		m.removedmissions[ids[i]] = struct{}{}
	}
}

// RemovedMissions returns the removed IDs of the "missions" edge to the Mission entity.
func (m *MissionKindMutation) RemovedMissionsIDs() (ids []int64) {
	for id := range m.removedmissions {
		ids = append(ids, id)
	}
	return
}

// MissionsIDs returns the "missions" edge IDs in the mutation.
func (m *MissionKindMutation) MissionsIDs() (ids []int64) {
	for id := range m.missions {
		ids = append(ids, id)
	}
	return
}

// ResetMissions resets all changes to the "missions" edge.
func (m *MissionKindMutation) ResetMissions() {
	m.missions = nil
	m.clearedmissions = false
	m.removedmissions = nil
}

// Where appends a list predicates to the MissionKindMutation builder.
func (m *MissionKindMutation) Where(ps ...predicate.MissionKind) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionKindMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionKindMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionKind, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionKindMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionKindMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionKind).
func (m *MissionKindMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionKindMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, missionkind.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionkind.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionkind.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionkind.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionkind.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, missionkind.FieldType)
	}
	if m.category != nil {
		fields = append(fields, missionkind.FieldCategory)
	}
	if m.billing_type != nil {
		fields = append(fields, missionkind.FieldBillingType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionKindMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionkind.FieldCreatedBy:
		return m.CreatedBy()
	case missionkind.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionkind.FieldCreatedAt:
		return m.CreatedAt()
	case missionkind.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionkind.FieldDeletedAt:
		return m.DeletedAt()
	case missionkind.FieldType:
		return m.GetType()
	case missionkind.FieldCategory:
		return m.Category()
	case missionkind.FieldBillingType:
		return m.BillingType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionKindMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionkind.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionkind.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionkind.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionkind.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionkind.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionkind.FieldType:
		return m.OldType(ctx)
	case missionkind.FieldCategory:
		return m.OldCategory(ctx)
	case missionkind.FieldBillingType:
		return m.OldBillingType(ctx)
	}
	return nil, fmt.Errorf("unknown MissionKind field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKindMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionkind.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionkind.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionkind.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionkind.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionkind.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionkind.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionkind.FieldCategory:
		v, ok := value.(enums.MissionCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case missionkind.FieldBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingType(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKind field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionKindMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionkind.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionkind.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionKindMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionkind.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionkind.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKindMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionkind.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionkind.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKind numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionKindMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionKindMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionKindMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionKind nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionKindMutation) ResetField(name string) error {
	switch name {
	case missionkind.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionkind.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionkind.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionkind.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionkind.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionkind.FieldType:
		m.ResetType()
		return nil
	case missionkind.FieldCategory:
		m.ResetCategory()
		return nil
	case missionkind.FieldBillingType:
		m.ResetBillingType()
		return nil
	}
	return fmt.Errorf("unknown MissionKind field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionKindMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.missions != nil {
		edges = append(edges, missionkind.EdgeMissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionKindMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionkind.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.missions))
		for id := range m.missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionKindMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmissions != nil {
		edges = append(edges, missionkind.EdgeMissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionKindMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionkind.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.removedmissions))
		for id := range m.removedmissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionKindMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmissions {
		edges = append(edges, missionkind.EdgeMissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionKindMutation) EdgeCleared(name string) bool {
	switch name {
	case missionkind.EdgeMissions:
		return m.clearedmissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionKindMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MissionKind unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionKindMutation) ResetEdge(name string) error {
	switch name {
	case missionkind.EdgeMissions:
		m.ResetMissions()
		return nil
	}
	return fmt.Errorf("unknown MissionKind edge %s", name)
}

// MissionOrderMutation represents an operation that mutates the MissionOrder nodes in the graph.
type MissionOrderMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	created_by                  *int64
	addcreated_by               *int64
	updated_by                  *int64
	addupdated_by               *int64
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	status                      *enums.MissionOrderStatus
	consume_amount              *int64
	addconsume_amount           *int64
	produce_amount              *int64
	addproduce_amount           *int64
	gas_amount                  *int64
	addgas_amount               *int64
	mission_type                *enums.MissionType
	mission_billing_type        *enums.MissionBillingType
	call_way                    *enums.MissionCallWay
	serial_number               *string
	started_at                  *time.Time
	finished_at                 *time.Time
	buy_duration                *int64
	addbuy_duration             *int64
	plan_started_at             *time.Time
	plan_finished_at            *time.Time
	expired_warning_time        *time.Time
	mission_batch_number        *string
	total_amount                *int64
	addtotal_amount             *int64
	settled_amount              *int64
	addsettled_amount           *int64
	settled_count               *int64
	addsettled_count            *int64
	total_settle_count          *int64
	addtotal_settle_count       *int64
	lately_settled_at           *time.Time
	clearedFields               map[string]struct{}
	consume_user                *int64
	clearedconsume_user         bool
	produce_user                *int64
	clearedproduce_user         bool
	symbol                      *int64
	clearedsymbol               bool
	bills                       map[int64]struct{}
	removedbills                map[int64]struct{}
	clearedbills                bool
	mission_batch               *int64
	clearedmission_batch        bool
	mission                     *int64
	clearedmission              bool
	device                      *int64
	cleareddevice               bool
	extra_service_orders        map[int64]struct{}
	removedextra_service_orders map[int64]struct{}
	clearedextra_service_orders bool
	done                        bool
	oldValue                    func(context.Context) (*MissionOrder, error)
	predicates                  []predicate.MissionOrder
}

var _ ent.Mutation = (*MissionOrderMutation)(nil)

// missionorderOption allows management of the mutation configuration using functional options.
type missionorderOption func(*MissionOrderMutation)

// newMissionOrderMutation creates new mutation for the MissionOrder entity.
func newMissionOrderMutation(c config, op Op, opts ...missionorderOption) *MissionOrderMutation {
	m := &MissionOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionOrderID sets the ID field of the mutation.
func withMissionOrderID(id int64) missionorderOption {
	return func(m *MissionOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionOrder
		)
		m.oldValue = func(ctx context.Context) (*MissionOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionOrder sets the old MissionOrder of the mutation.
func withMissionOrder(node *MissionOrder) missionorderOption {
	return func(m *MissionOrderMutation) {
		m.oldValue = func(context.Context) (*MissionOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionOrder entities.
func (m *MissionOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionOrderMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionOrderMutation) ResetMissionID() {
	m.mission = nil
}

// SetStatus sets the "status" field.
func (m *MissionOrderMutation) SetStatus(eos enums.MissionOrderStatus) {
	m.status = &eos
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionOrderMutation) Status() (r enums.MissionOrderStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldStatus(ctx context.Context) (v enums.MissionOrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionOrderMutation) ResetStatus() {
	m.status = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *MissionOrderMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *MissionOrderMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *MissionOrderMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetConsumeUserID sets the "consume_user_id" field.
func (m *MissionOrderMutation) SetConsumeUserID(i int64) {
	m.consume_user = &i
}

// ConsumeUserID returns the value of the "consume_user_id" field in the mutation.
func (m *MissionOrderMutation) ConsumeUserID() (r int64, exists bool) {
	v := m.consume_user
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumeUserID returns the old "consume_user_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldConsumeUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumeUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumeUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumeUserID: %w", err)
	}
	return oldValue.ConsumeUserID, nil
}

// ResetConsumeUserID resets all changes to the "consume_user_id" field.
func (m *MissionOrderMutation) ResetConsumeUserID() {
	m.consume_user = nil
}

// SetConsumeAmount sets the "consume_amount" field.
func (m *MissionOrderMutation) SetConsumeAmount(i int64) {
	m.consume_amount = &i
	m.addconsume_amount = nil
}

// ConsumeAmount returns the value of the "consume_amount" field in the mutation.
func (m *MissionOrderMutation) ConsumeAmount() (r int64, exists bool) {
	v := m.consume_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumeAmount returns the old "consume_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldConsumeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumeAmount: %w", err)
	}
	return oldValue.ConsumeAmount, nil
}

// AddConsumeAmount adds i to the "consume_amount" field.
func (m *MissionOrderMutation) AddConsumeAmount(i int64) {
	if m.addconsume_amount != nil {
		*m.addconsume_amount += i
	} else {
		m.addconsume_amount = &i
	}
}

// AddedConsumeAmount returns the value that was added to the "consume_amount" field in this mutation.
func (m *MissionOrderMutation) AddedConsumeAmount() (r int64, exists bool) {
	v := m.addconsume_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetConsumeAmount resets all changes to the "consume_amount" field.
func (m *MissionOrderMutation) ResetConsumeAmount() {
	m.consume_amount = nil
	m.addconsume_amount = nil
}

// SetProduceUserID sets the "produce_user_id" field.
func (m *MissionOrderMutation) SetProduceUserID(i int64) {
	m.produce_user = &i
}

// ProduceUserID returns the value of the "produce_user_id" field in the mutation.
func (m *MissionOrderMutation) ProduceUserID() (r int64, exists bool) {
	v := m.produce_user
	if v == nil {
		return
	}
	return *v, true
}

// OldProduceUserID returns the old "produce_user_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldProduceUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProduceUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProduceUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduceUserID: %w", err)
	}
	return oldValue.ProduceUserID, nil
}

// ResetProduceUserID resets all changes to the "produce_user_id" field.
func (m *MissionOrderMutation) ResetProduceUserID() {
	m.produce_user = nil
}

// SetProduceAmount sets the "produce_amount" field.
func (m *MissionOrderMutation) SetProduceAmount(i int64) {
	m.produce_amount = &i
	m.addproduce_amount = nil
}

// ProduceAmount returns the value of the "produce_amount" field in the mutation.
func (m *MissionOrderMutation) ProduceAmount() (r int64, exists bool) {
	v := m.produce_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldProduceAmount returns the old "produce_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldProduceAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProduceAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProduceAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduceAmount: %w", err)
	}
	return oldValue.ProduceAmount, nil
}

// AddProduceAmount adds i to the "produce_amount" field.
func (m *MissionOrderMutation) AddProduceAmount(i int64) {
	if m.addproduce_amount != nil {
		*m.addproduce_amount += i
	} else {
		m.addproduce_amount = &i
	}
}

// AddedProduceAmount returns the value that was added to the "produce_amount" field in this mutation.
func (m *MissionOrderMutation) AddedProduceAmount() (r int64, exists bool) {
	v := m.addproduce_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetProduceAmount resets all changes to the "produce_amount" field.
func (m *MissionOrderMutation) ResetProduceAmount() {
	m.produce_amount = nil
	m.addproduce_amount = nil
}

// SetGasAmount sets the "gas_amount" field.
func (m *MissionOrderMutation) SetGasAmount(i int64) {
	m.gas_amount = &i
	m.addgas_amount = nil
}

// GasAmount returns the value of the "gas_amount" field in the mutation.
func (m *MissionOrderMutation) GasAmount() (r int64, exists bool) {
	v := m.gas_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldGasAmount returns the old "gas_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldGasAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGasAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGasAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGasAmount: %w", err)
	}
	return oldValue.GasAmount, nil
}

// AddGasAmount adds i to the "gas_amount" field.
func (m *MissionOrderMutation) AddGasAmount(i int64) {
	if m.addgas_amount != nil {
		*m.addgas_amount += i
	} else {
		m.addgas_amount = &i
	}
}

// AddedGasAmount returns the value that was added to the "gas_amount" field in this mutation.
func (m *MissionOrderMutation) AddedGasAmount() (r int64, exists bool) {
	v := m.addgas_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetGasAmount resets all changes to the "gas_amount" field.
func (m *MissionOrderMutation) ResetGasAmount() {
	m.gas_amount = nil
	m.addgas_amount = nil
}

// SetMissionType sets the "mission_type" field.
func (m *MissionOrderMutation) SetMissionType(et enums.MissionType) {
	m.mission_type = &et
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *MissionOrderMutation) MissionType() (r enums.MissionType, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *MissionOrderMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionBillingType sets the "mission_billing_type" field.
func (m *MissionOrderMutation) SetMissionBillingType(ebt enums.MissionBillingType) {
	m.mission_billing_type = &ebt
}

// MissionBillingType returns the value of the "mission_billing_type" field in the mutation.
func (m *MissionOrderMutation) MissionBillingType() (r enums.MissionBillingType, exists bool) {
	v := m.mission_billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBillingType returns the old "mission_billing_type" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBillingType: %w", err)
	}
	return oldValue.MissionBillingType, nil
}

// ResetMissionBillingType resets all changes to the "mission_billing_type" field.
func (m *MissionOrderMutation) ResetMissionBillingType() {
	m.mission_billing_type = nil
}

// SetCallWay sets the "call_way" field.
func (m *MissionOrderMutation) SetCallWay(ecw enums.MissionCallWay) {
	m.call_way = &ecw
}

// CallWay returns the value of the "call_way" field in the mutation.
func (m *MissionOrderMutation) CallWay() (r enums.MissionCallWay, exists bool) {
	v := m.call_way
	if v == nil {
		return
	}
	return *v, true
}

// OldCallWay returns the old "call_way" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldCallWay(ctx context.Context) (v enums.MissionCallWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallWay: %w", err)
	}
	return oldValue.CallWay, nil
}

// ResetCallWay resets all changes to the "call_way" field.
func (m *MissionOrderMutation) ResetCallWay() {
	m.call_way = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *MissionOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MissionOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MissionOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionOrderMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionOrderMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionOrderMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionOrderMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionOrderMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionOrderMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetBuyDuration sets the "buy_duration" field.
func (m *MissionOrderMutation) SetBuyDuration(i int64) {
	m.buy_duration = &i
	m.addbuy_duration = nil
}

// BuyDuration returns the value of the "buy_duration" field in the mutation.
func (m *MissionOrderMutation) BuyDuration() (r int64, exists bool) {
	v := m.buy_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyDuration returns the old "buy_duration" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldBuyDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyDuration: %w", err)
	}
	return oldValue.BuyDuration, nil
}

// AddBuyDuration adds i to the "buy_duration" field.
func (m *MissionOrderMutation) AddBuyDuration(i int64) {
	if m.addbuy_duration != nil {
		*m.addbuy_duration += i
	} else {
		m.addbuy_duration = &i
	}
}

// AddedBuyDuration returns the value that was added to the "buy_duration" field in this mutation.
func (m *MissionOrderMutation) AddedBuyDuration() (r int64, exists bool) {
	v := m.addbuy_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetBuyDuration resets all changes to the "buy_duration" field.
func (m *MissionOrderMutation) ResetBuyDuration() {
	m.buy_duration = nil
	m.addbuy_duration = nil
}

// SetPlanStartedAt sets the "plan_started_at" field.
func (m *MissionOrderMutation) SetPlanStartedAt(t time.Time) {
	m.plan_started_at = &t
}

// PlanStartedAt returns the value of the "plan_started_at" field in the mutation.
func (m *MissionOrderMutation) PlanStartedAt() (r time.Time, exists bool) {
	v := m.plan_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanStartedAt returns the old "plan_started_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldPlanStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanStartedAt: %w", err)
	}
	return oldValue.PlanStartedAt, nil
}

// ClearPlanStartedAt clears the value of the "plan_started_at" field.
func (m *MissionOrderMutation) ClearPlanStartedAt() {
	m.plan_started_at = nil
	m.clearedFields[missionorder.FieldPlanStartedAt] = struct{}{}
}

// PlanStartedAtCleared returns if the "plan_started_at" field was cleared in this mutation.
func (m *MissionOrderMutation) PlanStartedAtCleared() bool {
	_, ok := m.clearedFields[missionorder.FieldPlanStartedAt]
	return ok
}

// ResetPlanStartedAt resets all changes to the "plan_started_at" field.
func (m *MissionOrderMutation) ResetPlanStartedAt() {
	m.plan_started_at = nil
	delete(m.clearedFields, missionorder.FieldPlanStartedAt)
}

// SetPlanFinishedAt sets the "plan_finished_at" field.
func (m *MissionOrderMutation) SetPlanFinishedAt(t time.Time) {
	m.plan_finished_at = &t
}

// PlanFinishedAt returns the value of the "plan_finished_at" field in the mutation.
func (m *MissionOrderMutation) PlanFinishedAt() (r time.Time, exists bool) {
	v := m.plan_finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanFinishedAt returns the old "plan_finished_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldPlanFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanFinishedAt: %w", err)
	}
	return oldValue.PlanFinishedAt, nil
}

// ClearPlanFinishedAt clears the value of the "plan_finished_at" field.
func (m *MissionOrderMutation) ClearPlanFinishedAt() {
	m.plan_finished_at = nil
	m.clearedFields[missionorder.FieldPlanFinishedAt] = struct{}{}
}

// PlanFinishedAtCleared returns if the "plan_finished_at" field was cleared in this mutation.
func (m *MissionOrderMutation) PlanFinishedAtCleared() bool {
	_, ok := m.clearedFields[missionorder.FieldPlanFinishedAt]
	return ok
}

// ResetPlanFinishedAt resets all changes to the "plan_finished_at" field.
func (m *MissionOrderMutation) ResetPlanFinishedAt() {
	m.plan_finished_at = nil
	delete(m.clearedFields, missionorder.FieldPlanFinishedAt)
}

// SetExpiredWarningTime sets the "expired_warning_time" field.
func (m *MissionOrderMutation) SetExpiredWarningTime(t time.Time) {
	m.expired_warning_time = &t
}

// ExpiredWarningTime returns the value of the "expired_warning_time" field in the mutation.
func (m *MissionOrderMutation) ExpiredWarningTime() (r time.Time, exists bool) {
	v := m.expired_warning_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredWarningTime returns the old "expired_warning_time" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldExpiredWarningTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredWarningTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredWarningTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredWarningTime: %w", err)
	}
	return oldValue.ExpiredWarningTime, nil
}

// ClearExpiredWarningTime clears the value of the "expired_warning_time" field.
func (m *MissionOrderMutation) ClearExpiredWarningTime() {
	m.expired_warning_time = nil
	m.clearedFields[missionorder.FieldExpiredWarningTime] = struct{}{}
}

// ExpiredWarningTimeCleared returns if the "expired_warning_time" field was cleared in this mutation.
func (m *MissionOrderMutation) ExpiredWarningTimeCleared() bool {
	_, ok := m.clearedFields[missionorder.FieldExpiredWarningTime]
	return ok
}

// ResetExpiredWarningTime resets all changes to the "expired_warning_time" field.
func (m *MissionOrderMutation) ResetExpiredWarningTime() {
	m.expired_warning_time = nil
	delete(m.clearedFields, missionorder.FieldExpiredWarningTime)
}

// SetMissionBatchID sets the "mission_batch_id" field.
func (m *MissionOrderMutation) SetMissionBatchID(i int64) {
	m.mission_batch = &i
}

// MissionBatchID returns the value of the "mission_batch_id" field in the mutation.
func (m *MissionOrderMutation) MissionBatchID() (r int64, exists bool) {
	v := m.mission_batch
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchID returns the old "mission_batch_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchID: %w", err)
	}
	return oldValue.MissionBatchID, nil
}

// ResetMissionBatchID resets all changes to the "mission_batch_id" field.
func (m *MissionOrderMutation) ResetMissionBatchID() {
	m.mission_batch = nil
}

// SetMissionBatchNumber sets the "mission_batch_number" field.
func (m *MissionOrderMutation) SetMissionBatchNumber(s string) {
	m.mission_batch_number = &s
}

// MissionBatchNumber returns the value of the "mission_batch_number" field in the mutation.
func (m *MissionOrderMutation) MissionBatchNumber() (r string, exists bool) {
	v := m.mission_batch_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchNumber returns the old "mission_batch_number" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldMissionBatchNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchNumber: %w", err)
	}
	return oldValue.MissionBatchNumber, nil
}

// ResetMissionBatchNumber resets all changes to the "mission_batch_number" field.
func (m *MissionOrderMutation) ResetMissionBatchNumber() {
	m.mission_batch_number = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionOrderMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionOrderMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionOrderMutation) ResetDeviceID() {
	m.device = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *MissionOrderMutation) SetTotalAmount(i int64) {
	m.total_amount = &i
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *MissionOrderMutation) TotalAmount() (r int64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldTotalAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds i to the "total_amount" field.
func (m *MissionOrderMutation) AddTotalAmount(i int64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += i
	} else {
		m.addtotal_amount = &i
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *MissionOrderMutation) AddedTotalAmount() (r int64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *MissionOrderMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetSettledAmount sets the "settled_amount" field.
func (m *MissionOrderMutation) SetSettledAmount(i int64) {
	m.settled_amount = &i
	m.addsettled_amount = nil
}

// SettledAmount returns the value of the "settled_amount" field in the mutation.
func (m *MissionOrderMutation) SettledAmount() (r int64, exists bool) {
	v := m.settled_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledAmount returns the old "settled_amount" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldSettledAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledAmount: %w", err)
	}
	return oldValue.SettledAmount, nil
}

// AddSettledAmount adds i to the "settled_amount" field.
func (m *MissionOrderMutation) AddSettledAmount(i int64) {
	if m.addsettled_amount != nil {
		*m.addsettled_amount += i
	} else {
		m.addsettled_amount = &i
	}
}

// AddedSettledAmount returns the value that was added to the "settled_amount" field in this mutation.
func (m *MissionOrderMutation) AddedSettledAmount() (r int64, exists bool) {
	v := m.addsettled_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettledAmount resets all changes to the "settled_amount" field.
func (m *MissionOrderMutation) ResetSettledAmount() {
	m.settled_amount = nil
	m.addsettled_amount = nil
}

// SetSettledCount sets the "settled_count" field.
func (m *MissionOrderMutation) SetSettledCount(i int64) {
	m.settled_count = &i
	m.addsettled_count = nil
}

// SettledCount returns the value of the "settled_count" field in the mutation.
func (m *MissionOrderMutation) SettledCount() (r int64, exists bool) {
	v := m.settled_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledCount returns the old "settled_count" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldSettledCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledCount: %w", err)
	}
	return oldValue.SettledCount, nil
}

// AddSettledCount adds i to the "settled_count" field.
func (m *MissionOrderMutation) AddSettledCount(i int64) {
	if m.addsettled_count != nil {
		*m.addsettled_count += i
	} else {
		m.addsettled_count = &i
	}
}

// AddedSettledCount returns the value that was added to the "settled_count" field in this mutation.
func (m *MissionOrderMutation) AddedSettledCount() (r int64, exists bool) {
	v := m.addsettled_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettledCount resets all changes to the "settled_count" field.
func (m *MissionOrderMutation) ResetSettledCount() {
	m.settled_count = nil
	m.addsettled_count = nil
}

// SetTotalSettleCount sets the "total_settle_count" field.
func (m *MissionOrderMutation) SetTotalSettleCount(i int64) {
	m.total_settle_count = &i
	m.addtotal_settle_count = nil
}

// TotalSettleCount returns the value of the "total_settle_count" field in the mutation.
func (m *MissionOrderMutation) TotalSettleCount() (r int64, exists bool) {
	v := m.total_settle_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSettleCount returns the old "total_settle_count" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldTotalSettleCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSettleCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSettleCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSettleCount: %w", err)
	}
	return oldValue.TotalSettleCount, nil
}

// AddTotalSettleCount adds i to the "total_settle_count" field.
func (m *MissionOrderMutation) AddTotalSettleCount(i int64) {
	if m.addtotal_settle_count != nil {
		*m.addtotal_settle_count += i
	} else {
		m.addtotal_settle_count = &i
	}
}

// AddedTotalSettleCount returns the value that was added to the "total_settle_count" field in this mutation.
func (m *MissionOrderMutation) AddedTotalSettleCount() (r int64, exists bool) {
	v := m.addtotal_settle_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSettleCount resets all changes to the "total_settle_count" field.
func (m *MissionOrderMutation) ResetTotalSettleCount() {
	m.total_settle_count = nil
	m.addtotal_settle_count = nil
}

// SetLatelySettledAt sets the "lately_settled_at" field.
func (m *MissionOrderMutation) SetLatelySettledAt(t time.Time) {
	m.lately_settled_at = &t
}

// LatelySettledAt returns the value of the "lately_settled_at" field in the mutation.
func (m *MissionOrderMutation) LatelySettledAt() (r time.Time, exists bool) {
	v := m.lately_settled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLatelySettledAt returns the old "lately_settled_at" field's value of the MissionOrder entity.
// If the MissionOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionOrderMutation) OldLatelySettledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatelySettledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatelySettledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatelySettledAt: %w", err)
	}
	return oldValue.LatelySettledAt, nil
}

// ResetLatelySettledAt resets all changes to the "lately_settled_at" field.
func (m *MissionOrderMutation) ResetLatelySettledAt() {
	m.lately_settled_at = nil
}

// ClearConsumeUser clears the "consume_user" edge to the User entity.
func (m *MissionOrderMutation) ClearConsumeUser() {
	m.clearedconsume_user = true
	m.clearedFields[missionorder.FieldConsumeUserID] = struct{}{}
}

// ConsumeUserCleared reports if the "consume_user" edge to the User entity was cleared.
func (m *MissionOrderMutation) ConsumeUserCleared() bool {
	return m.clearedconsume_user
}

// ConsumeUserIDs returns the "consume_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConsumeUserID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) ConsumeUserIDs() (ids []int64) {
	if id := m.consume_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConsumeUser resets all changes to the "consume_user" edge.
func (m *MissionOrderMutation) ResetConsumeUser() {
	m.consume_user = nil
	m.clearedconsume_user = false
}

// ClearProduceUser clears the "produce_user" edge to the User entity.
func (m *MissionOrderMutation) ClearProduceUser() {
	m.clearedproduce_user = true
	m.clearedFields[missionorder.FieldProduceUserID] = struct{}{}
}

// ProduceUserCleared reports if the "produce_user" edge to the User entity was cleared.
func (m *MissionOrderMutation) ProduceUserCleared() bool {
	return m.clearedproduce_user
}

// ProduceUserIDs returns the "produce_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProduceUserID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) ProduceUserIDs() (ids []int64) {
	if id := m.produce_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduceUser resets all changes to the "produce_user" edge.
func (m *MissionOrderMutation) ResetProduceUser() {
	m.produce_user = nil
	m.clearedproduce_user = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *MissionOrderMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[missionorder.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *MissionOrderMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *MissionOrderMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// AddBillIDs adds the "bills" edge to the Bill entity by ids.
func (m *MissionOrderMutation) AddBillIDs(ids ...int64) {
	if m.bills == nil {
		m.bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the Bill entity.
func (m *MissionOrderMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the Bill entity was cleared.
func (m *MissionOrderMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the Bill entity by IDs.
func (m *MissionOrderMutation) RemoveBillIDs(ids ...int64) {
	if m.removedbills == nil {
		m.removedbills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the Bill entity.
func (m *MissionOrderMutation) RemovedBillsIDs() (ids []int64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *MissionOrderMutation) BillsIDs() (ids []int64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *MissionOrderMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// ClearMissionBatch clears the "mission_batch" edge to the MissionBatch entity.
func (m *MissionOrderMutation) ClearMissionBatch() {
	m.clearedmission_batch = true
	m.clearedFields[missionorder.FieldMissionBatchID] = struct{}{}
}

// MissionBatchCleared reports if the "mission_batch" edge to the MissionBatch entity was cleared.
func (m *MissionOrderMutation) MissionBatchCleared() bool {
	return m.clearedmission_batch
}

// MissionBatchIDs returns the "mission_batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionBatchID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) MissionBatchIDs() (ids []int64) {
	if id := m.mission_batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionBatch resets all changes to the "mission_batch" edge.
func (m *MissionOrderMutation) ResetMissionBatch() {
	m.mission_batch = nil
	m.clearedmission_batch = false
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionOrderMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionorder.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionOrderMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionOrderMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *MissionOrderMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[missionorder.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *MissionOrderMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *MissionOrderMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *MissionOrderMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddExtraServiceOrderIDs adds the "extra_service_orders" edge to the ExtraServiceOrder entity by ids.
func (m *MissionOrderMutation) AddExtraServiceOrderIDs(ids ...int64) {
	if m.extra_service_orders == nil {
		m.extra_service_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_orders[ids[i]] = struct{}{}
	}
}

// ClearExtraServiceOrders clears the "extra_service_orders" edge to the ExtraServiceOrder entity.
func (m *MissionOrderMutation) ClearExtraServiceOrders() {
	m.clearedextra_service_orders = true
}

// ExtraServiceOrdersCleared reports if the "extra_service_orders" edge to the ExtraServiceOrder entity was cleared.
func (m *MissionOrderMutation) ExtraServiceOrdersCleared() bool {
	return m.clearedextra_service_orders
}

// RemoveExtraServiceOrderIDs removes the "extra_service_orders" edge to the ExtraServiceOrder entity by IDs.
func (m *MissionOrderMutation) RemoveExtraServiceOrderIDs(ids ...int64) {
	if m.removedextra_service_orders == nil {
		m.removedextra_service_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_orders, ids[i])
		m.removedextra_service_orders[ids[i]] = struct{}{}
	}
}

// RemovedExtraServiceOrders returns the removed IDs of the "extra_service_orders" edge to the ExtraServiceOrder entity.
func (m *MissionOrderMutation) RemovedExtraServiceOrdersIDs() (ids []int64) {
	for id := range m.removedextra_service_orders {
		ids = append(ids, id)
	}
	return
}

// ExtraServiceOrdersIDs returns the "extra_service_orders" edge IDs in the mutation.
func (m *MissionOrderMutation) ExtraServiceOrdersIDs() (ids []int64) {
	for id := range m.extra_service_orders {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServiceOrders resets all changes to the "extra_service_orders" edge.
func (m *MissionOrderMutation) ResetExtraServiceOrders() {
	m.extra_service_orders = nil
	m.clearedextra_service_orders = false
	m.removedextra_service_orders = nil
}

// Where appends a list predicates to the MissionOrderMutation builder.
func (m *MissionOrderMutation) Where(ps ...predicate.MissionOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionOrder).
func (m *MissionOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionOrderMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.created_by != nil {
		fields = append(fields, missionorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionorder.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, missionorder.FieldMissionID)
	}
	if m.status != nil {
		fields = append(fields, missionorder.FieldStatus)
	}
	if m.symbol != nil {
		fields = append(fields, missionorder.FieldSymbolID)
	}
	if m.consume_user != nil {
		fields = append(fields, missionorder.FieldConsumeUserID)
	}
	if m.consume_amount != nil {
		fields = append(fields, missionorder.FieldConsumeAmount)
	}
	if m.produce_user != nil {
		fields = append(fields, missionorder.FieldProduceUserID)
	}
	if m.produce_amount != nil {
		fields = append(fields, missionorder.FieldProduceAmount)
	}
	if m.gas_amount != nil {
		fields = append(fields, missionorder.FieldGasAmount)
	}
	if m.mission_type != nil {
		fields = append(fields, missionorder.FieldMissionType)
	}
	if m.mission_billing_type != nil {
		fields = append(fields, missionorder.FieldMissionBillingType)
	}
	if m.call_way != nil {
		fields = append(fields, missionorder.FieldCallWay)
	}
	if m.serial_number != nil {
		fields = append(fields, missionorder.FieldSerialNumber)
	}
	if m.started_at != nil {
		fields = append(fields, missionorder.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionorder.FieldFinishedAt)
	}
	if m.buy_duration != nil {
		fields = append(fields, missionorder.FieldBuyDuration)
	}
	if m.plan_started_at != nil {
		fields = append(fields, missionorder.FieldPlanStartedAt)
	}
	if m.plan_finished_at != nil {
		fields = append(fields, missionorder.FieldPlanFinishedAt)
	}
	if m.expired_warning_time != nil {
		fields = append(fields, missionorder.FieldExpiredWarningTime)
	}
	if m.mission_batch != nil {
		fields = append(fields, missionorder.FieldMissionBatchID)
	}
	if m.mission_batch_number != nil {
		fields = append(fields, missionorder.FieldMissionBatchNumber)
	}
	if m.device != nil {
		fields = append(fields, missionorder.FieldDeviceID)
	}
	if m.total_amount != nil {
		fields = append(fields, missionorder.FieldTotalAmount)
	}
	if m.settled_amount != nil {
		fields = append(fields, missionorder.FieldSettledAmount)
	}
	if m.settled_count != nil {
		fields = append(fields, missionorder.FieldSettledCount)
	}
	if m.total_settle_count != nil {
		fields = append(fields, missionorder.FieldTotalSettleCount)
	}
	if m.lately_settled_at != nil {
		fields = append(fields, missionorder.FieldLatelySettledAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionorder.FieldCreatedBy:
		return m.CreatedBy()
	case missionorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionorder.FieldCreatedAt:
		return m.CreatedAt()
	case missionorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionorder.FieldDeletedAt:
		return m.DeletedAt()
	case missionorder.FieldMissionID:
		return m.MissionID()
	case missionorder.FieldStatus:
		return m.Status()
	case missionorder.FieldSymbolID:
		return m.SymbolID()
	case missionorder.FieldConsumeUserID:
		return m.ConsumeUserID()
	case missionorder.FieldConsumeAmount:
		return m.ConsumeAmount()
	case missionorder.FieldProduceUserID:
		return m.ProduceUserID()
	case missionorder.FieldProduceAmount:
		return m.ProduceAmount()
	case missionorder.FieldGasAmount:
		return m.GasAmount()
	case missionorder.FieldMissionType:
		return m.MissionType()
	case missionorder.FieldMissionBillingType:
		return m.MissionBillingType()
	case missionorder.FieldCallWay:
		return m.CallWay()
	case missionorder.FieldSerialNumber:
		return m.SerialNumber()
	case missionorder.FieldStartedAt:
		return m.StartedAt()
	case missionorder.FieldFinishedAt:
		return m.FinishedAt()
	case missionorder.FieldBuyDuration:
		return m.BuyDuration()
	case missionorder.FieldPlanStartedAt:
		return m.PlanStartedAt()
	case missionorder.FieldPlanFinishedAt:
		return m.PlanFinishedAt()
	case missionorder.FieldExpiredWarningTime:
		return m.ExpiredWarningTime()
	case missionorder.FieldMissionBatchID:
		return m.MissionBatchID()
	case missionorder.FieldMissionBatchNumber:
		return m.MissionBatchNumber()
	case missionorder.FieldDeviceID:
		return m.DeviceID()
	case missionorder.FieldTotalAmount:
		return m.TotalAmount()
	case missionorder.FieldSettledAmount:
		return m.SettledAmount()
	case missionorder.FieldSettledCount:
		return m.SettledCount()
	case missionorder.FieldTotalSettleCount:
		return m.TotalSettleCount()
	case missionorder.FieldLatelySettledAt:
		return m.LatelySettledAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionorder.FieldStatus:
		return m.OldStatus(ctx)
	case missionorder.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case missionorder.FieldConsumeUserID:
		return m.OldConsumeUserID(ctx)
	case missionorder.FieldConsumeAmount:
		return m.OldConsumeAmount(ctx)
	case missionorder.FieldProduceUserID:
		return m.OldProduceUserID(ctx)
	case missionorder.FieldProduceAmount:
		return m.OldProduceAmount(ctx)
	case missionorder.FieldGasAmount:
		return m.OldGasAmount(ctx)
	case missionorder.FieldMissionType:
		return m.OldMissionType(ctx)
	case missionorder.FieldMissionBillingType:
		return m.OldMissionBillingType(ctx)
	case missionorder.FieldCallWay:
		return m.OldCallWay(ctx)
	case missionorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case missionorder.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionorder.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionorder.FieldBuyDuration:
		return m.OldBuyDuration(ctx)
	case missionorder.FieldPlanStartedAt:
		return m.OldPlanStartedAt(ctx)
	case missionorder.FieldPlanFinishedAt:
		return m.OldPlanFinishedAt(ctx)
	case missionorder.FieldExpiredWarningTime:
		return m.OldExpiredWarningTime(ctx)
	case missionorder.FieldMissionBatchID:
		return m.OldMissionBatchID(ctx)
	case missionorder.FieldMissionBatchNumber:
		return m.OldMissionBatchNumber(ctx)
	case missionorder.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionorder.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case missionorder.FieldSettledAmount:
		return m.OldSettledAmount(ctx)
	case missionorder.FieldSettledCount:
		return m.OldSettledCount(ctx)
	case missionorder.FieldTotalSettleCount:
		return m.OldTotalSettleCount(ctx)
	case missionorder.FieldLatelySettledAt:
		return m.OldLatelySettledAt(ctx)
	}
	return nil, fmt.Errorf("unknown MissionOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionorder.FieldStatus:
		v, ok := value.(enums.MissionOrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case missionorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case missionorder.FieldConsumeUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumeUserID(v)
		return nil
	case missionorder.FieldConsumeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumeAmount(v)
		return nil
	case missionorder.FieldProduceUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduceUserID(v)
		return nil
	case missionorder.FieldProduceAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduceAmount(v)
		return nil
	case missionorder.FieldGasAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGasAmount(v)
		return nil
	case missionorder.FieldMissionType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case missionorder.FieldMissionBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBillingType(v)
		return nil
	case missionorder.FieldCallWay:
		v, ok := value.(enums.MissionCallWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallWay(v)
		return nil
	case missionorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case missionorder.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionorder.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionorder.FieldBuyDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyDuration(v)
		return nil
	case missionorder.FieldPlanStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanStartedAt(v)
		return nil
	case missionorder.FieldPlanFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanFinishedAt(v)
		return nil
	case missionorder.FieldExpiredWarningTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredWarningTime(v)
		return nil
	case missionorder.FieldMissionBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchID(v)
		return nil
	case missionorder.FieldMissionBatchNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchNumber(v)
		return nil
	case missionorder.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionorder.FieldTotalAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case missionorder.FieldSettledAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledAmount(v)
		return nil
	case missionorder.FieldSettledCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledCount(v)
		return nil
	case missionorder.FieldTotalSettleCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSettleCount(v)
		return nil
	case missionorder.FieldLatelySettledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatelySettledAt(v)
		return nil
	}
	return fmt.Errorf("unknown MissionOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionorder.FieldUpdatedBy)
	}
	if m.addconsume_amount != nil {
		fields = append(fields, missionorder.FieldConsumeAmount)
	}
	if m.addproduce_amount != nil {
		fields = append(fields, missionorder.FieldProduceAmount)
	}
	if m.addgas_amount != nil {
		fields = append(fields, missionorder.FieldGasAmount)
	}
	if m.addbuy_duration != nil {
		fields = append(fields, missionorder.FieldBuyDuration)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, missionorder.FieldTotalAmount)
	}
	if m.addsettled_amount != nil {
		fields = append(fields, missionorder.FieldSettledAmount)
	}
	if m.addsettled_count != nil {
		fields = append(fields, missionorder.FieldSettledCount)
	}
	if m.addtotal_settle_count != nil {
		fields = append(fields, missionorder.FieldTotalSettleCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionorder.FieldConsumeAmount:
		return m.AddedConsumeAmount()
	case missionorder.FieldProduceAmount:
		return m.AddedProduceAmount()
	case missionorder.FieldGasAmount:
		return m.AddedGasAmount()
	case missionorder.FieldBuyDuration:
		return m.AddedBuyDuration()
	case missionorder.FieldTotalAmount:
		return m.AddedTotalAmount()
	case missionorder.FieldSettledAmount:
		return m.AddedSettledAmount()
	case missionorder.FieldSettledCount:
		return m.AddedSettledCount()
	case missionorder.FieldTotalSettleCount:
		return m.AddedTotalSettleCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionorder.FieldConsumeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConsumeAmount(v)
		return nil
	case missionorder.FieldProduceAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProduceAmount(v)
		return nil
	case missionorder.FieldGasAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGasAmount(v)
		return nil
	case missionorder.FieldBuyDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuyDuration(v)
		return nil
	case missionorder.FieldTotalAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case missionorder.FieldSettledAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettledAmount(v)
		return nil
	case missionorder.FieldSettledCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettledCount(v)
		return nil
	case missionorder.FieldTotalSettleCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSettleCount(v)
		return nil
	}
	return fmt.Errorf("unknown MissionOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(missionorder.FieldPlanStartedAt) {
		fields = append(fields, missionorder.FieldPlanStartedAt)
	}
	if m.FieldCleared(missionorder.FieldPlanFinishedAt) {
		fields = append(fields, missionorder.FieldPlanFinishedAt)
	}
	if m.FieldCleared(missionorder.FieldExpiredWarningTime) {
		fields = append(fields, missionorder.FieldExpiredWarningTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionOrderMutation) ClearField(name string) error {
	switch name {
	case missionorder.FieldPlanStartedAt:
		m.ClearPlanStartedAt()
		return nil
	case missionorder.FieldPlanFinishedAt:
		m.ClearPlanFinishedAt()
		return nil
	case missionorder.FieldExpiredWarningTime:
		m.ClearExpiredWarningTime()
		return nil
	}
	return fmt.Errorf("unknown MissionOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionOrderMutation) ResetField(name string) error {
	switch name {
	case missionorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionorder.FieldStatus:
		m.ResetStatus()
		return nil
	case missionorder.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case missionorder.FieldConsumeUserID:
		m.ResetConsumeUserID()
		return nil
	case missionorder.FieldConsumeAmount:
		m.ResetConsumeAmount()
		return nil
	case missionorder.FieldProduceUserID:
		m.ResetProduceUserID()
		return nil
	case missionorder.FieldProduceAmount:
		m.ResetProduceAmount()
		return nil
	case missionorder.FieldGasAmount:
		m.ResetGasAmount()
		return nil
	case missionorder.FieldMissionType:
		m.ResetMissionType()
		return nil
	case missionorder.FieldMissionBillingType:
		m.ResetMissionBillingType()
		return nil
	case missionorder.FieldCallWay:
		m.ResetCallWay()
		return nil
	case missionorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case missionorder.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionorder.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionorder.FieldBuyDuration:
		m.ResetBuyDuration()
		return nil
	case missionorder.FieldPlanStartedAt:
		m.ResetPlanStartedAt()
		return nil
	case missionorder.FieldPlanFinishedAt:
		m.ResetPlanFinishedAt()
		return nil
	case missionorder.FieldExpiredWarningTime:
		m.ResetExpiredWarningTime()
		return nil
	case missionorder.FieldMissionBatchID:
		m.ResetMissionBatchID()
		return nil
	case missionorder.FieldMissionBatchNumber:
		m.ResetMissionBatchNumber()
		return nil
	case missionorder.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionorder.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case missionorder.FieldSettledAmount:
		m.ResetSettledAmount()
		return nil
	case missionorder.FieldSettledCount:
		m.ResetSettledCount()
		return nil
	case missionorder.FieldTotalSettleCount:
		m.ResetTotalSettleCount()
		return nil
	case missionorder.FieldLatelySettledAt:
		m.ResetLatelySettledAt()
		return nil
	}
	return fmt.Errorf("unknown MissionOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.consume_user != nil {
		edges = append(edges, missionorder.EdgeConsumeUser)
	}
	if m.produce_user != nil {
		edges = append(edges, missionorder.EdgeProduceUser)
	}
	if m.symbol != nil {
		edges = append(edges, missionorder.EdgeSymbol)
	}
	if m.bills != nil {
		edges = append(edges, missionorder.EdgeBills)
	}
	if m.mission_batch != nil {
		edges = append(edges, missionorder.EdgeMissionBatch)
	}
	if m.mission != nil {
		edges = append(edges, missionorder.EdgeMission)
	}
	if m.device != nil {
		edges = append(edges, missionorder.EdgeDevice)
	}
	if m.extra_service_orders != nil {
		edges = append(edges, missionorder.EdgeExtraServiceOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionorder.EdgeConsumeUser:
		if id := m.consume_user; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeProduceUser:
		if id := m.produce_user; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case missionorder.EdgeMissionBatch:
		if id := m.mission_batch; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case missionorder.EdgeExtraServiceOrders:
		ids := make([]ent.Value, 0, len(m.extra_service_orders))
		for id := range m.extra_service_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedbills != nil {
		edges = append(edges, missionorder.EdgeBills)
	}
	if m.removedextra_service_orders != nil {
		edges = append(edges, missionorder.EdgeExtraServiceOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	case missionorder.EdgeExtraServiceOrders:
		ids := make([]ent.Value, 0, len(m.removedextra_service_orders))
		for id := range m.removedextra_service_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedconsume_user {
		edges = append(edges, missionorder.EdgeConsumeUser)
	}
	if m.clearedproduce_user {
		edges = append(edges, missionorder.EdgeProduceUser)
	}
	if m.clearedsymbol {
		edges = append(edges, missionorder.EdgeSymbol)
	}
	if m.clearedbills {
		edges = append(edges, missionorder.EdgeBills)
	}
	if m.clearedmission_batch {
		edges = append(edges, missionorder.EdgeMissionBatch)
	}
	if m.clearedmission {
		edges = append(edges, missionorder.EdgeMission)
	}
	if m.cleareddevice {
		edges = append(edges, missionorder.EdgeDevice)
	}
	if m.clearedextra_service_orders {
		edges = append(edges, missionorder.EdgeExtraServiceOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case missionorder.EdgeConsumeUser:
		return m.clearedconsume_user
	case missionorder.EdgeProduceUser:
		return m.clearedproduce_user
	case missionorder.EdgeSymbol:
		return m.clearedsymbol
	case missionorder.EdgeBills:
		return m.clearedbills
	case missionorder.EdgeMissionBatch:
		return m.clearedmission_batch
	case missionorder.EdgeMission:
		return m.clearedmission
	case missionorder.EdgeDevice:
		return m.cleareddevice
	case missionorder.EdgeExtraServiceOrders:
		return m.clearedextra_service_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionOrderMutation) ClearEdge(name string) error {
	switch name {
	case missionorder.EdgeConsumeUser:
		m.ClearConsumeUser()
		return nil
	case missionorder.EdgeProduceUser:
		m.ClearProduceUser()
		return nil
	case missionorder.EdgeSymbol:
		m.ClearSymbol()
		return nil
	case missionorder.EdgeMissionBatch:
		m.ClearMissionBatch()
		return nil
	case missionorder.EdgeMission:
		m.ClearMission()
		return nil
	case missionorder.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown MissionOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionOrderMutation) ResetEdge(name string) error {
	switch name {
	case missionorder.EdgeConsumeUser:
		m.ResetConsumeUser()
		return nil
	case missionorder.EdgeProduceUser:
		m.ResetProduceUser()
		return nil
	case missionorder.EdgeSymbol:
		m.ResetSymbol()
		return nil
	case missionorder.EdgeBills:
		m.ResetBills()
		return nil
	case missionorder.EdgeMissionBatch:
		m.ResetMissionBatch()
		return nil
	case missionorder.EdgeMission:
		m.ResetMission()
		return nil
	case missionorder.EdgeDevice:
		m.ResetDevice()
		return nil
	case missionorder.EdgeExtraServiceOrders:
		m.ResetExtraServiceOrders()
		return nil
	}
	return fmt.Errorf("unknown MissionOrder edge %s", name)
}

// MissionProduceOrderMutation represents an operation that mutates the MissionProduceOrder nodes in the graph.
type MissionProduceOrderMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_by                   *int64
	addcreated_by                *int64
	updated_by                   *int64
	addupdated_by                *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	mission_id                   *int64
	addmission_id                *int64
	status                       *enums.MissionOrderStatus
	pure_cep                     *int64
	addpure_cep                  *int64
	gift_cep                     *int64
	addgift_cep                  *int64
	symbol_id                    *int64
	addsymbol_id                 *int64
	amount                       *int64
	addamount                    *int64
	_type                        *enums.MissionType
	is_time                      *bool
	serial_number                *string
	clearedFields                map[string]struct{}
	user                         *int64
	cleareduser                  bool
	earn_bills                   map[int64]struct{}
	removedearn_bills            map[int64]struct{}
	clearedearn_bills            bool
	device                       *int64
	cleareddevice                bool
	mission_consume_order        *int64
	clearedmission_consume_order bool
	mission_production           *int64
	clearedmission_production    bool
	done                         bool
	oldValue                     func(context.Context) (*MissionProduceOrder, error)
	predicates                   []predicate.MissionProduceOrder
}

var _ ent.Mutation = (*MissionProduceOrderMutation)(nil)

// missionproduceorderOption allows management of the mutation configuration using functional options.
type missionproduceorderOption func(*MissionProduceOrderMutation)

// newMissionProduceOrderMutation creates new mutation for the MissionProduceOrder entity.
func newMissionProduceOrderMutation(c config, op Op, opts ...missionproduceorderOption) *MissionProduceOrderMutation {
	m := &MissionProduceOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionProduceOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionProduceOrderID sets the ID field of the mutation.
func withMissionProduceOrderID(id int64) missionproduceorderOption {
	return func(m *MissionProduceOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionProduceOrder
		)
		m.oldValue = func(ctx context.Context) (*MissionProduceOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionProduceOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionProduceOrder sets the old MissionProduceOrder of the mutation.
func withMissionProduceOrder(node *MissionProduceOrder) missionproduceorderOption {
	return func(m *MissionProduceOrderMutation) {
		m.oldValue = func(context.Context) (*MissionProduceOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionProduceOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionProduceOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionProduceOrder entities.
func (m *MissionProduceOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionProduceOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionProduceOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionProduceOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionProduceOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionProduceOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionProduceOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionProduceOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionProduceOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionProduceOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionProduceOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionProduceOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionProduceOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionProduceOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionProduceOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionProduceOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionProduceOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionProduceOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionProduceOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionProduceOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionProduceOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionProduceOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionProduceOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionProduceOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionProduceOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionProduceOrderMutation) ResetUserID() {
	m.user = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionProduceOrderMutation) SetMissionID(i int64) {
	m.mission_id = &i
	m.addmission_id = nil
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionProduceOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// AddMissionID adds i to the "mission_id" field.
func (m *MissionProduceOrderMutation) AddMissionID(i int64) {
	if m.addmission_id != nil {
		*m.addmission_id += i
	} else {
		m.addmission_id = &i
	}
}

// AddedMissionID returns the value that was added to the "mission_id" field in this mutation.
func (m *MissionProduceOrderMutation) AddedMissionID() (r int64, exists bool) {
	v := m.addmission_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionProduceOrderMutation) ResetMissionID() {
	m.mission_id = nil
	m.addmission_id = nil
}

// SetMissionProductionID sets the "mission_production_id" field.
func (m *MissionProduceOrderMutation) SetMissionProductionID(i int64) {
	m.mission_production = &i
}

// MissionProductionID returns the value of the "mission_production_id" field in the mutation.
func (m *MissionProduceOrderMutation) MissionProductionID() (r int64, exists bool) {
	v := m.mission_production
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionProductionID returns the old "mission_production_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldMissionProductionID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionProductionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionProductionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionProductionID: %w", err)
	}
	return oldValue.MissionProductionID, nil
}

// ClearMissionProductionID clears the value of the "mission_production_id" field.
func (m *MissionProduceOrderMutation) ClearMissionProductionID() {
	m.mission_production = nil
	m.clearedFields[missionproduceorder.FieldMissionProductionID] = struct{}{}
}

// MissionProductionIDCleared returns if the "mission_production_id" field was cleared in this mutation.
func (m *MissionProduceOrderMutation) MissionProductionIDCleared() bool {
	_, ok := m.clearedFields[missionproduceorder.FieldMissionProductionID]
	return ok
}

// ResetMissionProductionID resets all changes to the "mission_production_id" field.
func (m *MissionProduceOrderMutation) ResetMissionProductionID() {
	m.mission_production = nil
	delete(m.clearedFields, missionproduceorder.FieldMissionProductionID)
}

// SetStatus sets the "status" field.
func (m *MissionProduceOrderMutation) SetStatus(eos enums.MissionOrderStatus) {
	m.status = &eos
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionProduceOrderMutation) Status() (r enums.MissionOrderStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldStatus(ctx context.Context) (v enums.MissionOrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionProduceOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *MissionProduceOrderMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *MissionProduceOrderMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *MissionProduceOrderMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *MissionProduceOrderMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *MissionProduceOrderMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *MissionProduceOrderMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *MissionProduceOrderMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *MissionProduceOrderMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *MissionProduceOrderMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *MissionProduceOrderMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *MissionProduceOrderMutation) SetSymbolID(i int64) {
	m.symbol_id = &i
	m.addsymbol_id = nil
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *MissionProduceOrderMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// AddSymbolID adds i to the "symbol_id" field.
func (m *MissionProduceOrderMutation) AddSymbolID(i int64) {
	if m.addsymbol_id != nil {
		*m.addsymbol_id += i
	} else {
		m.addsymbol_id = &i
	}
}

// AddedSymbolID returns the value that was added to the "symbol_id" field in this mutation.
func (m *MissionProduceOrderMutation) AddedSymbolID() (r int64, exists bool) {
	v := m.addsymbol_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *MissionProduceOrderMutation) ResetSymbolID() {
	m.symbol_id = nil
	m.addsymbol_id = nil
}

// SetAmount sets the "amount" field.
func (m *MissionProduceOrderMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *MissionProduceOrderMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *MissionProduceOrderMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *MissionProduceOrderMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *MissionProduceOrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetType sets the "type" field.
func (m *MissionProduceOrderMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionProduceOrderMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionProduceOrderMutation) ResetType() {
	m._type = nil
}

// SetIsTime sets the "is_time" field.
func (m *MissionProduceOrderMutation) SetIsTime(b bool) {
	m.is_time = &b
}

// IsTime returns the value of the "is_time" field in the mutation.
func (m *MissionProduceOrderMutation) IsTime() (r bool, exists bool) {
	v := m.is_time
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTime returns the old "is_time" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldIsTime(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTime: %w", err)
	}
	return oldValue.IsTime, nil
}

// ResetIsTime resets all changes to the "is_time" field.
func (m *MissionProduceOrderMutation) ResetIsTime() {
	m.is_time = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionProduceOrderMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionProduceOrderMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionProduceOrderMutation) ResetDeviceID() {
	m.device = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *MissionProduceOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MissionProduceOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MissionProduceOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetMissionConsumeOrderID sets the "mission_consume_order_id" field.
func (m *MissionProduceOrderMutation) SetMissionConsumeOrderID(i int64) {
	m.mission_consume_order = &i
}

// MissionConsumeOrderID returns the value of the "mission_consume_order_id" field in the mutation.
func (m *MissionProduceOrderMutation) MissionConsumeOrderID() (r int64, exists bool) {
	v := m.mission_consume_order
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionConsumeOrderID returns the old "mission_consume_order_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldMissionConsumeOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionConsumeOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionConsumeOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionConsumeOrderID: %w", err)
	}
	return oldValue.MissionConsumeOrderID, nil
}

// ResetMissionConsumeOrderID resets all changes to the "mission_consume_order_id" field.
func (m *MissionProduceOrderMutation) ResetMissionConsumeOrderID() {
	m.mission_consume_order = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionProduceOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionproduceorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionProduceOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionProduceOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *MissionProduceOrderMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *MissionProduceOrderMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *MissionProduceOrderMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *MissionProduceOrderMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *MissionProduceOrderMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *MissionProduceOrderMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *MissionProduceOrderMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *MissionProduceOrderMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[missionproduceorder.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *MissionProduceOrderMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *MissionProduceOrderMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// ClearMissionConsumeOrder clears the "mission_consume_order" edge to the MissionConsumeOrder entity.
func (m *MissionProduceOrderMutation) ClearMissionConsumeOrder() {
	m.clearedmission_consume_order = true
	m.clearedFields[missionproduceorder.FieldMissionConsumeOrderID] = struct{}{}
}

// MissionConsumeOrderCleared reports if the "mission_consume_order" edge to the MissionConsumeOrder entity was cleared.
func (m *MissionProduceOrderMutation) MissionConsumeOrderCleared() bool {
	return m.clearedmission_consume_order
}

// MissionConsumeOrderIDs returns the "mission_consume_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionConsumeOrderID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) MissionConsumeOrderIDs() (ids []int64) {
	if id := m.mission_consume_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionConsumeOrder resets all changes to the "mission_consume_order" edge.
func (m *MissionProduceOrderMutation) ResetMissionConsumeOrder() {
	m.mission_consume_order = nil
	m.clearedmission_consume_order = false
}

// ClearMissionProduction clears the "mission_production" edge to the MissionProduction entity.
func (m *MissionProduceOrderMutation) ClearMissionProduction() {
	m.clearedmission_production = true
	m.clearedFields[missionproduceorder.FieldMissionProductionID] = struct{}{}
}

// MissionProductionCleared reports if the "mission_production" edge to the MissionProduction entity was cleared.
func (m *MissionProduceOrderMutation) MissionProductionCleared() bool {
	return m.MissionProductionIDCleared() || m.clearedmission_production
}

// MissionProductionIDs returns the "mission_production" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionProductionID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) MissionProductionIDs() (ids []int64) {
	if id := m.mission_production; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionProduction resets all changes to the "mission_production" edge.
func (m *MissionProduceOrderMutation) ResetMissionProduction() {
	m.mission_production = nil
	m.clearedmission_production = false
}

// Where appends a list predicates to the MissionProduceOrderMutation builder.
func (m *MissionProduceOrderMutation) Where(ps ...predicate.MissionProduceOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionProduceOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionProduceOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionProduceOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionProduceOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionProduceOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionProduceOrder).
func (m *MissionProduceOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionProduceOrderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_by != nil {
		fields = append(fields, missionproduceorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionproduceorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionproduceorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionproduceorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionproduceorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, missionproduceorder.FieldUserID)
	}
	if m.mission_id != nil {
		fields = append(fields, missionproduceorder.FieldMissionID)
	}
	if m.mission_production != nil {
		fields = append(fields, missionproduceorder.FieldMissionProductionID)
	}
	if m.status != nil {
		fields = append(fields, missionproduceorder.FieldStatus)
	}
	if m.pure_cep != nil {
		fields = append(fields, missionproduceorder.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, missionproduceorder.FieldGiftCep)
	}
	if m.symbol_id != nil {
		fields = append(fields, missionproduceorder.FieldSymbolID)
	}
	if m.amount != nil {
		fields = append(fields, missionproduceorder.FieldAmount)
	}
	if m._type != nil {
		fields = append(fields, missionproduceorder.FieldType)
	}
	if m.is_time != nil {
		fields = append(fields, missionproduceorder.FieldIsTime)
	}
	if m.device != nil {
		fields = append(fields, missionproduceorder.FieldDeviceID)
	}
	if m.serial_number != nil {
		fields = append(fields, missionproduceorder.FieldSerialNumber)
	}
	if m.mission_consume_order != nil {
		fields = append(fields, missionproduceorder.FieldMissionConsumeOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionProduceOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		return m.CreatedBy()
	case missionproduceorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionproduceorder.FieldCreatedAt:
		return m.CreatedAt()
	case missionproduceorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionproduceorder.FieldDeletedAt:
		return m.DeletedAt()
	case missionproduceorder.FieldUserID:
		return m.UserID()
	case missionproduceorder.FieldMissionID:
		return m.MissionID()
	case missionproduceorder.FieldMissionProductionID:
		return m.MissionProductionID()
	case missionproduceorder.FieldStatus:
		return m.Status()
	case missionproduceorder.FieldPureCep:
		return m.PureCep()
	case missionproduceorder.FieldGiftCep:
		return m.GiftCep()
	case missionproduceorder.FieldSymbolID:
		return m.SymbolID()
	case missionproduceorder.FieldAmount:
		return m.Amount()
	case missionproduceorder.FieldType:
		return m.GetType()
	case missionproduceorder.FieldIsTime:
		return m.IsTime()
	case missionproduceorder.FieldDeviceID:
		return m.DeviceID()
	case missionproduceorder.FieldSerialNumber:
		return m.SerialNumber()
	case missionproduceorder.FieldMissionConsumeOrderID:
		return m.MissionConsumeOrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionProduceOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionproduceorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionproduceorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionproduceorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionproduceorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionproduceorder.FieldUserID:
		return m.OldUserID(ctx)
	case missionproduceorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionproduceorder.FieldMissionProductionID:
		return m.OldMissionProductionID(ctx)
	case missionproduceorder.FieldStatus:
		return m.OldStatus(ctx)
	case missionproduceorder.FieldPureCep:
		return m.OldPureCep(ctx)
	case missionproduceorder.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case missionproduceorder.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case missionproduceorder.FieldAmount:
		return m.OldAmount(ctx)
	case missionproduceorder.FieldType:
		return m.OldType(ctx)
	case missionproduceorder.FieldIsTime:
		return m.OldIsTime(ctx)
	case missionproduceorder.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionproduceorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case missionproduceorder.FieldMissionConsumeOrderID:
		return m.OldMissionConsumeOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown MissionProduceOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProduceOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionproduceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionproduceorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionproduceorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionproduceorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionproduceorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case missionproduceorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionproduceorder.FieldMissionProductionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionProductionID(v)
		return nil
	case missionproduceorder.FieldStatus:
		v, ok := value.(enums.MissionOrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case missionproduceorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case missionproduceorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case missionproduceorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case missionproduceorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case missionproduceorder.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionproduceorder.FieldIsTime:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTime(v)
		return nil
	case missionproduceorder.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionproduceorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case missionproduceorder.FieldMissionConsumeOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionConsumeOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionProduceOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionproduceorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionproduceorder.FieldUpdatedBy)
	}
	if m.addmission_id != nil {
		fields = append(fields, missionproduceorder.FieldMissionID)
	}
	if m.addpure_cep != nil {
		fields = append(fields, missionproduceorder.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, missionproduceorder.FieldGiftCep)
	}
	if m.addsymbol_id != nil {
		fields = append(fields, missionproduceorder.FieldSymbolID)
	}
	if m.addamount != nil {
		fields = append(fields, missionproduceorder.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionProduceOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionproduceorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionproduceorder.FieldMissionID:
		return m.AddedMissionID()
	case missionproduceorder.FieldPureCep:
		return m.AddedPureCep()
	case missionproduceorder.FieldGiftCep:
		return m.AddedGiftCep()
	case missionproduceorder.FieldSymbolID:
		return m.AddedSymbolID()
	case missionproduceorder.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProduceOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionproduceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionproduceorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMissionID(v)
		return nil
	case missionproduceorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case missionproduceorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case missionproduceorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSymbolID(v)
		return nil
	case missionproduceorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionProduceOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(missionproduceorder.FieldMissionProductionID) {
		fields = append(fields, missionproduceorder.FieldMissionProductionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionProduceOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionProduceOrderMutation) ClearField(name string) error {
	switch name {
	case missionproduceorder.FieldMissionProductionID:
		m.ClearMissionProductionID()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionProduceOrderMutation) ResetField(name string) error {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionproduceorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionproduceorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionproduceorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionproduceorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionproduceorder.FieldUserID:
		m.ResetUserID()
		return nil
	case missionproduceorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionproduceorder.FieldMissionProductionID:
		m.ResetMissionProductionID()
		return nil
	case missionproduceorder.FieldStatus:
		m.ResetStatus()
		return nil
	case missionproduceorder.FieldPureCep:
		m.ResetPureCep()
		return nil
	case missionproduceorder.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case missionproduceorder.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case missionproduceorder.FieldAmount:
		m.ResetAmount()
		return nil
	case missionproduceorder.FieldType:
		m.ResetType()
		return nil
	case missionproduceorder.FieldIsTime:
		m.ResetIsTime()
		return nil
	case missionproduceorder.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionproduceorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case missionproduceorder.FieldMissionConsumeOrderID:
		m.ResetMissionConsumeOrderID()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionProduceOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, missionproduceorder.EdgeUser)
	}
	if m.earn_bills != nil {
		edges = append(edges, missionproduceorder.EdgeEarnBills)
	}
	if m.device != nil {
		edges = append(edges, missionproduceorder.EdgeDevice)
	}
	if m.mission_consume_order != nil {
		edges = append(edges, missionproduceorder.EdgeMissionConsumeOrder)
	}
	if m.mission_production != nil {
		edges = append(edges, missionproduceorder.EdgeMissionProduction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionProduceOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionproduceorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionproduceorder.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	case missionproduceorder.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case missionproduceorder.EdgeMissionConsumeOrder:
		if id := m.mission_consume_order; id != nil {
			return []ent.Value{*id}
		}
	case missionproduceorder.EdgeMissionProduction:
		if id := m.mission_production; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionProduceOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedearn_bills != nil {
		edges = append(edges, missionproduceorder.EdgeEarnBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionProduceOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionproduceorder.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionProduceOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, missionproduceorder.EdgeUser)
	}
	if m.clearedearn_bills {
		edges = append(edges, missionproduceorder.EdgeEarnBills)
	}
	if m.cleareddevice {
		edges = append(edges, missionproduceorder.EdgeDevice)
	}
	if m.clearedmission_consume_order {
		edges = append(edges, missionproduceorder.EdgeMissionConsumeOrder)
	}
	if m.clearedmission_production {
		edges = append(edges, missionproduceorder.EdgeMissionProduction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionProduceOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case missionproduceorder.EdgeUser:
		return m.cleareduser
	case missionproduceorder.EdgeEarnBills:
		return m.clearedearn_bills
	case missionproduceorder.EdgeDevice:
		return m.cleareddevice
	case missionproduceorder.EdgeMissionConsumeOrder:
		return m.clearedmission_consume_order
	case missionproduceorder.EdgeMissionProduction:
		return m.clearedmission_production
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionProduceOrderMutation) ClearEdge(name string) error {
	switch name {
	case missionproduceorder.EdgeUser:
		m.ClearUser()
		return nil
	case missionproduceorder.EdgeDevice:
		m.ClearDevice()
		return nil
	case missionproduceorder.EdgeMissionConsumeOrder:
		m.ClearMissionConsumeOrder()
		return nil
	case missionproduceorder.EdgeMissionProduction:
		m.ClearMissionProduction()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionProduceOrderMutation) ResetEdge(name string) error {
	switch name {
	case missionproduceorder.EdgeUser:
		m.ResetUser()
		return nil
	case missionproduceorder.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	case missionproduceorder.EdgeDevice:
		m.ResetDevice()
		return nil
	case missionproduceorder.EdgeMissionConsumeOrder:
		m.ResetMissionConsumeOrder()
		return nil
	case missionproduceorder.EdgeMissionProduction:
		m.ResetMissionProduction()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder edge %s", name)
}

// MissionProductionMutation represents an operation that mutates the MissionProduction nodes in the graph.
type MissionProductionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_by                   *int64
	addcreated_by                *int64
	updated_by                   *int64
	addupdated_by                *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	started_at                   *time.Time
	finished_at                  *time.Time
	state                        *enums.MissionState
	gpu_version                  *enums.GpuVersion
	device_slot                  *int8
	adddevice_slot               *int8
	urls                         *string
	resp_status_code             *int32
	addresp_status_code          *int32
	resp_body                    *string
	clearedFields                map[string]struct{}
	mission                      *int64
	clearedmission               bool
	user                         *int64
	cleareduser                  bool
	device                       *int64
	cleareddevice                bool
	mission_produce_order        *int64
	clearedmission_produce_order bool
	done                         bool
	oldValue                     func(context.Context) (*MissionProduction, error)
	predicates                   []predicate.MissionProduction
}

var _ ent.Mutation = (*MissionProductionMutation)(nil)

// missionproductionOption allows management of the mutation configuration using functional options.
type missionproductionOption func(*MissionProductionMutation)

// newMissionProductionMutation creates new mutation for the MissionProduction entity.
func newMissionProductionMutation(c config, op Op, opts ...missionproductionOption) *MissionProductionMutation {
	m := &MissionProductionMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionProduction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionProductionID sets the ID field of the mutation.
func withMissionProductionID(id int64) missionproductionOption {
	return func(m *MissionProductionMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionProduction
		)
		m.oldValue = func(ctx context.Context) (*MissionProduction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionProduction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionProduction sets the old MissionProduction of the mutation.
func withMissionProduction(node *MissionProduction) missionproductionOption {
	return func(m *MissionProductionMutation) {
		m.oldValue = func(context.Context) (*MissionProduction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionProductionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionProductionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionProduction entities.
func (m *MissionProductionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionProductionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionProductionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionProduction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionProductionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionProductionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionProductionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionProductionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionProductionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionProductionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionProductionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionProductionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionProductionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionProductionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionProductionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionProductionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionProductionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionProductionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionProductionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionProductionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionProductionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionProductionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionProductionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionProductionMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionProductionMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionProductionMutation) ResetMissionID() {
	m.mission = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionProductionMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionProductionMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionProductionMutation) ResetUserID() {
	m.user = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionProductionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionProductionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionProductionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionProductionMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionProductionMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionProductionMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetState sets the "state" field.
func (m *MissionProductionMutation) SetState(es enums.MissionState) {
	m.state = &es
}

// State returns the value of the "state" field in the mutation.
func (m *MissionProductionMutation) State() (r enums.MissionState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldState(ctx context.Context) (v enums.MissionState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *MissionProductionMutation) ResetState() {
	m.state = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionProductionMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionProductionMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionProductionMutation) ResetDeviceID() {
	m.device = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *MissionProductionMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *MissionProductionMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *MissionProductionMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetDeviceSlot sets the "device_slot" field.
func (m *MissionProductionMutation) SetDeviceSlot(i int8) {
	m.device_slot = &i
	m.adddevice_slot = nil
}

// DeviceSlot returns the value of the "device_slot" field in the mutation.
func (m *MissionProductionMutation) DeviceSlot() (r int8, exists bool) {
	v := m.device_slot
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceSlot returns the old "device_slot" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldDeviceSlot(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceSlot: %w", err)
	}
	return oldValue.DeviceSlot, nil
}

// AddDeviceSlot adds i to the "device_slot" field.
func (m *MissionProductionMutation) AddDeviceSlot(i int8) {
	if m.adddevice_slot != nil {
		*m.adddevice_slot += i
	} else {
		m.adddevice_slot = &i
	}
}

// AddedDeviceSlot returns the value that was added to the "device_slot" field in this mutation.
func (m *MissionProductionMutation) AddedDeviceSlot() (r int8, exists bool) {
	v := m.adddevice_slot
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceSlot resets all changes to the "device_slot" field.
func (m *MissionProductionMutation) ResetDeviceSlot() {
	m.device_slot = nil
	m.adddevice_slot = nil
}

// SetUrls sets the "urls" field.
func (m *MissionProductionMutation) SetUrls(s string) {
	m.urls = &s
}

// Urls returns the value of the "urls" field in the mutation.
func (m *MissionProductionMutation) Urls() (r string, exists bool) {
	v := m.urls
	if v == nil {
		return
	}
	return *v, true
}

// OldUrls returns the old "urls" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldUrls(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrls: %w", err)
	}
	return oldValue.Urls, nil
}

// ResetUrls resets all changes to the "urls" field.
func (m *MissionProductionMutation) ResetUrls() {
	m.urls = nil
}

// SetRespStatusCode sets the "resp_status_code" field.
func (m *MissionProductionMutation) SetRespStatusCode(i int32) {
	m.resp_status_code = &i
	m.addresp_status_code = nil
}

// RespStatusCode returns the value of the "resp_status_code" field in the mutation.
func (m *MissionProductionMutation) RespStatusCode() (r int32, exists bool) {
	v := m.resp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRespStatusCode returns the old "resp_status_code" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldRespStatusCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespStatusCode: %w", err)
	}
	return oldValue.RespStatusCode, nil
}

// AddRespStatusCode adds i to the "resp_status_code" field.
func (m *MissionProductionMutation) AddRespStatusCode(i int32) {
	if m.addresp_status_code != nil {
		*m.addresp_status_code += i
	} else {
		m.addresp_status_code = &i
	}
}

// AddedRespStatusCode returns the value that was added to the "resp_status_code" field in this mutation.
func (m *MissionProductionMutation) AddedRespStatusCode() (r int32, exists bool) {
	v := m.addresp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetRespStatusCode resets all changes to the "resp_status_code" field.
func (m *MissionProductionMutation) ResetRespStatusCode() {
	m.resp_status_code = nil
	m.addresp_status_code = nil
}

// SetRespBody sets the "resp_body" field.
func (m *MissionProductionMutation) SetRespBody(s string) {
	m.resp_body = &s
}

// RespBody returns the value of the "resp_body" field in the mutation.
func (m *MissionProductionMutation) RespBody() (r string, exists bool) {
	v := m.resp_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRespBody returns the old "resp_body" field's value of the MissionProduction entity.
// If the MissionProduction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProductionMutation) OldRespBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespBody: %w", err)
	}
	return oldValue.RespBody, nil
}

// ResetRespBody resets all changes to the "resp_body" field.
func (m *MissionProductionMutation) ResetRespBody() {
	m.resp_body = nil
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionProductionMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionproduction.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionProductionMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionProductionMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionProductionMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionProductionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionproduction.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionProductionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionProductionMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionProductionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *MissionProductionMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[missionproduction.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *MissionProductionMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *MissionProductionMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *MissionProductionMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// SetMissionProduceOrderID sets the "mission_produce_order" edge to the MissionProduceOrder entity by id.
func (m *MissionProductionMutation) SetMissionProduceOrderID(id int64) {
	m.mission_produce_order = &id
}

// ClearMissionProduceOrder clears the "mission_produce_order" edge to the MissionProduceOrder entity.
func (m *MissionProductionMutation) ClearMissionProduceOrder() {
	m.clearedmission_produce_order = true
}

// MissionProduceOrderCleared reports if the "mission_produce_order" edge to the MissionProduceOrder entity was cleared.
func (m *MissionProductionMutation) MissionProduceOrderCleared() bool {
	return m.clearedmission_produce_order
}

// MissionProduceOrderID returns the "mission_produce_order" edge ID in the mutation.
func (m *MissionProductionMutation) MissionProduceOrderID() (id int64, exists bool) {
	if m.mission_produce_order != nil {
		return *m.mission_produce_order, true
	}
	return
}

// MissionProduceOrderIDs returns the "mission_produce_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionProduceOrderID instead. It exists only for internal usage by the builders.
func (m *MissionProductionMutation) MissionProduceOrderIDs() (ids []int64) {
	if id := m.mission_produce_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionProduceOrder resets all changes to the "mission_produce_order" edge.
func (m *MissionProductionMutation) ResetMissionProduceOrder() {
	m.mission_produce_order = nil
	m.clearedmission_produce_order = false
}

// Where appends a list predicates to the MissionProductionMutation builder.
func (m *MissionProductionMutation) Where(ps ...predicate.MissionProduction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionProductionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionProductionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionProduction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionProductionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionProductionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionProduction).
func (m *MissionProductionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionProductionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, missionproduction.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionproduction.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionproduction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionproduction.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionproduction.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, missionproduction.FieldMissionID)
	}
	if m.user != nil {
		fields = append(fields, missionproduction.FieldUserID)
	}
	if m.started_at != nil {
		fields = append(fields, missionproduction.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionproduction.FieldFinishedAt)
	}
	if m.state != nil {
		fields = append(fields, missionproduction.FieldState)
	}
	if m.device != nil {
		fields = append(fields, missionproduction.FieldDeviceID)
	}
	if m.gpu_version != nil {
		fields = append(fields, missionproduction.FieldGpuVersion)
	}
	if m.device_slot != nil {
		fields = append(fields, missionproduction.FieldDeviceSlot)
	}
	if m.urls != nil {
		fields = append(fields, missionproduction.FieldUrls)
	}
	if m.resp_status_code != nil {
		fields = append(fields, missionproduction.FieldRespStatusCode)
	}
	if m.resp_body != nil {
		fields = append(fields, missionproduction.FieldRespBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionProductionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionproduction.FieldCreatedBy:
		return m.CreatedBy()
	case missionproduction.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionproduction.FieldCreatedAt:
		return m.CreatedAt()
	case missionproduction.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionproduction.FieldDeletedAt:
		return m.DeletedAt()
	case missionproduction.FieldMissionID:
		return m.MissionID()
	case missionproduction.FieldUserID:
		return m.UserID()
	case missionproduction.FieldStartedAt:
		return m.StartedAt()
	case missionproduction.FieldFinishedAt:
		return m.FinishedAt()
	case missionproduction.FieldState:
		return m.State()
	case missionproduction.FieldDeviceID:
		return m.DeviceID()
	case missionproduction.FieldGpuVersion:
		return m.GpuVersion()
	case missionproduction.FieldDeviceSlot:
		return m.DeviceSlot()
	case missionproduction.FieldUrls:
		return m.Urls()
	case missionproduction.FieldRespStatusCode:
		return m.RespStatusCode()
	case missionproduction.FieldRespBody:
		return m.RespBody()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionProductionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionproduction.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionproduction.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionproduction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionproduction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionproduction.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionproduction.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionproduction.FieldUserID:
		return m.OldUserID(ctx)
	case missionproduction.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionproduction.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionproduction.FieldState:
		return m.OldState(ctx)
	case missionproduction.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionproduction.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case missionproduction.FieldDeviceSlot:
		return m.OldDeviceSlot(ctx)
	case missionproduction.FieldUrls:
		return m.OldUrls(ctx)
	case missionproduction.FieldRespStatusCode:
		return m.OldRespStatusCode(ctx)
	case missionproduction.FieldRespBody:
		return m.OldRespBody(ctx)
	}
	return nil, fmt.Errorf("unknown MissionProduction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProductionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionproduction.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionproduction.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionproduction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionproduction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionproduction.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionproduction.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionproduction.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case missionproduction.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionproduction.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionproduction.FieldState:
		v, ok := value.(enums.MissionState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case missionproduction.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionproduction.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case missionproduction.FieldDeviceSlot:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceSlot(v)
		return nil
	case missionproduction.FieldUrls:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrls(v)
		return nil
	case missionproduction.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespStatusCode(v)
		return nil
	case missionproduction.FieldRespBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespBody(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionProductionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionproduction.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionproduction.FieldUpdatedBy)
	}
	if m.adddevice_slot != nil {
		fields = append(fields, missionproduction.FieldDeviceSlot)
	}
	if m.addresp_status_code != nil {
		fields = append(fields, missionproduction.FieldRespStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionProductionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionproduction.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionproduction.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionproduction.FieldDeviceSlot:
		return m.AddedDeviceSlot()
	case missionproduction.FieldRespStatusCode:
		return m.AddedRespStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProductionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionproduction.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionproduction.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionproduction.FieldDeviceSlot:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceSlot(v)
		return nil
	case missionproduction.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRespStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionProductionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionProductionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionProductionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionProduction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionProductionMutation) ResetField(name string) error {
	switch name {
	case missionproduction.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionproduction.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionproduction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionproduction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionproduction.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionproduction.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionproduction.FieldUserID:
		m.ResetUserID()
		return nil
	case missionproduction.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionproduction.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionproduction.FieldState:
		m.ResetState()
		return nil
	case missionproduction.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionproduction.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case missionproduction.FieldDeviceSlot:
		m.ResetDeviceSlot()
		return nil
	case missionproduction.FieldUrls:
		m.ResetUrls()
		return nil
	case missionproduction.FieldRespStatusCode:
		m.ResetRespStatusCode()
		return nil
	case missionproduction.FieldRespBody:
		m.ResetRespBody()
		return nil
	}
	return fmt.Errorf("unknown MissionProduction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionProductionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.mission != nil {
		edges = append(edges, missionproduction.EdgeMission)
	}
	if m.user != nil {
		edges = append(edges, missionproduction.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, missionproduction.EdgeDevice)
	}
	if m.mission_produce_order != nil {
		edges = append(edges, missionproduction.EdgeMissionProduceOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionProductionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionproduction.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case missionproduction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionproduction.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case missionproduction.EdgeMissionProduceOrder:
		if id := m.mission_produce_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionProductionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionProductionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionProductionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmission {
		edges = append(edges, missionproduction.EdgeMission)
	}
	if m.cleareduser {
		edges = append(edges, missionproduction.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, missionproduction.EdgeDevice)
	}
	if m.clearedmission_produce_order {
		edges = append(edges, missionproduction.EdgeMissionProduceOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionProductionMutation) EdgeCleared(name string) bool {
	switch name {
	case missionproduction.EdgeMission:
		return m.clearedmission
	case missionproduction.EdgeUser:
		return m.cleareduser
	case missionproduction.EdgeDevice:
		return m.cleareddevice
	case missionproduction.EdgeMissionProduceOrder:
		return m.clearedmission_produce_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionProductionMutation) ClearEdge(name string) error {
	switch name {
	case missionproduction.EdgeMission:
		m.ClearMission()
		return nil
	case missionproduction.EdgeUser:
		m.ClearUser()
		return nil
	case missionproduction.EdgeDevice:
		m.ClearDevice()
		return nil
	case missionproduction.EdgeMissionProduceOrder:
		m.ClearMissionProduceOrder()
		return nil
	}
	return fmt.Errorf("unknown MissionProduction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionProductionMutation) ResetEdge(name string) error {
	switch name {
	case missionproduction.EdgeMission:
		m.ResetMission()
		return nil
	case missionproduction.EdgeUser:
		m.ResetUser()
		return nil
	case missionproduction.EdgeDevice:
		m.ResetDevice()
		return nil
	case missionproduction.EdgeMissionProduceOrder:
		m.ResetMissionProduceOrder()
		return nil
	}
	return fmt.Errorf("unknown MissionProduction edge %s", name)
}

// OutputLogMutation represents an operation that mutates the OutputLog nodes in the graph.
type OutputLogMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	trace_id      *int64
	addtrace_id   *int64
	headers       *string
	body          *string
	url           *string
	ip            *string
	caller        *string
	status        *int16
	addstatus     *int16
	hmac_key      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OutputLog, error)
	predicates    []predicate.OutputLog
}

var _ ent.Mutation = (*OutputLogMutation)(nil)

// outputlogOption allows management of the mutation configuration using functional options.
type outputlogOption func(*OutputLogMutation)

// newOutputLogMutation creates new mutation for the OutputLog entity.
func newOutputLogMutation(c config, op Op, opts ...outputlogOption) *OutputLogMutation {
	m := &OutputLogMutation{
		config:        c,
		op:            op,
		typ:           TypeOutputLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutputLogID sets the ID field of the mutation.
func withOutputLogID(id int64) outputlogOption {
	return func(m *OutputLogMutation) {
		var (
			err   error
			once  sync.Once
			value *OutputLog
		)
		m.oldValue = func(ctx context.Context) (*OutputLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutputLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutputLog sets the old OutputLog of the mutation.
func withOutputLog(node *OutputLog) outputlogOption {
	return func(m *OutputLogMutation) {
		m.oldValue = func(context.Context) (*OutputLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutputLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutputLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OutputLog entities.
func (m *OutputLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutputLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutputLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutputLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OutputLogMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OutputLogMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OutputLogMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OutputLogMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OutputLogMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OutputLogMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OutputLogMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OutputLogMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OutputLogMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OutputLogMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OutputLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OutputLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OutputLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OutputLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OutputLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OutputLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OutputLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OutputLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OutputLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTraceID sets the "trace_id" field.
func (m *OutputLogMutation) SetTraceID(i int64) {
	m.trace_id = &i
	m.addtrace_id = nil
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *OutputLogMutation) TraceID() (r int64, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldTraceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// AddTraceID adds i to the "trace_id" field.
func (m *OutputLogMutation) AddTraceID(i int64) {
	if m.addtrace_id != nil {
		*m.addtrace_id += i
	} else {
		m.addtrace_id = &i
	}
}

// AddedTraceID returns the value that was added to the "trace_id" field in this mutation.
func (m *OutputLogMutation) AddedTraceID() (r int64, exists bool) {
	v := m.addtrace_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *OutputLogMutation) ResetTraceID() {
	m.trace_id = nil
	m.addtrace_id = nil
}

// SetHeaders sets the "headers" field.
func (m *OutputLogMutation) SetHeaders(s string) {
	m.headers = &s
}

// Headers returns the value of the "headers" field in the mutation.
func (m *OutputLogMutation) Headers() (r string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldHeaders(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ResetHeaders resets all changes to the "headers" field.
func (m *OutputLogMutation) ResetHeaders() {
	m.headers = nil
}

// SetBody sets the "body" field.
func (m *OutputLogMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *OutputLogMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *OutputLogMutation) ClearBody() {
	m.body = nil
	m.clearedFields[outputlog.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *OutputLogMutation) BodyCleared() bool {
	_, ok := m.clearedFields[outputlog.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *OutputLogMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, outputlog.FieldBody)
}

// SetURL sets the "url" field.
func (m *OutputLogMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *OutputLogMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *OutputLogMutation) ResetURL() {
	m.url = nil
}

// SetIP sets the "ip" field.
func (m *OutputLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *OutputLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *OutputLogMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[outputlog.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *OutputLogMutation) IPCleared() bool {
	_, ok := m.clearedFields[outputlog.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *OutputLogMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, outputlog.FieldIP)
}

// SetCaller sets the "caller" field.
func (m *OutputLogMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *OutputLogMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *OutputLogMutation) ResetCaller() {
	m.caller = nil
}

// SetStatus sets the "status" field.
func (m *OutputLogMutation) SetStatus(i int16) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OutputLogMutation) Status() (r int16, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldStatus(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OutputLogMutation) AddStatus(i int16) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OutputLogMutation) AddedStatus() (r int16, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OutputLogMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[outputlog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OutputLogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[outputlog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OutputLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, outputlog.FieldStatus)
}

// SetHmacKey sets the "hmac_key" field.
func (m *OutputLogMutation) SetHmacKey(s string) {
	m.hmac_key = &s
}

// HmacKey returns the value of the "hmac_key" field in the mutation.
func (m *OutputLogMutation) HmacKey() (r string, exists bool) {
	v := m.hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHmacKey returns the old "hmac_key" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHmacKey: %w", err)
	}
	return oldValue.HmacKey, nil
}

// ResetHmacKey resets all changes to the "hmac_key" field.
func (m *OutputLogMutation) ResetHmacKey() {
	m.hmac_key = nil
}

// Where appends a list predicates to the OutputLogMutation builder.
func (m *OutputLogMutation) Where(ps ...predicate.OutputLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OutputLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OutputLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OutputLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OutputLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OutputLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OutputLog).
func (m *OutputLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutputLogMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, outputlog.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, outputlog.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, outputlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, outputlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, outputlog.FieldDeletedAt)
	}
	if m.trace_id != nil {
		fields = append(fields, outputlog.FieldTraceID)
	}
	if m.headers != nil {
		fields = append(fields, outputlog.FieldHeaders)
	}
	if m.body != nil {
		fields = append(fields, outputlog.FieldBody)
	}
	if m.url != nil {
		fields = append(fields, outputlog.FieldURL)
	}
	if m.ip != nil {
		fields = append(fields, outputlog.FieldIP)
	}
	if m.caller != nil {
		fields = append(fields, outputlog.FieldCaller)
	}
	if m.status != nil {
		fields = append(fields, outputlog.FieldStatus)
	}
	if m.hmac_key != nil {
		fields = append(fields, outputlog.FieldHmacKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutputLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outputlog.FieldCreatedBy:
		return m.CreatedBy()
	case outputlog.FieldUpdatedBy:
		return m.UpdatedBy()
	case outputlog.FieldCreatedAt:
		return m.CreatedAt()
	case outputlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case outputlog.FieldDeletedAt:
		return m.DeletedAt()
	case outputlog.FieldTraceID:
		return m.TraceID()
	case outputlog.FieldHeaders:
		return m.Headers()
	case outputlog.FieldBody:
		return m.Body()
	case outputlog.FieldURL:
		return m.URL()
	case outputlog.FieldIP:
		return m.IP()
	case outputlog.FieldCaller:
		return m.Caller()
	case outputlog.FieldStatus:
		return m.Status()
	case outputlog.FieldHmacKey:
		return m.HmacKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutputLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outputlog.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case outputlog.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case outputlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case outputlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case outputlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case outputlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case outputlog.FieldHeaders:
		return m.OldHeaders(ctx)
	case outputlog.FieldBody:
		return m.OldBody(ctx)
	case outputlog.FieldURL:
		return m.OldURL(ctx)
	case outputlog.FieldIP:
		return m.OldIP(ctx)
	case outputlog.FieldCaller:
		return m.OldCaller(ctx)
	case outputlog.FieldStatus:
		return m.OldStatus(ctx)
	case outputlog.FieldHmacKey:
		return m.OldHmacKey(ctx)
	}
	return nil, fmt.Errorf("unknown OutputLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutputLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case outputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case outputlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case outputlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case outputlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case outputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case outputlog.FieldHeaders:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case outputlog.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case outputlog.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case outputlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case outputlog.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case outputlog.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case outputlog.FieldHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHmacKey(v)
		return nil
	}
	return fmt.Errorf("unknown OutputLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutputLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, outputlog.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, outputlog.FieldUpdatedBy)
	}
	if m.addtrace_id != nil {
		fields = append(fields, outputlog.FieldTraceID)
	}
	if m.addstatus != nil {
		fields = append(fields, outputlog.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutputLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case outputlog.FieldCreatedBy:
		return m.AddedCreatedBy()
	case outputlog.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case outputlog.FieldTraceID:
		return m.AddedTraceID()
	case outputlog.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutputLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case outputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case outputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case outputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraceID(v)
		return nil
	case outputlog.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OutputLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutputLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(outputlog.FieldBody) {
		fields = append(fields, outputlog.FieldBody)
	}
	if m.FieldCleared(outputlog.FieldIP) {
		fields = append(fields, outputlog.FieldIP)
	}
	if m.FieldCleared(outputlog.FieldStatus) {
		fields = append(fields, outputlog.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutputLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutputLogMutation) ClearField(name string) error {
	switch name {
	case outputlog.FieldBody:
		m.ClearBody()
		return nil
	case outputlog.FieldIP:
		m.ClearIP()
		return nil
	case outputlog.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown OutputLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutputLogMutation) ResetField(name string) error {
	switch name {
	case outputlog.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case outputlog.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case outputlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case outputlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case outputlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case outputlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case outputlog.FieldHeaders:
		m.ResetHeaders()
		return nil
	case outputlog.FieldBody:
		m.ResetBody()
		return nil
	case outputlog.FieldURL:
		m.ResetURL()
		return nil
	case outputlog.FieldIP:
		m.ResetIP()
		return nil
	case outputlog.FieldCaller:
		m.ResetCaller()
		return nil
	case outputlog.FieldStatus:
		m.ResetStatus()
		return nil
	case outputlog.FieldHmacKey:
		m.ResetHmacKey()
		return nil
	}
	return fmt.Errorf("unknown OutputLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutputLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutputLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutputLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutputLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutputLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutputLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutputLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OutputLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutputLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OutputLog edge %s", name)
}

// PlatformAccountMutation represents an operation that mutates the PlatformAccount nodes in the graph.
type PlatformAccountMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	_type             *platformaccount.Type
	sum_total_cep     *int64
	addsum_total_cep  *int64
	total_cep         *int64
	addtotal_cep      *int64
	sum_pure_cep      *int64
	addsum_pure_cep   *int64
	pure_cep          *int64
	addpure_cep       *int64
	sum_gift_cep      *int64
	addsum_gift_cep   *int64
	gift_cep          *int64
	addgift_cep       *int64
	clearedFields     map[string]struct{}
	earn_bills        map[int64]struct{}
	removedearn_bills map[int64]struct{}
	clearedearn_bills bool
	cost_bills        map[int64]struct{}
	removedcost_bills map[int64]struct{}
	clearedcost_bills bool
	done              bool
	oldValue          func(context.Context) (*PlatformAccount, error)
	predicates        []predicate.PlatformAccount
}

var _ ent.Mutation = (*PlatformAccountMutation)(nil)

// platformaccountOption allows management of the mutation configuration using functional options.
type platformaccountOption func(*PlatformAccountMutation)

// newPlatformAccountMutation creates new mutation for the PlatformAccount entity.
func newPlatformAccountMutation(c config, op Op, opts ...platformaccountOption) *PlatformAccountMutation {
	m := &PlatformAccountMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformAccountID sets the ID field of the mutation.
func withPlatformAccountID(id int64) platformaccountOption {
	return func(m *PlatformAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformAccount
		)
		m.oldValue = func(ctx context.Context) (*PlatformAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformAccount sets the old PlatformAccount of the mutation.
func withPlatformAccount(node *PlatformAccount) platformaccountOption {
	return func(m *PlatformAccountMutation) {
		m.oldValue = func(context.Context) (*PlatformAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlatformAccount entities.
func (m *PlatformAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *PlatformAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PlatformAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PlatformAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PlatformAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PlatformAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PlatformAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PlatformAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PlatformAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PlatformAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PlatformAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlatformAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlatformAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlatformAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlatformAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlatformAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlatformAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlatformAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlatformAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlatformAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *PlatformAccountMutation) SetType(pl platformaccount.Type) {
	m._type = &pl
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlatformAccountMutation) GetType() (r platformaccount.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldType(ctx context.Context) (v platformaccount.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PlatformAccountMutation) ResetType() {
	m._type = nil
}

// SetSumTotalCep sets the "sum_total_cep" field.
func (m *PlatformAccountMutation) SetSumTotalCep(i int64) {
	m.sum_total_cep = &i
	m.addsum_total_cep = nil
}

// SumTotalCep returns the value of the "sum_total_cep" field in the mutation.
func (m *PlatformAccountMutation) SumTotalCep() (r int64, exists bool) {
	v := m.sum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumTotalCep returns the old "sum_total_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldSumTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumTotalCep: %w", err)
	}
	return oldValue.SumTotalCep, nil
}

// AddSumTotalCep adds i to the "sum_total_cep" field.
func (m *PlatformAccountMutation) AddSumTotalCep(i int64) {
	if m.addsum_total_cep != nil {
		*m.addsum_total_cep += i
	} else {
		m.addsum_total_cep = &i
	}
}

// AddedSumTotalCep returns the value that was added to the "sum_total_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedSumTotalCep() (r int64, exists bool) {
	v := m.addsum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumTotalCep resets all changes to the "sum_total_cep" field.
func (m *PlatformAccountMutation) ResetSumTotalCep() {
	m.sum_total_cep = nil
	m.addsum_total_cep = nil
}

// SetTotalCep sets the "total_cep" field.
func (m *PlatformAccountMutation) SetTotalCep(i int64) {
	m.total_cep = &i
	m.addtotal_cep = nil
}

// TotalCep returns the value of the "total_cep" field in the mutation.
func (m *PlatformAccountMutation) TotalCep() (r int64, exists bool) {
	v := m.total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCep returns the old "total_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCep: %w", err)
	}
	return oldValue.TotalCep, nil
}

// AddTotalCep adds i to the "total_cep" field.
func (m *PlatformAccountMutation) AddTotalCep(i int64) {
	if m.addtotal_cep != nil {
		*m.addtotal_cep += i
	} else {
		m.addtotal_cep = &i
	}
}

// AddedTotalCep returns the value that was added to the "total_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedTotalCep() (r int64, exists bool) {
	v := m.addtotal_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCep resets all changes to the "total_cep" field.
func (m *PlatformAccountMutation) ResetTotalCep() {
	m.total_cep = nil
	m.addtotal_cep = nil
}

// SetSumPureCep sets the "sum_pure_cep" field.
func (m *PlatformAccountMutation) SetSumPureCep(i int64) {
	m.sum_pure_cep = &i
	m.addsum_pure_cep = nil
}

// SumPureCep returns the value of the "sum_pure_cep" field in the mutation.
func (m *PlatformAccountMutation) SumPureCep() (r int64, exists bool) {
	v := m.sum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumPureCep returns the old "sum_pure_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldSumPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumPureCep: %w", err)
	}
	return oldValue.SumPureCep, nil
}

// AddSumPureCep adds i to the "sum_pure_cep" field.
func (m *PlatformAccountMutation) AddSumPureCep(i int64) {
	if m.addsum_pure_cep != nil {
		*m.addsum_pure_cep += i
	} else {
		m.addsum_pure_cep = &i
	}
}

// AddedSumPureCep returns the value that was added to the "sum_pure_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedSumPureCep() (r int64, exists bool) {
	v := m.addsum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumPureCep resets all changes to the "sum_pure_cep" field.
func (m *PlatformAccountMutation) ResetSumPureCep() {
	m.sum_pure_cep = nil
	m.addsum_pure_cep = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *PlatformAccountMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *PlatformAccountMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *PlatformAccountMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *PlatformAccountMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetSumGiftCep sets the "sum_gift_cep" field.
func (m *PlatformAccountMutation) SetSumGiftCep(i int64) {
	m.sum_gift_cep = &i
	m.addsum_gift_cep = nil
}

// SumGiftCep returns the value of the "sum_gift_cep" field in the mutation.
func (m *PlatformAccountMutation) SumGiftCep() (r int64, exists bool) {
	v := m.sum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumGiftCep returns the old "sum_gift_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldSumGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumGiftCep: %w", err)
	}
	return oldValue.SumGiftCep, nil
}

// AddSumGiftCep adds i to the "sum_gift_cep" field.
func (m *PlatformAccountMutation) AddSumGiftCep(i int64) {
	if m.addsum_gift_cep != nil {
		*m.addsum_gift_cep += i
	} else {
		m.addsum_gift_cep = &i
	}
}

// AddedSumGiftCep returns the value that was added to the "sum_gift_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedSumGiftCep() (r int64, exists bool) {
	v := m.addsum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumGiftCep resets all changes to the "sum_gift_cep" field.
func (m *PlatformAccountMutation) ResetSumGiftCep() {
	m.sum_gift_cep = nil
	m.addsum_gift_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *PlatformAccountMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *PlatformAccountMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *PlatformAccountMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *PlatformAccountMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *PlatformAccountMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *PlatformAccountMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *PlatformAccountMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *PlatformAccountMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *PlatformAccountMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *PlatformAccountMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *PlatformAccountMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *PlatformAccountMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *PlatformAccountMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *PlatformAccountMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *PlatformAccountMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *PlatformAccountMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *PlatformAccountMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *PlatformAccountMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// Where appends a list predicates to the PlatformAccountMutation builder.
func (m *PlatformAccountMutation) Where(ps ...predicate.PlatformAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlatformAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlatformAccount).
func (m *PlatformAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformAccountMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, platformaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, platformaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, platformaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, platformaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, platformaccount.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, platformaccount.FieldType)
	}
	if m.sum_total_cep != nil {
		fields = append(fields, platformaccount.FieldSumTotalCep)
	}
	if m.total_cep != nil {
		fields = append(fields, platformaccount.FieldTotalCep)
	}
	if m.sum_pure_cep != nil {
		fields = append(fields, platformaccount.FieldSumPureCep)
	}
	if m.pure_cep != nil {
		fields = append(fields, platformaccount.FieldPureCep)
	}
	if m.sum_gift_cep != nil {
		fields = append(fields, platformaccount.FieldSumGiftCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, platformaccount.FieldGiftCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformaccount.FieldCreatedBy:
		return m.CreatedBy()
	case platformaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case platformaccount.FieldCreatedAt:
		return m.CreatedAt()
	case platformaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case platformaccount.FieldDeletedAt:
		return m.DeletedAt()
	case platformaccount.FieldType:
		return m.GetType()
	case platformaccount.FieldSumTotalCep:
		return m.SumTotalCep()
	case platformaccount.FieldTotalCep:
		return m.TotalCep()
	case platformaccount.FieldSumPureCep:
		return m.SumPureCep()
	case platformaccount.FieldPureCep:
		return m.PureCep()
	case platformaccount.FieldSumGiftCep:
		return m.SumGiftCep()
	case platformaccount.FieldGiftCep:
		return m.GiftCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case platformaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case platformaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case platformaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case platformaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case platformaccount.FieldType:
		return m.OldType(ctx)
	case platformaccount.FieldSumTotalCep:
		return m.OldSumTotalCep(ctx)
	case platformaccount.FieldTotalCep:
		return m.OldTotalCep(ctx)
	case platformaccount.FieldSumPureCep:
		return m.OldSumPureCep(ctx)
	case platformaccount.FieldPureCep:
		return m.OldPureCep(ctx)
	case platformaccount.FieldSumGiftCep:
		return m.OldSumGiftCep(ctx)
	case platformaccount.FieldGiftCep:
		return m.OldGiftCep(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case platformaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case platformaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case platformaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case platformaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case platformaccount.FieldType:
		v, ok := value.(platformaccount.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case platformaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumTotalCep(v)
		return nil
	case platformaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCep(v)
		return nil
	case platformaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumPureCep(v)
		return nil
	case platformaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case platformaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumGiftCep(v)
		return nil
	case platformaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, platformaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, platformaccount.FieldUpdatedBy)
	}
	if m.addsum_total_cep != nil {
		fields = append(fields, platformaccount.FieldSumTotalCep)
	}
	if m.addtotal_cep != nil {
		fields = append(fields, platformaccount.FieldTotalCep)
	}
	if m.addsum_pure_cep != nil {
		fields = append(fields, platformaccount.FieldSumPureCep)
	}
	if m.addpure_cep != nil {
		fields = append(fields, platformaccount.FieldPureCep)
	}
	if m.addsum_gift_cep != nil {
		fields = append(fields, platformaccount.FieldSumGiftCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, platformaccount.FieldGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case platformaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case platformaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case platformaccount.FieldSumTotalCep:
		return m.AddedSumTotalCep()
	case platformaccount.FieldTotalCep:
		return m.AddedTotalCep()
	case platformaccount.FieldSumPureCep:
		return m.AddedSumPureCep()
	case platformaccount.FieldPureCep:
		return m.AddedPureCep()
	case platformaccount.FieldSumGiftCep:
		return m.AddedSumGiftCep()
	case platformaccount.FieldGiftCep:
		return m.AddedGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case platformaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case platformaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case platformaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumTotalCep(v)
		return nil
	case platformaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCep(v)
		return nil
	case platformaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumPureCep(v)
		return nil
	case platformaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case platformaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumGiftCep(v)
		return nil
	case platformaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlatformAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformAccountMutation) ResetField(name string) error {
	switch name {
	case platformaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case platformaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case platformaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case platformaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case platformaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case platformaccount.FieldType:
		m.ResetType()
		return nil
	case platformaccount.FieldSumTotalCep:
		m.ResetSumTotalCep()
		return nil
	case platformaccount.FieldTotalCep:
		m.ResetTotalCep()
		return nil
	case platformaccount.FieldSumPureCep:
		m.ResetSumPureCep()
		return nil
	case platformaccount.FieldPureCep:
		m.ResetPureCep()
		return nil
	case platformaccount.FieldSumGiftCep:
		m.ResetSumGiftCep()
		return nil
	case platformaccount.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.earn_bills != nil {
		edges = append(edges, platformaccount.EdgeEarnBills)
	}
	if m.cost_bills != nil {
		edges = append(edges, platformaccount.EdgeCostBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	case platformaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedearn_bills != nil {
		edges = append(edges, platformaccount.EdgeEarnBills)
	}
	if m.removedcost_bills != nil {
		edges = append(edges, platformaccount.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case platformaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	case platformaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedearn_bills {
		edges = append(edges, platformaccount.EdgeEarnBills)
	}
	if m.clearedcost_bills {
		edges = append(edges, platformaccount.EdgeCostBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case platformaccount.EdgeEarnBills:
		return m.clearedearn_bills
	case platformaccount.EdgeCostBills:
		return m.clearedcost_bills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformAccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformAccountMutation) ResetEdge(name string) error {
	switch name {
	case platformaccount.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	case platformaccount.EdgeCostBills:
		m.ResetCostBills()
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount edge %s", name)
}

// PriceMutation represents an operation that mutates the Price nodes in the graph.
type PriceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_by           *int64
	addcreated_by        *int64
	updated_by           *int64
	addupdated_by        *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	gpu_version          *enums.GpuVersion
	mission_type         *enums.MissionType
	mission_category     *enums.MissionCategory
	mission_billing_type *enums.MissionBillingType
	cep                  *int64
	addcep               *int64
	original_cep         *int64
	addoriginal_cep      *int64
	started_at           *time.Time
	finished_at          *time.Time
	is_deprecated        *bool
	is_sensitive         *bool
	is_hot_gpu           *bool
	clearedFields        map[string]struct{}
	gpu                  *int64
	clearedgpu           bool
	done                 bool
	oldValue             func(context.Context) (*Price, error)
	predicates           []predicate.Price
}

var _ ent.Mutation = (*PriceMutation)(nil)

// priceOption allows management of the mutation configuration using functional options.
type priceOption func(*PriceMutation)

// newPriceMutation creates new mutation for the Price entity.
func newPriceMutation(c config, op Op, opts ...priceOption) *PriceMutation {
	m := &PriceMutation{
		config:        c,
		op:            op,
		typ:           TypePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPriceID sets the ID field of the mutation.
func withPriceID(id int64) priceOption {
	return func(m *PriceMutation) {
		var (
			err   error
			once  sync.Once
			value *Price
		)
		m.oldValue = func(ctx context.Context) (*Price, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Price.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrice sets the old Price of the mutation.
func withPrice(node *Price) priceOption {
	return func(m *PriceMutation) {
		m.oldValue = func(context.Context) (*Price, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Price entities.
func (m *PriceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PriceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PriceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Price.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *PriceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PriceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PriceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PriceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PriceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PriceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PriceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PriceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PriceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PriceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetGpuID sets the "gpu_id" field.
func (m *PriceMutation) SetGpuID(i int64) {
	m.gpu = &i
}

// GpuID returns the value of the "gpu_id" field in the mutation.
func (m *PriceMutation) GpuID() (r int64, exists bool) {
	v := m.gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuID returns the old "gpu_id" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldGpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuID: %w", err)
	}
	return oldValue.GpuID, nil
}

// ResetGpuID resets all changes to the "gpu_id" field.
func (m *PriceMutation) ResetGpuID() {
	m.gpu = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *PriceMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *PriceMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *PriceMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetMissionType sets the "mission_type" field.
func (m *PriceMutation) SetMissionType(et enums.MissionType) {
	m.mission_type = &et
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *PriceMutation) MissionType() (r enums.MissionType, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldMissionType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *PriceMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionCategory sets the "mission_category" field.
func (m *PriceMutation) SetMissionCategory(ec enums.MissionCategory) {
	m.mission_category = &ec
}

// MissionCategory returns the value of the "mission_category" field in the mutation.
func (m *PriceMutation) MissionCategory() (r enums.MissionCategory, exists bool) {
	v := m.mission_category
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionCategory returns the old "mission_category" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldMissionCategory(ctx context.Context) (v enums.MissionCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionCategory: %w", err)
	}
	return oldValue.MissionCategory, nil
}

// ResetMissionCategory resets all changes to the "mission_category" field.
func (m *PriceMutation) ResetMissionCategory() {
	m.mission_category = nil
}

// SetMissionBillingType sets the "mission_billing_type" field.
func (m *PriceMutation) SetMissionBillingType(ebt enums.MissionBillingType) {
	m.mission_billing_type = &ebt
}

// MissionBillingType returns the value of the "mission_billing_type" field in the mutation.
func (m *PriceMutation) MissionBillingType() (r enums.MissionBillingType, exists bool) {
	v := m.mission_billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBillingType returns the old "mission_billing_type" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldMissionBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBillingType: %w", err)
	}
	return oldValue.MissionBillingType, nil
}

// ResetMissionBillingType resets all changes to the "mission_billing_type" field.
func (m *PriceMutation) ResetMissionBillingType() {
	m.mission_billing_type = nil
}

// SetCep sets the "cep" field.
func (m *PriceMutation) SetCep(i int64) {
	m.cep = &i
	m.addcep = nil
}

// Cep returns the value of the "cep" field in the mutation.
func (m *PriceMutation) Cep() (r int64, exists bool) {
	v := m.cep
	if v == nil {
		return
	}
	return *v, true
}

// OldCep returns the old "cep" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCep: %w", err)
	}
	return oldValue.Cep, nil
}

// AddCep adds i to the "cep" field.
func (m *PriceMutation) AddCep(i int64) {
	if m.addcep != nil {
		*m.addcep += i
	} else {
		m.addcep = &i
	}
}

// AddedCep returns the value that was added to the "cep" field in this mutation.
func (m *PriceMutation) AddedCep() (r int64, exists bool) {
	v := m.addcep
	if v == nil {
		return
	}
	return *v, true
}

// ResetCep resets all changes to the "cep" field.
func (m *PriceMutation) ResetCep() {
	m.cep = nil
	m.addcep = nil
}

// SetOriginalCep sets the "original_cep" field.
func (m *PriceMutation) SetOriginalCep(i int64) {
	m.original_cep = &i
	m.addoriginal_cep = nil
}

// OriginalCep returns the value of the "original_cep" field in the mutation.
func (m *PriceMutation) OriginalCep() (r int64, exists bool) {
	v := m.original_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalCep returns the old "original_cep" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldOriginalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalCep: %w", err)
	}
	return oldValue.OriginalCep, nil
}

// AddOriginalCep adds i to the "original_cep" field.
func (m *PriceMutation) AddOriginalCep(i int64) {
	if m.addoriginal_cep != nil {
		*m.addoriginal_cep += i
	} else {
		m.addoriginal_cep = &i
	}
}

// AddedOriginalCep returns the value that was added to the "original_cep" field in this mutation.
func (m *PriceMutation) AddedOriginalCep() (r int64, exists bool) {
	v := m.addoriginal_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetOriginalCep resets all changes to the "original_cep" field.
func (m *PriceMutation) ResetOriginalCep() {
	m.original_cep = nil
	m.addoriginal_cep = nil
}

// SetStartedAt sets the "started_at" field.
func (m *PriceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *PriceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *PriceMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[price.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *PriceMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[price.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *PriceMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, price.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *PriceMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *PriceMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *PriceMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[price.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *PriceMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[price.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *PriceMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, price.FieldFinishedAt)
}

// SetIsDeprecated sets the "is_deprecated" field.
func (m *PriceMutation) SetIsDeprecated(b bool) {
	m.is_deprecated = &b
}

// IsDeprecated returns the value of the "is_deprecated" field in the mutation.
func (m *PriceMutation) IsDeprecated() (r bool, exists bool) {
	v := m.is_deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeprecated returns the old "is_deprecated" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldIsDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeprecated: %w", err)
	}
	return oldValue.IsDeprecated, nil
}

// ResetIsDeprecated resets all changes to the "is_deprecated" field.
func (m *PriceMutation) ResetIsDeprecated() {
	m.is_deprecated = nil
}

// SetIsSensitive sets the "is_sensitive" field.
func (m *PriceMutation) SetIsSensitive(b bool) {
	m.is_sensitive = &b
}

// IsSensitive returns the value of the "is_sensitive" field in the mutation.
func (m *PriceMutation) IsSensitive() (r bool, exists bool) {
	v := m.is_sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSensitive returns the old "is_sensitive" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldIsSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSensitive: %w", err)
	}
	return oldValue.IsSensitive, nil
}

// ResetIsSensitive resets all changes to the "is_sensitive" field.
func (m *PriceMutation) ResetIsSensitive() {
	m.is_sensitive = nil
}

// SetIsHotGpu sets the "is_hot_gpu" field.
func (m *PriceMutation) SetIsHotGpu(b bool) {
	m.is_hot_gpu = &b
}

// IsHotGpu returns the value of the "is_hot_gpu" field in the mutation.
func (m *PriceMutation) IsHotGpu() (r bool, exists bool) {
	v := m.is_hot_gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHotGpu returns the old "is_hot_gpu" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldIsHotGpu(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHotGpu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHotGpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHotGpu: %w", err)
	}
	return oldValue.IsHotGpu, nil
}

// ResetIsHotGpu resets all changes to the "is_hot_gpu" field.
func (m *PriceMutation) ResetIsHotGpu() {
	m.is_hot_gpu = nil
}

// ClearGpu clears the "gpu" edge to the Gpu entity.
func (m *PriceMutation) ClearGpu() {
	m.clearedgpu = true
	m.clearedFields[price.FieldGpuID] = struct{}{}
}

// GpuCleared reports if the "gpu" edge to the Gpu entity was cleared.
func (m *PriceMutation) GpuCleared() bool {
	return m.clearedgpu
}

// GpuIDs returns the "gpu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GpuID instead. It exists only for internal usage by the builders.
func (m *PriceMutation) GpuIDs() (ids []int64) {
	if id := m.gpu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGpu resets all changes to the "gpu" edge.
func (m *PriceMutation) ResetGpu() {
	m.gpu = nil
	m.clearedgpu = false
}

// Where appends a list predicates to the PriceMutation builder.
func (m *PriceMutation) Where(ps ...predicate.Price) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Price, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Price).
func (m *PriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PriceMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, price.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, price.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, price.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, price.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, price.FieldDeletedAt)
	}
	if m.gpu != nil {
		fields = append(fields, price.FieldGpuID)
	}
	if m.gpu_version != nil {
		fields = append(fields, price.FieldGpuVersion)
	}
	if m.mission_type != nil {
		fields = append(fields, price.FieldMissionType)
	}
	if m.mission_category != nil {
		fields = append(fields, price.FieldMissionCategory)
	}
	if m.mission_billing_type != nil {
		fields = append(fields, price.FieldMissionBillingType)
	}
	if m.cep != nil {
		fields = append(fields, price.FieldCep)
	}
	if m.original_cep != nil {
		fields = append(fields, price.FieldOriginalCep)
	}
	if m.started_at != nil {
		fields = append(fields, price.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, price.FieldFinishedAt)
	}
	if m.is_deprecated != nil {
		fields = append(fields, price.FieldIsDeprecated)
	}
	if m.is_sensitive != nil {
		fields = append(fields, price.FieldIsSensitive)
	}
	if m.is_hot_gpu != nil {
		fields = append(fields, price.FieldIsHotGpu)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case price.FieldCreatedBy:
		return m.CreatedBy()
	case price.FieldUpdatedBy:
		return m.UpdatedBy()
	case price.FieldCreatedAt:
		return m.CreatedAt()
	case price.FieldUpdatedAt:
		return m.UpdatedAt()
	case price.FieldDeletedAt:
		return m.DeletedAt()
	case price.FieldGpuID:
		return m.GpuID()
	case price.FieldGpuVersion:
		return m.GpuVersion()
	case price.FieldMissionType:
		return m.MissionType()
	case price.FieldMissionCategory:
		return m.MissionCategory()
	case price.FieldMissionBillingType:
		return m.MissionBillingType()
	case price.FieldCep:
		return m.Cep()
	case price.FieldOriginalCep:
		return m.OriginalCep()
	case price.FieldStartedAt:
		return m.StartedAt()
	case price.FieldFinishedAt:
		return m.FinishedAt()
	case price.FieldIsDeprecated:
		return m.IsDeprecated()
	case price.FieldIsSensitive:
		return m.IsSensitive()
	case price.FieldIsHotGpu:
		return m.IsHotGpu()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case price.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case price.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case price.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case price.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case price.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case price.FieldGpuID:
		return m.OldGpuID(ctx)
	case price.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case price.FieldMissionType:
		return m.OldMissionType(ctx)
	case price.FieldMissionCategory:
		return m.OldMissionCategory(ctx)
	case price.FieldMissionBillingType:
		return m.OldMissionBillingType(ctx)
	case price.FieldCep:
		return m.OldCep(ctx)
	case price.FieldOriginalCep:
		return m.OldOriginalCep(ctx)
	case price.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case price.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case price.FieldIsDeprecated:
		return m.OldIsDeprecated(ctx)
	case price.FieldIsSensitive:
		return m.OldIsSensitive(ctx)
	case price.FieldIsHotGpu:
		return m.OldIsHotGpu(ctx)
	}
	return nil, fmt.Errorf("unknown Price field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case price.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case price.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case price.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case price.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case price.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case price.FieldGpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuID(v)
		return nil
	case price.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case price.FieldMissionType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case price.FieldMissionCategory:
		v, ok := value.(enums.MissionCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionCategory(v)
		return nil
	case price.FieldMissionBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBillingType(v)
		return nil
	case price.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCep(v)
		return nil
	case price.FieldOriginalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalCep(v)
		return nil
	case price.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case price.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case price.FieldIsDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeprecated(v)
		return nil
	case price.FieldIsSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSensitive(v)
		return nil
	case price.FieldIsHotGpu:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHotGpu(v)
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PriceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, price.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, price.FieldUpdatedBy)
	}
	if m.addcep != nil {
		fields = append(fields, price.FieldCep)
	}
	if m.addoriginal_cep != nil {
		fields = append(fields, price.FieldOriginalCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case price.FieldCreatedBy:
		return m.AddedCreatedBy()
	case price.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case price.FieldCep:
		return m.AddedCep()
	case price.FieldOriginalCep:
		return m.AddedOriginalCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case price.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case price.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case price.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCep(v)
		return nil
	case price.FieldOriginalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginalCep(v)
		return nil
	}
	return fmt.Errorf("unknown Price numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(price.FieldStartedAt) {
		fields = append(fields, price.FieldStartedAt)
	}
	if m.FieldCleared(price.FieldFinishedAt) {
		fields = append(fields, price.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PriceMutation) ClearField(name string) error {
	switch name {
	case price.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case price.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Price nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PriceMutation) ResetField(name string) error {
	switch name {
	case price.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case price.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case price.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case price.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case price.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case price.FieldGpuID:
		m.ResetGpuID()
		return nil
	case price.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case price.FieldMissionType:
		m.ResetMissionType()
		return nil
	case price.FieldMissionCategory:
		m.ResetMissionCategory()
		return nil
	case price.FieldMissionBillingType:
		m.ResetMissionBillingType()
		return nil
	case price.FieldCep:
		m.ResetCep()
		return nil
	case price.FieldOriginalCep:
		m.ResetOriginalCep()
		return nil
	case price.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case price.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case price.FieldIsDeprecated:
		m.ResetIsDeprecated()
		return nil
	case price.FieldIsSensitive:
		m.ResetIsSensitive()
		return nil
	case price.FieldIsHotGpu:
		m.ResetIsHotGpu()
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.gpu != nil {
		edges = append(edges, price.EdgeGpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case price.EdgeGpu:
		if id := m.gpu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgpu {
		edges = append(edges, price.EdgeGpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PriceMutation) EdgeCleared(name string) bool {
	switch name {
	case price.EdgeGpu:
		return m.clearedgpu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PriceMutation) ClearEdge(name string) error {
	switch name {
	case price.EdgeGpu:
		m.ClearGpu()
		return nil
	}
	return fmt.Errorf("unknown Price unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PriceMutation) ResetEdge(name string) error {
	switch name {
	case price.EdgeGpu:
		m.ResetGpu()
		return nil
	}
	return fmt.Errorf("unknown Price edge %s", name)
}

// ProfitAccountMutation represents an operation that mutates the ProfitAccount nodes in the graph.
type ProfitAccountMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	sum_cep           *int64
	addsum_cep        *int64
	remain_cep        *int64
	addremain_cep     *int64
	clearedFields     map[string]struct{}
	user              *int64
	cleareduser       bool
	earn_bills        map[int64]struct{}
	removedearn_bills map[int64]struct{}
	clearedearn_bills bool
	done              bool
	oldValue          func(context.Context) (*ProfitAccount, error)
	predicates        []predicate.ProfitAccount
}

var _ ent.Mutation = (*ProfitAccountMutation)(nil)

// profitaccountOption allows management of the mutation configuration using functional options.
type profitaccountOption func(*ProfitAccountMutation)

// newProfitAccountMutation creates new mutation for the ProfitAccount entity.
func newProfitAccountMutation(c config, op Op, opts ...profitaccountOption) *ProfitAccountMutation {
	m := &ProfitAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeProfitAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfitAccountID sets the ID field of the mutation.
func withProfitAccountID(id int64) profitaccountOption {
	return func(m *ProfitAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfitAccount
		)
		m.oldValue = func(ctx context.Context) (*ProfitAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfitAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfitAccount sets the old ProfitAccount of the mutation.
func withProfitAccount(node *ProfitAccount) profitaccountOption {
	return func(m *ProfitAccountMutation) {
		m.oldValue = func(context.Context) (*ProfitAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfitAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfitAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfitAccount entities.
func (m *ProfitAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfitAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfitAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfitAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ProfitAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProfitAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProfitAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProfitAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProfitAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProfitAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProfitAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ProfitAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ProfitAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProfitAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfitAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfitAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfitAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfitAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfitAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfitAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProfitAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProfitAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProfitAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ProfitAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProfitAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProfitAccountMutation) ResetUserID() {
	m.user = nil
}

// SetSumCep sets the "sum_cep" field.
func (m *ProfitAccountMutation) SetSumCep(i int64) {
	m.sum_cep = &i
	m.addsum_cep = nil
}

// SumCep returns the value of the "sum_cep" field in the mutation.
func (m *ProfitAccountMutation) SumCep() (r int64, exists bool) {
	v := m.sum_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumCep returns the old "sum_cep" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldSumCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumCep: %w", err)
	}
	return oldValue.SumCep, nil
}

// AddSumCep adds i to the "sum_cep" field.
func (m *ProfitAccountMutation) AddSumCep(i int64) {
	if m.addsum_cep != nil {
		*m.addsum_cep += i
	} else {
		m.addsum_cep = &i
	}
}

// AddedSumCep returns the value that was added to the "sum_cep" field in this mutation.
func (m *ProfitAccountMutation) AddedSumCep() (r int64, exists bool) {
	v := m.addsum_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumCep resets all changes to the "sum_cep" field.
func (m *ProfitAccountMutation) ResetSumCep() {
	m.sum_cep = nil
	m.addsum_cep = nil
}

// SetRemainCep sets the "remain_cep" field.
func (m *ProfitAccountMutation) SetRemainCep(i int64) {
	m.remain_cep = &i
	m.addremain_cep = nil
}

// RemainCep returns the value of the "remain_cep" field in the mutation.
func (m *ProfitAccountMutation) RemainCep() (r int64, exists bool) {
	v := m.remain_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainCep returns the old "remain_cep" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldRemainCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainCep: %w", err)
	}
	return oldValue.RemainCep, nil
}

// AddRemainCep adds i to the "remain_cep" field.
func (m *ProfitAccountMutation) AddRemainCep(i int64) {
	if m.addremain_cep != nil {
		*m.addremain_cep += i
	} else {
		m.addremain_cep = &i
	}
}

// AddedRemainCep returns the value that was added to the "remain_cep" field in this mutation.
func (m *ProfitAccountMutation) AddedRemainCep() (r int64, exists bool) {
	v := m.addremain_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainCep resets all changes to the "remain_cep" field.
func (m *ProfitAccountMutation) ResetRemainCep() {
	m.remain_cep = nil
	m.addremain_cep = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfitAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[profitaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfitAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfitAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfitAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *ProfitAccountMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *ProfitAccountMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *ProfitAccountMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *ProfitAccountMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *ProfitAccountMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *ProfitAccountMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *ProfitAccountMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// Where appends a list predicates to the ProfitAccountMutation builder.
func (m *ProfitAccountMutation) Where(ps ...predicate.ProfitAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfitAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfitAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfitAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfitAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfitAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfitAccount).
func (m *ProfitAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfitAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, profitaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, profitaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, profitaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profitaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, profitaccount.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, profitaccount.FieldUserID)
	}
	if m.sum_cep != nil {
		fields = append(fields, profitaccount.FieldSumCep)
	}
	if m.remain_cep != nil {
		fields = append(fields, profitaccount.FieldRemainCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfitAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profitaccount.FieldCreatedBy:
		return m.CreatedBy()
	case profitaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case profitaccount.FieldCreatedAt:
		return m.CreatedAt()
	case profitaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case profitaccount.FieldDeletedAt:
		return m.DeletedAt()
	case profitaccount.FieldUserID:
		return m.UserID()
	case profitaccount.FieldSumCep:
		return m.SumCep()
	case profitaccount.FieldRemainCep:
		return m.RemainCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfitAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profitaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case profitaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case profitaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profitaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profitaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case profitaccount.FieldUserID:
		return m.OldUserID(ctx)
	case profitaccount.FieldSumCep:
		return m.OldSumCep(ctx)
	case profitaccount.FieldRemainCep:
		return m.OldRemainCep(ctx)
	}
	return nil, fmt.Errorf("unknown ProfitAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profitaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case profitaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case profitaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profitaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profitaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case profitaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case profitaccount.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumCep(v)
		return nil
	case profitaccount.FieldRemainCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainCep(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfitAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, profitaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, profitaccount.FieldUpdatedBy)
	}
	if m.addsum_cep != nil {
		fields = append(fields, profitaccount.FieldSumCep)
	}
	if m.addremain_cep != nil {
		fields = append(fields, profitaccount.FieldRemainCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfitAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profitaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case profitaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case profitaccount.FieldSumCep:
		return m.AddedSumCep()
	case profitaccount.FieldRemainCep:
		return m.AddedRemainCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profitaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case profitaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case profitaccount.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumCep(v)
		return nil
	case profitaccount.FieldRemainCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainCep(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfitAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfitAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfitAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfitAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfitAccountMutation) ResetField(name string) error {
	switch name {
	case profitaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case profitaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case profitaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profitaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profitaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case profitaccount.FieldUserID:
		m.ResetUserID()
		return nil
	case profitaccount.FieldSumCep:
		m.ResetSumCep()
		return nil
	case profitaccount.FieldRemainCep:
		m.ResetRemainCep()
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfitAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, profitaccount.EdgeUser)
	}
	if m.earn_bills != nil {
		edges = append(edges, profitaccount.EdgeEarnBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfitAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profitaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case profitaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfitAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedearn_bills != nil {
		edges = append(edges, profitaccount.EdgeEarnBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfitAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profitaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfitAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, profitaccount.EdgeUser)
	}
	if m.clearedearn_bills {
		edges = append(edges, profitaccount.EdgeEarnBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfitAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case profitaccount.EdgeUser:
		return m.cleareduser
	case profitaccount.EdgeEarnBills:
		return m.clearedearn_bills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfitAccountMutation) ClearEdge(name string) error {
	switch name {
	case profitaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfitAccountMutation) ResetEdge(name string) error {
	switch name {
	case profitaccount.EdgeUser:
		m.ResetUser()
		return nil
	case profitaccount.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount edge %s", name)
}

// ProfitSettingMutation represents an operation that mutates the ProfitSetting nodes in the graph.
type ProfitSettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	ratio         *int64
	addratio      *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ProfitSetting, error)
	predicates    []predicate.ProfitSetting
}

var _ ent.Mutation = (*ProfitSettingMutation)(nil)

// profitsettingOption allows management of the mutation configuration using functional options.
type profitsettingOption func(*ProfitSettingMutation)

// newProfitSettingMutation creates new mutation for the ProfitSetting entity.
func newProfitSettingMutation(c config, op Op, opts ...profitsettingOption) *ProfitSettingMutation {
	m := &ProfitSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeProfitSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfitSettingID sets the ID field of the mutation.
func withProfitSettingID(id int64) profitsettingOption {
	return func(m *ProfitSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfitSetting
		)
		m.oldValue = func(ctx context.Context) (*ProfitSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfitSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfitSetting sets the old ProfitSetting of the mutation.
func withProfitSetting(node *ProfitSetting) profitsettingOption {
	return func(m *ProfitSettingMutation) {
		m.oldValue = func(context.Context) (*ProfitSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfitSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfitSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfitSetting entities.
func (m *ProfitSettingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfitSettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfitSettingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfitSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ProfitSettingMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProfitSettingMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProfitSettingMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProfitSettingMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProfitSettingMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProfitSettingMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProfitSettingMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ProfitSettingMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ProfitSettingMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProfitSettingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfitSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfitSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfitSettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfitSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfitSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfitSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProfitSettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProfitSettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProfitSettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ProfitSettingMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProfitSettingMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProfitSettingMutation) ResetUserID() {
	m.user = nil
}

// SetRatio sets the "ratio" field.
func (m *ProfitSettingMutation) SetRatio(i int64) {
	m.ratio = &i
	m.addratio = nil
}

// Ratio returns the value of the "ratio" field in the mutation.
func (m *ProfitSettingMutation) Ratio() (r int64, exists bool) {
	v := m.ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldRatio returns the old "ratio" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldRatio(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatio: %w", err)
	}
	return oldValue.Ratio, nil
}

// AddRatio adds i to the "ratio" field.
func (m *ProfitSettingMutation) AddRatio(i int64) {
	if m.addratio != nil {
		*m.addratio += i
	} else {
		m.addratio = &i
	}
}

// AddedRatio returns the value that was added to the "ratio" field in this mutation.
func (m *ProfitSettingMutation) AddedRatio() (r int64, exists bool) {
	v := m.addratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatio resets all changes to the "ratio" field.
func (m *ProfitSettingMutation) ResetRatio() {
	m.ratio = nil
	m.addratio = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfitSettingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[profitsetting.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfitSettingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfitSettingMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfitSettingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProfitSettingMutation builder.
func (m *ProfitSettingMutation) Where(ps ...predicate.ProfitSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfitSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfitSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfitSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfitSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfitSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfitSetting).
func (m *ProfitSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfitSettingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, profitsetting.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, profitsetting.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, profitsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profitsetting.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, profitsetting.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, profitsetting.FieldUserID)
	}
	if m.ratio != nil {
		fields = append(fields, profitsetting.FieldRatio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfitSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profitsetting.FieldCreatedBy:
		return m.CreatedBy()
	case profitsetting.FieldUpdatedBy:
		return m.UpdatedBy()
	case profitsetting.FieldCreatedAt:
		return m.CreatedAt()
	case profitsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case profitsetting.FieldDeletedAt:
		return m.DeletedAt()
	case profitsetting.FieldUserID:
		return m.UserID()
	case profitsetting.FieldRatio:
		return m.Ratio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfitSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profitsetting.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case profitsetting.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case profitsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profitsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profitsetting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case profitsetting.FieldUserID:
		return m.OldUserID(ctx)
	case profitsetting.FieldRatio:
		return m.OldRatio(ctx)
	}
	return nil, fmt.Errorf("unknown ProfitSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profitsetting.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case profitsetting.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case profitsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profitsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profitsetting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case profitsetting.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case profitsetting.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatio(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfitSettingMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, profitsetting.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, profitsetting.FieldUpdatedBy)
	}
	if m.addratio != nil {
		fields = append(fields, profitsetting.FieldRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfitSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profitsetting.FieldCreatedBy:
		return m.AddedCreatedBy()
	case profitsetting.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case profitsetting.FieldRatio:
		return m.AddedRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profitsetting.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case profitsetting.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case profitsetting.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatio(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfitSettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfitSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfitSettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfitSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfitSettingMutation) ResetField(name string) error {
	switch name {
	case profitsetting.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case profitsetting.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case profitsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profitsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profitsetting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case profitsetting.FieldUserID:
		m.ResetUserID()
		return nil
	case profitsetting.FieldRatio:
		m.ResetRatio()
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfitSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, profitsetting.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfitSettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profitsetting.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfitSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfitSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfitSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, profitsetting.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfitSettingMutation) EdgeCleared(name string) bool {
	switch name {
	case profitsetting.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfitSettingMutation) ClearEdge(name string) error {
	switch name {
	case profitsetting.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfitSettingMutation) ResetEdge(name string) error {
	switch name {
	case profitsetting.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting edge %s", name)
}

// RechargeCampaignRuleMutation represents an operation that mutates the RechargeCampaignRule nodes in the graph.
type RechargeCampaignRuleMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_by      *int64
	addcreated_by   *int64
	updated_by      *int64
	addupdated_by   *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	little_value    *int64
	addlittle_value *int64
	large_value     *int64
	addlarge_value  *int64
	gift_percent    *int64
	addgift_percent *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*RechargeCampaignRule, error)
	predicates      []predicate.RechargeCampaignRule
}

var _ ent.Mutation = (*RechargeCampaignRuleMutation)(nil)

// rechargecampaignruleOption allows management of the mutation configuration using functional options.
type rechargecampaignruleOption func(*RechargeCampaignRuleMutation)

// newRechargeCampaignRuleMutation creates new mutation for the RechargeCampaignRule entity.
func newRechargeCampaignRuleMutation(c config, op Op, opts ...rechargecampaignruleOption) *RechargeCampaignRuleMutation {
	m := &RechargeCampaignRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeRechargeCampaignRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRechargeCampaignRuleID sets the ID field of the mutation.
func withRechargeCampaignRuleID(id int64) rechargecampaignruleOption {
	return func(m *RechargeCampaignRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *RechargeCampaignRule
		)
		m.oldValue = func(ctx context.Context) (*RechargeCampaignRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RechargeCampaignRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRechargeCampaignRule sets the old RechargeCampaignRule of the mutation.
func withRechargeCampaignRule(node *RechargeCampaignRule) rechargecampaignruleOption {
	return func(m *RechargeCampaignRuleMutation) {
		m.oldValue = func(context.Context) (*RechargeCampaignRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RechargeCampaignRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RechargeCampaignRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RechargeCampaignRule entities.
func (m *RechargeCampaignRuleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RechargeCampaignRuleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RechargeCampaignRuleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RechargeCampaignRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *RechargeCampaignRuleMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RechargeCampaignRuleMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RechargeCampaignRuleMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RechargeCampaignRuleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RechargeCampaignRuleMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RechargeCampaignRuleMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RechargeCampaignRuleMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RechargeCampaignRuleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RechargeCampaignRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RechargeCampaignRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RechargeCampaignRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RechargeCampaignRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RechargeCampaignRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RechargeCampaignRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RechargeCampaignRuleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RechargeCampaignRuleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RechargeCampaignRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetLittleValue sets the "little_value" field.
func (m *RechargeCampaignRuleMutation) SetLittleValue(i int64) {
	m.little_value = &i
	m.addlittle_value = nil
}

// LittleValue returns the value of the "little_value" field in the mutation.
func (m *RechargeCampaignRuleMutation) LittleValue() (r int64, exists bool) {
	v := m.little_value
	if v == nil {
		return
	}
	return *v, true
}

// OldLittleValue returns the old "little_value" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldLittleValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLittleValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLittleValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLittleValue: %w", err)
	}
	return oldValue.LittleValue, nil
}

// AddLittleValue adds i to the "little_value" field.
func (m *RechargeCampaignRuleMutation) AddLittleValue(i int64) {
	if m.addlittle_value != nil {
		*m.addlittle_value += i
	} else {
		m.addlittle_value = &i
	}
}

// AddedLittleValue returns the value that was added to the "little_value" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedLittleValue() (r int64, exists bool) {
	v := m.addlittle_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetLittleValue resets all changes to the "little_value" field.
func (m *RechargeCampaignRuleMutation) ResetLittleValue() {
	m.little_value = nil
	m.addlittle_value = nil
}

// SetLargeValue sets the "large_value" field.
func (m *RechargeCampaignRuleMutation) SetLargeValue(i int64) {
	m.large_value = &i
	m.addlarge_value = nil
}

// LargeValue returns the value of the "large_value" field in the mutation.
func (m *RechargeCampaignRuleMutation) LargeValue() (r int64, exists bool) {
	v := m.large_value
	if v == nil {
		return
	}
	return *v, true
}

// OldLargeValue returns the old "large_value" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldLargeValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLargeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLargeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLargeValue: %w", err)
	}
	return oldValue.LargeValue, nil
}

// AddLargeValue adds i to the "large_value" field.
func (m *RechargeCampaignRuleMutation) AddLargeValue(i int64) {
	if m.addlarge_value != nil {
		*m.addlarge_value += i
	} else {
		m.addlarge_value = &i
	}
}

// AddedLargeValue returns the value that was added to the "large_value" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedLargeValue() (r int64, exists bool) {
	v := m.addlarge_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetLargeValue resets all changes to the "large_value" field.
func (m *RechargeCampaignRuleMutation) ResetLargeValue() {
	m.large_value = nil
	m.addlarge_value = nil
}

// SetGiftPercent sets the "gift_percent" field.
func (m *RechargeCampaignRuleMutation) SetGiftPercent(i int64) {
	m.gift_percent = &i
	m.addgift_percent = nil
}

// GiftPercent returns the value of the "gift_percent" field in the mutation.
func (m *RechargeCampaignRuleMutation) GiftPercent() (r int64, exists bool) {
	v := m.gift_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftPercent returns the old "gift_percent" field's value of the RechargeCampaignRule entity.
// If the RechargeCampaignRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeCampaignRuleMutation) OldGiftPercent(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftPercent: %w", err)
	}
	return oldValue.GiftPercent, nil
}

// AddGiftPercent adds i to the "gift_percent" field.
func (m *RechargeCampaignRuleMutation) AddGiftPercent(i int64) {
	if m.addgift_percent != nil {
		*m.addgift_percent += i
	} else {
		m.addgift_percent = &i
	}
}

// AddedGiftPercent returns the value that was added to the "gift_percent" field in this mutation.
func (m *RechargeCampaignRuleMutation) AddedGiftPercent() (r int64, exists bool) {
	v := m.addgift_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftPercent resets all changes to the "gift_percent" field.
func (m *RechargeCampaignRuleMutation) ResetGiftPercent() {
	m.gift_percent = nil
	m.addgift_percent = nil
}

// Where appends a list predicates to the RechargeCampaignRuleMutation builder.
func (m *RechargeCampaignRuleMutation) Where(ps ...predicate.RechargeCampaignRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RechargeCampaignRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RechargeCampaignRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RechargeCampaignRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RechargeCampaignRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RechargeCampaignRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RechargeCampaignRule).
func (m *RechargeCampaignRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RechargeCampaignRuleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, rechargecampaignrule.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, rechargecampaignrule.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, rechargecampaignrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rechargecampaignrule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rechargecampaignrule.FieldDeletedAt)
	}
	if m.little_value != nil {
		fields = append(fields, rechargecampaignrule.FieldLittleValue)
	}
	if m.large_value != nil {
		fields = append(fields, rechargecampaignrule.FieldLargeValue)
	}
	if m.gift_percent != nil {
		fields = append(fields, rechargecampaignrule.FieldGiftPercent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RechargeCampaignRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		return m.CreatedBy()
	case rechargecampaignrule.FieldUpdatedBy:
		return m.UpdatedBy()
	case rechargecampaignrule.FieldCreatedAt:
		return m.CreatedAt()
	case rechargecampaignrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case rechargecampaignrule.FieldDeletedAt:
		return m.DeletedAt()
	case rechargecampaignrule.FieldLittleValue:
		return m.LittleValue()
	case rechargecampaignrule.FieldLargeValue:
		return m.LargeValue()
	case rechargecampaignrule.FieldGiftPercent:
		return m.GiftPercent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RechargeCampaignRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rechargecampaignrule.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rechargecampaignrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rechargecampaignrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rechargecampaignrule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rechargecampaignrule.FieldLittleValue:
		return m.OldLittleValue(ctx)
	case rechargecampaignrule.FieldLargeValue:
		return m.OldLargeValue(ctx)
	case rechargecampaignrule.FieldGiftPercent:
		return m.OldGiftPercent(ctx)
	}
	return nil, fmt.Errorf("unknown RechargeCampaignRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeCampaignRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rechargecampaignrule.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rechargecampaignrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rechargecampaignrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rechargecampaignrule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rechargecampaignrule.FieldLittleValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLittleValue(v)
		return nil
	case rechargecampaignrule.FieldLargeValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLargeValue(v)
		return nil
	case rechargecampaignrule.FieldGiftPercent:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftPercent(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeCampaignRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RechargeCampaignRuleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, rechargecampaignrule.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, rechargecampaignrule.FieldUpdatedBy)
	}
	if m.addlittle_value != nil {
		fields = append(fields, rechargecampaignrule.FieldLittleValue)
	}
	if m.addlarge_value != nil {
		fields = append(fields, rechargecampaignrule.FieldLargeValue)
	}
	if m.addgift_percent != nil {
		fields = append(fields, rechargecampaignrule.FieldGiftPercent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RechargeCampaignRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		return m.AddedCreatedBy()
	case rechargecampaignrule.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case rechargecampaignrule.FieldLittleValue:
		return m.AddedLittleValue()
	case rechargecampaignrule.FieldLargeValue:
		return m.AddedLargeValue()
	case rechargecampaignrule.FieldGiftPercent:
		return m.AddedGiftPercent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeCampaignRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case rechargecampaignrule.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case rechargecampaignrule.FieldLittleValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLittleValue(v)
		return nil
	case rechargecampaignrule.FieldLargeValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLargeValue(v)
		return nil
	case rechargecampaignrule.FieldGiftPercent:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftPercent(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeCampaignRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RechargeCampaignRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RechargeCampaignRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RechargeCampaignRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RechargeCampaignRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RechargeCampaignRuleMutation) ResetField(name string) error {
	switch name {
	case rechargecampaignrule.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rechargecampaignrule.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rechargecampaignrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rechargecampaignrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rechargecampaignrule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rechargecampaignrule.FieldLittleValue:
		m.ResetLittleValue()
		return nil
	case rechargecampaignrule.FieldLargeValue:
		m.ResetLargeValue()
		return nil
	case rechargecampaignrule.FieldGiftPercent:
		m.ResetGiftPercent()
		return nil
	}
	return fmt.Errorf("unknown RechargeCampaignRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RechargeCampaignRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RechargeCampaignRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RechargeCampaignRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RechargeCampaignRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RechargeCampaignRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RechargeCampaignRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RechargeCampaignRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RechargeCampaignRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RechargeCampaignRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RechargeCampaignRule edge %s", name)
}

// RechargeOrderMutation represents an operation that mutates the RechargeOrder nodes in the graph.
type RechargeOrderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_by            *int64
	addcreated_by         *int64
	updated_by            *int64
	addupdated_by         *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	status                *rechargeorder.Status
	pure_cep              *int64
	addpure_cep           *int64
	gift_cep              *int64
	addgift_cep           *int64
	_type                 *rechargeorder.Type
	serial_number         *string
	third_api_resp        *string
	from_user_id          *int64
	addfrom_user_id       *int64
	out_transaction_id    *string
	clearedFields         map[string]struct{}
	user                  *int64
	cleareduser           bool
	cost_bills            map[int64]struct{}
	removedcost_bills     map[int64]struct{}
	clearedcost_bills     bool
	vx_social             *int64
	clearedvx_social      bool
	campaign_order        *int64
	clearedcampaign_order bool
	done                  bool
	oldValue              func(context.Context) (*RechargeOrder, error)
	predicates            []predicate.RechargeOrder
}

var _ ent.Mutation = (*RechargeOrderMutation)(nil)

// rechargeorderOption allows management of the mutation configuration using functional options.
type rechargeorderOption func(*RechargeOrderMutation)

// newRechargeOrderMutation creates new mutation for the RechargeOrder entity.
func newRechargeOrderMutation(c config, op Op, opts ...rechargeorderOption) *RechargeOrderMutation {
	m := &RechargeOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeRechargeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRechargeOrderID sets the ID field of the mutation.
func withRechargeOrderID(id int64) rechargeorderOption {
	return func(m *RechargeOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *RechargeOrder
		)
		m.oldValue = func(ctx context.Context) (*RechargeOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RechargeOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRechargeOrder sets the old RechargeOrder of the mutation.
func withRechargeOrder(node *RechargeOrder) rechargeorderOption {
	return func(m *RechargeOrderMutation) {
		m.oldValue = func(context.Context) (*RechargeOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RechargeOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RechargeOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RechargeOrder entities.
func (m *RechargeOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RechargeOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RechargeOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RechargeOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *RechargeOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RechargeOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RechargeOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RechargeOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RechargeOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RechargeOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RechargeOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RechargeOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RechargeOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RechargeOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RechargeOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RechargeOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RechargeOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RechargeOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RechargeOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RechargeOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RechargeOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RechargeOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RechargeOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *RechargeOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RechargeOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RechargeOrderMutation) ResetUserID() {
	m.user = nil
}

// SetStatus sets the "status" field.
func (m *RechargeOrderMutation) SetStatus(r rechargeorder.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RechargeOrderMutation) Status() (r rechargeorder.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldStatus(ctx context.Context) (v rechargeorder.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RechargeOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *RechargeOrderMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *RechargeOrderMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *RechargeOrderMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *RechargeOrderMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *RechargeOrderMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *RechargeOrderMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *RechargeOrderMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *RechargeOrderMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *RechargeOrderMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *RechargeOrderMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetSocialID sets the "social_id" field.
func (m *RechargeOrderMutation) SetSocialID(i int64) {
	m.vx_social = &i
}

// SocialID returns the value of the "social_id" field in the mutation.
func (m *RechargeOrderMutation) SocialID() (r int64, exists bool) {
	v := m.vx_social
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialID returns the old "social_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldSocialID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialID: %w", err)
	}
	return oldValue.SocialID, nil
}

// ClearSocialID clears the value of the "social_id" field.
func (m *RechargeOrderMutation) ClearSocialID() {
	m.vx_social = nil
	m.clearedFields[rechargeorder.FieldSocialID] = struct{}{}
}

// SocialIDCleared returns if the "social_id" field was cleared in this mutation.
func (m *RechargeOrderMutation) SocialIDCleared() bool {
	_, ok := m.clearedFields[rechargeorder.FieldSocialID]
	return ok
}

// ResetSocialID resets all changes to the "social_id" field.
func (m *RechargeOrderMutation) ResetSocialID() {
	m.vx_social = nil
	delete(m.clearedFields, rechargeorder.FieldSocialID)
}

// SetType sets the "type" field.
func (m *RechargeOrderMutation) SetType(r rechargeorder.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RechargeOrderMutation) GetType() (r rechargeorder.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldType(ctx context.Context) (v rechargeorder.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RechargeOrderMutation) ResetType() {
	m._type = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *RechargeOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *RechargeOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *RechargeOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetThirdAPIResp sets the "third_api_resp" field.
func (m *RechargeOrderMutation) SetThirdAPIResp(s string) {
	m.third_api_resp = &s
}

// ThirdAPIResp returns the value of the "third_api_resp" field in the mutation.
func (m *RechargeOrderMutation) ThirdAPIResp() (r string, exists bool) {
	v := m.third_api_resp
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdAPIResp returns the old "third_api_resp" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldThirdAPIResp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdAPIResp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdAPIResp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdAPIResp: %w", err)
	}
	return oldValue.ThirdAPIResp, nil
}

// ResetThirdAPIResp resets all changes to the "third_api_resp" field.
func (m *RechargeOrderMutation) ResetThirdAPIResp() {
	m.third_api_resp = nil
}

// SetFromUserID sets the "from_user_id" field.
func (m *RechargeOrderMutation) SetFromUserID(i int64) {
	m.from_user_id = &i
	m.addfrom_user_id = nil
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *RechargeOrderMutation) FromUserID() (r int64, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldFromUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// AddFromUserID adds i to the "from_user_id" field.
func (m *RechargeOrderMutation) AddFromUserID(i int64) {
	if m.addfrom_user_id != nil {
		*m.addfrom_user_id += i
	} else {
		m.addfrom_user_id = &i
	}
}

// AddedFromUserID returns the value that was added to the "from_user_id" field in this mutation.
func (m *RechargeOrderMutation) AddedFromUserID() (r int64, exists bool) {
	v := m.addfrom_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *RechargeOrderMutation) ResetFromUserID() {
	m.from_user_id = nil
	m.addfrom_user_id = nil
}

// SetOutTransactionID sets the "out_transaction_id" field.
func (m *RechargeOrderMutation) SetOutTransactionID(s string) {
	m.out_transaction_id = &s
}

// OutTransactionID returns the value of the "out_transaction_id" field in the mutation.
func (m *RechargeOrderMutation) OutTransactionID() (r string, exists bool) {
	v := m.out_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTransactionID returns the old "out_transaction_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldOutTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTransactionID: %w", err)
	}
	return oldValue.OutTransactionID, nil
}

// ResetOutTransactionID resets all changes to the "out_transaction_id" field.
func (m *RechargeOrderMutation) ResetOutTransactionID() {
	m.out_transaction_id = nil
}

// SetCampaignOrderID sets the "campaign_order_id" field.
func (m *RechargeOrderMutation) SetCampaignOrderID(i int64) {
	m.campaign_order = &i
}

// CampaignOrderID returns the value of the "campaign_order_id" field in the mutation.
func (m *RechargeOrderMutation) CampaignOrderID() (r int64, exists bool) {
	v := m.campaign_order
	if v == nil {
		return
	}
	return *v, true
}

// OldCampaignOrderID returns the old "campaign_order_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCampaignOrderID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCampaignOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCampaignOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCampaignOrderID: %w", err)
	}
	return oldValue.CampaignOrderID, nil
}

// ClearCampaignOrderID clears the value of the "campaign_order_id" field.
func (m *RechargeOrderMutation) ClearCampaignOrderID() {
	m.campaign_order = nil
	m.clearedFields[rechargeorder.FieldCampaignOrderID] = struct{}{}
}

// CampaignOrderIDCleared returns if the "campaign_order_id" field was cleared in this mutation.
func (m *RechargeOrderMutation) CampaignOrderIDCleared() bool {
	_, ok := m.clearedFields[rechargeorder.FieldCampaignOrderID]
	return ok
}

// ResetCampaignOrderID resets all changes to the "campaign_order_id" field.
func (m *RechargeOrderMutation) ResetCampaignOrderID() {
	m.campaign_order = nil
	delete(m.clearedFields, rechargeorder.FieldCampaignOrderID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *RechargeOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[rechargeorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RechargeOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RechargeOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RechargeOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *RechargeOrderMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *RechargeOrderMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *RechargeOrderMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *RechargeOrderMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *RechargeOrderMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *RechargeOrderMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *RechargeOrderMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// SetVxSocialID sets the "vx_social" edge to the VXSocial entity by id.
func (m *RechargeOrderMutation) SetVxSocialID(id int64) {
	m.vx_social = &id
}

// ClearVxSocial clears the "vx_social" edge to the VXSocial entity.
func (m *RechargeOrderMutation) ClearVxSocial() {
	m.clearedvx_social = true
	m.clearedFields[rechargeorder.FieldSocialID] = struct{}{}
}

// VxSocialCleared reports if the "vx_social" edge to the VXSocial entity was cleared.
func (m *RechargeOrderMutation) VxSocialCleared() bool {
	return m.SocialIDCleared() || m.clearedvx_social
}

// VxSocialID returns the "vx_social" edge ID in the mutation.
func (m *RechargeOrderMutation) VxSocialID() (id int64, exists bool) {
	if m.vx_social != nil {
		return *m.vx_social, true
	}
	return
}

// VxSocialIDs returns the "vx_social" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VxSocialID instead. It exists only for internal usage by the builders.
func (m *RechargeOrderMutation) VxSocialIDs() (ids []int64) {
	if id := m.vx_social; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVxSocial resets all changes to the "vx_social" edge.
func (m *RechargeOrderMutation) ResetVxSocial() {
	m.vx_social = nil
	m.clearedvx_social = false
}

// ClearCampaignOrder clears the "campaign_order" edge to the CampaignOrder entity.
func (m *RechargeOrderMutation) ClearCampaignOrder() {
	m.clearedcampaign_order = true
	m.clearedFields[rechargeorder.FieldCampaignOrderID] = struct{}{}
}

// CampaignOrderCleared reports if the "campaign_order" edge to the CampaignOrder entity was cleared.
func (m *RechargeOrderMutation) CampaignOrderCleared() bool {
	return m.CampaignOrderIDCleared() || m.clearedcampaign_order
}

// CampaignOrderIDs returns the "campaign_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignOrderID instead. It exists only for internal usage by the builders.
func (m *RechargeOrderMutation) CampaignOrderIDs() (ids []int64) {
	if id := m.campaign_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaignOrder resets all changes to the "campaign_order" edge.
func (m *RechargeOrderMutation) ResetCampaignOrder() {
	m.campaign_order = nil
	m.clearedcampaign_order = false
}

// Where appends a list predicates to the RechargeOrderMutation builder.
func (m *RechargeOrderMutation) Where(ps ...predicate.RechargeOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RechargeOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RechargeOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RechargeOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RechargeOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RechargeOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RechargeOrder).
func (m *RechargeOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RechargeOrderMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, rechargeorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, rechargeorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, rechargeorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rechargeorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rechargeorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, rechargeorder.FieldUserID)
	}
	if m.status != nil {
		fields = append(fields, rechargeorder.FieldStatus)
	}
	if m.pure_cep != nil {
		fields = append(fields, rechargeorder.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, rechargeorder.FieldGiftCep)
	}
	if m.vx_social != nil {
		fields = append(fields, rechargeorder.FieldSocialID)
	}
	if m._type != nil {
		fields = append(fields, rechargeorder.FieldType)
	}
	if m.serial_number != nil {
		fields = append(fields, rechargeorder.FieldSerialNumber)
	}
	if m.third_api_resp != nil {
		fields = append(fields, rechargeorder.FieldThirdAPIResp)
	}
	if m.from_user_id != nil {
		fields = append(fields, rechargeorder.FieldFromUserID)
	}
	if m.out_transaction_id != nil {
		fields = append(fields, rechargeorder.FieldOutTransactionID)
	}
	if m.campaign_order != nil {
		fields = append(fields, rechargeorder.FieldCampaignOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RechargeOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rechargeorder.FieldCreatedBy:
		return m.CreatedBy()
	case rechargeorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case rechargeorder.FieldCreatedAt:
		return m.CreatedAt()
	case rechargeorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case rechargeorder.FieldDeletedAt:
		return m.DeletedAt()
	case rechargeorder.FieldUserID:
		return m.UserID()
	case rechargeorder.FieldStatus:
		return m.Status()
	case rechargeorder.FieldPureCep:
		return m.PureCep()
	case rechargeorder.FieldGiftCep:
		return m.GiftCep()
	case rechargeorder.FieldSocialID:
		return m.SocialID()
	case rechargeorder.FieldType:
		return m.GetType()
	case rechargeorder.FieldSerialNumber:
		return m.SerialNumber()
	case rechargeorder.FieldThirdAPIResp:
		return m.ThirdAPIResp()
	case rechargeorder.FieldFromUserID:
		return m.FromUserID()
	case rechargeorder.FieldOutTransactionID:
		return m.OutTransactionID()
	case rechargeorder.FieldCampaignOrderID:
		return m.CampaignOrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RechargeOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rechargeorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rechargeorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rechargeorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rechargeorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rechargeorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rechargeorder.FieldUserID:
		return m.OldUserID(ctx)
	case rechargeorder.FieldStatus:
		return m.OldStatus(ctx)
	case rechargeorder.FieldPureCep:
		return m.OldPureCep(ctx)
	case rechargeorder.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case rechargeorder.FieldSocialID:
		return m.OldSocialID(ctx)
	case rechargeorder.FieldType:
		return m.OldType(ctx)
	case rechargeorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case rechargeorder.FieldThirdAPIResp:
		return m.OldThirdAPIResp(ctx)
	case rechargeorder.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case rechargeorder.FieldOutTransactionID:
		return m.OldOutTransactionID(ctx)
	case rechargeorder.FieldCampaignOrderID:
		return m.OldCampaignOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown RechargeOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rechargeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rechargeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rechargeorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rechargeorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rechargeorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rechargeorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case rechargeorder.FieldStatus:
		v, ok := value.(rechargeorder.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rechargeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case rechargeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case rechargeorder.FieldSocialID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialID(v)
		return nil
	case rechargeorder.FieldType:
		v, ok := value.(rechargeorder.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case rechargeorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case rechargeorder.FieldThirdAPIResp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdAPIResp(v)
		return nil
	case rechargeorder.FieldFromUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case rechargeorder.FieldOutTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTransactionID(v)
		return nil
	case rechargeorder.FieldCampaignOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCampaignOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RechargeOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, rechargeorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, rechargeorder.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, rechargeorder.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, rechargeorder.FieldGiftCep)
	}
	if m.addfrom_user_id != nil {
		fields = append(fields, rechargeorder.FieldFromUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RechargeOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rechargeorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case rechargeorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case rechargeorder.FieldPureCep:
		return m.AddedPureCep()
	case rechargeorder.FieldGiftCep:
		return m.AddedGiftCep()
	case rechargeorder.FieldFromUserID:
		return m.AddedFromUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rechargeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case rechargeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case rechargeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case rechargeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case rechargeorder.FieldFromUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromUserID(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RechargeOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rechargeorder.FieldSocialID) {
		fields = append(fields, rechargeorder.FieldSocialID)
	}
	if m.FieldCleared(rechargeorder.FieldCampaignOrderID) {
		fields = append(fields, rechargeorder.FieldCampaignOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RechargeOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RechargeOrderMutation) ClearField(name string) error {
	switch name {
	case rechargeorder.FieldSocialID:
		m.ClearSocialID()
		return nil
	case rechargeorder.FieldCampaignOrderID:
		m.ClearCampaignOrderID()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RechargeOrderMutation) ResetField(name string) error {
	switch name {
	case rechargeorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rechargeorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rechargeorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rechargeorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rechargeorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rechargeorder.FieldUserID:
		m.ResetUserID()
		return nil
	case rechargeorder.FieldStatus:
		m.ResetStatus()
		return nil
	case rechargeorder.FieldPureCep:
		m.ResetPureCep()
		return nil
	case rechargeorder.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case rechargeorder.FieldSocialID:
		m.ResetSocialID()
		return nil
	case rechargeorder.FieldType:
		m.ResetType()
		return nil
	case rechargeorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case rechargeorder.FieldThirdAPIResp:
		m.ResetThirdAPIResp()
		return nil
	case rechargeorder.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case rechargeorder.FieldOutTransactionID:
		m.ResetOutTransactionID()
		return nil
	case rechargeorder.FieldCampaignOrderID:
		m.ResetCampaignOrderID()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RechargeOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, rechargeorder.EdgeUser)
	}
	if m.cost_bills != nil {
		edges = append(edges, rechargeorder.EdgeCostBills)
	}
	if m.vx_social != nil {
		edges = append(edges, rechargeorder.EdgeVxSocial)
	}
	if m.campaign_order != nil {
		edges = append(edges, rechargeorder.EdgeCampaignOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RechargeOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rechargeorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case rechargeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case rechargeorder.EdgeVxSocial:
		if id := m.vx_social; id != nil {
			return []ent.Value{*id}
		}
	case rechargeorder.EdgeCampaignOrder:
		if id := m.campaign_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RechargeOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcost_bills != nil {
		edges = append(edges, rechargeorder.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RechargeOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rechargeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RechargeOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, rechargeorder.EdgeUser)
	}
	if m.clearedcost_bills {
		edges = append(edges, rechargeorder.EdgeCostBills)
	}
	if m.clearedvx_social {
		edges = append(edges, rechargeorder.EdgeVxSocial)
	}
	if m.clearedcampaign_order {
		edges = append(edges, rechargeorder.EdgeCampaignOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RechargeOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case rechargeorder.EdgeUser:
		return m.cleareduser
	case rechargeorder.EdgeCostBills:
		return m.clearedcost_bills
	case rechargeorder.EdgeVxSocial:
		return m.clearedvx_social
	case rechargeorder.EdgeCampaignOrder:
		return m.clearedcampaign_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RechargeOrderMutation) ClearEdge(name string) error {
	switch name {
	case rechargeorder.EdgeUser:
		m.ClearUser()
		return nil
	case rechargeorder.EdgeVxSocial:
		m.ClearVxSocial()
		return nil
	case rechargeorder.EdgeCampaignOrder:
		m.ClearCampaignOrder()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RechargeOrderMutation) ResetEdge(name string) error {
	switch name {
	case rechargeorder.EdgeUser:
		m.ResetUser()
		return nil
	case rechargeorder.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case rechargeorder.EdgeVxSocial:
		m.ResetVxSocial()
		return nil
	case rechargeorder.EdgeCampaignOrder:
		m.ResetCampaignOrder()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder edge %s", name)
}

// RenewalAgreementMutation represents an operation that mutates the RenewalAgreement nodes in the graph.
type RenewalAgreementMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	next_pay_time     *time.Time
	_type             *enums.RenewalType
	sub_status        *enums.RenewalSubStatus
	pay_status        *enums.RenewalPayStatus
	symbol_id         *int64
	addsymbol_id      *int64
	first_pay         *int64
	addfirst_pay      *int64
	after_pay         *int64
	addafter_pay      *int64
	last_warning_time *time.Time
	sub_finished_time *time.Time
	clearedFields     map[string]struct{}
	user              *int64
	cleareduser       bool
	mission           *int64
	clearedmission    bool
	done              bool
	oldValue          func(context.Context) (*RenewalAgreement, error)
	predicates        []predicate.RenewalAgreement
}

var _ ent.Mutation = (*RenewalAgreementMutation)(nil)

// renewalagreementOption allows management of the mutation configuration using functional options.
type renewalagreementOption func(*RenewalAgreementMutation)

// newRenewalAgreementMutation creates new mutation for the RenewalAgreement entity.
func newRenewalAgreementMutation(c config, op Op, opts ...renewalagreementOption) *RenewalAgreementMutation {
	m := &RenewalAgreementMutation{
		config:        c,
		op:            op,
		typ:           TypeRenewalAgreement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRenewalAgreementID sets the ID field of the mutation.
func withRenewalAgreementID(id int64) renewalagreementOption {
	return func(m *RenewalAgreementMutation) {
		var (
			err   error
			once  sync.Once
			value *RenewalAgreement
		)
		m.oldValue = func(ctx context.Context) (*RenewalAgreement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RenewalAgreement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRenewalAgreement sets the old RenewalAgreement of the mutation.
func withRenewalAgreement(node *RenewalAgreement) renewalagreementOption {
	return func(m *RenewalAgreementMutation) {
		m.oldValue = func(context.Context) (*RenewalAgreement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RenewalAgreementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RenewalAgreementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RenewalAgreement entities.
func (m *RenewalAgreementMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RenewalAgreementMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RenewalAgreementMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RenewalAgreement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *RenewalAgreementMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RenewalAgreementMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RenewalAgreementMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RenewalAgreementMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RenewalAgreementMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RenewalAgreementMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RenewalAgreementMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RenewalAgreementMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RenewalAgreementMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RenewalAgreementMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RenewalAgreementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RenewalAgreementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RenewalAgreementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RenewalAgreementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RenewalAgreementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RenewalAgreementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RenewalAgreementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RenewalAgreementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RenewalAgreementMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetNextPayTime sets the "next_pay_time" field.
func (m *RenewalAgreementMutation) SetNextPayTime(t time.Time) {
	m.next_pay_time = &t
}

// NextPayTime returns the value of the "next_pay_time" field in the mutation.
func (m *RenewalAgreementMutation) NextPayTime() (r time.Time, exists bool) {
	v := m.next_pay_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNextPayTime returns the old "next_pay_time" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldNextPayTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextPayTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextPayTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextPayTime: %w", err)
	}
	return oldValue.NextPayTime, nil
}

// ResetNextPayTime resets all changes to the "next_pay_time" field.
func (m *RenewalAgreementMutation) ResetNextPayTime() {
	m.next_pay_time = nil
}

// SetType sets the "type" field.
func (m *RenewalAgreementMutation) SetType(et enums.RenewalType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *RenewalAgreementMutation) GetType() (r enums.RenewalType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldType(ctx context.Context) (v enums.RenewalType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RenewalAgreementMutation) ResetType() {
	m._type = nil
}

// SetSubStatus sets the "sub_status" field.
func (m *RenewalAgreementMutation) SetSubStatus(ess enums.RenewalSubStatus) {
	m.sub_status = &ess
}

// SubStatus returns the value of the "sub_status" field in the mutation.
func (m *RenewalAgreementMutation) SubStatus() (r enums.RenewalSubStatus, exists bool) {
	v := m.sub_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSubStatus returns the old "sub_status" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldSubStatus(ctx context.Context) (v enums.RenewalSubStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubStatus: %w", err)
	}
	return oldValue.SubStatus, nil
}

// ResetSubStatus resets all changes to the "sub_status" field.
func (m *RenewalAgreementMutation) ResetSubStatus() {
	m.sub_status = nil
}

// SetPayStatus sets the "pay_status" field.
func (m *RenewalAgreementMutation) SetPayStatus(eps enums.RenewalPayStatus) {
	m.pay_status = &eps
}

// PayStatus returns the value of the "pay_status" field in the mutation.
func (m *RenewalAgreementMutation) PayStatus() (r enums.RenewalPayStatus, exists bool) {
	v := m.pay_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPayStatus returns the old "pay_status" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldPayStatus(ctx context.Context) (v enums.RenewalPayStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayStatus: %w", err)
	}
	return oldValue.PayStatus, nil
}

// ResetPayStatus resets all changes to the "pay_status" field.
func (m *RenewalAgreementMutation) ResetPayStatus() {
	m.pay_status = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *RenewalAgreementMutation) SetSymbolID(i int64) {
	m.symbol_id = &i
	m.addsymbol_id = nil
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *RenewalAgreementMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// AddSymbolID adds i to the "symbol_id" field.
func (m *RenewalAgreementMutation) AddSymbolID(i int64) {
	if m.addsymbol_id != nil {
		*m.addsymbol_id += i
	} else {
		m.addsymbol_id = &i
	}
}

// AddedSymbolID returns the value that was added to the "symbol_id" field in this mutation.
func (m *RenewalAgreementMutation) AddedSymbolID() (r int64, exists bool) {
	v := m.addsymbol_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *RenewalAgreementMutation) ResetSymbolID() {
	m.symbol_id = nil
	m.addsymbol_id = nil
}

// SetFirstPay sets the "first_pay" field.
func (m *RenewalAgreementMutation) SetFirstPay(i int64) {
	m.first_pay = &i
	m.addfirst_pay = nil
}

// FirstPay returns the value of the "first_pay" field in the mutation.
func (m *RenewalAgreementMutation) FirstPay() (r int64, exists bool) {
	v := m.first_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstPay returns the old "first_pay" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldFirstPay(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstPay: %w", err)
	}
	return oldValue.FirstPay, nil
}

// AddFirstPay adds i to the "first_pay" field.
func (m *RenewalAgreementMutation) AddFirstPay(i int64) {
	if m.addfirst_pay != nil {
		*m.addfirst_pay += i
	} else {
		m.addfirst_pay = &i
	}
}

// AddedFirstPay returns the value that was added to the "first_pay" field in this mutation.
func (m *RenewalAgreementMutation) AddedFirstPay() (r int64, exists bool) {
	v := m.addfirst_pay
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstPay resets all changes to the "first_pay" field.
func (m *RenewalAgreementMutation) ResetFirstPay() {
	m.first_pay = nil
	m.addfirst_pay = nil
}

// SetAfterPay sets the "after_pay" field.
func (m *RenewalAgreementMutation) SetAfterPay(i int64) {
	m.after_pay = &i
	m.addafter_pay = nil
}

// AfterPay returns the value of the "after_pay" field in the mutation.
func (m *RenewalAgreementMutation) AfterPay() (r int64, exists bool) {
	v := m.after_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldAfterPay returns the old "after_pay" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldAfterPay(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfterPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfterPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfterPay: %w", err)
	}
	return oldValue.AfterPay, nil
}

// AddAfterPay adds i to the "after_pay" field.
func (m *RenewalAgreementMutation) AddAfterPay(i int64) {
	if m.addafter_pay != nil {
		*m.addafter_pay += i
	} else {
		m.addafter_pay = &i
	}
}

// AddedAfterPay returns the value that was added to the "after_pay" field in this mutation.
func (m *RenewalAgreementMutation) AddedAfterPay() (r int64, exists bool) {
	v := m.addafter_pay
	if v == nil {
		return
	}
	return *v, true
}

// ResetAfterPay resets all changes to the "after_pay" field.
func (m *RenewalAgreementMutation) ResetAfterPay() {
	m.after_pay = nil
	m.addafter_pay = nil
}

// SetLastWarningTime sets the "last_warning_time" field.
func (m *RenewalAgreementMutation) SetLastWarningTime(t time.Time) {
	m.last_warning_time = &t
}

// LastWarningTime returns the value of the "last_warning_time" field in the mutation.
func (m *RenewalAgreementMutation) LastWarningTime() (r time.Time, exists bool) {
	v := m.last_warning_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastWarningTime returns the old "last_warning_time" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldLastWarningTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastWarningTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastWarningTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastWarningTime: %w", err)
	}
	return oldValue.LastWarningTime, nil
}

// ResetLastWarningTime resets all changes to the "last_warning_time" field.
func (m *RenewalAgreementMutation) ResetLastWarningTime() {
	m.last_warning_time = nil
}

// SetSubFinishedTime sets the "sub_finished_time" field.
func (m *RenewalAgreementMutation) SetSubFinishedTime(t time.Time) {
	m.sub_finished_time = &t
}

// SubFinishedTime returns the value of the "sub_finished_time" field in the mutation.
func (m *RenewalAgreementMutation) SubFinishedTime() (r time.Time, exists bool) {
	v := m.sub_finished_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSubFinishedTime returns the old "sub_finished_time" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldSubFinishedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubFinishedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubFinishedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubFinishedTime: %w", err)
	}
	return oldValue.SubFinishedTime, nil
}

// ResetSubFinishedTime resets all changes to the "sub_finished_time" field.
func (m *RenewalAgreementMutation) ResetSubFinishedTime() {
	m.sub_finished_time = nil
}

// SetUserID sets the "user_id" field.
func (m *RenewalAgreementMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RenewalAgreementMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RenewalAgreementMutation) ResetUserID() {
	m.user = nil
}

// SetMissionID sets the "mission_id" field.
func (m *RenewalAgreementMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *RenewalAgreementMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the RenewalAgreement entity.
// If the RenewalAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenewalAgreementMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *RenewalAgreementMutation) ResetMissionID() {
	m.mission = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RenewalAgreementMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[renewalagreement.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RenewalAgreementMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RenewalAgreementMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RenewalAgreementMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *RenewalAgreementMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[renewalagreement.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *RenewalAgreementMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *RenewalAgreementMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *RenewalAgreementMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// Where appends a list predicates to the RenewalAgreementMutation builder.
func (m *RenewalAgreementMutation) Where(ps ...predicate.RenewalAgreement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RenewalAgreementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RenewalAgreementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RenewalAgreement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RenewalAgreementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RenewalAgreementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RenewalAgreement).
func (m *RenewalAgreementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RenewalAgreementMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, renewalagreement.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, renewalagreement.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, renewalagreement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, renewalagreement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, renewalagreement.FieldDeletedAt)
	}
	if m.next_pay_time != nil {
		fields = append(fields, renewalagreement.FieldNextPayTime)
	}
	if m._type != nil {
		fields = append(fields, renewalagreement.FieldType)
	}
	if m.sub_status != nil {
		fields = append(fields, renewalagreement.FieldSubStatus)
	}
	if m.pay_status != nil {
		fields = append(fields, renewalagreement.FieldPayStatus)
	}
	if m.symbol_id != nil {
		fields = append(fields, renewalagreement.FieldSymbolID)
	}
	if m.first_pay != nil {
		fields = append(fields, renewalagreement.FieldFirstPay)
	}
	if m.after_pay != nil {
		fields = append(fields, renewalagreement.FieldAfterPay)
	}
	if m.last_warning_time != nil {
		fields = append(fields, renewalagreement.FieldLastWarningTime)
	}
	if m.sub_finished_time != nil {
		fields = append(fields, renewalagreement.FieldSubFinishedTime)
	}
	if m.user != nil {
		fields = append(fields, renewalagreement.FieldUserID)
	}
	if m.mission != nil {
		fields = append(fields, renewalagreement.FieldMissionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RenewalAgreementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case renewalagreement.FieldCreatedBy:
		return m.CreatedBy()
	case renewalagreement.FieldUpdatedBy:
		return m.UpdatedBy()
	case renewalagreement.FieldCreatedAt:
		return m.CreatedAt()
	case renewalagreement.FieldUpdatedAt:
		return m.UpdatedAt()
	case renewalagreement.FieldDeletedAt:
		return m.DeletedAt()
	case renewalagreement.FieldNextPayTime:
		return m.NextPayTime()
	case renewalagreement.FieldType:
		return m.GetType()
	case renewalagreement.FieldSubStatus:
		return m.SubStatus()
	case renewalagreement.FieldPayStatus:
		return m.PayStatus()
	case renewalagreement.FieldSymbolID:
		return m.SymbolID()
	case renewalagreement.FieldFirstPay:
		return m.FirstPay()
	case renewalagreement.FieldAfterPay:
		return m.AfterPay()
	case renewalagreement.FieldLastWarningTime:
		return m.LastWarningTime()
	case renewalagreement.FieldSubFinishedTime:
		return m.SubFinishedTime()
	case renewalagreement.FieldUserID:
		return m.UserID()
	case renewalagreement.FieldMissionID:
		return m.MissionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RenewalAgreementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case renewalagreement.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case renewalagreement.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case renewalagreement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case renewalagreement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case renewalagreement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case renewalagreement.FieldNextPayTime:
		return m.OldNextPayTime(ctx)
	case renewalagreement.FieldType:
		return m.OldType(ctx)
	case renewalagreement.FieldSubStatus:
		return m.OldSubStatus(ctx)
	case renewalagreement.FieldPayStatus:
		return m.OldPayStatus(ctx)
	case renewalagreement.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case renewalagreement.FieldFirstPay:
		return m.OldFirstPay(ctx)
	case renewalagreement.FieldAfterPay:
		return m.OldAfterPay(ctx)
	case renewalagreement.FieldLastWarningTime:
		return m.OldLastWarningTime(ctx)
	case renewalagreement.FieldSubFinishedTime:
		return m.OldSubFinishedTime(ctx)
	case renewalagreement.FieldUserID:
		return m.OldUserID(ctx)
	case renewalagreement.FieldMissionID:
		return m.OldMissionID(ctx)
	}
	return nil, fmt.Errorf("unknown RenewalAgreement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RenewalAgreementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case renewalagreement.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case renewalagreement.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case renewalagreement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case renewalagreement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case renewalagreement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case renewalagreement.FieldNextPayTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextPayTime(v)
		return nil
	case renewalagreement.FieldType:
		v, ok := value.(enums.RenewalType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case renewalagreement.FieldSubStatus:
		v, ok := value.(enums.RenewalSubStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubStatus(v)
		return nil
	case renewalagreement.FieldPayStatus:
		v, ok := value.(enums.RenewalPayStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayStatus(v)
		return nil
	case renewalagreement.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case renewalagreement.FieldFirstPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstPay(v)
		return nil
	case renewalagreement.FieldAfterPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfterPay(v)
		return nil
	case renewalagreement.FieldLastWarningTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastWarningTime(v)
		return nil
	case renewalagreement.FieldSubFinishedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubFinishedTime(v)
		return nil
	case renewalagreement.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case renewalagreement.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RenewalAgreementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, renewalagreement.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, renewalagreement.FieldUpdatedBy)
	}
	if m.addsymbol_id != nil {
		fields = append(fields, renewalagreement.FieldSymbolID)
	}
	if m.addfirst_pay != nil {
		fields = append(fields, renewalagreement.FieldFirstPay)
	}
	if m.addafter_pay != nil {
		fields = append(fields, renewalagreement.FieldAfterPay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RenewalAgreementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case renewalagreement.FieldCreatedBy:
		return m.AddedCreatedBy()
	case renewalagreement.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case renewalagreement.FieldSymbolID:
		return m.AddedSymbolID()
	case renewalagreement.FieldFirstPay:
		return m.AddedFirstPay()
	case renewalagreement.FieldAfterPay:
		return m.AddedAfterPay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RenewalAgreementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case renewalagreement.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case renewalagreement.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case renewalagreement.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSymbolID(v)
		return nil
	case renewalagreement.FieldFirstPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstPay(v)
		return nil
	case renewalagreement.FieldAfterPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAfterPay(v)
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RenewalAgreementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RenewalAgreementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RenewalAgreementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RenewalAgreement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RenewalAgreementMutation) ResetField(name string) error {
	switch name {
	case renewalagreement.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case renewalagreement.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case renewalagreement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case renewalagreement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case renewalagreement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case renewalagreement.FieldNextPayTime:
		m.ResetNextPayTime()
		return nil
	case renewalagreement.FieldType:
		m.ResetType()
		return nil
	case renewalagreement.FieldSubStatus:
		m.ResetSubStatus()
		return nil
	case renewalagreement.FieldPayStatus:
		m.ResetPayStatus()
		return nil
	case renewalagreement.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case renewalagreement.FieldFirstPay:
		m.ResetFirstPay()
		return nil
	case renewalagreement.FieldAfterPay:
		m.ResetAfterPay()
		return nil
	case renewalagreement.FieldLastWarningTime:
		m.ResetLastWarningTime()
		return nil
	case renewalagreement.FieldSubFinishedTime:
		m.ResetSubFinishedTime()
		return nil
	case renewalagreement.FieldUserID:
		m.ResetUserID()
		return nil
	case renewalagreement.FieldMissionID:
		m.ResetMissionID()
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RenewalAgreementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, renewalagreement.EdgeUser)
	}
	if m.mission != nil {
		edges = append(edges, renewalagreement.EdgeMission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RenewalAgreementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case renewalagreement.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case renewalagreement.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RenewalAgreementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RenewalAgreementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RenewalAgreementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, renewalagreement.EdgeUser)
	}
	if m.clearedmission {
		edges = append(edges, renewalagreement.EdgeMission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RenewalAgreementMutation) EdgeCleared(name string) bool {
	switch name {
	case renewalagreement.EdgeUser:
		return m.cleareduser
	case renewalagreement.EdgeMission:
		return m.clearedmission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RenewalAgreementMutation) ClearEdge(name string) error {
	switch name {
	case renewalagreement.EdgeUser:
		m.ClearUser()
		return nil
	case renewalagreement.EdgeMission:
		m.ClearMission()
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RenewalAgreementMutation) ResetEdge(name string) error {
	switch name {
	case renewalagreement.EdgeUser:
		m.ResetUser()
		return nil
	case renewalagreement.EdgeMission:
		m.ResetMission()
		return nil
	}
	return fmt.Errorf("unknown RenewalAgreement edge %s", name)
}

// SymbolMutation represents an operation that mutates the Symbol nodes in the graph.
type SymbolMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	name                       *string
	clearedFields              map[string]struct{}
	wallets                    map[int64]struct{}
	removedwallets             map[int64]struct{}
	clearedwallets             bool
	bills                      map[int64]struct{}
	removedbills               map[int64]struct{}
	clearedbills               bool
	mission_orders             map[int64]struct{}
	removedmission_orders      map[int64]struct{}
	clearedmission_orders      bool
	transfer_orders            map[int64]struct{}
	removedtransfer_orders     map[int64]struct{}
	clearedtransfer_orders     bool
	extra_service_order        map[int64]struct{}
	removedextra_service_order map[int64]struct{}
	clearedextra_service_order bool
	done                       bool
	oldValue                   func(context.Context) (*Symbol, error)
	predicates                 []predicate.Symbol
}

var _ ent.Mutation = (*SymbolMutation)(nil)

// symbolOption allows management of the mutation configuration using functional options.
type symbolOption func(*SymbolMutation)

// newSymbolMutation creates new mutation for the Symbol entity.
func newSymbolMutation(c config, op Op, opts ...symbolOption) *SymbolMutation {
	m := &SymbolMutation{
		config:        c,
		op:            op,
		typ:           TypeSymbol,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSymbolID sets the ID field of the mutation.
func withSymbolID(id int64) symbolOption {
	return func(m *SymbolMutation) {
		var (
			err   error
			once  sync.Once
			value *Symbol
		)
		m.oldValue = func(ctx context.Context) (*Symbol, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Symbol.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSymbol sets the old Symbol of the mutation.
func withSymbol(node *Symbol) symbolOption {
	return func(m *SymbolMutation) {
		m.oldValue = func(context.Context) (*Symbol, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SymbolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SymbolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Symbol entities.
func (m *SymbolMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SymbolMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SymbolMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Symbol.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *SymbolMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SymbolMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *SymbolMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SymbolMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SymbolMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SymbolMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SymbolMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *SymbolMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SymbolMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SymbolMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SymbolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SymbolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SymbolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SymbolMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SymbolMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SymbolMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SymbolMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SymbolMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SymbolMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *SymbolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SymbolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SymbolMutation) ResetName() {
	m.name = nil
}

// AddWalletIDs adds the "wallets" edge to the Wallet entity by ids.
func (m *SymbolMutation) AddWalletIDs(ids ...int64) {
	if m.wallets == nil {
		m.wallets = make(map[int64]struct{})
	}
	for i := range ids {
		m.wallets[ids[i]] = struct{}{}
	}
}

// ClearWallets clears the "wallets" edge to the Wallet entity.
func (m *SymbolMutation) ClearWallets() {
	m.clearedwallets = true
}

// WalletsCleared reports if the "wallets" edge to the Wallet entity was cleared.
func (m *SymbolMutation) WalletsCleared() bool {
	return m.clearedwallets
}

// RemoveWalletIDs removes the "wallets" edge to the Wallet entity by IDs.
func (m *SymbolMutation) RemoveWalletIDs(ids ...int64) {
	if m.removedwallets == nil {
		m.removedwallets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.wallets, ids[i])
		m.removedwallets[ids[i]] = struct{}{}
	}
}

// RemovedWallets returns the removed IDs of the "wallets" edge to the Wallet entity.
func (m *SymbolMutation) RemovedWalletsIDs() (ids []int64) {
	for id := range m.removedwallets {
		ids = append(ids, id)
	}
	return
}

// WalletsIDs returns the "wallets" edge IDs in the mutation.
func (m *SymbolMutation) WalletsIDs() (ids []int64) {
	for id := range m.wallets {
		ids = append(ids, id)
	}
	return
}

// ResetWallets resets all changes to the "wallets" edge.
func (m *SymbolMutation) ResetWallets() {
	m.wallets = nil
	m.clearedwallets = false
	m.removedwallets = nil
}

// AddBillIDs adds the "bills" edge to the Bill entity by ids.
func (m *SymbolMutation) AddBillIDs(ids ...int64) {
	if m.bills == nil {
		m.bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the Bill entity.
func (m *SymbolMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the Bill entity was cleared.
func (m *SymbolMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the Bill entity by IDs.
func (m *SymbolMutation) RemoveBillIDs(ids ...int64) {
	if m.removedbills == nil {
		m.removedbills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the Bill entity.
func (m *SymbolMutation) RemovedBillsIDs() (ids []int64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *SymbolMutation) BillsIDs() (ids []int64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *SymbolMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// AddMissionOrderIDs adds the "mission_orders" edge to the MissionOrder entity by ids.
func (m *SymbolMutation) AddMissionOrderIDs(ids ...int64) {
	if m.mission_orders == nil {
		m.mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionOrders clears the "mission_orders" edge to the MissionOrder entity.
func (m *SymbolMutation) ClearMissionOrders() {
	m.clearedmission_orders = true
}

// MissionOrdersCleared reports if the "mission_orders" edge to the MissionOrder entity was cleared.
func (m *SymbolMutation) MissionOrdersCleared() bool {
	return m.clearedmission_orders
}

// RemoveMissionOrderIDs removes the "mission_orders" edge to the MissionOrder entity by IDs.
func (m *SymbolMutation) RemoveMissionOrderIDs(ids ...int64) {
	if m.removedmission_orders == nil {
		m.removedmission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_orders, ids[i])
		m.removedmission_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionOrders returns the removed IDs of the "mission_orders" edge to the MissionOrder entity.
func (m *SymbolMutation) RemovedMissionOrdersIDs() (ids []int64) {
	for id := range m.removedmission_orders {
		ids = append(ids, id)
	}
	return
}

// MissionOrdersIDs returns the "mission_orders" edge IDs in the mutation.
func (m *SymbolMutation) MissionOrdersIDs() (ids []int64) {
	for id := range m.mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionOrders resets all changes to the "mission_orders" edge.
func (m *SymbolMutation) ResetMissionOrders() {
	m.mission_orders = nil
	m.clearedmission_orders = false
	m.removedmission_orders = nil
}

// AddTransferOrderIDs adds the "transfer_orders" edge to the TransferOrder entity by ids.
func (m *SymbolMutation) AddTransferOrderIDs(ids ...int64) {
	if m.transfer_orders == nil {
		m.transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.transfer_orders[ids[i]] = struct{}{}
	}
}

// ClearTransferOrders clears the "transfer_orders" edge to the TransferOrder entity.
func (m *SymbolMutation) ClearTransferOrders() {
	m.clearedtransfer_orders = true
}

// TransferOrdersCleared reports if the "transfer_orders" edge to the TransferOrder entity was cleared.
func (m *SymbolMutation) TransferOrdersCleared() bool {
	return m.clearedtransfer_orders
}

// RemoveTransferOrderIDs removes the "transfer_orders" edge to the TransferOrder entity by IDs.
func (m *SymbolMutation) RemoveTransferOrderIDs(ids ...int64) {
	if m.removedtransfer_orders == nil {
		m.removedtransfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.transfer_orders, ids[i])
		m.removedtransfer_orders[ids[i]] = struct{}{}
	}
}

// RemovedTransferOrders returns the removed IDs of the "transfer_orders" edge to the TransferOrder entity.
func (m *SymbolMutation) RemovedTransferOrdersIDs() (ids []int64) {
	for id := range m.removedtransfer_orders {
		ids = append(ids, id)
	}
	return
}

// TransferOrdersIDs returns the "transfer_orders" edge IDs in the mutation.
func (m *SymbolMutation) TransferOrdersIDs() (ids []int64) {
	for id := range m.transfer_orders {
		ids = append(ids, id)
	}
	return
}

// ResetTransferOrders resets all changes to the "transfer_orders" edge.
func (m *SymbolMutation) ResetTransferOrders() {
	m.transfer_orders = nil
	m.clearedtransfer_orders = false
	m.removedtransfer_orders = nil
}

// AddExtraServiceOrderIDs adds the "extra_service_order" edge to the ExtraServiceOrder entity by ids.
func (m *SymbolMutation) AddExtraServiceOrderIDs(ids ...int64) {
	if m.extra_service_order == nil {
		m.extra_service_order = make(map[int64]struct{})
	}
	for i := range ids {
		m.extra_service_order[ids[i]] = struct{}{}
	}
}

// ClearExtraServiceOrder clears the "extra_service_order" edge to the ExtraServiceOrder entity.
func (m *SymbolMutation) ClearExtraServiceOrder() {
	m.clearedextra_service_order = true
}

// ExtraServiceOrderCleared reports if the "extra_service_order" edge to the ExtraServiceOrder entity was cleared.
func (m *SymbolMutation) ExtraServiceOrderCleared() bool {
	return m.clearedextra_service_order
}

// RemoveExtraServiceOrderIDs removes the "extra_service_order" edge to the ExtraServiceOrder entity by IDs.
func (m *SymbolMutation) RemoveExtraServiceOrderIDs(ids ...int64) {
	if m.removedextra_service_order == nil {
		m.removedextra_service_order = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.extra_service_order, ids[i])
		m.removedextra_service_order[ids[i]] = struct{}{}
	}
}

// RemovedExtraServiceOrder returns the removed IDs of the "extra_service_order" edge to the ExtraServiceOrder entity.
func (m *SymbolMutation) RemovedExtraServiceOrderIDs() (ids []int64) {
	for id := range m.removedextra_service_order {
		ids = append(ids, id)
	}
	return
}

// ExtraServiceOrderIDs returns the "extra_service_order" edge IDs in the mutation.
func (m *SymbolMutation) ExtraServiceOrderIDs() (ids []int64) {
	for id := range m.extra_service_order {
		ids = append(ids, id)
	}
	return
}

// ResetExtraServiceOrder resets all changes to the "extra_service_order" edge.
func (m *SymbolMutation) ResetExtraServiceOrder() {
	m.extra_service_order = nil
	m.clearedextra_service_order = false
	m.removedextra_service_order = nil
}

// Where appends a list predicates to the SymbolMutation builder.
func (m *SymbolMutation) Where(ps ...predicate.Symbol) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SymbolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SymbolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Symbol, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SymbolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SymbolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Symbol).
func (m *SymbolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SymbolMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_by != nil {
		fields = append(fields, symbol.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, symbol.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, symbol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, symbol.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, symbol.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, symbol.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SymbolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case symbol.FieldCreatedBy:
		return m.CreatedBy()
	case symbol.FieldUpdatedBy:
		return m.UpdatedBy()
	case symbol.FieldCreatedAt:
		return m.CreatedAt()
	case symbol.FieldUpdatedAt:
		return m.UpdatedAt()
	case symbol.FieldDeletedAt:
		return m.DeletedAt()
	case symbol.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SymbolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case symbol.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case symbol.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case symbol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case symbol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case symbol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case symbol.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Symbol field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SymbolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case symbol.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case symbol.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case symbol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case symbol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case symbol.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case symbol.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Symbol field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SymbolMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, symbol.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, symbol.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SymbolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case symbol.FieldCreatedBy:
		return m.AddedCreatedBy()
	case symbol.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SymbolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case symbol.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case symbol.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Symbol numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SymbolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SymbolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SymbolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Symbol nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SymbolMutation) ResetField(name string) error {
	switch name {
	case symbol.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case symbol.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case symbol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case symbol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case symbol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case symbol.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Symbol field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SymbolMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.wallets != nil {
		edges = append(edges, symbol.EdgeWallets)
	}
	if m.bills != nil {
		edges = append(edges, symbol.EdgeBills)
	}
	if m.mission_orders != nil {
		edges = append(edges, symbol.EdgeMissionOrders)
	}
	if m.transfer_orders != nil {
		edges = append(edges, symbol.EdgeTransferOrders)
	}
	if m.extra_service_order != nil {
		edges = append(edges, symbol.EdgeExtraServiceOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SymbolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case symbol.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.wallets))
		for id := range m.wallets {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.mission_orders))
		for id := range m.mission_orders {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeTransferOrders:
		ids := make([]ent.Value, 0, len(m.transfer_orders))
		for id := range m.transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeExtraServiceOrder:
		ids := make([]ent.Value, 0, len(m.extra_service_order))
		for id := range m.extra_service_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SymbolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedwallets != nil {
		edges = append(edges, symbol.EdgeWallets)
	}
	if m.removedbills != nil {
		edges = append(edges, symbol.EdgeBills)
	}
	if m.removedmission_orders != nil {
		edges = append(edges, symbol.EdgeMissionOrders)
	}
	if m.removedtransfer_orders != nil {
		edges = append(edges, symbol.EdgeTransferOrders)
	}
	if m.removedextra_service_order != nil {
		edges = append(edges, symbol.EdgeExtraServiceOrder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SymbolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case symbol.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.removedwallets))
		for id := range m.removedwallets {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_orders))
		for id := range m.removedmission_orders {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeTransferOrders:
		ids := make([]ent.Value, 0, len(m.removedtransfer_orders))
		for id := range m.removedtransfer_orders {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeExtraServiceOrder:
		ids := make([]ent.Value, 0, len(m.removedextra_service_order))
		for id := range m.removedextra_service_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SymbolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedwallets {
		edges = append(edges, symbol.EdgeWallets)
	}
	if m.clearedbills {
		edges = append(edges, symbol.EdgeBills)
	}
	if m.clearedmission_orders {
		edges = append(edges, symbol.EdgeMissionOrders)
	}
	if m.clearedtransfer_orders {
		edges = append(edges, symbol.EdgeTransferOrders)
	}
	if m.clearedextra_service_order {
		edges = append(edges, symbol.EdgeExtraServiceOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SymbolMutation) EdgeCleared(name string) bool {
	switch name {
	case symbol.EdgeWallets:
		return m.clearedwallets
	case symbol.EdgeBills:
		return m.clearedbills
	case symbol.EdgeMissionOrders:
		return m.clearedmission_orders
	case symbol.EdgeTransferOrders:
		return m.clearedtransfer_orders
	case symbol.EdgeExtraServiceOrder:
		return m.clearedextra_service_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SymbolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Symbol unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SymbolMutation) ResetEdge(name string) error {
	switch name {
	case symbol.EdgeWallets:
		m.ResetWallets()
		return nil
	case symbol.EdgeBills:
		m.ResetBills()
		return nil
	case symbol.EdgeMissionOrders:
		m.ResetMissionOrders()
		return nil
	case symbol.EdgeTransferOrders:
		m.ResetTransferOrders()
		return nil
	case symbol.EdgeExtraServiceOrder:
		m.ResetExtraServiceOrder()
		return nil
	}
	return fmt.Errorf("unknown Symbol edge %s", name)
}

// TransferOrderMutation represents an operation that mutates the TransferOrder nodes in the graph.
type TransferOrderMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_by         *int64
	addcreated_by      *int64
	updated_by         *int64
	addupdated_by      *int64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	status             *transferorder.Status
	amount             *int64
	addamount          *int64
	_type              *enums.TransferOrderType
	serial_number      *string
	third_api_resp     *string
	out_transaction_id *string
	clearedFields      map[string]struct{}
	source_user        *int64
	clearedsource_user bool
	target_user        *int64
	clearedtarget_user bool
	bills              map[int64]struct{}
	removedbills       map[int64]struct{}
	clearedbills       bool
	vx_social          *int64
	clearedvx_social   bool
	symbol             *int64
	clearedsymbol      bool
	done               bool
	oldValue           func(context.Context) (*TransferOrder, error)
	predicates         []predicate.TransferOrder
}

var _ ent.Mutation = (*TransferOrderMutation)(nil)

// transferorderOption allows management of the mutation configuration using functional options.
type transferorderOption func(*TransferOrderMutation)

// newTransferOrderMutation creates new mutation for the TransferOrder entity.
func newTransferOrderMutation(c config, op Op, opts ...transferorderOption) *TransferOrderMutation {
	m := &TransferOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeTransferOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferOrderID sets the ID field of the mutation.
func withTransferOrderID(id int64) transferorderOption {
	return func(m *TransferOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *TransferOrder
		)
		m.oldValue = func(ctx context.Context) (*TransferOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransferOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransferOrder sets the old TransferOrder of the mutation.
func withTransferOrder(node *TransferOrder) transferorderOption {
	return func(m *TransferOrderMutation) {
		m.oldValue = func(context.Context) (*TransferOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransferOrder entities.
func (m *TransferOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransferOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *TransferOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TransferOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TransferOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TransferOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TransferOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TransferOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TransferOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TransferOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TransferOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TransferOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TransferOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransferOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransferOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransferOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransferOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransferOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransferOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransferOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransferOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetSourceUserID sets the "source_user_id" field.
func (m *TransferOrderMutation) SetSourceUserID(i int64) {
	m.source_user = &i
}

// SourceUserID returns the value of the "source_user_id" field in the mutation.
func (m *TransferOrderMutation) SourceUserID() (r int64, exists bool) {
	v := m.source_user
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceUserID returns the old "source_user_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldSourceUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceUserID: %w", err)
	}
	return oldValue.SourceUserID, nil
}

// ResetSourceUserID resets all changes to the "source_user_id" field.
func (m *TransferOrderMutation) ResetSourceUserID() {
	m.source_user = nil
}

// SetTargetUserID sets the "target_user_id" field.
func (m *TransferOrderMutation) SetTargetUserID(i int64) {
	m.target_user = &i
}

// TargetUserID returns the value of the "target_user_id" field in the mutation.
func (m *TransferOrderMutation) TargetUserID() (r int64, exists bool) {
	v := m.target_user
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetUserID returns the old "target_user_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldTargetUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetUserID: %w", err)
	}
	return oldValue.TargetUserID, nil
}

// ResetTargetUserID resets all changes to the "target_user_id" field.
func (m *TransferOrderMutation) ResetTargetUserID() {
	m.target_user = nil
}

// SetStatus sets the "status" field.
func (m *TransferOrderMutation) SetStatus(t transferorder.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TransferOrderMutation) Status() (r transferorder.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldStatus(ctx context.Context) (v transferorder.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransferOrderMutation) ResetStatus() {
	m.status = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *TransferOrderMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *TransferOrderMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *TransferOrderMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetAmount sets the "amount" field.
func (m *TransferOrderMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransferOrderMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TransferOrderMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransferOrderMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransferOrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetType sets the "type" field.
func (m *TransferOrderMutation) SetType(eot enums.TransferOrderType) {
	m._type = &eot
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransferOrderMutation) GetType() (r enums.TransferOrderType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldType(ctx context.Context) (v enums.TransferOrderType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransferOrderMutation) ResetType() {
	m._type = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *TransferOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *TransferOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *TransferOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetSocialID sets the "social_id" field.
func (m *TransferOrderMutation) SetSocialID(i int64) {
	m.vx_social = &i
}

// SocialID returns the value of the "social_id" field in the mutation.
func (m *TransferOrderMutation) SocialID() (r int64, exists bool) {
	v := m.vx_social
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialID returns the old "social_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldSocialID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialID: %w", err)
	}
	return oldValue.SocialID, nil
}

// ClearSocialID clears the value of the "social_id" field.
func (m *TransferOrderMutation) ClearSocialID() {
	m.vx_social = nil
	m.clearedFields[transferorder.FieldSocialID] = struct{}{}
}

// SocialIDCleared returns if the "social_id" field was cleared in this mutation.
func (m *TransferOrderMutation) SocialIDCleared() bool {
	_, ok := m.clearedFields[transferorder.FieldSocialID]
	return ok
}

// ResetSocialID resets all changes to the "social_id" field.
func (m *TransferOrderMutation) ResetSocialID() {
	m.vx_social = nil
	delete(m.clearedFields, transferorder.FieldSocialID)
}

// SetThirdAPIResp sets the "third_api_resp" field.
func (m *TransferOrderMutation) SetThirdAPIResp(s string) {
	m.third_api_resp = &s
}

// ThirdAPIResp returns the value of the "third_api_resp" field in the mutation.
func (m *TransferOrderMutation) ThirdAPIResp() (r string, exists bool) {
	v := m.third_api_resp
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdAPIResp returns the old "third_api_resp" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldThirdAPIResp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdAPIResp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdAPIResp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdAPIResp: %w", err)
	}
	return oldValue.ThirdAPIResp, nil
}

// ResetThirdAPIResp resets all changes to the "third_api_resp" field.
func (m *TransferOrderMutation) ResetThirdAPIResp() {
	m.third_api_resp = nil
}

// SetOutTransactionID sets the "out_transaction_id" field.
func (m *TransferOrderMutation) SetOutTransactionID(s string) {
	m.out_transaction_id = &s
}

// OutTransactionID returns the value of the "out_transaction_id" field in the mutation.
func (m *TransferOrderMutation) OutTransactionID() (r string, exists bool) {
	v := m.out_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTransactionID returns the old "out_transaction_id" field's value of the TransferOrder entity.
// If the TransferOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferOrderMutation) OldOutTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTransactionID: %w", err)
	}
	return oldValue.OutTransactionID, nil
}

// ResetOutTransactionID resets all changes to the "out_transaction_id" field.
func (m *TransferOrderMutation) ResetOutTransactionID() {
	m.out_transaction_id = nil
}

// ClearSourceUser clears the "source_user" edge to the User entity.
func (m *TransferOrderMutation) ClearSourceUser() {
	m.clearedsource_user = true
	m.clearedFields[transferorder.FieldSourceUserID] = struct{}{}
}

// SourceUserCleared reports if the "source_user" edge to the User entity was cleared.
func (m *TransferOrderMutation) SourceUserCleared() bool {
	return m.clearedsource_user
}

// SourceUserIDs returns the "source_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceUserID instead. It exists only for internal usage by the builders.
func (m *TransferOrderMutation) SourceUserIDs() (ids []int64) {
	if id := m.source_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceUser resets all changes to the "source_user" edge.
func (m *TransferOrderMutation) ResetSourceUser() {
	m.source_user = nil
	m.clearedsource_user = false
}

// ClearTargetUser clears the "target_user" edge to the User entity.
func (m *TransferOrderMutation) ClearTargetUser() {
	m.clearedtarget_user = true
	m.clearedFields[transferorder.FieldTargetUserID] = struct{}{}
}

// TargetUserCleared reports if the "target_user" edge to the User entity was cleared.
func (m *TransferOrderMutation) TargetUserCleared() bool {
	return m.clearedtarget_user
}

// TargetUserIDs returns the "target_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetUserID instead. It exists only for internal usage by the builders.
func (m *TransferOrderMutation) TargetUserIDs() (ids []int64) {
	if id := m.target_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetUser resets all changes to the "target_user" edge.
func (m *TransferOrderMutation) ResetTargetUser() {
	m.target_user = nil
	m.clearedtarget_user = false
}

// AddBillIDs adds the "bills" edge to the Bill entity by ids.
func (m *TransferOrderMutation) AddBillIDs(ids ...int64) {
	if m.bills == nil {
		m.bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the Bill entity.
func (m *TransferOrderMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the Bill entity was cleared.
func (m *TransferOrderMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the Bill entity by IDs.
func (m *TransferOrderMutation) RemoveBillIDs(ids ...int64) {
	if m.removedbills == nil {
		m.removedbills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the Bill entity.
func (m *TransferOrderMutation) RemovedBillsIDs() (ids []int64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *TransferOrderMutation) BillsIDs() (ids []int64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *TransferOrderMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// SetVxSocialID sets the "vx_social" edge to the VXSocial entity by id.
func (m *TransferOrderMutation) SetVxSocialID(id int64) {
	m.vx_social = &id
}

// ClearVxSocial clears the "vx_social" edge to the VXSocial entity.
func (m *TransferOrderMutation) ClearVxSocial() {
	m.clearedvx_social = true
	m.clearedFields[transferorder.FieldSocialID] = struct{}{}
}

// VxSocialCleared reports if the "vx_social" edge to the VXSocial entity was cleared.
func (m *TransferOrderMutation) VxSocialCleared() bool {
	return m.SocialIDCleared() || m.clearedvx_social
}

// VxSocialID returns the "vx_social" edge ID in the mutation.
func (m *TransferOrderMutation) VxSocialID() (id int64, exists bool) {
	if m.vx_social != nil {
		return *m.vx_social, true
	}
	return
}

// VxSocialIDs returns the "vx_social" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VxSocialID instead. It exists only for internal usage by the builders.
func (m *TransferOrderMutation) VxSocialIDs() (ids []int64) {
	if id := m.vx_social; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVxSocial resets all changes to the "vx_social" edge.
func (m *TransferOrderMutation) ResetVxSocial() {
	m.vx_social = nil
	m.clearedvx_social = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *TransferOrderMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[transferorder.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *TransferOrderMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *TransferOrderMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *TransferOrderMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// Where appends a list predicates to the TransferOrderMutation builder.
func (m *TransferOrderMutation) Where(ps ...predicate.TransferOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransferOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransferOrder).
func (m *TransferOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferOrderMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, transferorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, transferorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, transferorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transferorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transferorder.FieldDeletedAt)
	}
	if m.source_user != nil {
		fields = append(fields, transferorder.FieldSourceUserID)
	}
	if m.target_user != nil {
		fields = append(fields, transferorder.FieldTargetUserID)
	}
	if m.status != nil {
		fields = append(fields, transferorder.FieldStatus)
	}
	if m.symbol != nil {
		fields = append(fields, transferorder.FieldSymbolID)
	}
	if m.amount != nil {
		fields = append(fields, transferorder.FieldAmount)
	}
	if m._type != nil {
		fields = append(fields, transferorder.FieldType)
	}
	if m.serial_number != nil {
		fields = append(fields, transferorder.FieldSerialNumber)
	}
	if m.vx_social != nil {
		fields = append(fields, transferorder.FieldSocialID)
	}
	if m.third_api_resp != nil {
		fields = append(fields, transferorder.FieldThirdAPIResp)
	}
	if m.out_transaction_id != nil {
		fields = append(fields, transferorder.FieldOutTransactionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transferorder.FieldCreatedBy:
		return m.CreatedBy()
	case transferorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case transferorder.FieldCreatedAt:
		return m.CreatedAt()
	case transferorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case transferorder.FieldDeletedAt:
		return m.DeletedAt()
	case transferorder.FieldSourceUserID:
		return m.SourceUserID()
	case transferorder.FieldTargetUserID:
		return m.TargetUserID()
	case transferorder.FieldStatus:
		return m.Status()
	case transferorder.FieldSymbolID:
		return m.SymbolID()
	case transferorder.FieldAmount:
		return m.Amount()
	case transferorder.FieldType:
		return m.GetType()
	case transferorder.FieldSerialNumber:
		return m.SerialNumber()
	case transferorder.FieldSocialID:
		return m.SocialID()
	case transferorder.FieldThirdAPIResp:
		return m.ThirdAPIResp()
	case transferorder.FieldOutTransactionID:
		return m.OutTransactionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transferorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case transferorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case transferorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transferorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transferorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transferorder.FieldSourceUserID:
		return m.OldSourceUserID(ctx)
	case transferorder.FieldTargetUserID:
		return m.OldTargetUserID(ctx)
	case transferorder.FieldStatus:
		return m.OldStatus(ctx)
	case transferorder.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case transferorder.FieldAmount:
		return m.OldAmount(ctx)
	case transferorder.FieldType:
		return m.OldType(ctx)
	case transferorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case transferorder.FieldSocialID:
		return m.OldSocialID(ctx)
	case transferorder.FieldThirdAPIResp:
		return m.OldThirdAPIResp(ctx)
	case transferorder.FieldOutTransactionID:
		return m.OldOutTransactionID(ctx)
	}
	return nil, fmt.Errorf("unknown TransferOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transferorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case transferorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case transferorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transferorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transferorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transferorder.FieldSourceUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceUserID(v)
		return nil
	case transferorder.FieldTargetUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetUserID(v)
		return nil
	case transferorder.FieldStatus:
		v, ok := value.(transferorder.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transferorder.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case transferorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transferorder.FieldType:
		v, ok := value.(enums.TransferOrderType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transferorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case transferorder.FieldSocialID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialID(v)
		return nil
	case transferorder.FieldThirdAPIResp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdAPIResp(v)
		return nil
	case transferorder.FieldOutTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTransactionID(v)
		return nil
	}
	return fmt.Errorf("unknown TransferOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, transferorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, transferorder.FieldUpdatedBy)
	}
	if m.addamount != nil {
		fields = append(fields, transferorder.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transferorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case transferorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case transferorder.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transferorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case transferorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case transferorder.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TransferOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transferorder.FieldSocialID) {
		fields = append(fields, transferorder.FieldSocialID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferOrderMutation) ClearField(name string) error {
	switch name {
	case transferorder.FieldSocialID:
		m.ClearSocialID()
		return nil
	}
	return fmt.Errorf("unknown TransferOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferOrderMutation) ResetField(name string) error {
	switch name {
	case transferorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case transferorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case transferorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transferorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transferorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transferorder.FieldSourceUserID:
		m.ResetSourceUserID()
		return nil
	case transferorder.FieldTargetUserID:
		m.ResetTargetUserID()
		return nil
	case transferorder.FieldStatus:
		m.ResetStatus()
		return nil
	case transferorder.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case transferorder.FieldAmount:
		m.ResetAmount()
		return nil
	case transferorder.FieldType:
		m.ResetType()
		return nil
	case transferorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case transferorder.FieldSocialID:
		m.ResetSocialID()
		return nil
	case transferorder.FieldThirdAPIResp:
		m.ResetThirdAPIResp()
		return nil
	case transferorder.FieldOutTransactionID:
		m.ResetOutTransactionID()
		return nil
	}
	return fmt.Errorf("unknown TransferOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.source_user != nil {
		edges = append(edges, transferorder.EdgeSourceUser)
	}
	if m.target_user != nil {
		edges = append(edges, transferorder.EdgeTargetUser)
	}
	if m.bills != nil {
		edges = append(edges, transferorder.EdgeBills)
	}
	if m.vx_social != nil {
		edges = append(edges, transferorder.EdgeVxSocial)
	}
	if m.symbol != nil {
		edges = append(edges, transferorder.EdgeSymbol)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transferorder.EdgeSourceUser:
		if id := m.source_user; id != nil {
			return []ent.Value{*id}
		}
	case transferorder.EdgeTargetUser:
		if id := m.target_user; id != nil {
			return []ent.Value{*id}
		}
	case transferorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case transferorder.EdgeVxSocial:
		if id := m.vx_social; id != nil {
			return []ent.Value{*id}
		}
	case transferorder.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedbills != nil {
		edges = append(edges, transferorder.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transferorder.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedsource_user {
		edges = append(edges, transferorder.EdgeSourceUser)
	}
	if m.clearedtarget_user {
		edges = append(edges, transferorder.EdgeTargetUser)
	}
	if m.clearedbills {
		edges = append(edges, transferorder.EdgeBills)
	}
	if m.clearedvx_social {
		edges = append(edges, transferorder.EdgeVxSocial)
	}
	if m.clearedsymbol {
		edges = append(edges, transferorder.EdgeSymbol)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case transferorder.EdgeSourceUser:
		return m.clearedsource_user
	case transferorder.EdgeTargetUser:
		return m.clearedtarget_user
	case transferorder.EdgeBills:
		return m.clearedbills
	case transferorder.EdgeVxSocial:
		return m.clearedvx_social
	case transferorder.EdgeSymbol:
		return m.clearedsymbol
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferOrderMutation) ClearEdge(name string) error {
	switch name {
	case transferorder.EdgeSourceUser:
		m.ClearSourceUser()
		return nil
	case transferorder.EdgeTargetUser:
		m.ClearTargetUser()
		return nil
	case transferorder.EdgeVxSocial:
		m.ClearVxSocial()
		return nil
	case transferorder.EdgeSymbol:
		m.ClearSymbol()
		return nil
	}
	return fmt.Errorf("unknown TransferOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferOrderMutation) ResetEdge(name string) error {
	switch name {
	case transferorder.EdgeSourceUser:
		m.ResetSourceUser()
		return nil
	case transferorder.EdgeTargetUser:
		m.ResetTargetUser()
		return nil
	case transferorder.EdgeBills:
		m.ResetBills()
		return nil
	case transferorder.EdgeVxSocial:
		m.ResetVxSocial()
		return nil
	case transferorder.EdgeSymbol:
		m.ResetSymbol()
		return nil
	}
	return fmt.Errorf("unknown TransferOrder edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int64
	created_by                     *int64
	addcreated_by                  *int64
	updated_by                     *int64
	addupdated_by                  *int64
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	name                           *string
	nick_name                      *string
	jpg_url                        *string
	key                            *string
	secret                         *string
	phone                          *string
	password                       *string
	is_frozen                      *bool
	is_recharge                    *bool
	user_type                      *user.UserType
	pop_version                    *string
	area_code                      *string
	email                          *string
	clearedFields                  map[string]struct{}
	vx_accounts                    map[int64]struct{}
	removedvx_accounts             map[int64]struct{}
	clearedvx_accounts             bool
	collects                       map[int64]struct{}
	removedcollects                map[int64]struct{}
	clearedcollects                bool
	devices                        map[int64]struct{}
	removeddevices                 map[int64]struct{}
	cleareddevices                 bool
	profit_settings                map[int64]struct{}
	removedprofit_settings         map[int64]struct{}
	clearedprofit_settings         bool
	cost_account                   *int64
	clearedcost_account            bool
	profit_account                 *int64
	clearedprofit_account          bool
	cost_bills                     map[int64]struct{}
	removedcost_bills              map[int64]struct{}
	clearedcost_bills              bool
	earn_bills                     map[int64]struct{}
	removedearn_bills              map[int64]struct{}
	clearedearn_bills              bool
	mission_consume_orders         map[int64]struct{}
	removedmission_consume_orders  map[int64]struct{}
	clearedmission_consume_orders  bool
	mission_produce_orders         map[int64]struct{}
	removedmission_produce_orders  map[int64]struct{}
	clearedmission_produce_orders  bool
	recharge_orders                map[int64]struct{}
	removedrecharge_orders         map[int64]struct{}
	clearedrecharge_orders         bool
	vx_socials                     map[int64]struct{}
	removedvx_socials              map[int64]struct{}
	clearedvx_socials              bool
	mission_batches                map[int64]struct{}
	removedmission_batches         map[int64]struct{}
	clearedmission_batches         bool
	user_devices                   map[int64]struct{}
	removeduser_devices            map[int64]struct{}
	cleareduser_devices            bool
	parent                         *int64
	clearedparent                  bool
	children                       map[int64]struct{}
	removedchildren                map[int64]struct{}
	clearedchildren                bool
	invites                        map[int64]struct{}
	removedinvites                 map[int64]struct{}
	clearedinvites                 bool
	campaign_orders                map[int64]struct{}
	removedcampaign_orders         map[int64]struct{}
	clearedcampaign_orders         bool
	wallets                        map[int64]struct{}
	removedwallets                 map[int64]struct{}
	clearedwallets                 bool
	withdraw_account               *int64
	clearedwithdraw_account        bool
	income_bills                   map[int64]struct{}
	removedincome_bills            map[int64]struct{}
	clearedincome_bills            bool
	outcome_bills                  map[int64]struct{}
	removedoutcome_bills           map[int64]struct{}
	clearedoutcome_bills           bool
	mission_productions            map[int64]struct{}
	removedmission_productions     map[int64]struct{}
	clearedmission_productions     bool
	missions                       map[int64]struct{}
	removedmissions                map[int64]struct{}
	clearedmissions                bool
	income_transfer_orders         map[int64]struct{}
	removedincome_transfer_orders  map[int64]struct{}
	clearedincome_transfer_orders  bool
	outcome_transfer_orders        map[int64]struct{}
	removedoutcome_transfer_orders map[int64]struct{}
	clearedoutcome_transfer_orders bool
	consume_mission_orders         map[int64]struct{}
	removedconsume_mission_orders  map[int64]struct{}
	clearedconsume_mission_orders  bool
	produce_mission_orders         map[int64]struct{}
	removedproduce_mission_orders  map[int64]struct{}
	clearedproduce_mission_orders  bool
	login_records                  map[int64]struct{}
	removedlogin_records           map[int64]struct{}
	clearedlogin_records           bool
	renewal_agreements             map[int64]struct{}
	removedrenewal_agreements      map[int64]struct{}
	clearedrenewal_agreements      bool
	artworks                       map[int64]struct{}
	removedartworks                map[int64]struct{}
	clearedartworks                bool
	artwork_likes                  map[int64]struct{}
	removedartwork_likes           map[int64]struct{}
	clearedartwork_likes           bool
	cdk_infos                      map[int64]struct{}
	removedcdk_infos               map[int64]struct{}
	clearedcdk_infos               bool
	use_cdk_infos                  map[int64]struct{}
	removeduse_cdk_infos           map[int64]struct{}
	cleareduse_cdk_infos           bool
	done                           bool
	oldValue                       func(context.Context) (*User, error)
	predicates                     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetNickName sets the "nick_name" field.
func (m *UserMutation) SetNickName(s string) {
	m.nick_name = &s
}

// NickName returns the value of the "nick_name" field in the mutation.
func (m *UserMutation) NickName() (r string, exists bool) {
	v := m.nick_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNickName returns the old "nick_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickName: %w", err)
	}
	return oldValue.NickName, nil
}

// ResetNickName resets all changes to the "nick_name" field.
func (m *UserMutation) ResetNickName() {
	m.nick_name = nil
}

// SetJpgURL sets the "jpg_url" field.
func (m *UserMutation) SetJpgURL(s string) {
	m.jpg_url = &s
}

// JpgURL returns the value of the "jpg_url" field in the mutation.
func (m *UserMutation) JpgURL() (r string, exists bool) {
	v := m.jpg_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJpgURL returns the old "jpg_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJpgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJpgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJpgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJpgURL: %w", err)
	}
	return oldValue.JpgURL, nil
}

// ResetJpgURL resets all changes to the "jpg_url" field.
func (m *UserMutation) ResetJpgURL() {
	m.jpg_url = nil
}

// SetKey sets the "key" field.
func (m *UserMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UserMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UserMutation) ResetKey() {
	m.key = nil
}

// SetSecret sets the "secret" field.
func (m *UserMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *UserMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *UserMutation) ResetSecret() {
	m.secret = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetIsFrozen sets the "is_frozen" field.
func (m *UserMutation) SetIsFrozen(b bool) {
	m.is_frozen = &b
}

// IsFrozen returns the value of the "is_frozen" field in the mutation.
func (m *UserMutation) IsFrozen() (r bool, exists bool) {
	v := m.is_frozen
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFrozen returns the old "is_frozen" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsFrozen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFrozen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFrozen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFrozen: %w", err)
	}
	return oldValue.IsFrozen, nil
}

// ResetIsFrozen resets all changes to the "is_frozen" field.
func (m *UserMutation) ResetIsFrozen() {
	m.is_frozen = nil
}

// SetIsRecharge sets the "is_recharge" field.
func (m *UserMutation) SetIsRecharge(b bool) {
	m.is_recharge = &b
}

// IsRecharge returns the value of the "is_recharge" field in the mutation.
func (m *UserMutation) IsRecharge() (r bool, exists bool) {
	v := m.is_recharge
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRecharge returns the old "is_recharge" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsRecharge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRecharge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRecharge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRecharge: %w", err)
	}
	return oldValue.IsRecharge, nil
}

// ResetIsRecharge resets all changes to the "is_recharge" field.
func (m *UserMutation) ResetIsRecharge() {
	m.is_recharge = nil
}

// SetUserType sets the "user_type" field.
func (m *UserMutation) SetUserType(ut user.UserType) {
	m.user_type = &ut
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *UserMutation) UserType() (r user.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserType(ctx context.Context) (v user.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ResetUserType resets all changes to the "user_type" field.
func (m *UserMutation) ResetUserType() {
	m.user_type = nil
}

// SetParentID sets the "parent_id" field.
func (m *UserMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *UserMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *UserMutation) ResetParentID() {
	m.parent = nil
}

// SetPopVersion sets the "pop_version" field.
func (m *UserMutation) SetPopVersion(s string) {
	m.pop_version = &s
}

// PopVersion returns the value of the "pop_version" field in the mutation.
func (m *UserMutation) PopVersion() (r string, exists bool) {
	v := m.pop_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPopVersion returns the old "pop_version" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPopVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopVersion: %w", err)
	}
	return oldValue.PopVersion, nil
}

// ResetPopVersion resets all changes to the "pop_version" field.
func (m *UserMutation) ResetPopVersion() {
	m.pop_version = nil
}

// SetAreaCode sets the "area_code" field.
func (m *UserMutation) SetAreaCode(s string) {
	m.area_code = &s
}

// AreaCode returns the value of the "area_code" field in the mutation.
func (m *UserMutation) AreaCode() (r string, exists bool) {
	v := m.area_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaCode returns the old "area_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAreaCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaCode: %w", err)
	}
	return oldValue.AreaCode, nil
}

// ResetAreaCode resets all changes to the "area_code" field.
func (m *UserMutation) ResetAreaCode() {
	m.area_code = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddVxAccountIDs adds the "vx_accounts" edge to the VXAccount entity by ids.
func (m *UserMutation) AddVxAccountIDs(ids ...int64) {
	if m.vx_accounts == nil {
		m.vx_accounts = make(map[int64]struct{})
	}
	for i := range ids {
		m.vx_accounts[ids[i]] = struct{}{}
	}
}

// ClearVxAccounts clears the "vx_accounts" edge to the VXAccount entity.
func (m *UserMutation) ClearVxAccounts() {
	m.clearedvx_accounts = true
}

// VxAccountsCleared reports if the "vx_accounts" edge to the VXAccount entity was cleared.
func (m *UserMutation) VxAccountsCleared() bool {
	return m.clearedvx_accounts
}

// RemoveVxAccountIDs removes the "vx_accounts" edge to the VXAccount entity by IDs.
func (m *UserMutation) RemoveVxAccountIDs(ids ...int64) {
	if m.removedvx_accounts == nil {
		m.removedvx_accounts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.vx_accounts, ids[i])
		m.removedvx_accounts[ids[i]] = struct{}{}
	}
}

// RemovedVxAccounts returns the removed IDs of the "vx_accounts" edge to the VXAccount entity.
func (m *UserMutation) RemovedVxAccountsIDs() (ids []int64) {
	for id := range m.removedvx_accounts {
		ids = append(ids, id)
	}
	return
}

// VxAccountsIDs returns the "vx_accounts" edge IDs in the mutation.
func (m *UserMutation) VxAccountsIDs() (ids []int64) {
	for id := range m.vx_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetVxAccounts resets all changes to the "vx_accounts" edge.
func (m *UserMutation) ResetVxAccounts() {
	m.vx_accounts = nil
	m.clearedvx_accounts = false
	m.removedvx_accounts = nil
}

// AddCollectIDs adds the "collects" edge to the Collect entity by ids.
func (m *UserMutation) AddCollectIDs(ids ...int64) {
	if m.collects == nil {
		m.collects = make(map[int64]struct{})
	}
	for i := range ids {
		m.collects[ids[i]] = struct{}{}
	}
}

// ClearCollects clears the "collects" edge to the Collect entity.
func (m *UserMutation) ClearCollects() {
	m.clearedcollects = true
}

// CollectsCleared reports if the "collects" edge to the Collect entity was cleared.
func (m *UserMutation) CollectsCleared() bool {
	return m.clearedcollects
}

// RemoveCollectIDs removes the "collects" edge to the Collect entity by IDs.
func (m *UserMutation) RemoveCollectIDs(ids ...int64) {
	if m.removedcollects == nil {
		m.removedcollects = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.collects, ids[i])
		m.removedcollects[ids[i]] = struct{}{}
	}
}

// RemovedCollects returns the removed IDs of the "collects" edge to the Collect entity.
func (m *UserMutation) RemovedCollectsIDs() (ids []int64) {
	for id := range m.removedcollects {
		ids = append(ids, id)
	}
	return
}

// CollectsIDs returns the "collects" edge IDs in the mutation.
func (m *UserMutation) CollectsIDs() (ids []int64) {
	for id := range m.collects {
		ids = append(ids, id)
	}
	return
}

// ResetCollects resets all changes to the "collects" edge.
func (m *UserMutation) ResetCollects() {
	m.collects = nil
	m.clearedcollects = false
	m.removedcollects = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...int64) {
	if m.devices == nil {
		m.devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *UserMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *UserMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...int64) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *UserMutation) RemovedDevicesIDs() (ids []int64) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *UserMutation) DevicesIDs() (ids []int64) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *UserMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddProfitSettingIDs adds the "profit_settings" edge to the ProfitSetting entity by ids.
func (m *UserMutation) AddProfitSettingIDs(ids ...int64) {
	if m.profit_settings == nil {
		m.profit_settings = make(map[int64]struct{})
	}
	for i := range ids {
		m.profit_settings[ids[i]] = struct{}{}
	}
}

// ClearProfitSettings clears the "profit_settings" edge to the ProfitSetting entity.
func (m *UserMutation) ClearProfitSettings() {
	m.clearedprofit_settings = true
}

// ProfitSettingsCleared reports if the "profit_settings" edge to the ProfitSetting entity was cleared.
func (m *UserMutation) ProfitSettingsCleared() bool {
	return m.clearedprofit_settings
}

// RemoveProfitSettingIDs removes the "profit_settings" edge to the ProfitSetting entity by IDs.
func (m *UserMutation) RemoveProfitSettingIDs(ids ...int64) {
	if m.removedprofit_settings == nil {
		m.removedprofit_settings = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.profit_settings, ids[i])
		m.removedprofit_settings[ids[i]] = struct{}{}
	}
}

// RemovedProfitSettings returns the removed IDs of the "profit_settings" edge to the ProfitSetting entity.
func (m *UserMutation) RemovedProfitSettingsIDs() (ids []int64) {
	for id := range m.removedprofit_settings {
		ids = append(ids, id)
	}
	return
}

// ProfitSettingsIDs returns the "profit_settings" edge IDs in the mutation.
func (m *UserMutation) ProfitSettingsIDs() (ids []int64) {
	for id := range m.profit_settings {
		ids = append(ids, id)
	}
	return
}

// ResetProfitSettings resets all changes to the "profit_settings" edge.
func (m *UserMutation) ResetProfitSettings() {
	m.profit_settings = nil
	m.clearedprofit_settings = false
	m.removedprofit_settings = nil
}

// SetCostAccountID sets the "cost_account" edge to the CostAccount entity by id.
func (m *UserMutation) SetCostAccountID(id int64) {
	m.cost_account = &id
}

// ClearCostAccount clears the "cost_account" edge to the CostAccount entity.
func (m *UserMutation) ClearCostAccount() {
	m.clearedcost_account = true
}

// CostAccountCleared reports if the "cost_account" edge to the CostAccount entity was cleared.
func (m *UserMutation) CostAccountCleared() bool {
	return m.clearedcost_account
}

// CostAccountID returns the "cost_account" edge ID in the mutation.
func (m *UserMutation) CostAccountID() (id int64, exists bool) {
	if m.cost_account != nil {
		return *m.cost_account, true
	}
	return
}

// CostAccountIDs returns the "cost_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CostAccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CostAccountIDs() (ids []int64) {
	if id := m.cost_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCostAccount resets all changes to the "cost_account" edge.
func (m *UserMutation) ResetCostAccount() {
	m.cost_account = nil
	m.clearedcost_account = false
}

// SetProfitAccountID sets the "profit_account" edge to the ProfitAccount entity by id.
func (m *UserMutation) SetProfitAccountID(id int64) {
	m.profit_account = &id
}

// ClearProfitAccount clears the "profit_account" edge to the ProfitAccount entity.
func (m *UserMutation) ClearProfitAccount() {
	m.clearedprofit_account = true
}

// ProfitAccountCleared reports if the "profit_account" edge to the ProfitAccount entity was cleared.
func (m *UserMutation) ProfitAccountCleared() bool {
	return m.clearedprofit_account
}

// ProfitAccountID returns the "profit_account" edge ID in the mutation.
func (m *UserMutation) ProfitAccountID() (id int64, exists bool) {
	if m.profit_account != nil {
		return *m.profit_account, true
	}
	return
}

// ProfitAccountIDs returns the "profit_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfitAccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfitAccountIDs() (ids []int64) {
	if id := m.profit_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfitAccount resets all changes to the "profit_account" edge.
func (m *UserMutation) ResetProfitAccount() {
	m.profit_account = nil
	m.clearedprofit_account = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *UserMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *UserMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *UserMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *UserMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *UserMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *UserMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *UserMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *UserMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *UserMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *UserMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *UserMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *UserMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *UserMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *UserMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// AddMissionConsumeOrderIDs adds the "mission_consume_orders" edge to the MissionConsumeOrder entity by ids.
func (m *UserMutation) AddMissionConsumeOrderIDs(ids ...int64) {
	if m.mission_consume_orders == nil {
		m.mission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_consume_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionConsumeOrders clears the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *UserMutation) ClearMissionConsumeOrders() {
	m.clearedmission_consume_orders = true
}

// MissionConsumeOrdersCleared reports if the "mission_consume_orders" edge to the MissionConsumeOrder entity was cleared.
func (m *UserMutation) MissionConsumeOrdersCleared() bool {
	return m.clearedmission_consume_orders
}

// RemoveMissionConsumeOrderIDs removes the "mission_consume_orders" edge to the MissionConsumeOrder entity by IDs.
func (m *UserMutation) RemoveMissionConsumeOrderIDs(ids ...int64) {
	if m.removedmission_consume_orders == nil {
		m.removedmission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_consume_orders, ids[i])
		m.removedmission_consume_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionConsumeOrders returns the removed IDs of the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *UserMutation) RemovedMissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.removedmission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// MissionConsumeOrdersIDs returns the "mission_consume_orders" edge IDs in the mutation.
func (m *UserMutation) MissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.mission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionConsumeOrders resets all changes to the "mission_consume_orders" edge.
func (m *UserMutation) ResetMissionConsumeOrders() {
	m.mission_consume_orders = nil
	m.clearedmission_consume_orders = false
	m.removedmission_consume_orders = nil
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *UserMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *UserMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *UserMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *UserMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *UserMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *UserMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *UserMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// AddRechargeOrderIDs adds the "recharge_orders" edge to the RechargeOrder entity by ids.
func (m *UserMutation) AddRechargeOrderIDs(ids ...int64) {
	if m.recharge_orders == nil {
		m.recharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.recharge_orders[ids[i]] = struct{}{}
	}
}

// ClearRechargeOrders clears the "recharge_orders" edge to the RechargeOrder entity.
func (m *UserMutation) ClearRechargeOrders() {
	m.clearedrecharge_orders = true
}

// RechargeOrdersCleared reports if the "recharge_orders" edge to the RechargeOrder entity was cleared.
func (m *UserMutation) RechargeOrdersCleared() bool {
	return m.clearedrecharge_orders
}

// RemoveRechargeOrderIDs removes the "recharge_orders" edge to the RechargeOrder entity by IDs.
func (m *UserMutation) RemoveRechargeOrderIDs(ids ...int64) {
	if m.removedrecharge_orders == nil {
		m.removedrecharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.recharge_orders, ids[i])
		m.removedrecharge_orders[ids[i]] = struct{}{}
	}
}

// RemovedRechargeOrders returns the removed IDs of the "recharge_orders" edge to the RechargeOrder entity.
func (m *UserMutation) RemovedRechargeOrdersIDs() (ids []int64) {
	for id := range m.removedrecharge_orders {
		ids = append(ids, id)
	}
	return
}

// RechargeOrdersIDs returns the "recharge_orders" edge IDs in the mutation.
func (m *UserMutation) RechargeOrdersIDs() (ids []int64) {
	for id := range m.recharge_orders {
		ids = append(ids, id)
	}
	return
}

// ResetRechargeOrders resets all changes to the "recharge_orders" edge.
func (m *UserMutation) ResetRechargeOrders() {
	m.recharge_orders = nil
	m.clearedrecharge_orders = false
	m.removedrecharge_orders = nil
}

// AddVxSocialIDs adds the "vx_socials" edge to the VXSocial entity by ids.
func (m *UserMutation) AddVxSocialIDs(ids ...int64) {
	if m.vx_socials == nil {
		m.vx_socials = make(map[int64]struct{})
	}
	for i := range ids {
		m.vx_socials[ids[i]] = struct{}{}
	}
}

// ClearVxSocials clears the "vx_socials" edge to the VXSocial entity.
func (m *UserMutation) ClearVxSocials() {
	m.clearedvx_socials = true
}

// VxSocialsCleared reports if the "vx_socials" edge to the VXSocial entity was cleared.
func (m *UserMutation) VxSocialsCleared() bool {
	return m.clearedvx_socials
}

// RemoveVxSocialIDs removes the "vx_socials" edge to the VXSocial entity by IDs.
func (m *UserMutation) RemoveVxSocialIDs(ids ...int64) {
	if m.removedvx_socials == nil {
		m.removedvx_socials = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.vx_socials, ids[i])
		m.removedvx_socials[ids[i]] = struct{}{}
	}
}

// RemovedVxSocials returns the removed IDs of the "vx_socials" edge to the VXSocial entity.
func (m *UserMutation) RemovedVxSocialsIDs() (ids []int64) {
	for id := range m.removedvx_socials {
		ids = append(ids, id)
	}
	return
}

// VxSocialsIDs returns the "vx_socials" edge IDs in the mutation.
func (m *UserMutation) VxSocialsIDs() (ids []int64) {
	for id := range m.vx_socials {
		ids = append(ids, id)
	}
	return
}

// ResetVxSocials resets all changes to the "vx_socials" edge.
func (m *UserMutation) ResetVxSocials() {
	m.vx_socials = nil
	m.clearedvx_socials = false
	m.removedvx_socials = nil
}

// AddMissionBatchIDs adds the "mission_batches" edge to the MissionBatch entity by ids.
func (m *UserMutation) AddMissionBatchIDs(ids ...int64) {
	if m.mission_batches == nil {
		m.mission_batches = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_batches[ids[i]] = struct{}{}
	}
}

// ClearMissionBatches clears the "mission_batches" edge to the MissionBatch entity.
func (m *UserMutation) ClearMissionBatches() {
	m.clearedmission_batches = true
}

// MissionBatchesCleared reports if the "mission_batches" edge to the MissionBatch entity was cleared.
func (m *UserMutation) MissionBatchesCleared() bool {
	return m.clearedmission_batches
}

// RemoveMissionBatchIDs removes the "mission_batches" edge to the MissionBatch entity by IDs.
func (m *UserMutation) RemoveMissionBatchIDs(ids ...int64) {
	if m.removedmission_batches == nil {
		m.removedmission_batches = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_batches, ids[i])
		m.removedmission_batches[ids[i]] = struct{}{}
	}
}

// RemovedMissionBatches returns the removed IDs of the "mission_batches" edge to the MissionBatch entity.
func (m *UserMutation) RemovedMissionBatchesIDs() (ids []int64) {
	for id := range m.removedmission_batches {
		ids = append(ids, id)
	}
	return
}

// MissionBatchesIDs returns the "mission_batches" edge IDs in the mutation.
func (m *UserMutation) MissionBatchesIDs() (ids []int64) {
	for id := range m.mission_batches {
		ids = append(ids, id)
	}
	return
}

// ResetMissionBatches resets all changes to the "mission_batches" edge.
func (m *UserMutation) ResetMissionBatches() {
	m.mission_batches = nil
	m.clearedmission_batches = false
	m.removedmission_batches = nil
}

// AddUserDeviceIDs adds the "user_devices" edge to the UserDevice entity by ids.
func (m *UserMutation) AddUserDeviceIDs(ids ...int64) {
	if m.user_devices == nil {
		m.user_devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_devices[ids[i]] = struct{}{}
	}
}

// ClearUserDevices clears the "user_devices" edge to the UserDevice entity.
func (m *UserMutation) ClearUserDevices() {
	m.cleareduser_devices = true
}

// UserDevicesCleared reports if the "user_devices" edge to the UserDevice entity was cleared.
func (m *UserMutation) UserDevicesCleared() bool {
	return m.cleareduser_devices
}

// RemoveUserDeviceIDs removes the "user_devices" edge to the UserDevice entity by IDs.
func (m *UserMutation) RemoveUserDeviceIDs(ids ...int64) {
	if m.removeduser_devices == nil {
		m.removeduser_devices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_devices, ids[i])
		m.removeduser_devices[ids[i]] = struct{}{}
	}
}

// RemovedUserDevices returns the removed IDs of the "user_devices" edge to the UserDevice entity.
func (m *UserMutation) RemovedUserDevicesIDs() (ids []int64) {
	for id := range m.removeduser_devices {
		ids = append(ids, id)
	}
	return
}

// UserDevicesIDs returns the "user_devices" edge IDs in the mutation.
func (m *UserMutation) UserDevicesIDs() (ids []int64) {
	for id := range m.user_devices {
		ids = append(ids, id)
	}
	return
}

// ResetUserDevices resets all changes to the "user_devices" edge.
func (m *UserMutation) ResetUserDevices() {
	m.user_devices = nil
	m.cleareduser_devices = false
	m.removeduser_devices = nil
}

// ClearParent clears the "parent" edge to the User entity.
func (m *UserMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[user.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the User entity was cleared.
func (m *UserMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *UserMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the User entity by ids.
func (m *UserMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the User entity.
func (m *UserMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the User entity was cleared.
func (m *UserMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the User entity by IDs.
func (m *UserMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the User entity.
func (m *UserMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *UserMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *UserMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddInviteIDs adds the "invites" edge to the Invite entity by ids.
func (m *UserMutation) AddInviteIDs(ids ...int64) {
	if m.invites == nil {
		m.invites = make(map[int64]struct{})
	}
	for i := range ids {
		m.invites[ids[i]] = struct{}{}
	}
}

// ClearInvites clears the "invites" edge to the Invite entity.
func (m *UserMutation) ClearInvites() {
	m.clearedinvites = true
}

// InvitesCleared reports if the "invites" edge to the Invite entity was cleared.
func (m *UserMutation) InvitesCleared() bool {
	return m.clearedinvites
}

// RemoveInviteIDs removes the "invites" edge to the Invite entity by IDs.
func (m *UserMutation) RemoveInviteIDs(ids ...int64) {
	if m.removedinvites == nil {
		m.removedinvites = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invites, ids[i])
		m.removedinvites[ids[i]] = struct{}{}
	}
}

// RemovedInvites returns the removed IDs of the "invites" edge to the Invite entity.
func (m *UserMutation) RemovedInvitesIDs() (ids []int64) {
	for id := range m.removedinvites {
		ids = append(ids, id)
	}
	return
}

// InvitesIDs returns the "invites" edge IDs in the mutation.
func (m *UserMutation) InvitesIDs() (ids []int64) {
	for id := range m.invites {
		ids = append(ids, id)
	}
	return
}

// ResetInvites resets all changes to the "invites" edge.
func (m *UserMutation) ResetInvites() {
	m.invites = nil
	m.clearedinvites = false
	m.removedinvites = nil
}

// AddCampaignOrderIDs adds the "campaign_orders" edge to the CampaignOrder entity by ids.
func (m *UserMutation) AddCampaignOrderIDs(ids ...int64) {
	if m.campaign_orders == nil {
		m.campaign_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.campaign_orders[ids[i]] = struct{}{}
	}
}

// ClearCampaignOrders clears the "campaign_orders" edge to the CampaignOrder entity.
func (m *UserMutation) ClearCampaignOrders() {
	m.clearedcampaign_orders = true
}

// CampaignOrdersCleared reports if the "campaign_orders" edge to the CampaignOrder entity was cleared.
func (m *UserMutation) CampaignOrdersCleared() bool {
	return m.clearedcampaign_orders
}

// RemoveCampaignOrderIDs removes the "campaign_orders" edge to the CampaignOrder entity by IDs.
func (m *UserMutation) RemoveCampaignOrderIDs(ids ...int64) {
	if m.removedcampaign_orders == nil {
		m.removedcampaign_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.campaign_orders, ids[i])
		m.removedcampaign_orders[ids[i]] = struct{}{}
	}
}

// RemovedCampaignOrders returns the removed IDs of the "campaign_orders" edge to the CampaignOrder entity.
func (m *UserMutation) RemovedCampaignOrdersIDs() (ids []int64) {
	for id := range m.removedcampaign_orders {
		ids = append(ids, id)
	}
	return
}

// CampaignOrdersIDs returns the "campaign_orders" edge IDs in the mutation.
func (m *UserMutation) CampaignOrdersIDs() (ids []int64) {
	for id := range m.campaign_orders {
		ids = append(ids, id)
	}
	return
}

// ResetCampaignOrders resets all changes to the "campaign_orders" edge.
func (m *UserMutation) ResetCampaignOrders() {
	m.campaign_orders = nil
	m.clearedcampaign_orders = false
	m.removedcampaign_orders = nil
}

// AddWalletIDs adds the "wallets" edge to the Wallet entity by ids.
func (m *UserMutation) AddWalletIDs(ids ...int64) {
	if m.wallets == nil {
		m.wallets = make(map[int64]struct{})
	}
	for i := range ids {
		m.wallets[ids[i]] = struct{}{}
	}
}

// ClearWallets clears the "wallets" edge to the Wallet entity.
func (m *UserMutation) ClearWallets() {
	m.clearedwallets = true
}

// WalletsCleared reports if the "wallets" edge to the Wallet entity was cleared.
func (m *UserMutation) WalletsCleared() bool {
	return m.clearedwallets
}

// RemoveWalletIDs removes the "wallets" edge to the Wallet entity by IDs.
func (m *UserMutation) RemoveWalletIDs(ids ...int64) {
	if m.removedwallets == nil {
		m.removedwallets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.wallets, ids[i])
		m.removedwallets[ids[i]] = struct{}{}
	}
}

// RemovedWallets returns the removed IDs of the "wallets" edge to the Wallet entity.
func (m *UserMutation) RemovedWalletsIDs() (ids []int64) {
	for id := range m.removedwallets {
		ids = append(ids, id)
	}
	return
}

// WalletsIDs returns the "wallets" edge IDs in the mutation.
func (m *UserMutation) WalletsIDs() (ids []int64) {
	for id := range m.wallets {
		ids = append(ids, id)
	}
	return
}

// ResetWallets resets all changes to the "wallets" edge.
func (m *UserMutation) ResetWallets() {
	m.wallets = nil
	m.clearedwallets = false
	m.removedwallets = nil
}

// SetWithdrawAccountID sets the "withdraw_account" edge to the WithdrawAccount entity by id.
func (m *UserMutation) SetWithdrawAccountID(id int64) {
	m.withdraw_account = &id
}

// ClearWithdrawAccount clears the "withdraw_account" edge to the WithdrawAccount entity.
func (m *UserMutation) ClearWithdrawAccount() {
	m.clearedwithdraw_account = true
}

// WithdrawAccountCleared reports if the "withdraw_account" edge to the WithdrawAccount entity was cleared.
func (m *UserMutation) WithdrawAccountCleared() bool {
	return m.clearedwithdraw_account
}

// WithdrawAccountID returns the "withdraw_account" edge ID in the mutation.
func (m *UserMutation) WithdrawAccountID() (id int64, exists bool) {
	if m.withdraw_account != nil {
		return *m.withdraw_account, true
	}
	return
}

// WithdrawAccountIDs returns the "withdraw_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WithdrawAccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) WithdrawAccountIDs() (ids []int64) {
	if id := m.withdraw_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWithdrawAccount resets all changes to the "withdraw_account" edge.
func (m *UserMutation) ResetWithdrawAccount() {
	m.withdraw_account = nil
	m.clearedwithdraw_account = false
}

// AddIncomeBillIDs adds the "income_bills" edge to the Bill entity by ids.
func (m *UserMutation) AddIncomeBillIDs(ids ...int64) {
	if m.income_bills == nil {
		m.income_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.income_bills[ids[i]] = struct{}{}
	}
}

// ClearIncomeBills clears the "income_bills" edge to the Bill entity.
func (m *UserMutation) ClearIncomeBills() {
	m.clearedincome_bills = true
}

// IncomeBillsCleared reports if the "income_bills" edge to the Bill entity was cleared.
func (m *UserMutation) IncomeBillsCleared() bool {
	return m.clearedincome_bills
}

// RemoveIncomeBillIDs removes the "income_bills" edge to the Bill entity by IDs.
func (m *UserMutation) RemoveIncomeBillIDs(ids ...int64) {
	if m.removedincome_bills == nil {
		m.removedincome_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.income_bills, ids[i])
		m.removedincome_bills[ids[i]] = struct{}{}
	}
}

// RemovedIncomeBills returns the removed IDs of the "income_bills" edge to the Bill entity.
func (m *UserMutation) RemovedIncomeBillsIDs() (ids []int64) {
	for id := range m.removedincome_bills {
		ids = append(ids, id)
	}
	return
}

// IncomeBillsIDs returns the "income_bills" edge IDs in the mutation.
func (m *UserMutation) IncomeBillsIDs() (ids []int64) {
	for id := range m.income_bills {
		ids = append(ids, id)
	}
	return
}

// ResetIncomeBills resets all changes to the "income_bills" edge.
func (m *UserMutation) ResetIncomeBills() {
	m.income_bills = nil
	m.clearedincome_bills = false
	m.removedincome_bills = nil
}

// AddOutcomeBillIDs adds the "outcome_bills" edge to the Bill entity by ids.
func (m *UserMutation) AddOutcomeBillIDs(ids ...int64) {
	if m.outcome_bills == nil {
		m.outcome_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.outcome_bills[ids[i]] = struct{}{}
	}
}

// ClearOutcomeBills clears the "outcome_bills" edge to the Bill entity.
func (m *UserMutation) ClearOutcomeBills() {
	m.clearedoutcome_bills = true
}

// OutcomeBillsCleared reports if the "outcome_bills" edge to the Bill entity was cleared.
func (m *UserMutation) OutcomeBillsCleared() bool {
	return m.clearedoutcome_bills
}

// RemoveOutcomeBillIDs removes the "outcome_bills" edge to the Bill entity by IDs.
func (m *UserMutation) RemoveOutcomeBillIDs(ids ...int64) {
	if m.removedoutcome_bills == nil {
		m.removedoutcome_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.outcome_bills, ids[i])
		m.removedoutcome_bills[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeBills returns the removed IDs of the "outcome_bills" edge to the Bill entity.
func (m *UserMutation) RemovedOutcomeBillsIDs() (ids []int64) {
	for id := range m.removedoutcome_bills {
		ids = append(ids, id)
	}
	return
}

// OutcomeBillsIDs returns the "outcome_bills" edge IDs in the mutation.
func (m *UserMutation) OutcomeBillsIDs() (ids []int64) {
	for id := range m.outcome_bills {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeBills resets all changes to the "outcome_bills" edge.
func (m *UserMutation) ResetOutcomeBills() {
	m.outcome_bills = nil
	m.clearedoutcome_bills = false
	m.removedoutcome_bills = nil
}

// AddMissionProductionIDs adds the "mission_productions" edge to the MissionProduction entity by ids.
func (m *UserMutation) AddMissionProductionIDs(ids ...int64) {
	if m.mission_productions == nil {
		m.mission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_productions[ids[i]] = struct{}{}
	}
}

// ClearMissionProductions clears the "mission_productions" edge to the MissionProduction entity.
func (m *UserMutation) ClearMissionProductions() {
	m.clearedmission_productions = true
}

// MissionProductionsCleared reports if the "mission_productions" edge to the MissionProduction entity was cleared.
func (m *UserMutation) MissionProductionsCleared() bool {
	return m.clearedmission_productions
}

// RemoveMissionProductionIDs removes the "mission_productions" edge to the MissionProduction entity by IDs.
func (m *UserMutation) RemoveMissionProductionIDs(ids ...int64) {
	if m.removedmission_productions == nil {
		m.removedmission_productions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_productions, ids[i])
		m.removedmission_productions[ids[i]] = struct{}{}
	}
}

// RemovedMissionProductions returns the removed IDs of the "mission_productions" edge to the MissionProduction entity.
func (m *UserMutation) RemovedMissionProductionsIDs() (ids []int64) {
	for id := range m.removedmission_productions {
		ids = append(ids, id)
	}
	return
}

// MissionProductionsIDs returns the "mission_productions" edge IDs in the mutation.
func (m *UserMutation) MissionProductionsIDs() (ids []int64) {
	for id := range m.mission_productions {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProductions resets all changes to the "mission_productions" edge.
func (m *UserMutation) ResetMissionProductions() {
	m.mission_productions = nil
	m.clearedmission_productions = false
	m.removedmission_productions = nil
}

// AddMissionIDs adds the "missions" edge to the Mission entity by ids.
func (m *UserMutation) AddMissionIDs(ids ...int64) {
	if m.missions == nil {
		m.missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.missions[ids[i]] = struct{}{}
	}
}

// ClearMissions clears the "missions" edge to the Mission entity.
func (m *UserMutation) ClearMissions() {
	m.clearedmissions = true
}

// MissionsCleared reports if the "missions" edge to the Mission entity was cleared.
func (m *UserMutation) MissionsCleared() bool {
	return m.clearedmissions
}

// RemoveMissionIDs removes the "missions" edge to the Mission entity by IDs.
func (m *UserMutation) RemoveMissionIDs(ids ...int64) {
	if m.removedmissions == nil {
		m.removedmissions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.missions, ids[i])
		m.removedmissions[ids[i]] = struct{}{}
	}
}

// RemovedMissions returns the removed IDs of the "missions" edge to the Mission entity.
func (m *UserMutation) RemovedMissionsIDs() (ids []int64) {
	for id := range m.removedmissions {
		ids = append(ids, id)
	}
	return
}

// MissionsIDs returns the "missions" edge IDs in the mutation.
func (m *UserMutation) MissionsIDs() (ids []int64) {
	for id := range m.missions {
		ids = append(ids, id)
	}
	return
}

// ResetMissions resets all changes to the "missions" edge.
func (m *UserMutation) ResetMissions() {
	m.missions = nil
	m.clearedmissions = false
	m.removedmissions = nil
}

// AddIncomeTransferOrderIDs adds the "income_transfer_orders" edge to the TransferOrder entity by ids.
func (m *UserMutation) AddIncomeTransferOrderIDs(ids ...int64) {
	if m.income_transfer_orders == nil {
		m.income_transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.income_transfer_orders[ids[i]] = struct{}{}
	}
}

// ClearIncomeTransferOrders clears the "income_transfer_orders" edge to the TransferOrder entity.
func (m *UserMutation) ClearIncomeTransferOrders() {
	m.clearedincome_transfer_orders = true
}

// IncomeTransferOrdersCleared reports if the "income_transfer_orders" edge to the TransferOrder entity was cleared.
func (m *UserMutation) IncomeTransferOrdersCleared() bool {
	return m.clearedincome_transfer_orders
}

// RemoveIncomeTransferOrderIDs removes the "income_transfer_orders" edge to the TransferOrder entity by IDs.
func (m *UserMutation) RemoveIncomeTransferOrderIDs(ids ...int64) {
	if m.removedincome_transfer_orders == nil {
		m.removedincome_transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.income_transfer_orders, ids[i])
		m.removedincome_transfer_orders[ids[i]] = struct{}{}
	}
}

// RemovedIncomeTransferOrders returns the removed IDs of the "income_transfer_orders" edge to the TransferOrder entity.
func (m *UserMutation) RemovedIncomeTransferOrdersIDs() (ids []int64) {
	for id := range m.removedincome_transfer_orders {
		ids = append(ids, id)
	}
	return
}

// IncomeTransferOrdersIDs returns the "income_transfer_orders" edge IDs in the mutation.
func (m *UserMutation) IncomeTransferOrdersIDs() (ids []int64) {
	for id := range m.income_transfer_orders {
		ids = append(ids, id)
	}
	return
}

// ResetIncomeTransferOrders resets all changes to the "income_transfer_orders" edge.
func (m *UserMutation) ResetIncomeTransferOrders() {
	m.income_transfer_orders = nil
	m.clearedincome_transfer_orders = false
	m.removedincome_transfer_orders = nil
}

// AddOutcomeTransferOrderIDs adds the "outcome_transfer_orders" edge to the TransferOrder entity by ids.
func (m *UserMutation) AddOutcomeTransferOrderIDs(ids ...int64) {
	if m.outcome_transfer_orders == nil {
		m.outcome_transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.outcome_transfer_orders[ids[i]] = struct{}{}
	}
}

// ClearOutcomeTransferOrders clears the "outcome_transfer_orders" edge to the TransferOrder entity.
func (m *UserMutation) ClearOutcomeTransferOrders() {
	m.clearedoutcome_transfer_orders = true
}

// OutcomeTransferOrdersCleared reports if the "outcome_transfer_orders" edge to the TransferOrder entity was cleared.
func (m *UserMutation) OutcomeTransferOrdersCleared() bool {
	return m.clearedoutcome_transfer_orders
}

// RemoveOutcomeTransferOrderIDs removes the "outcome_transfer_orders" edge to the TransferOrder entity by IDs.
func (m *UserMutation) RemoveOutcomeTransferOrderIDs(ids ...int64) {
	if m.removedoutcome_transfer_orders == nil {
		m.removedoutcome_transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.outcome_transfer_orders, ids[i])
		m.removedoutcome_transfer_orders[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeTransferOrders returns the removed IDs of the "outcome_transfer_orders" edge to the TransferOrder entity.
func (m *UserMutation) RemovedOutcomeTransferOrdersIDs() (ids []int64) {
	for id := range m.removedoutcome_transfer_orders {
		ids = append(ids, id)
	}
	return
}

// OutcomeTransferOrdersIDs returns the "outcome_transfer_orders" edge IDs in the mutation.
func (m *UserMutation) OutcomeTransferOrdersIDs() (ids []int64) {
	for id := range m.outcome_transfer_orders {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeTransferOrders resets all changes to the "outcome_transfer_orders" edge.
func (m *UserMutation) ResetOutcomeTransferOrders() {
	m.outcome_transfer_orders = nil
	m.clearedoutcome_transfer_orders = false
	m.removedoutcome_transfer_orders = nil
}

// AddConsumeMissionOrderIDs adds the "consume_mission_orders" edge to the MissionOrder entity by ids.
func (m *UserMutation) AddConsumeMissionOrderIDs(ids ...int64) {
	if m.consume_mission_orders == nil {
		m.consume_mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.consume_mission_orders[ids[i]] = struct{}{}
	}
}

// ClearConsumeMissionOrders clears the "consume_mission_orders" edge to the MissionOrder entity.
func (m *UserMutation) ClearConsumeMissionOrders() {
	m.clearedconsume_mission_orders = true
}

// ConsumeMissionOrdersCleared reports if the "consume_mission_orders" edge to the MissionOrder entity was cleared.
func (m *UserMutation) ConsumeMissionOrdersCleared() bool {
	return m.clearedconsume_mission_orders
}

// RemoveConsumeMissionOrderIDs removes the "consume_mission_orders" edge to the MissionOrder entity by IDs.
func (m *UserMutation) RemoveConsumeMissionOrderIDs(ids ...int64) {
	if m.removedconsume_mission_orders == nil {
		m.removedconsume_mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.consume_mission_orders, ids[i])
		m.removedconsume_mission_orders[ids[i]] = struct{}{}
	}
}

// RemovedConsumeMissionOrders returns the removed IDs of the "consume_mission_orders" edge to the MissionOrder entity.
func (m *UserMutation) RemovedConsumeMissionOrdersIDs() (ids []int64) {
	for id := range m.removedconsume_mission_orders {
		ids = append(ids, id)
	}
	return
}

// ConsumeMissionOrdersIDs returns the "consume_mission_orders" edge IDs in the mutation.
func (m *UserMutation) ConsumeMissionOrdersIDs() (ids []int64) {
	for id := range m.consume_mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetConsumeMissionOrders resets all changes to the "consume_mission_orders" edge.
func (m *UserMutation) ResetConsumeMissionOrders() {
	m.consume_mission_orders = nil
	m.clearedconsume_mission_orders = false
	m.removedconsume_mission_orders = nil
}

// AddProduceMissionOrderIDs adds the "produce_mission_orders" edge to the MissionOrder entity by ids.
func (m *UserMutation) AddProduceMissionOrderIDs(ids ...int64) {
	if m.produce_mission_orders == nil {
		m.produce_mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.produce_mission_orders[ids[i]] = struct{}{}
	}
}

// ClearProduceMissionOrders clears the "produce_mission_orders" edge to the MissionOrder entity.
func (m *UserMutation) ClearProduceMissionOrders() {
	m.clearedproduce_mission_orders = true
}

// ProduceMissionOrdersCleared reports if the "produce_mission_orders" edge to the MissionOrder entity was cleared.
func (m *UserMutation) ProduceMissionOrdersCleared() bool {
	return m.clearedproduce_mission_orders
}

// RemoveProduceMissionOrderIDs removes the "produce_mission_orders" edge to the MissionOrder entity by IDs.
func (m *UserMutation) RemoveProduceMissionOrderIDs(ids ...int64) {
	if m.removedproduce_mission_orders == nil {
		m.removedproduce_mission_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.produce_mission_orders, ids[i])
		m.removedproduce_mission_orders[ids[i]] = struct{}{}
	}
}

// RemovedProduceMissionOrders returns the removed IDs of the "produce_mission_orders" edge to the MissionOrder entity.
func (m *UserMutation) RemovedProduceMissionOrdersIDs() (ids []int64) {
	for id := range m.removedproduce_mission_orders {
		ids = append(ids, id)
	}
	return
}

// ProduceMissionOrdersIDs returns the "produce_mission_orders" edge IDs in the mutation.
func (m *UserMutation) ProduceMissionOrdersIDs() (ids []int64) {
	for id := range m.produce_mission_orders {
		ids = append(ids, id)
	}
	return
}

// ResetProduceMissionOrders resets all changes to the "produce_mission_orders" edge.
func (m *UserMutation) ResetProduceMissionOrders() {
	m.produce_mission_orders = nil
	m.clearedproduce_mission_orders = false
	m.removedproduce_mission_orders = nil
}

// AddLoginRecordIDs adds the "login_records" edge to the LoginRecord entity by ids.
func (m *UserMutation) AddLoginRecordIDs(ids ...int64) {
	if m.login_records == nil {
		m.login_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.login_records[ids[i]] = struct{}{}
	}
}

// ClearLoginRecords clears the "login_records" edge to the LoginRecord entity.
func (m *UserMutation) ClearLoginRecords() {
	m.clearedlogin_records = true
}

// LoginRecordsCleared reports if the "login_records" edge to the LoginRecord entity was cleared.
func (m *UserMutation) LoginRecordsCleared() bool {
	return m.clearedlogin_records
}

// RemoveLoginRecordIDs removes the "login_records" edge to the LoginRecord entity by IDs.
func (m *UserMutation) RemoveLoginRecordIDs(ids ...int64) {
	if m.removedlogin_records == nil {
		m.removedlogin_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.login_records, ids[i])
		m.removedlogin_records[ids[i]] = struct{}{}
	}
}

// RemovedLoginRecords returns the removed IDs of the "login_records" edge to the LoginRecord entity.
func (m *UserMutation) RemovedLoginRecordsIDs() (ids []int64) {
	for id := range m.removedlogin_records {
		ids = append(ids, id)
	}
	return
}

// LoginRecordsIDs returns the "login_records" edge IDs in the mutation.
func (m *UserMutation) LoginRecordsIDs() (ids []int64) {
	for id := range m.login_records {
		ids = append(ids, id)
	}
	return
}

// ResetLoginRecords resets all changes to the "login_records" edge.
func (m *UserMutation) ResetLoginRecords() {
	m.login_records = nil
	m.clearedlogin_records = false
	m.removedlogin_records = nil
}

// AddRenewalAgreementIDs adds the "renewal_agreements" edge to the RenewalAgreement entity by ids.
func (m *UserMutation) AddRenewalAgreementIDs(ids ...int64) {
	if m.renewal_agreements == nil {
		m.renewal_agreements = make(map[int64]struct{})
	}
	for i := range ids {
		m.renewal_agreements[ids[i]] = struct{}{}
	}
}

// ClearRenewalAgreements clears the "renewal_agreements" edge to the RenewalAgreement entity.
func (m *UserMutation) ClearRenewalAgreements() {
	m.clearedrenewal_agreements = true
}

// RenewalAgreementsCleared reports if the "renewal_agreements" edge to the RenewalAgreement entity was cleared.
func (m *UserMutation) RenewalAgreementsCleared() bool {
	return m.clearedrenewal_agreements
}

// RemoveRenewalAgreementIDs removes the "renewal_agreements" edge to the RenewalAgreement entity by IDs.
func (m *UserMutation) RemoveRenewalAgreementIDs(ids ...int64) {
	if m.removedrenewal_agreements == nil {
		m.removedrenewal_agreements = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.renewal_agreements, ids[i])
		m.removedrenewal_agreements[ids[i]] = struct{}{}
	}
}

// RemovedRenewalAgreements returns the removed IDs of the "renewal_agreements" edge to the RenewalAgreement entity.
func (m *UserMutation) RemovedRenewalAgreementsIDs() (ids []int64) {
	for id := range m.removedrenewal_agreements {
		ids = append(ids, id)
	}
	return
}

// RenewalAgreementsIDs returns the "renewal_agreements" edge IDs in the mutation.
func (m *UserMutation) RenewalAgreementsIDs() (ids []int64) {
	for id := range m.renewal_agreements {
		ids = append(ids, id)
	}
	return
}

// ResetRenewalAgreements resets all changes to the "renewal_agreements" edge.
func (m *UserMutation) ResetRenewalAgreements() {
	m.renewal_agreements = nil
	m.clearedrenewal_agreements = false
	m.removedrenewal_agreements = nil
}

// AddArtworkIDs adds the "artworks" edge to the Artwork entity by ids.
func (m *UserMutation) AddArtworkIDs(ids ...int64) {
	if m.artworks == nil {
		m.artworks = make(map[int64]struct{})
	}
	for i := range ids {
		m.artworks[ids[i]] = struct{}{}
	}
}

// ClearArtworks clears the "artworks" edge to the Artwork entity.
func (m *UserMutation) ClearArtworks() {
	m.clearedartworks = true
}

// ArtworksCleared reports if the "artworks" edge to the Artwork entity was cleared.
func (m *UserMutation) ArtworksCleared() bool {
	return m.clearedartworks
}

// RemoveArtworkIDs removes the "artworks" edge to the Artwork entity by IDs.
func (m *UserMutation) RemoveArtworkIDs(ids ...int64) {
	if m.removedartworks == nil {
		m.removedartworks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.artworks, ids[i])
		m.removedartworks[ids[i]] = struct{}{}
	}
}

// RemovedArtworks returns the removed IDs of the "artworks" edge to the Artwork entity.
func (m *UserMutation) RemovedArtworksIDs() (ids []int64) {
	for id := range m.removedartworks {
		ids = append(ids, id)
	}
	return
}

// ArtworksIDs returns the "artworks" edge IDs in the mutation.
func (m *UserMutation) ArtworksIDs() (ids []int64) {
	for id := range m.artworks {
		ids = append(ids, id)
	}
	return
}

// ResetArtworks resets all changes to the "artworks" edge.
func (m *UserMutation) ResetArtworks() {
	m.artworks = nil
	m.clearedartworks = false
	m.removedartworks = nil
}

// AddArtworkLikeIDs adds the "artwork_likes" edge to the ArtworkLike entity by ids.
func (m *UserMutation) AddArtworkLikeIDs(ids ...int64) {
	if m.artwork_likes == nil {
		m.artwork_likes = make(map[int64]struct{})
	}
	for i := range ids {
		m.artwork_likes[ids[i]] = struct{}{}
	}
}

// ClearArtworkLikes clears the "artwork_likes" edge to the ArtworkLike entity.
func (m *UserMutation) ClearArtworkLikes() {
	m.clearedartwork_likes = true
}

// ArtworkLikesCleared reports if the "artwork_likes" edge to the ArtworkLike entity was cleared.
func (m *UserMutation) ArtworkLikesCleared() bool {
	return m.clearedartwork_likes
}

// RemoveArtworkLikeIDs removes the "artwork_likes" edge to the ArtworkLike entity by IDs.
func (m *UserMutation) RemoveArtworkLikeIDs(ids ...int64) {
	if m.removedartwork_likes == nil {
		m.removedartwork_likes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.artwork_likes, ids[i])
		m.removedartwork_likes[ids[i]] = struct{}{}
	}
}

// RemovedArtworkLikes returns the removed IDs of the "artwork_likes" edge to the ArtworkLike entity.
func (m *UserMutation) RemovedArtworkLikesIDs() (ids []int64) {
	for id := range m.removedartwork_likes {
		ids = append(ids, id)
	}
	return
}

// ArtworkLikesIDs returns the "artwork_likes" edge IDs in the mutation.
func (m *UserMutation) ArtworkLikesIDs() (ids []int64) {
	for id := range m.artwork_likes {
		ids = append(ids, id)
	}
	return
}

// ResetArtworkLikes resets all changes to the "artwork_likes" edge.
func (m *UserMutation) ResetArtworkLikes() {
	m.artwork_likes = nil
	m.clearedartwork_likes = false
	m.removedartwork_likes = nil
}

// AddCdkInfoIDs adds the "cdk_infos" edge to the CDKInfo entity by ids.
func (m *UserMutation) AddCdkInfoIDs(ids ...int64) {
	if m.cdk_infos == nil {
		m.cdk_infos = make(map[int64]struct{})
	}
	for i := range ids {
		m.cdk_infos[ids[i]] = struct{}{}
	}
}

// ClearCdkInfos clears the "cdk_infos" edge to the CDKInfo entity.
func (m *UserMutation) ClearCdkInfos() {
	m.clearedcdk_infos = true
}

// CdkInfosCleared reports if the "cdk_infos" edge to the CDKInfo entity was cleared.
func (m *UserMutation) CdkInfosCleared() bool {
	return m.clearedcdk_infos
}

// RemoveCdkInfoIDs removes the "cdk_infos" edge to the CDKInfo entity by IDs.
func (m *UserMutation) RemoveCdkInfoIDs(ids ...int64) {
	if m.removedcdk_infos == nil {
		m.removedcdk_infos = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cdk_infos, ids[i])
		m.removedcdk_infos[ids[i]] = struct{}{}
	}
}

// RemovedCdkInfos returns the removed IDs of the "cdk_infos" edge to the CDKInfo entity.
func (m *UserMutation) RemovedCdkInfosIDs() (ids []int64) {
	for id := range m.removedcdk_infos {
		ids = append(ids, id)
	}
	return
}

// CdkInfosIDs returns the "cdk_infos" edge IDs in the mutation.
func (m *UserMutation) CdkInfosIDs() (ids []int64) {
	for id := range m.cdk_infos {
		ids = append(ids, id)
	}
	return
}

// ResetCdkInfos resets all changes to the "cdk_infos" edge.
func (m *UserMutation) ResetCdkInfos() {
	m.cdk_infos = nil
	m.clearedcdk_infos = false
	m.removedcdk_infos = nil
}

// AddUseCdkInfoIDs adds the "use_cdk_infos" edge to the CDKInfo entity by ids.
func (m *UserMutation) AddUseCdkInfoIDs(ids ...int64) {
	if m.use_cdk_infos == nil {
		m.use_cdk_infos = make(map[int64]struct{})
	}
	for i := range ids {
		m.use_cdk_infos[ids[i]] = struct{}{}
	}
}

// ClearUseCdkInfos clears the "use_cdk_infos" edge to the CDKInfo entity.
func (m *UserMutation) ClearUseCdkInfos() {
	m.cleareduse_cdk_infos = true
}

// UseCdkInfosCleared reports if the "use_cdk_infos" edge to the CDKInfo entity was cleared.
func (m *UserMutation) UseCdkInfosCleared() bool {
	return m.cleareduse_cdk_infos
}

// RemoveUseCdkInfoIDs removes the "use_cdk_infos" edge to the CDKInfo entity by IDs.
func (m *UserMutation) RemoveUseCdkInfoIDs(ids ...int64) {
	if m.removeduse_cdk_infos == nil {
		m.removeduse_cdk_infos = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.use_cdk_infos, ids[i])
		m.removeduse_cdk_infos[ids[i]] = struct{}{}
	}
}

// RemovedUseCdkInfos returns the removed IDs of the "use_cdk_infos" edge to the CDKInfo entity.
func (m *UserMutation) RemovedUseCdkInfosIDs() (ids []int64) {
	for id := range m.removeduse_cdk_infos {
		ids = append(ids, id)
	}
	return
}

// UseCdkInfosIDs returns the "use_cdk_infos" edge IDs in the mutation.
func (m *UserMutation) UseCdkInfosIDs() (ids []int64) {
	for id := range m.use_cdk_infos {
		ids = append(ids, id)
	}
	return
}

// ResetUseCdkInfos resets all changes to the "use_cdk_infos" edge.
func (m *UserMutation) ResetUseCdkInfos() {
	m.use_cdk_infos = nil
	m.cleareduse_cdk_infos = false
	m.removeduse_cdk_infos = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.nick_name != nil {
		fields = append(fields, user.FieldNickName)
	}
	if m.jpg_url != nil {
		fields = append(fields, user.FieldJpgURL)
	}
	if m.key != nil {
		fields = append(fields, user.FieldKey)
	}
	if m.secret != nil {
		fields = append(fields, user.FieldSecret)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.is_frozen != nil {
		fields = append(fields, user.FieldIsFrozen)
	}
	if m.is_recharge != nil {
		fields = append(fields, user.FieldIsRecharge)
	}
	if m.user_type != nil {
		fields = append(fields, user.FieldUserType)
	}
	if m.parent != nil {
		fields = append(fields, user.FieldParentID)
	}
	if m.pop_version != nil {
		fields = append(fields, user.FieldPopVersion)
	}
	if m.area_code != nil {
		fields = append(fields, user.FieldAreaCode)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldNickName:
		return m.NickName()
	case user.FieldJpgURL:
		return m.JpgURL()
	case user.FieldKey:
		return m.Key()
	case user.FieldSecret:
		return m.Secret()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPassword:
		return m.Password()
	case user.FieldIsFrozen:
		return m.IsFrozen()
	case user.FieldIsRecharge:
		return m.IsRecharge()
	case user.FieldUserType:
		return m.UserType()
	case user.FieldParentID:
		return m.ParentID()
	case user.FieldPopVersion:
		return m.PopVersion()
	case user.FieldAreaCode:
		return m.AreaCode()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldNickName:
		return m.OldNickName(ctx)
	case user.FieldJpgURL:
		return m.OldJpgURL(ctx)
	case user.FieldKey:
		return m.OldKey(ctx)
	case user.FieldSecret:
		return m.OldSecret(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldIsFrozen:
		return m.OldIsFrozen(ctx)
	case user.FieldIsRecharge:
		return m.OldIsRecharge(ctx)
	case user.FieldUserType:
		return m.OldUserType(ctx)
	case user.FieldParentID:
		return m.OldParentID(ctx)
	case user.FieldPopVersion:
		return m.OldPopVersion(ctx)
	case user.FieldAreaCode:
		return m.OldAreaCode(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldNickName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickName(v)
		return nil
	case user.FieldJpgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJpgURL(v)
		return nil
	case user.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case user.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldIsFrozen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFrozen(v)
		return nil
	case user.FieldIsRecharge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRecharge(v)
		return nil
	case user.FieldUserType:
		v, ok := value.(user.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case user.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case user.FieldPopVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopVersion(v)
		return nil
	case user.FieldAreaCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaCode(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldNickName:
		m.ResetNickName()
		return nil
	case user.FieldJpgURL:
		m.ResetJpgURL()
		return nil
	case user.FieldKey:
		m.ResetKey()
		return nil
	case user.FieldSecret:
		m.ResetSecret()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldIsFrozen:
		m.ResetIsFrozen()
		return nil
	case user.FieldIsRecharge:
		m.ResetIsRecharge()
		return nil
	case user.FieldUserType:
		m.ResetUserType()
		return nil
	case user.FieldParentID:
		m.ResetParentID()
		return nil
	case user.FieldPopVersion:
		m.ResetPopVersion()
		return nil
	case user.FieldAreaCode:
		m.ResetAreaCode()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 34)
	if m.vx_accounts != nil {
		edges = append(edges, user.EdgeVxAccounts)
	}
	if m.collects != nil {
		edges = append(edges, user.EdgeCollects)
	}
	if m.devices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.profit_settings != nil {
		edges = append(edges, user.EdgeProfitSettings)
	}
	if m.cost_account != nil {
		edges = append(edges, user.EdgeCostAccount)
	}
	if m.profit_account != nil {
		edges = append(edges, user.EdgeProfitAccount)
	}
	if m.cost_bills != nil {
		edges = append(edges, user.EdgeCostBills)
	}
	if m.earn_bills != nil {
		edges = append(edges, user.EdgeEarnBills)
	}
	if m.mission_consume_orders != nil {
		edges = append(edges, user.EdgeMissionConsumeOrders)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, user.EdgeMissionProduceOrders)
	}
	if m.recharge_orders != nil {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.vx_socials != nil {
		edges = append(edges, user.EdgeVxSocials)
	}
	if m.mission_batches != nil {
		edges = append(edges, user.EdgeMissionBatches)
	}
	if m.user_devices != nil {
		edges = append(edges, user.EdgeUserDevices)
	}
	if m.parent != nil {
		edges = append(edges, user.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, user.EdgeChildren)
	}
	if m.invites != nil {
		edges = append(edges, user.EdgeInvites)
	}
	if m.campaign_orders != nil {
		edges = append(edges, user.EdgeCampaignOrders)
	}
	if m.wallets != nil {
		edges = append(edges, user.EdgeWallets)
	}
	if m.withdraw_account != nil {
		edges = append(edges, user.EdgeWithdrawAccount)
	}
	if m.income_bills != nil {
		edges = append(edges, user.EdgeIncomeBills)
	}
	if m.outcome_bills != nil {
		edges = append(edges, user.EdgeOutcomeBills)
	}
	if m.mission_productions != nil {
		edges = append(edges, user.EdgeMissionProductions)
	}
	if m.missions != nil {
		edges = append(edges, user.EdgeMissions)
	}
	if m.income_transfer_orders != nil {
		edges = append(edges, user.EdgeIncomeTransferOrders)
	}
	if m.outcome_transfer_orders != nil {
		edges = append(edges, user.EdgeOutcomeTransferOrders)
	}
	if m.consume_mission_orders != nil {
		edges = append(edges, user.EdgeConsumeMissionOrders)
	}
	if m.produce_mission_orders != nil {
		edges = append(edges, user.EdgeProduceMissionOrders)
	}
	if m.login_records != nil {
		edges = append(edges, user.EdgeLoginRecords)
	}
	if m.renewal_agreements != nil {
		edges = append(edges, user.EdgeRenewalAgreements)
	}
	if m.artworks != nil {
		edges = append(edges, user.EdgeArtworks)
	}
	if m.artwork_likes != nil {
		edges = append(edges, user.EdgeArtworkLikes)
	}
	if m.cdk_infos != nil {
		edges = append(edges, user.EdgeCdkInfos)
	}
	if m.use_cdk_infos != nil {
		edges = append(edges, user.EdgeUseCdkInfos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVxAccounts:
		ids := make([]ent.Value, 0, len(m.vx_accounts))
		for id := range m.vx_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCollects:
		ids := make([]ent.Value, 0, len(m.collects))
		for id := range m.collects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfitSettings:
		ids := make([]ent.Value, 0, len(m.profit_settings))
		for id := range m.profit_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCostAccount:
		if id := m.cost_account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeProfitAccount:
		if id := m.profit_account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.mission_consume_orders))
		for id := range m.mission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.recharge_orders))
		for id := range m.recharge_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVxSocials:
		ids := make([]ent.Value, 0, len(m.vx_socials))
		for id := range m.vx_socials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionBatches:
		ids := make([]ent.Value, 0, len(m.mission_batches))
		for id := range m.mission_batches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.user_devices))
		for id := range m.user_devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.invites))
		for id := range m.invites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCampaignOrders:
		ids := make([]ent.Value, 0, len(m.campaign_orders))
		for id := range m.campaign_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.wallets))
		for id := range m.wallets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWithdrawAccount:
		if id := m.withdraw_account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeIncomeBills:
		ids := make([]ent.Value, 0, len(m.income_bills))
		for id := range m.income_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOutcomeBills:
		ids := make([]ent.Value, 0, len(m.outcome_bills))
		for id := range m.outcome_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.mission_productions))
		for id := range m.mission_productions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.missions))
		for id := range m.missions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncomeTransferOrders:
		ids := make([]ent.Value, 0, len(m.income_transfer_orders))
		for id := range m.income_transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOutcomeTransferOrders:
		ids := make([]ent.Value, 0, len(m.outcome_transfer_orders))
		for id := range m.outcome_transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConsumeMissionOrders:
		ids := make([]ent.Value, 0, len(m.consume_mission_orders))
		for id := range m.consume_mission_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProduceMissionOrders:
		ids := make([]ent.Value, 0, len(m.produce_mission_orders))
		for id := range m.produce_mission_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginRecords:
		ids := make([]ent.Value, 0, len(m.login_records))
		for id := range m.login_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRenewalAgreements:
		ids := make([]ent.Value, 0, len(m.renewal_agreements))
		for id := range m.renewal_agreements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtworks:
		ids := make([]ent.Value, 0, len(m.artworks))
		for id := range m.artworks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtworkLikes:
		ids := make([]ent.Value, 0, len(m.artwork_likes))
		for id := range m.artwork_likes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCdkInfos:
		ids := make([]ent.Value, 0, len(m.cdk_infos))
		for id := range m.cdk_infos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUseCdkInfos:
		ids := make([]ent.Value, 0, len(m.use_cdk_infos))
		for id := range m.use_cdk_infos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 34)
	if m.removedvx_accounts != nil {
		edges = append(edges, user.EdgeVxAccounts)
	}
	if m.removedcollects != nil {
		edges = append(edges, user.EdgeCollects)
	}
	if m.removeddevices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.removedprofit_settings != nil {
		edges = append(edges, user.EdgeProfitSettings)
	}
	if m.removedcost_bills != nil {
		edges = append(edges, user.EdgeCostBills)
	}
	if m.removedearn_bills != nil {
		edges = append(edges, user.EdgeEarnBills)
	}
	if m.removedmission_consume_orders != nil {
		edges = append(edges, user.EdgeMissionConsumeOrders)
	}
	if m.removedmission_produce_orders != nil {
		edges = append(edges, user.EdgeMissionProduceOrders)
	}
	if m.removedrecharge_orders != nil {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.removedvx_socials != nil {
		edges = append(edges, user.EdgeVxSocials)
	}
	if m.removedmission_batches != nil {
		edges = append(edges, user.EdgeMissionBatches)
	}
	if m.removeduser_devices != nil {
		edges = append(edges, user.EdgeUserDevices)
	}
	if m.removedchildren != nil {
		edges = append(edges, user.EdgeChildren)
	}
	if m.removedinvites != nil {
		edges = append(edges, user.EdgeInvites)
	}
	if m.removedcampaign_orders != nil {
		edges = append(edges, user.EdgeCampaignOrders)
	}
	if m.removedwallets != nil {
		edges = append(edges, user.EdgeWallets)
	}
	if m.removedincome_bills != nil {
		edges = append(edges, user.EdgeIncomeBills)
	}
	if m.removedoutcome_bills != nil {
		edges = append(edges, user.EdgeOutcomeBills)
	}
	if m.removedmission_productions != nil {
		edges = append(edges, user.EdgeMissionProductions)
	}
	if m.removedmissions != nil {
		edges = append(edges, user.EdgeMissions)
	}
	if m.removedincome_transfer_orders != nil {
		edges = append(edges, user.EdgeIncomeTransferOrders)
	}
	if m.removedoutcome_transfer_orders != nil {
		edges = append(edges, user.EdgeOutcomeTransferOrders)
	}
	if m.removedconsume_mission_orders != nil {
		edges = append(edges, user.EdgeConsumeMissionOrders)
	}
	if m.removedproduce_mission_orders != nil {
		edges = append(edges, user.EdgeProduceMissionOrders)
	}
	if m.removedlogin_records != nil {
		edges = append(edges, user.EdgeLoginRecords)
	}
	if m.removedrenewal_agreements != nil {
		edges = append(edges, user.EdgeRenewalAgreements)
	}
	if m.removedartworks != nil {
		edges = append(edges, user.EdgeArtworks)
	}
	if m.removedartwork_likes != nil {
		edges = append(edges, user.EdgeArtworkLikes)
	}
	if m.removedcdk_infos != nil {
		edges = append(edges, user.EdgeCdkInfos)
	}
	if m.removeduse_cdk_infos != nil {
		edges = append(edges, user.EdgeUseCdkInfos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVxAccounts:
		ids := make([]ent.Value, 0, len(m.removedvx_accounts))
		for id := range m.removedvx_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCollects:
		ids := make([]ent.Value, 0, len(m.removedcollects))
		for id := range m.removedcollects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfitSettings:
		ids := make([]ent.Value, 0, len(m.removedprofit_settings))
		for id := range m.removedprofit_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_consume_orders))
		for id := range m.removedmission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.removedrecharge_orders))
		for id := range m.removedrecharge_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVxSocials:
		ids := make([]ent.Value, 0, len(m.removedvx_socials))
		for id := range m.removedvx_socials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionBatches:
		ids := make([]ent.Value, 0, len(m.removedmission_batches))
		for id := range m.removedmission_batches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.removeduser_devices))
		for id := range m.removeduser_devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.removedinvites))
		for id := range m.removedinvites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCampaignOrders:
		ids := make([]ent.Value, 0, len(m.removedcampaign_orders))
		for id := range m.removedcampaign_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.removedwallets))
		for id := range m.removedwallets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncomeBills:
		ids := make([]ent.Value, 0, len(m.removedincome_bills))
		for id := range m.removedincome_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOutcomeBills:
		ids := make([]ent.Value, 0, len(m.removedoutcome_bills))
		for id := range m.removedoutcome_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProductions:
		ids := make([]ent.Value, 0, len(m.removedmission_productions))
		for id := range m.removedmission_productions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissions:
		ids := make([]ent.Value, 0, len(m.removedmissions))
		for id := range m.removedmissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncomeTransferOrders:
		ids := make([]ent.Value, 0, len(m.removedincome_transfer_orders))
		for id := range m.removedincome_transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOutcomeTransferOrders:
		ids := make([]ent.Value, 0, len(m.removedoutcome_transfer_orders))
		for id := range m.removedoutcome_transfer_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConsumeMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedconsume_mission_orders))
		for id := range m.removedconsume_mission_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProduceMissionOrders:
		ids := make([]ent.Value, 0, len(m.removedproduce_mission_orders))
		for id := range m.removedproduce_mission_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginRecords:
		ids := make([]ent.Value, 0, len(m.removedlogin_records))
		for id := range m.removedlogin_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRenewalAgreements:
		ids := make([]ent.Value, 0, len(m.removedrenewal_agreements))
		for id := range m.removedrenewal_agreements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtworks:
		ids := make([]ent.Value, 0, len(m.removedartworks))
		for id := range m.removedartworks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtworkLikes:
		ids := make([]ent.Value, 0, len(m.removedartwork_likes))
		for id := range m.removedartwork_likes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCdkInfos:
		ids := make([]ent.Value, 0, len(m.removedcdk_infos))
		for id := range m.removedcdk_infos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUseCdkInfos:
		ids := make([]ent.Value, 0, len(m.removeduse_cdk_infos))
		for id := range m.removeduse_cdk_infos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 34)
	if m.clearedvx_accounts {
		edges = append(edges, user.EdgeVxAccounts)
	}
	if m.clearedcollects {
		edges = append(edges, user.EdgeCollects)
	}
	if m.cleareddevices {
		edges = append(edges, user.EdgeDevices)
	}
	if m.clearedprofit_settings {
		edges = append(edges, user.EdgeProfitSettings)
	}
	if m.clearedcost_account {
		edges = append(edges, user.EdgeCostAccount)
	}
	if m.clearedprofit_account {
		edges = append(edges, user.EdgeProfitAccount)
	}
	if m.clearedcost_bills {
		edges = append(edges, user.EdgeCostBills)
	}
	if m.clearedearn_bills {
		edges = append(edges, user.EdgeEarnBills)
	}
	if m.clearedmission_consume_orders {
		edges = append(edges, user.EdgeMissionConsumeOrders)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, user.EdgeMissionProduceOrders)
	}
	if m.clearedrecharge_orders {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.clearedvx_socials {
		edges = append(edges, user.EdgeVxSocials)
	}
	if m.clearedmission_batches {
		edges = append(edges, user.EdgeMissionBatches)
	}
	if m.cleareduser_devices {
		edges = append(edges, user.EdgeUserDevices)
	}
	if m.clearedparent {
		edges = append(edges, user.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, user.EdgeChildren)
	}
	if m.clearedinvites {
		edges = append(edges, user.EdgeInvites)
	}
	if m.clearedcampaign_orders {
		edges = append(edges, user.EdgeCampaignOrders)
	}
	if m.clearedwallets {
		edges = append(edges, user.EdgeWallets)
	}
	if m.clearedwithdraw_account {
		edges = append(edges, user.EdgeWithdrawAccount)
	}
	if m.clearedincome_bills {
		edges = append(edges, user.EdgeIncomeBills)
	}
	if m.clearedoutcome_bills {
		edges = append(edges, user.EdgeOutcomeBills)
	}
	if m.clearedmission_productions {
		edges = append(edges, user.EdgeMissionProductions)
	}
	if m.clearedmissions {
		edges = append(edges, user.EdgeMissions)
	}
	if m.clearedincome_transfer_orders {
		edges = append(edges, user.EdgeIncomeTransferOrders)
	}
	if m.clearedoutcome_transfer_orders {
		edges = append(edges, user.EdgeOutcomeTransferOrders)
	}
	if m.clearedconsume_mission_orders {
		edges = append(edges, user.EdgeConsumeMissionOrders)
	}
	if m.clearedproduce_mission_orders {
		edges = append(edges, user.EdgeProduceMissionOrders)
	}
	if m.clearedlogin_records {
		edges = append(edges, user.EdgeLoginRecords)
	}
	if m.clearedrenewal_agreements {
		edges = append(edges, user.EdgeRenewalAgreements)
	}
	if m.clearedartworks {
		edges = append(edges, user.EdgeArtworks)
	}
	if m.clearedartwork_likes {
		edges = append(edges, user.EdgeArtworkLikes)
	}
	if m.clearedcdk_infos {
		edges = append(edges, user.EdgeCdkInfos)
	}
	if m.cleareduse_cdk_infos {
		edges = append(edges, user.EdgeUseCdkInfos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeVxAccounts:
		return m.clearedvx_accounts
	case user.EdgeCollects:
		return m.clearedcollects
	case user.EdgeDevices:
		return m.cleareddevices
	case user.EdgeProfitSettings:
		return m.clearedprofit_settings
	case user.EdgeCostAccount:
		return m.clearedcost_account
	case user.EdgeProfitAccount:
		return m.clearedprofit_account
	case user.EdgeCostBills:
		return m.clearedcost_bills
	case user.EdgeEarnBills:
		return m.clearedearn_bills
	case user.EdgeMissionConsumeOrders:
		return m.clearedmission_consume_orders
	case user.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case user.EdgeRechargeOrders:
		return m.clearedrecharge_orders
	case user.EdgeVxSocials:
		return m.clearedvx_socials
	case user.EdgeMissionBatches:
		return m.clearedmission_batches
	case user.EdgeUserDevices:
		return m.cleareduser_devices
	case user.EdgeParent:
		return m.clearedparent
	case user.EdgeChildren:
		return m.clearedchildren
	case user.EdgeInvites:
		return m.clearedinvites
	case user.EdgeCampaignOrders:
		return m.clearedcampaign_orders
	case user.EdgeWallets:
		return m.clearedwallets
	case user.EdgeWithdrawAccount:
		return m.clearedwithdraw_account
	case user.EdgeIncomeBills:
		return m.clearedincome_bills
	case user.EdgeOutcomeBills:
		return m.clearedoutcome_bills
	case user.EdgeMissionProductions:
		return m.clearedmission_productions
	case user.EdgeMissions:
		return m.clearedmissions
	case user.EdgeIncomeTransferOrders:
		return m.clearedincome_transfer_orders
	case user.EdgeOutcomeTransferOrders:
		return m.clearedoutcome_transfer_orders
	case user.EdgeConsumeMissionOrders:
		return m.clearedconsume_mission_orders
	case user.EdgeProduceMissionOrders:
		return m.clearedproduce_mission_orders
	case user.EdgeLoginRecords:
		return m.clearedlogin_records
	case user.EdgeRenewalAgreements:
		return m.clearedrenewal_agreements
	case user.EdgeArtworks:
		return m.clearedartworks
	case user.EdgeArtworkLikes:
		return m.clearedartwork_likes
	case user.EdgeCdkInfos:
		return m.clearedcdk_infos
	case user.EdgeUseCdkInfos:
		return m.cleareduse_cdk_infos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCostAccount:
		m.ClearCostAccount()
		return nil
	case user.EdgeProfitAccount:
		m.ClearProfitAccount()
		return nil
	case user.EdgeParent:
		m.ClearParent()
		return nil
	case user.EdgeWithdrawAccount:
		m.ClearWithdrawAccount()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeVxAccounts:
		m.ResetVxAccounts()
		return nil
	case user.EdgeCollects:
		m.ResetCollects()
		return nil
	case user.EdgeDevices:
		m.ResetDevices()
		return nil
	case user.EdgeProfitSettings:
		m.ResetProfitSettings()
		return nil
	case user.EdgeCostAccount:
		m.ResetCostAccount()
		return nil
	case user.EdgeProfitAccount:
		m.ResetProfitAccount()
		return nil
	case user.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case user.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	case user.EdgeMissionConsumeOrders:
		m.ResetMissionConsumeOrders()
		return nil
	case user.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case user.EdgeRechargeOrders:
		m.ResetRechargeOrders()
		return nil
	case user.EdgeVxSocials:
		m.ResetVxSocials()
		return nil
	case user.EdgeMissionBatches:
		m.ResetMissionBatches()
		return nil
	case user.EdgeUserDevices:
		m.ResetUserDevices()
		return nil
	case user.EdgeParent:
		m.ResetParent()
		return nil
	case user.EdgeChildren:
		m.ResetChildren()
		return nil
	case user.EdgeInvites:
		m.ResetInvites()
		return nil
	case user.EdgeCampaignOrders:
		m.ResetCampaignOrders()
		return nil
	case user.EdgeWallets:
		m.ResetWallets()
		return nil
	case user.EdgeWithdrawAccount:
		m.ResetWithdrawAccount()
		return nil
	case user.EdgeIncomeBills:
		m.ResetIncomeBills()
		return nil
	case user.EdgeOutcomeBills:
		m.ResetOutcomeBills()
		return nil
	case user.EdgeMissionProductions:
		m.ResetMissionProductions()
		return nil
	case user.EdgeMissions:
		m.ResetMissions()
		return nil
	case user.EdgeIncomeTransferOrders:
		m.ResetIncomeTransferOrders()
		return nil
	case user.EdgeOutcomeTransferOrders:
		m.ResetOutcomeTransferOrders()
		return nil
	case user.EdgeConsumeMissionOrders:
		m.ResetConsumeMissionOrders()
		return nil
	case user.EdgeProduceMissionOrders:
		m.ResetProduceMissionOrders()
		return nil
	case user.EdgeLoginRecords:
		m.ResetLoginRecords()
		return nil
	case user.EdgeRenewalAgreements:
		m.ResetRenewalAgreements()
		return nil
	case user.EdgeArtworks:
		m.ResetArtworks()
		return nil
	case user.EdgeArtworkLikes:
		m.ResetArtworkLikes()
		return nil
	case user.EdgeCdkInfos:
		m.ResetCdkInfos()
		return nil
	case user.EdgeUseCdkInfos:
		m.ResetUseCdkInfos()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDeviceMutation represents an operation that mutates the UserDevice nodes in the graph.
type UserDeviceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	device        *int64
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*UserDevice, error)
	predicates    []predicate.UserDevice
}

var _ ent.Mutation = (*UserDeviceMutation)(nil)

// userdeviceOption allows management of the mutation configuration using functional options.
type userdeviceOption func(*UserDeviceMutation)

// newUserDeviceMutation creates new mutation for the UserDevice entity.
func newUserDeviceMutation(c config, op Op, opts ...userdeviceOption) *UserDeviceMutation {
	m := &UserDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDeviceID sets the ID field of the mutation.
func withUserDeviceID(id int64) userdeviceOption {
	return func(m *UserDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDevice
		)
		m.oldValue = func(ctx context.Context) (*UserDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDevice sets the old UserDevice of the mutation.
func withUserDevice(node *UserDevice) userdeviceOption {
	return func(m *UserDeviceMutation) {
		m.oldValue = func(context.Context) (*UserDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserDevice entities.
func (m *UserDeviceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDeviceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserDeviceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserDeviceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserDeviceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserDeviceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserDeviceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserDeviceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserDeviceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserDeviceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserDeviceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserDeviceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserDeviceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserDeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserDeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserDeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserDeviceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserDeviceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserDeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserDeviceMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserDeviceMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserDeviceMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceID sets the "device_id" field.
func (m *UserDeviceMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *UserDeviceMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *UserDeviceMutation) ResetDeviceID() {
	m.device = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserDeviceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userdevice.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserDeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserDeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *UserDeviceMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[userdevice.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *UserDeviceMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *UserDeviceMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the UserDeviceMutation builder.
func (m *UserDeviceMutation) Where(ps ...predicate.UserDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserDevice).
func (m *UserDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDeviceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userdevice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userdevice.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.device != nil {
		fields = append(fields, userdevice.FieldDeviceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.CreatedBy()
	case userdevice.FieldUpdatedBy:
		return m.UpdatedBy()
	case userdevice.FieldCreatedAt:
		return m.CreatedAt()
	case userdevice.FieldUpdatedAt:
		return m.UpdatedAt()
	case userdevice.FieldDeletedAt:
		return m.DeletedAt()
	case userdevice.FieldUserID:
		return m.UserID()
	case userdevice.FieldDeviceID:
		return m.DeviceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userdevice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userdevice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userdevice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userdevice.FieldUserID:
		return m.OldUserID(ctx)
	case userdevice.FieldDeviceID:
		return m.OldDeviceID(ctx)
	}
	return nil, fmt.Errorf("unknown UserDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userdevice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userdevice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userdevice.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdevice.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userdevice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDeviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDeviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDeviceMutation) ResetField(name string) error {
	switch name {
	case userdevice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userdevice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userdevice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userdevice.FieldUserID:
		m.ResetUserID()
		return nil
	case userdevice.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userdevice.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, userdevice.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userdevice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userdevice.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userdevice.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, userdevice.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case userdevice.EdgeUser:
		return m.cleareduser
	case userdevice.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDeviceMutation) ClearEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ClearUser()
		return nil
	case userdevice.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown UserDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDeviceMutation) ResetEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ResetUser()
		return nil
	case userdevice.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown UserDevice edge %s", name)
}

// VXAccountMutation represents an operation that mutates the VXAccount nodes in the graph.
type VXAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	open_id       *string
	union_id      *string
	scope         *string
	session_key   *string
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*VXAccount, error)
	predicates    []predicate.VXAccount
}

var _ ent.Mutation = (*VXAccountMutation)(nil)

// vxaccountOption allows management of the mutation configuration using functional options.
type vxaccountOption func(*VXAccountMutation)

// newVXAccountMutation creates new mutation for the VXAccount entity.
func newVXAccountMutation(c config, op Op, opts ...vxaccountOption) *VXAccountMutation {
	m := &VXAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeVXAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVXAccountID sets the ID field of the mutation.
func withVXAccountID(id int64) vxaccountOption {
	return func(m *VXAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *VXAccount
		)
		m.oldValue = func(ctx context.Context) (*VXAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VXAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVXAccount sets the old VXAccount of the mutation.
func withVXAccount(node *VXAccount) vxaccountOption {
	return func(m *VXAccountMutation) {
		m.oldValue = func(context.Context) (*VXAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VXAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VXAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VXAccount entities.
func (m *VXAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VXAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VXAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VXAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *VXAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VXAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VXAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VXAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VXAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VXAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VXAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VXAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VXAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VXAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VXAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VXAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VXAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VXAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VXAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VXAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VXAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VXAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VXAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetOpenID sets the "open_id" field.
func (m *VXAccountMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *VXAccountMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *VXAccountMutation) ResetOpenID() {
	m.open_id = nil
}

// SetUnionID sets the "union_id" field.
func (m *VXAccountMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *VXAccountMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *VXAccountMutation) ResetUnionID() {
	m.union_id = nil
}

// SetScope sets the "scope" field.
func (m *VXAccountMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *VXAccountMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *VXAccountMutation) ResetScope() {
	m.scope = nil
}

// SetSessionKey sets the "session_key" field.
func (m *VXAccountMutation) SetSessionKey(s string) {
	m.session_key = &s
}

// SessionKey returns the value of the "session_key" field in the mutation.
func (m *VXAccountMutation) SessionKey() (r string, exists bool) {
	v := m.session_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionKey returns the old "session_key" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldSessionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionKey: %w", err)
	}
	return oldValue.SessionKey, nil
}

// ResetSessionKey resets all changes to the "session_key" field.
func (m *VXAccountMutation) ResetSessionKey() {
	m.session_key = nil
}

// SetUserID sets the "user_id" field.
func (m *VXAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VXAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VXAccountMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *VXAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[vxaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VXAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VXAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VXAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VXAccountMutation builder.
func (m *VXAccountMutation) Where(ps ...predicate.VXAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VXAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VXAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VXAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VXAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VXAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VXAccount).
func (m *VXAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VXAccountMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, vxaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, vxaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, vxaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vxaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vxaccount.FieldDeletedAt)
	}
	if m.open_id != nil {
		fields = append(fields, vxaccount.FieldOpenID)
	}
	if m.union_id != nil {
		fields = append(fields, vxaccount.FieldUnionID)
	}
	if m.scope != nil {
		fields = append(fields, vxaccount.FieldScope)
	}
	if m.session_key != nil {
		fields = append(fields, vxaccount.FieldSessionKey)
	}
	if m.user != nil {
		fields = append(fields, vxaccount.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VXAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vxaccount.FieldCreatedBy:
		return m.CreatedBy()
	case vxaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case vxaccount.FieldCreatedAt:
		return m.CreatedAt()
	case vxaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case vxaccount.FieldDeletedAt:
		return m.DeletedAt()
	case vxaccount.FieldOpenID:
		return m.OpenID()
	case vxaccount.FieldUnionID:
		return m.UnionID()
	case vxaccount.FieldScope:
		return m.Scope()
	case vxaccount.FieldSessionKey:
		return m.SessionKey()
	case vxaccount.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VXAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vxaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vxaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vxaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vxaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vxaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vxaccount.FieldOpenID:
		return m.OldOpenID(ctx)
	case vxaccount.FieldUnionID:
		return m.OldUnionID(ctx)
	case vxaccount.FieldScope:
		return m.OldScope(ctx)
	case vxaccount.FieldSessionKey:
		return m.OldSessionKey(ctx)
	case vxaccount.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown VXAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vxaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vxaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vxaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vxaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vxaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vxaccount.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case vxaccount.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	case vxaccount.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case vxaccount.FieldSessionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionKey(v)
		return nil
	case vxaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown VXAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VXAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vxaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vxaccount.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VXAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vxaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vxaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vxaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vxaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VXAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VXAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VXAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VXAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VXAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VXAccountMutation) ResetField(name string) error {
	switch name {
	case vxaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vxaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vxaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vxaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vxaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vxaccount.FieldOpenID:
		m.ResetOpenID()
		return nil
	case vxaccount.FieldUnionID:
		m.ResetUnionID()
		return nil
	case vxaccount.FieldScope:
		m.ResetScope()
		return nil
	case vxaccount.FieldSessionKey:
		m.ResetSessionKey()
		return nil
	case vxaccount.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown VXAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VXAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, vxaccount.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VXAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vxaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VXAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VXAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VXAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, vxaccount.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VXAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case vxaccount.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VXAccountMutation) ClearEdge(name string) error {
	switch name {
	case vxaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown VXAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VXAccountMutation) ResetEdge(name string) error {
	switch name {
	case vxaccount.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown VXAccount edge %s", name)
}

// VXSocialMutation represents an operation that mutates the VXSocial nodes in the graph.
type VXSocialMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_by             *int64
	addcreated_by          *int64
	updated_by             *int64
	addupdated_by          *int64
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	app_id                 *string
	open_id                *string
	union_id               *string
	scope                  *vxsocial.Scope
	session_key            *string
	access_token           *string
	refresh_token          *string
	clearedFields          map[string]struct{}
	user                   *int64
	cleareduser            bool
	recharge_orders        map[int64]struct{}
	removedrecharge_orders map[int64]struct{}
	clearedrecharge_orders bool
	transfer_orders        map[int64]struct{}
	removedtransfer_orders map[int64]struct{}
	clearedtransfer_orders bool
	done                   bool
	oldValue               func(context.Context) (*VXSocial, error)
	predicates             []predicate.VXSocial
}

var _ ent.Mutation = (*VXSocialMutation)(nil)

// vxsocialOption allows management of the mutation configuration using functional options.
type vxsocialOption func(*VXSocialMutation)

// newVXSocialMutation creates new mutation for the VXSocial entity.
func newVXSocialMutation(c config, op Op, opts ...vxsocialOption) *VXSocialMutation {
	m := &VXSocialMutation{
		config:        c,
		op:            op,
		typ:           TypeVXSocial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVXSocialID sets the ID field of the mutation.
func withVXSocialID(id int64) vxsocialOption {
	return func(m *VXSocialMutation) {
		var (
			err   error
			once  sync.Once
			value *VXSocial
		)
		m.oldValue = func(ctx context.Context) (*VXSocial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VXSocial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVXSocial sets the old VXSocial of the mutation.
func withVXSocial(node *VXSocial) vxsocialOption {
	return func(m *VXSocialMutation) {
		m.oldValue = func(context.Context) (*VXSocial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VXSocialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VXSocialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VXSocial entities.
func (m *VXSocialMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VXSocialMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VXSocialMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VXSocial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *VXSocialMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VXSocialMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VXSocialMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VXSocialMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VXSocialMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VXSocialMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VXSocialMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VXSocialMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VXSocialMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VXSocialMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VXSocialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VXSocialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VXSocialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VXSocialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VXSocialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VXSocialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VXSocialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VXSocialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VXSocialMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *VXSocialMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *VXSocialMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *VXSocialMutation) ResetAppID() {
	m.app_id = nil
}

// SetOpenID sets the "open_id" field.
func (m *VXSocialMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *VXSocialMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *VXSocialMutation) ResetOpenID() {
	m.open_id = nil
}

// SetUnionID sets the "union_id" field.
func (m *VXSocialMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *VXSocialMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *VXSocialMutation) ResetUnionID() {
	m.union_id = nil
}

// SetScope sets the "scope" field.
func (m *VXSocialMutation) SetScope(v vxsocial.Scope) {
	m.scope = &v
}

// Scope returns the value of the "scope" field in the mutation.
func (m *VXSocialMutation) Scope() (r vxsocial.Scope, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldScope(ctx context.Context) (v vxsocial.Scope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *VXSocialMutation) ResetScope() {
	m.scope = nil
}

// SetSessionKey sets the "session_key" field.
func (m *VXSocialMutation) SetSessionKey(s string) {
	m.session_key = &s
}

// SessionKey returns the value of the "session_key" field in the mutation.
func (m *VXSocialMutation) SessionKey() (r string, exists bool) {
	v := m.session_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionKey returns the old "session_key" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldSessionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionKey: %w", err)
	}
	return oldValue.SessionKey, nil
}

// ResetSessionKey resets all changes to the "session_key" field.
func (m *VXSocialMutation) ResetSessionKey() {
	m.session_key = nil
}

// SetAccessToken sets the "access_token" field.
func (m *VXSocialMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *VXSocialMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *VXSocialMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *VXSocialMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *VXSocialMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *VXSocialMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetUserID sets the "user_id" field.
func (m *VXSocialMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VXSocialMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VXSocialMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *VXSocialMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[vxsocial.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VXSocialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VXSocialMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VXSocialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddRechargeOrderIDs adds the "recharge_orders" edge to the RechargeOrder entity by ids.
func (m *VXSocialMutation) AddRechargeOrderIDs(ids ...int64) {
	if m.recharge_orders == nil {
		m.recharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.recharge_orders[ids[i]] = struct{}{}
	}
}

// ClearRechargeOrders clears the "recharge_orders" edge to the RechargeOrder entity.
func (m *VXSocialMutation) ClearRechargeOrders() {
	m.clearedrecharge_orders = true
}

// RechargeOrdersCleared reports if the "recharge_orders" edge to the RechargeOrder entity was cleared.
func (m *VXSocialMutation) RechargeOrdersCleared() bool {
	return m.clearedrecharge_orders
}

// RemoveRechargeOrderIDs removes the "recharge_orders" edge to the RechargeOrder entity by IDs.
func (m *VXSocialMutation) RemoveRechargeOrderIDs(ids ...int64) {
	if m.removedrecharge_orders == nil {
		m.removedrecharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.recharge_orders, ids[i])
		m.removedrecharge_orders[ids[i]] = struct{}{}
	}
}

// RemovedRechargeOrders returns the removed IDs of the "recharge_orders" edge to the RechargeOrder entity.
func (m *VXSocialMutation) RemovedRechargeOrdersIDs() (ids []int64) {
	for id := range m.removedrecharge_orders {
		ids = append(ids, id)
	}
	return
}

// RechargeOrdersIDs returns the "recharge_orders" edge IDs in the mutation.
func (m *VXSocialMutation) RechargeOrdersIDs() (ids []int64) {
	for id := range m.recharge_orders {
		ids = append(ids, id)
	}
	return
}

// ResetRechargeOrders resets all changes to the "recharge_orders" edge.
func (m *VXSocialMutation) ResetRechargeOrders() {
	m.recharge_orders = nil
	m.clearedrecharge_orders = false
	m.removedrecharge_orders = nil
}

// AddTransferOrderIDs adds the "transfer_orders" edge to the TransferOrder entity by ids.
func (m *VXSocialMutation) AddTransferOrderIDs(ids ...int64) {
	if m.transfer_orders == nil {
		m.transfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.transfer_orders[ids[i]] = struct{}{}
	}
}

// ClearTransferOrders clears the "transfer_orders" edge to the TransferOrder entity.
func (m *VXSocialMutation) ClearTransferOrders() {
	m.clearedtransfer_orders = true
}

// TransferOrdersCleared reports if the "transfer_orders" edge to the TransferOrder entity was cleared.
func (m *VXSocialMutation) TransferOrdersCleared() bool {
	return m.clearedtransfer_orders
}

// RemoveTransferOrderIDs removes the "transfer_orders" edge to the TransferOrder entity by IDs.
func (m *VXSocialMutation) RemoveTransferOrderIDs(ids ...int64) {
	if m.removedtransfer_orders == nil {
		m.removedtransfer_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.transfer_orders, ids[i])
		m.removedtransfer_orders[ids[i]] = struct{}{}
	}
}

// RemovedTransferOrders returns the removed IDs of the "transfer_orders" edge to the TransferOrder entity.
func (m *VXSocialMutation) RemovedTransferOrdersIDs() (ids []int64) {
	for id := range m.removedtransfer_orders {
		ids = append(ids, id)
	}
	return
}

// TransferOrdersIDs returns the "transfer_orders" edge IDs in the mutation.
func (m *VXSocialMutation) TransferOrdersIDs() (ids []int64) {
	for id := range m.transfer_orders {
		ids = append(ids, id)
	}
	return
}

// ResetTransferOrders resets all changes to the "transfer_orders" edge.
func (m *VXSocialMutation) ResetTransferOrders() {
	m.transfer_orders = nil
	m.clearedtransfer_orders = false
	m.removedtransfer_orders = nil
}

// Where appends a list predicates to the VXSocialMutation builder.
func (m *VXSocialMutation) Where(ps ...predicate.VXSocial) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VXSocialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VXSocialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VXSocial, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VXSocialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VXSocialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VXSocial).
func (m *VXSocialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VXSocialMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, vxsocial.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, vxsocial.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, vxsocial.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vxsocial.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vxsocial.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, vxsocial.FieldAppID)
	}
	if m.open_id != nil {
		fields = append(fields, vxsocial.FieldOpenID)
	}
	if m.union_id != nil {
		fields = append(fields, vxsocial.FieldUnionID)
	}
	if m.scope != nil {
		fields = append(fields, vxsocial.FieldScope)
	}
	if m.session_key != nil {
		fields = append(fields, vxsocial.FieldSessionKey)
	}
	if m.access_token != nil {
		fields = append(fields, vxsocial.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, vxsocial.FieldRefreshToken)
	}
	if m.user != nil {
		fields = append(fields, vxsocial.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VXSocialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vxsocial.FieldCreatedBy:
		return m.CreatedBy()
	case vxsocial.FieldUpdatedBy:
		return m.UpdatedBy()
	case vxsocial.FieldCreatedAt:
		return m.CreatedAt()
	case vxsocial.FieldUpdatedAt:
		return m.UpdatedAt()
	case vxsocial.FieldDeletedAt:
		return m.DeletedAt()
	case vxsocial.FieldAppID:
		return m.AppID()
	case vxsocial.FieldOpenID:
		return m.OpenID()
	case vxsocial.FieldUnionID:
		return m.UnionID()
	case vxsocial.FieldScope:
		return m.Scope()
	case vxsocial.FieldSessionKey:
		return m.SessionKey()
	case vxsocial.FieldAccessToken:
		return m.AccessToken()
	case vxsocial.FieldRefreshToken:
		return m.RefreshToken()
	case vxsocial.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VXSocialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vxsocial.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vxsocial.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vxsocial.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vxsocial.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vxsocial.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vxsocial.FieldAppID:
		return m.OldAppID(ctx)
	case vxsocial.FieldOpenID:
		return m.OldOpenID(ctx)
	case vxsocial.FieldUnionID:
		return m.OldUnionID(ctx)
	case vxsocial.FieldScope:
		return m.OldScope(ctx)
	case vxsocial.FieldSessionKey:
		return m.OldSessionKey(ctx)
	case vxsocial.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case vxsocial.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case vxsocial.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown VXSocial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXSocialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vxsocial.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vxsocial.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vxsocial.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vxsocial.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vxsocial.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vxsocial.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case vxsocial.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case vxsocial.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	case vxsocial.FieldScope:
		v, ok := value.(vxsocial.Scope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case vxsocial.FieldSessionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionKey(v)
		return nil
	case vxsocial.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case vxsocial.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case vxsocial.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown VXSocial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VXSocialMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vxsocial.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vxsocial.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VXSocialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vxsocial.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vxsocial.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXSocialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vxsocial.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vxsocial.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VXSocial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VXSocialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VXSocialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VXSocialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VXSocial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VXSocialMutation) ResetField(name string) error {
	switch name {
	case vxsocial.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vxsocial.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vxsocial.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vxsocial.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vxsocial.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vxsocial.FieldAppID:
		m.ResetAppID()
		return nil
	case vxsocial.FieldOpenID:
		m.ResetOpenID()
		return nil
	case vxsocial.FieldUnionID:
		m.ResetUnionID()
		return nil
	case vxsocial.FieldScope:
		m.ResetScope()
		return nil
	case vxsocial.FieldSessionKey:
		m.ResetSessionKey()
		return nil
	case vxsocial.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case vxsocial.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case vxsocial.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown VXSocial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VXSocialMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, vxsocial.EdgeUser)
	}
	if m.recharge_orders != nil {
		edges = append(edges, vxsocial.EdgeRechargeOrders)
	}
	if m.transfer_orders != nil {
		edges = append(edges, vxsocial.EdgeTransferOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VXSocialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vxsocial.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case vxsocial.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.recharge_orders))
		for id := range m.recharge_orders {
			ids = append(ids, id)
		}
		return ids
	case vxsocial.EdgeTransferOrders:
		ids := make([]ent.Value, 0, len(m.transfer_orders))
		for id := range m.transfer_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VXSocialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrecharge_orders != nil {
		edges = append(edges, vxsocial.EdgeRechargeOrders)
	}
	if m.removedtransfer_orders != nil {
		edges = append(edges, vxsocial.EdgeTransferOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VXSocialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vxsocial.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.removedrecharge_orders))
		for id := range m.removedrecharge_orders {
			ids = append(ids, id)
		}
		return ids
	case vxsocial.EdgeTransferOrders:
		ids := make([]ent.Value, 0, len(m.removedtransfer_orders))
		for id := range m.removedtransfer_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VXSocialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, vxsocial.EdgeUser)
	}
	if m.clearedrecharge_orders {
		edges = append(edges, vxsocial.EdgeRechargeOrders)
	}
	if m.clearedtransfer_orders {
		edges = append(edges, vxsocial.EdgeTransferOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VXSocialMutation) EdgeCleared(name string) bool {
	switch name {
	case vxsocial.EdgeUser:
		return m.cleareduser
	case vxsocial.EdgeRechargeOrders:
		return m.clearedrecharge_orders
	case vxsocial.EdgeTransferOrders:
		return m.clearedtransfer_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VXSocialMutation) ClearEdge(name string) error {
	switch name {
	case vxsocial.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown VXSocial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VXSocialMutation) ResetEdge(name string) error {
	switch name {
	case vxsocial.EdgeUser:
		m.ResetUser()
		return nil
	case vxsocial.EdgeRechargeOrders:
		m.ResetRechargeOrders()
		return nil
	case vxsocial.EdgeTransferOrders:
		m.ResetTransferOrders()
		return nil
	}
	return fmt.Errorf("unknown VXSocial edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	amount        *int64
	addamount     *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	symbol        *int64
	clearedsymbol bool
	done          bool
	oldValue      func(context.Context) (*Wallet, error)
	predicates    []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id int64) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wallet entities.
func (m *WalletMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *WalletMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WalletMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *WalletMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *WalletMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WalletMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WalletMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WalletMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *WalletMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *WalletMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WalletMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WalletMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WalletMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WalletMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WalletMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WalletMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *WalletMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WalletMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WalletMutation) ResetUserID() {
	m.user = nil
}

// SetSymbolID sets the "symbol_id" field.
func (m *WalletMutation) SetSymbolID(i int64) {
	m.symbol = &i
}

// SymbolID returns the value of the "symbol_id" field in the mutation.
func (m *WalletMutation) SymbolID() (r int64, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolID returns the old "symbol_id" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldSymbolID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolID: %w", err)
	}
	return oldValue.SymbolID, nil
}

// ResetSymbolID resets all changes to the "symbol_id" field.
func (m *WalletMutation) ResetSymbolID() {
	m.symbol = nil
}

// SetAmount sets the "amount" field.
func (m *WalletMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *WalletMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *WalletMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *WalletMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *WalletMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *WalletMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[wallet.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WalletMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WalletMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WalletMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *WalletMutation) ClearSymbol() {
	m.clearedsymbol = true
	m.clearedFields[wallet.FieldSymbolID] = struct{}{}
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *WalletMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *WalletMutation) SymbolIDs() (ids []int64) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *WalletMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Wallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, wallet.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, wallet.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, wallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wallet.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, wallet.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, wallet.FieldUserID)
	}
	if m.symbol != nil {
		fields = append(fields, wallet.FieldSymbolID)
	}
	if m.amount != nil {
		fields = append(fields, wallet.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldCreatedBy:
		return m.CreatedBy()
	case wallet.FieldUpdatedBy:
		return m.UpdatedBy()
	case wallet.FieldCreatedAt:
		return m.CreatedAt()
	case wallet.FieldUpdatedAt:
		return m.UpdatedAt()
	case wallet.FieldDeletedAt:
		return m.DeletedAt()
	case wallet.FieldUserID:
		return m.UserID()
	case wallet.FieldSymbolID:
		return m.SymbolID()
	case wallet.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case wallet.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case wallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case wallet.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case wallet.FieldUserID:
		return m.OldUserID(ctx)
	case wallet.FieldSymbolID:
		return m.OldSymbolID(ctx)
	case wallet.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case wallet.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case wallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wallet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case wallet.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case wallet.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case wallet.FieldSymbolID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolID(v)
		return nil
	case wallet.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, wallet.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, wallet.FieldUpdatedBy)
	}
	if m.addamount != nil {
		fields = append(fields, wallet.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldCreatedBy:
		return m.AddedCreatedBy()
	case wallet.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case wallet.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case wallet.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case wallet.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case wallet.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case wallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case wallet.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case wallet.FieldUserID:
		m.ResetUserID()
		return nil
	case wallet.FieldSymbolID:
		m.ResetSymbolID()
		return nil
	case wallet.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, wallet.EdgeUser)
	}
	if m.symbol != nil {
		edges = append(edges, wallet.EdgeSymbol)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case wallet.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, wallet.EdgeUser)
	}
	if m.clearedsymbol {
		edges = append(edges, wallet.EdgeSymbol)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	switch name {
	case wallet.EdgeUser:
		return m.cleareduser
	case wallet.EdgeSymbol:
		return m.clearedsymbol
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	switch name {
	case wallet.EdgeUser:
		m.ClearUser()
		return nil
	case wallet.EdgeSymbol:
		m.ClearSymbol()
		return nil
	}
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	switch name {
	case wallet.EdgeUser:
		m.ResetUser()
		return nil
	case wallet.EdgeSymbol:
		m.ResetSymbol()
		return nil
	}
	return fmt.Errorf("unknown Wallet edge %s", name)
}

// WithdrawAccountMutation represents an operation that mutates the WithdrawAccount nodes in the graph.
type WithdrawAccountMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_by       *int64
	addcreated_by    *int64
	updated_by       *int64
	addupdated_by    *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	business_name    *string
	business_id      *int64
	addbusiness_id   *int64
	business_type    *enums.BusinessType
	id_card          *string
	personal_name    *string
	phone            *string
	bank_card_number *string
	bank             *string
	way              *enums.TransferOrderType
	alipay_card_no   *string
	clearedFields    map[string]struct{}
	user             *int64
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*WithdrawAccount, error)
	predicates       []predicate.WithdrawAccount
}

var _ ent.Mutation = (*WithdrawAccountMutation)(nil)

// withdrawaccountOption allows management of the mutation configuration using functional options.
type withdrawaccountOption func(*WithdrawAccountMutation)

// newWithdrawAccountMutation creates new mutation for the WithdrawAccount entity.
func newWithdrawAccountMutation(c config, op Op, opts ...withdrawaccountOption) *WithdrawAccountMutation {
	m := &WithdrawAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeWithdrawAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWithdrawAccountID sets the ID field of the mutation.
func withWithdrawAccountID(id int64) withdrawaccountOption {
	return func(m *WithdrawAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *WithdrawAccount
		)
		m.oldValue = func(ctx context.Context) (*WithdrawAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WithdrawAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWithdrawAccount sets the old WithdrawAccount of the mutation.
func withWithdrawAccount(node *WithdrawAccount) withdrawaccountOption {
	return func(m *WithdrawAccountMutation) {
		m.oldValue = func(context.Context) (*WithdrawAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WithdrawAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WithdrawAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WithdrawAccount entities.
func (m *WithdrawAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WithdrawAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WithdrawAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WithdrawAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *WithdrawAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WithdrawAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *WithdrawAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *WithdrawAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WithdrawAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WithdrawAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WithdrawAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *WithdrawAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *WithdrawAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WithdrawAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WithdrawAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WithdrawAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WithdrawAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WithdrawAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WithdrawAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WithdrawAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WithdrawAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WithdrawAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WithdrawAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *WithdrawAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WithdrawAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WithdrawAccountMutation) ResetUserID() {
	m.user = nil
}

// SetBusinessName sets the "business_name" field.
func (m *WithdrawAccountMutation) SetBusinessName(s string) {
	m.business_name = &s
}

// BusinessName returns the value of the "business_name" field in the mutation.
func (m *WithdrawAccountMutation) BusinessName() (r string, exists bool) {
	v := m.business_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessName returns the old "business_name" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBusinessName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessName: %w", err)
	}
	return oldValue.BusinessName, nil
}

// ResetBusinessName resets all changes to the "business_name" field.
func (m *WithdrawAccountMutation) ResetBusinessName() {
	m.business_name = nil
}

// SetBusinessID sets the "business_id" field.
func (m *WithdrawAccountMutation) SetBusinessID(i int64) {
	m.business_id = &i
	m.addbusiness_id = nil
}

// BusinessID returns the value of the "business_id" field in the mutation.
func (m *WithdrawAccountMutation) BusinessID() (r int64, exists bool) {
	v := m.business_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessID returns the old "business_id" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBusinessID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessID: %w", err)
	}
	return oldValue.BusinessID, nil
}

// AddBusinessID adds i to the "business_id" field.
func (m *WithdrawAccountMutation) AddBusinessID(i int64) {
	if m.addbusiness_id != nil {
		*m.addbusiness_id += i
	} else {
		m.addbusiness_id = &i
	}
}

// AddedBusinessID returns the value that was added to the "business_id" field in this mutation.
func (m *WithdrawAccountMutation) AddedBusinessID() (r int64, exists bool) {
	v := m.addbusiness_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBusinessID resets all changes to the "business_id" field.
func (m *WithdrawAccountMutation) ResetBusinessID() {
	m.business_id = nil
	m.addbusiness_id = nil
}

// SetBusinessType sets the "business_type" field.
func (m *WithdrawAccountMutation) SetBusinessType(et enums.BusinessType) {
	m.business_type = &et
}

// BusinessType returns the value of the "business_type" field in the mutation.
func (m *WithdrawAccountMutation) BusinessType() (r enums.BusinessType, exists bool) {
	v := m.business_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessType returns the old "business_type" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBusinessType(ctx context.Context) (v enums.BusinessType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessType: %w", err)
	}
	return oldValue.BusinessType, nil
}

// ResetBusinessType resets all changes to the "business_type" field.
func (m *WithdrawAccountMutation) ResetBusinessType() {
	m.business_type = nil
}

// SetIDCard sets the "id_card" field.
func (m *WithdrawAccountMutation) SetIDCard(s string) {
	m.id_card = &s
}

// IDCard returns the value of the "id_card" field in the mutation.
func (m *WithdrawAccountMutation) IDCard() (r string, exists bool) {
	v := m.id_card
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCard returns the old "id_card" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldIDCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCard: %w", err)
	}
	return oldValue.IDCard, nil
}

// ResetIDCard resets all changes to the "id_card" field.
func (m *WithdrawAccountMutation) ResetIDCard() {
	m.id_card = nil
}

// SetPersonalName sets the "personal_name" field.
func (m *WithdrawAccountMutation) SetPersonalName(s string) {
	m.personal_name = &s
}

// PersonalName returns the value of the "personal_name" field in the mutation.
func (m *WithdrawAccountMutation) PersonalName() (r string, exists bool) {
	v := m.personal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalName returns the old "personal_name" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldPersonalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalName: %w", err)
	}
	return oldValue.PersonalName, nil
}

// ResetPersonalName resets all changes to the "personal_name" field.
func (m *WithdrawAccountMutation) ResetPersonalName() {
	m.personal_name = nil
}

// SetPhone sets the "phone" field.
func (m *WithdrawAccountMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *WithdrawAccountMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *WithdrawAccountMutation) ResetPhone() {
	m.phone = nil
}

// SetBankCardNumber sets the "bank_card_number" field.
func (m *WithdrawAccountMutation) SetBankCardNumber(s string) {
	m.bank_card_number = &s
}

// BankCardNumber returns the value of the "bank_card_number" field in the mutation.
func (m *WithdrawAccountMutation) BankCardNumber() (r string, exists bool) {
	v := m.bank_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBankCardNumber returns the old "bank_card_number" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBankCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankCardNumber: %w", err)
	}
	return oldValue.BankCardNumber, nil
}

// ResetBankCardNumber resets all changes to the "bank_card_number" field.
func (m *WithdrawAccountMutation) ResetBankCardNumber() {
	m.bank_card_number = nil
}

// SetBank sets the "bank" field.
func (m *WithdrawAccountMutation) SetBank(s string) {
	m.bank = &s
}

// Bank returns the value of the "bank" field in the mutation.
func (m *WithdrawAccountMutation) Bank() (r string, exists bool) {
	v := m.bank
	if v == nil {
		return
	}
	return *v, true
}

// OldBank returns the old "bank" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldBank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBank: %w", err)
	}
	return oldValue.Bank, nil
}

// ResetBank resets all changes to the "bank" field.
func (m *WithdrawAccountMutation) ResetBank() {
	m.bank = nil
}

// SetWay sets the "way" field.
func (m *WithdrawAccountMutation) SetWay(eot enums.TransferOrderType) {
	m.way = &eot
}

// Way returns the value of the "way" field in the mutation.
func (m *WithdrawAccountMutation) Way() (r enums.TransferOrderType, exists bool) {
	v := m.way
	if v == nil {
		return
	}
	return *v, true
}

// OldWay returns the old "way" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldWay(ctx context.Context) (v enums.TransferOrderType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWay: %w", err)
	}
	return oldValue.Way, nil
}

// ResetWay resets all changes to the "way" field.
func (m *WithdrawAccountMutation) ResetWay() {
	m.way = nil
}

// SetAlipayCardNo sets the "alipay_card_no" field.
func (m *WithdrawAccountMutation) SetAlipayCardNo(s string) {
	m.alipay_card_no = &s
}

// AlipayCardNo returns the value of the "alipay_card_no" field in the mutation.
func (m *WithdrawAccountMutation) AlipayCardNo() (r string, exists bool) {
	v := m.alipay_card_no
	if v == nil {
		return
	}
	return *v, true
}

// OldAlipayCardNo returns the old "alipay_card_no" field's value of the WithdrawAccount entity.
// If the WithdrawAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawAccountMutation) OldAlipayCardNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlipayCardNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlipayCardNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlipayCardNo: %w", err)
	}
	return oldValue.AlipayCardNo, nil
}

// ResetAlipayCardNo resets all changes to the "alipay_card_no" field.
func (m *WithdrawAccountMutation) ResetAlipayCardNo() {
	m.alipay_card_no = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *WithdrawAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[withdrawaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WithdrawAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WithdrawAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WithdrawAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WithdrawAccountMutation builder.
func (m *WithdrawAccountMutation) Where(ps ...predicate.WithdrawAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WithdrawAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WithdrawAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WithdrawAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WithdrawAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WithdrawAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WithdrawAccount).
func (m *WithdrawAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WithdrawAccountMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, withdrawaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, withdrawaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, withdrawaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, withdrawaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, withdrawaccount.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, withdrawaccount.FieldUserID)
	}
	if m.business_name != nil {
		fields = append(fields, withdrawaccount.FieldBusinessName)
	}
	if m.business_id != nil {
		fields = append(fields, withdrawaccount.FieldBusinessID)
	}
	if m.business_type != nil {
		fields = append(fields, withdrawaccount.FieldBusinessType)
	}
	if m.id_card != nil {
		fields = append(fields, withdrawaccount.FieldIDCard)
	}
	if m.personal_name != nil {
		fields = append(fields, withdrawaccount.FieldPersonalName)
	}
	if m.phone != nil {
		fields = append(fields, withdrawaccount.FieldPhone)
	}
	if m.bank_card_number != nil {
		fields = append(fields, withdrawaccount.FieldBankCardNumber)
	}
	if m.bank != nil {
		fields = append(fields, withdrawaccount.FieldBank)
	}
	if m.way != nil {
		fields = append(fields, withdrawaccount.FieldWay)
	}
	if m.alipay_card_no != nil {
		fields = append(fields, withdrawaccount.FieldAlipayCardNo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WithdrawAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		return m.CreatedBy()
	case withdrawaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case withdrawaccount.FieldCreatedAt:
		return m.CreatedAt()
	case withdrawaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case withdrawaccount.FieldDeletedAt:
		return m.DeletedAt()
	case withdrawaccount.FieldUserID:
		return m.UserID()
	case withdrawaccount.FieldBusinessName:
		return m.BusinessName()
	case withdrawaccount.FieldBusinessID:
		return m.BusinessID()
	case withdrawaccount.FieldBusinessType:
		return m.BusinessType()
	case withdrawaccount.FieldIDCard:
		return m.IDCard()
	case withdrawaccount.FieldPersonalName:
		return m.PersonalName()
	case withdrawaccount.FieldPhone:
		return m.Phone()
	case withdrawaccount.FieldBankCardNumber:
		return m.BankCardNumber()
	case withdrawaccount.FieldBank:
		return m.Bank()
	case withdrawaccount.FieldWay:
		return m.Way()
	case withdrawaccount.FieldAlipayCardNo:
		return m.AlipayCardNo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WithdrawAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case withdrawaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case withdrawaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case withdrawaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case withdrawaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case withdrawaccount.FieldUserID:
		return m.OldUserID(ctx)
	case withdrawaccount.FieldBusinessName:
		return m.OldBusinessName(ctx)
	case withdrawaccount.FieldBusinessID:
		return m.OldBusinessID(ctx)
	case withdrawaccount.FieldBusinessType:
		return m.OldBusinessType(ctx)
	case withdrawaccount.FieldIDCard:
		return m.OldIDCard(ctx)
	case withdrawaccount.FieldPersonalName:
		return m.OldPersonalName(ctx)
	case withdrawaccount.FieldPhone:
		return m.OldPhone(ctx)
	case withdrawaccount.FieldBankCardNumber:
		return m.OldBankCardNumber(ctx)
	case withdrawaccount.FieldBank:
		return m.OldBank(ctx)
	case withdrawaccount.FieldWay:
		return m.OldWay(ctx)
	case withdrawaccount.FieldAlipayCardNo:
		return m.OldAlipayCardNo(ctx)
	}
	return nil, fmt.Errorf("unknown WithdrawAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case withdrawaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case withdrawaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case withdrawaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case withdrawaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case withdrawaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case withdrawaccount.FieldBusinessName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessName(v)
		return nil
	case withdrawaccount.FieldBusinessID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessID(v)
		return nil
	case withdrawaccount.FieldBusinessType:
		v, ok := value.(enums.BusinessType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessType(v)
		return nil
	case withdrawaccount.FieldIDCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCard(v)
		return nil
	case withdrawaccount.FieldPersonalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalName(v)
		return nil
	case withdrawaccount.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case withdrawaccount.FieldBankCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankCardNumber(v)
		return nil
	case withdrawaccount.FieldBank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBank(v)
		return nil
	case withdrawaccount.FieldWay:
		v, ok := value.(enums.TransferOrderType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWay(v)
		return nil
	case withdrawaccount.FieldAlipayCardNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlipayCardNo(v)
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WithdrawAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, withdrawaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, withdrawaccount.FieldUpdatedBy)
	}
	if m.addbusiness_id != nil {
		fields = append(fields, withdrawaccount.FieldBusinessID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WithdrawAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case withdrawaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case withdrawaccount.FieldBusinessID:
		return m.AddedBusinessID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case withdrawaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case withdrawaccount.FieldBusinessID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBusinessID(v)
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WithdrawAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WithdrawAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WithdrawAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WithdrawAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WithdrawAccountMutation) ResetField(name string) error {
	switch name {
	case withdrawaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case withdrawaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case withdrawaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case withdrawaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case withdrawaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case withdrawaccount.FieldUserID:
		m.ResetUserID()
		return nil
	case withdrawaccount.FieldBusinessName:
		m.ResetBusinessName()
		return nil
	case withdrawaccount.FieldBusinessID:
		m.ResetBusinessID()
		return nil
	case withdrawaccount.FieldBusinessType:
		m.ResetBusinessType()
		return nil
	case withdrawaccount.FieldIDCard:
		m.ResetIDCard()
		return nil
	case withdrawaccount.FieldPersonalName:
		m.ResetPersonalName()
		return nil
	case withdrawaccount.FieldPhone:
		m.ResetPhone()
		return nil
	case withdrawaccount.FieldBankCardNumber:
		m.ResetBankCardNumber()
		return nil
	case withdrawaccount.FieldBank:
		m.ResetBank()
		return nil
	case withdrawaccount.FieldWay:
		m.ResetWay()
		return nil
	case withdrawaccount.FieldAlipayCardNo:
		m.ResetAlipayCardNo()
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WithdrawAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, withdrawaccount.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WithdrawAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case withdrawaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WithdrawAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WithdrawAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WithdrawAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, withdrawaccount.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WithdrawAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case withdrawaccount.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WithdrawAccountMutation) ClearEdge(name string) error {
	switch name {
	case withdrawaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WithdrawAccountMutation) ResetEdge(name string) error {
	switch name {
	case withdrawaccount.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WithdrawAccount edge %s", name)
}
