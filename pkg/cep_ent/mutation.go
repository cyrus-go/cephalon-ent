// Code generated by ent, DO NOT EDIT.

package cep_ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/collect"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/costbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/device"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/devicegpumission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/earnbill"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enumcondition"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/enummissionstatus"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/gpu"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/hmackeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/inputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/mission"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionbatch"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionconsumeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkeypair"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionkind"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/missionproduceorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/outputlog"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/platformaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/predicate"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/price"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/profitsetting"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/rechargeorder"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/user"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/userdevice"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxaccount"
	"github.com/stark-sim/cephalon-ent/pkg/cep_ent/vxsocial"
	"github.com/stark-sim/cephalon-ent/pkg/enums"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCollect             = "Collect"
	TypeCostAccount         = "CostAccount"
	TypeCostBill            = "CostBill"
	TypeDevice              = "Device"
	TypeDeviceGpuMission    = "DeviceGpuMission"
	TypeEarnBill            = "EarnBill"
	TypeEnumCondition       = "EnumCondition"
	TypeEnumMissionStatus   = "EnumMissionStatus"
	TypeGpu                 = "Gpu"
	TypeHmacKeyPair         = "HmacKeyPair"
	TypeInputLog            = "InputLog"
	TypeMission             = "Mission"
	TypeMissionBatch        = "MissionBatch"
	TypeMissionConsumeOrder = "MissionConsumeOrder"
	TypeMissionKeyPair      = "MissionKeyPair"
	TypeMissionKind         = "MissionKind"
	TypeMissionProduceOrder = "MissionProduceOrder"
	TypeOutputLog           = "OutputLog"
	TypePlatformAccount     = "PlatformAccount"
	TypePrice               = "Price"
	TypeProfitAccount       = "ProfitAccount"
	TypeProfitSetting       = "ProfitSetting"
	TypeRechargeOrder       = "RechargeOrder"
	TypeUser                = "User"
	TypeUserDevice          = "UserDevice"
	TypeVXAccount           = "VXAccount"
	TypeVXSocial            = "VXSocial"
)

// CollectMutation represents an operation that mutates the Collect nodes in the graph.
type CollectMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	url           *string
	jpg_name      *int64
	addjpg_name   *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Collect, error)
	predicates    []predicate.Collect
}

var _ ent.Mutation = (*CollectMutation)(nil)

// collectOption allows management of the mutation configuration using functional options.
type collectOption func(*CollectMutation)

// newCollectMutation creates new mutation for the Collect entity.
func newCollectMutation(c config, op Op, opts ...collectOption) *CollectMutation {
	m := &CollectMutation{
		config:        c,
		op:            op,
		typ:           TypeCollect,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollectID sets the ID field of the mutation.
func withCollectID(id int64) collectOption {
	return func(m *CollectMutation) {
		var (
			err   error
			once  sync.Once
			value *Collect
		)
		m.oldValue = func(ctx context.Context) (*Collect, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collect.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollect sets the old Collect of the mutation.
func withCollect(node *Collect) collectOption {
	return func(m *CollectMutation) {
		m.oldValue = func(context.Context) (*Collect, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Collect entities.
func (m *CollectMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollectMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollectMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Collect.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CollectMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CollectMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CollectMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CollectMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CollectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CollectMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CollectMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CollectMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CollectMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CollectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CollectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CollectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CollectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CollectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CollectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CollectMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetURL sets the "url" field.
func (m *CollectMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CollectMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *CollectMutation) ResetURL() {
	m.url = nil
}

// SetUserID sets the "user_id" field.
func (m *CollectMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CollectMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CollectMutation) ResetUserID() {
	m.user = nil
}

// SetJpgName sets the "jpg_name" field.
func (m *CollectMutation) SetJpgName(i int64) {
	m.jpg_name = &i
	m.addjpg_name = nil
}

// JpgName returns the value of the "jpg_name" field in the mutation.
func (m *CollectMutation) JpgName() (r int64, exists bool) {
	v := m.jpg_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJpgName returns the old "jpg_name" field's value of the Collect entity.
// If the Collect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectMutation) OldJpgName(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJpgName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJpgName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJpgName: %w", err)
	}
	return oldValue.JpgName, nil
}

// AddJpgName adds i to the "jpg_name" field.
func (m *CollectMutation) AddJpgName(i int64) {
	if m.addjpg_name != nil {
		*m.addjpg_name += i
	} else {
		m.addjpg_name = &i
	}
}

// AddedJpgName returns the value that was added to the "jpg_name" field in this mutation.
func (m *CollectMutation) AddedJpgName() (r int64, exists bool) {
	v := m.addjpg_name
	if v == nil {
		return
	}
	return *v, true
}

// ResetJpgName resets all changes to the "jpg_name" field.
func (m *CollectMutation) ResetJpgName() {
	m.jpg_name = nil
	m.addjpg_name = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CollectMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[collect.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CollectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CollectMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CollectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CollectMutation builder.
func (m *CollectMutation) Where(ps ...predicate.Collect) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Collect, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Collect).
func (m *CollectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, collect.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, collect.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, collect.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, collect.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, collect.FieldDeletedAt)
	}
	if m.url != nil {
		fields = append(fields, collect.FieldURL)
	}
	if m.user != nil {
		fields = append(fields, collect.FieldUserID)
	}
	if m.jpg_name != nil {
		fields = append(fields, collect.FieldJpgName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collect.FieldCreatedBy:
		return m.CreatedBy()
	case collect.FieldUpdatedBy:
		return m.UpdatedBy()
	case collect.FieldCreatedAt:
		return m.CreatedAt()
	case collect.FieldUpdatedAt:
		return m.UpdatedAt()
	case collect.FieldDeletedAt:
		return m.DeletedAt()
	case collect.FieldURL:
		return m.URL()
	case collect.FieldUserID:
		return m.UserID()
	case collect.FieldJpgName:
		return m.JpgName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collect.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case collect.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case collect.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case collect.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case collect.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case collect.FieldURL:
		return m.OldURL(ctx)
	case collect.FieldUserID:
		return m.OldUserID(ctx)
	case collect.FieldJpgName:
		return m.OldJpgName(ctx)
	}
	return nil, fmt.Errorf("unknown Collect field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collect.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case collect.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case collect.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collect.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case collect.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case collect.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case collect.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case collect.FieldJpgName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJpgName(v)
		return nil
	}
	return fmt.Errorf("unknown Collect field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, collect.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, collect.FieldUpdatedBy)
	}
	if m.addjpg_name != nil {
		fields = append(fields, collect.FieldJpgName)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case collect.FieldCreatedBy:
		return m.AddedCreatedBy()
	case collect.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case collect.FieldJpgName:
		return m.AddedJpgName()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case collect.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case collect.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case collect.FieldJpgName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJpgName(v)
		return nil
	}
	return fmt.Errorf("unknown Collect numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Collect nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectMutation) ResetField(name string) error {
	switch name {
	case collect.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case collect.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case collect.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collect.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case collect.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case collect.FieldURL:
		m.ResetURL()
		return nil
	case collect.FieldUserID:
		m.ResetUserID()
		return nil
	case collect.FieldJpgName:
		m.ResetJpgName()
		return nil
	}
	return fmt.Errorf("unknown Collect field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, collect.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collect.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, collect.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectMutation) EdgeCleared(name string) bool {
	switch name {
	case collect.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectMutation) ClearEdge(name string) error {
	switch name {
	case collect.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Collect unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectMutation) ResetEdge(name string) error {
	switch name {
	case collect.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Collect edge %s", name)
}

// CostAccountMutation represents an operation that mutates the CostAccount nodes in the graph.
type CostAccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_by          *int64
	addcreated_by       *int64
	updated_by          *int64
	addupdated_by       *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	total_cep           *int64
	addtotal_cep        *int64
	sum_total_cep       *int64
	addsum_total_cep    *int64
	frozen_total_cep    *int64
	addfrozen_total_cep *int64
	pure_cep            *int64
	addpure_cep         *int64
	sum_pure_cep        *int64
	addsum_pure_cep     *int64
	frozen_pure_cep     *int64
	addfrozen_pure_cep  *int64
	gift_cep            *int64
	addgift_cep         *int64
	sum_gift_cep        *int64
	addsum_gift_cep     *int64
	frozen_gift_cep     *int64
	addfrozen_gift_cep  *int64
	clearedFields       map[string]struct{}
	user                *int64
	cleareduser         bool
	cost_bills          map[int64]struct{}
	removedcost_bills   map[int64]struct{}
	clearedcost_bills   bool
	done                bool
	oldValue            func(context.Context) (*CostAccount, error)
	predicates          []predicate.CostAccount
}

var _ ent.Mutation = (*CostAccountMutation)(nil)

// costaccountOption allows management of the mutation configuration using functional options.
type costaccountOption func(*CostAccountMutation)

// newCostAccountMutation creates new mutation for the CostAccount entity.
func newCostAccountMutation(c config, op Op, opts ...costaccountOption) *CostAccountMutation {
	m := &CostAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeCostAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostAccountID sets the ID field of the mutation.
func withCostAccountID(id int64) costaccountOption {
	return func(m *CostAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *CostAccount
		)
		m.oldValue = func(ctx context.Context) (*CostAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CostAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCostAccount sets the old CostAccount of the mutation.
func withCostAccount(node *CostAccount) costaccountOption {
	return func(m *CostAccountMutation) {
		m.oldValue = func(context.Context) (*CostAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CostAccount entities.
func (m *CostAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CostAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CostAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CostAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CostAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CostAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CostAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CostAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CostAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CostAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CostAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CostAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CostAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CostAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CostAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CostAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CostAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CostAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CostAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CostAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CostAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CostAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CostAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CostAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CostAccountMutation) ResetUserID() {
	m.user = nil
}

// SetTotalCep sets the "total_cep" field.
func (m *CostAccountMutation) SetTotalCep(i int64) {
	m.total_cep = &i
	m.addtotal_cep = nil
}

// TotalCep returns the value of the "total_cep" field in the mutation.
func (m *CostAccountMutation) TotalCep() (r int64, exists bool) {
	v := m.total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCep returns the old "total_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCep: %w", err)
	}
	return oldValue.TotalCep, nil
}

// AddTotalCep adds i to the "total_cep" field.
func (m *CostAccountMutation) AddTotalCep(i int64) {
	if m.addtotal_cep != nil {
		*m.addtotal_cep += i
	} else {
		m.addtotal_cep = &i
	}
}

// AddedTotalCep returns the value that was added to the "total_cep" field in this mutation.
func (m *CostAccountMutation) AddedTotalCep() (r int64, exists bool) {
	v := m.addtotal_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCep resets all changes to the "total_cep" field.
func (m *CostAccountMutation) ResetTotalCep() {
	m.total_cep = nil
	m.addtotal_cep = nil
}

// SetSumTotalCep sets the "sum_total_cep" field.
func (m *CostAccountMutation) SetSumTotalCep(i int64) {
	m.sum_total_cep = &i
	m.addsum_total_cep = nil
}

// SumTotalCep returns the value of the "sum_total_cep" field in the mutation.
func (m *CostAccountMutation) SumTotalCep() (r int64, exists bool) {
	v := m.sum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumTotalCep returns the old "sum_total_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldSumTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumTotalCep: %w", err)
	}
	return oldValue.SumTotalCep, nil
}

// AddSumTotalCep adds i to the "sum_total_cep" field.
func (m *CostAccountMutation) AddSumTotalCep(i int64) {
	if m.addsum_total_cep != nil {
		*m.addsum_total_cep += i
	} else {
		m.addsum_total_cep = &i
	}
}

// AddedSumTotalCep returns the value that was added to the "sum_total_cep" field in this mutation.
func (m *CostAccountMutation) AddedSumTotalCep() (r int64, exists bool) {
	v := m.addsum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumTotalCep resets all changes to the "sum_total_cep" field.
func (m *CostAccountMutation) ResetSumTotalCep() {
	m.sum_total_cep = nil
	m.addsum_total_cep = nil
}

// SetFrozenTotalCep sets the "frozen_total_cep" field.
func (m *CostAccountMutation) SetFrozenTotalCep(i int64) {
	m.frozen_total_cep = &i
	m.addfrozen_total_cep = nil
}

// FrozenTotalCep returns the value of the "frozen_total_cep" field in the mutation.
func (m *CostAccountMutation) FrozenTotalCep() (r int64, exists bool) {
	v := m.frozen_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenTotalCep returns the old "frozen_total_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldFrozenTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenTotalCep: %w", err)
	}
	return oldValue.FrozenTotalCep, nil
}

// AddFrozenTotalCep adds i to the "frozen_total_cep" field.
func (m *CostAccountMutation) AddFrozenTotalCep(i int64) {
	if m.addfrozen_total_cep != nil {
		*m.addfrozen_total_cep += i
	} else {
		m.addfrozen_total_cep = &i
	}
}

// AddedFrozenTotalCep returns the value that was added to the "frozen_total_cep" field in this mutation.
func (m *CostAccountMutation) AddedFrozenTotalCep() (r int64, exists bool) {
	v := m.addfrozen_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenTotalCep resets all changes to the "frozen_total_cep" field.
func (m *CostAccountMutation) ResetFrozenTotalCep() {
	m.frozen_total_cep = nil
	m.addfrozen_total_cep = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *CostAccountMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *CostAccountMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *CostAccountMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *CostAccountMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *CostAccountMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetSumPureCep sets the "sum_pure_cep" field.
func (m *CostAccountMutation) SetSumPureCep(i int64) {
	m.sum_pure_cep = &i
	m.addsum_pure_cep = nil
}

// SumPureCep returns the value of the "sum_pure_cep" field in the mutation.
func (m *CostAccountMutation) SumPureCep() (r int64, exists bool) {
	v := m.sum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumPureCep returns the old "sum_pure_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldSumPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumPureCep: %w", err)
	}
	return oldValue.SumPureCep, nil
}

// AddSumPureCep adds i to the "sum_pure_cep" field.
func (m *CostAccountMutation) AddSumPureCep(i int64) {
	if m.addsum_pure_cep != nil {
		*m.addsum_pure_cep += i
	} else {
		m.addsum_pure_cep = &i
	}
}

// AddedSumPureCep returns the value that was added to the "sum_pure_cep" field in this mutation.
func (m *CostAccountMutation) AddedSumPureCep() (r int64, exists bool) {
	v := m.addsum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumPureCep resets all changes to the "sum_pure_cep" field.
func (m *CostAccountMutation) ResetSumPureCep() {
	m.sum_pure_cep = nil
	m.addsum_pure_cep = nil
}

// SetFrozenPureCep sets the "frozen_pure_cep" field.
func (m *CostAccountMutation) SetFrozenPureCep(i int64) {
	m.frozen_pure_cep = &i
	m.addfrozen_pure_cep = nil
}

// FrozenPureCep returns the value of the "frozen_pure_cep" field in the mutation.
func (m *CostAccountMutation) FrozenPureCep() (r int64, exists bool) {
	v := m.frozen_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenPureCep returns the old "frozen_pure_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldFrozenPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenPureCep: %w", err)
	}
	return oldValue.FrozenPureCep, nil
}

// AddFrozenPureCep adds i to the "frozen_pure_cep" field.
func (m *CostAccountMutation) AddFrozenPureCep(i int64) {
	if m.addfrozen_pure_cep != nil {
		*m.addfrozen_pure_cep += i
	} else {
		m.addfrozen_pure_cep = &i
	}
}

// AddedFrozenPureCep returns the value that was added to the "frozen_pure_cep" field in this mutation.
func (m *CostAccountMutation) AddedFrozenPureCep() (r int64, exists bool) {
	v := m.addfrozen_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenPureCep resets all changes to the "frozen_pure_cep" field.
func (m *CostAccountMutation) ResetFrozenPureCep() {
	m.frozen_pure_cep = nil
	m.addfrozen_pure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *CostAccountMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *CostAccountMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *CostAccountMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *CostAccountMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *CostAccountMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetSumGiftCep sets the "sum_gift_cep" field.
func (m *CostAccountMutation) SetSumGiftCep(i int64) {
	m.sum_gift_cep = &i
	m.addsum_gift_cep = nil
}

// SumGiftCep returns the value of the "sum_gift_cep" field in the mutation.
func (m *CostAccountMutation) SumGiftCep() (r int64, exists bool) {
	v := m.sum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumGiftCep returns the old "sum_gift_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldSumGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumGiftCep: %w", err)
	}
	return oldValue.SumGiftCep, nil
}

// AddSumGiftCep adds i to the "sum_gift_cep" field.
func (m *CostAccountMutation) AddSumGiftCep(i int64) {
	if m.addsum_gift_cep != nil {
		*m.addsum_gift_cep += i
	} else {
		m.addsum_gift_cep = &i
	}
}

// AddedSumGiftCep returns the value that was added to the "sum_gift_cep" field in this mutation.
func (m *CostAccountMutation) AddedSumGiftCep() (r int64, exists bool) {
	v := m.addsum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumGiftCep resets all changes to the "sum_gift_cep" field.
func (m *CostAccountMutation) ResetSumGiftCep() {
	m.sum_gift_cep = nil
	m.addsum_gift_cep = nil
}

// SetFrozenGiftCep sets the "frozen_gift_cep" field.
func (m *CostAccountMutation) SetFrozenGiftCep(i int64) {
	m.frozen_gift_cep = &i
	m.addfrozen_gift_cep = nil
}

// FrozenGiftCep returns the value of the "frozen_gift_cep" field in the mutation.
func (m *CostAccountMutation) FrozenGiftCep() (r int64, exists bool) {
	v := m.frozen_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenGiftCep returns the old "frozen_gift_cep" field's value of the CostAccount entity.
// If the CostAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostAccountMutation) OldFrozenGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenGiftCep: %w", err)
	}
	return oldValue.FrozenGiftCep, nil
}

// AddFrozenGiftCep adds i to the "frozen_gift_cep" field.
func (m *CostAccountMutation) AddFrozenGiftCep(i int64) {
	if m.addfrozen_gift_cep != nil {
		*m.addfrozen_gift_cep += i
	} else {
		m.addfrozen_gift_cep = &i
	}
}

// AddedFrozenGiftCep returns the value that was added to the "frozen_gift_cep" field in this mutation.
func (m *CostAccountMutation) AddedFrozenGiftCep() (r int64, exists bool) {
	v := m.addfrozen_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenGiftCep resets all changes to the "frozen_gift_cep" field.
func (m *CostAccountMutation) ResetFrozenGiftCep() {
	m.frozen_gift_cep = nil
	m.addfrozen_gift_cep = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CostAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[costaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CostAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CostAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CostAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *CostAccountMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *CostAccountMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *CostAccountMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *CostAccountMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *CostAccountMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *CostAccountMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *CostAccountMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// Where appends a list predicates to the CostAccountMutation builder.
func (m *CostAccountMutation) Where(ps ...predicate.CostAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CostAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CostAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CostAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CostAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CostAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CostAccount).
func (m *CostAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostAccountMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, costaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, costaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, costaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, costaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, costaccount.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, costaccount.FieldUserID)
	}
	if m.total_cep != nil {
		fields = append(fields, costaccount.FieldTotalCep)
	}
	if m.sum_total_cep != nil {
		fields = append(fields, costaccount.FieldSumTotalCep)
	}
	if m.frozen_total_cep != nil {
		fields = append(fields, costaccount.FieldFrozenTotalCep)
	}
	if m.pure_cep != nil {
		fields = append(fields, costaccount.FieldPureCep)
	}
	if m.sum_pure_cep != nil {
		fields = append(fields, costaccount.FieldSumPureCep)
	}
	if m.frozen_pure_cep != nil {
		fields = append(fields, costaccount.FieldFrozenPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, costaccount.FieldGiftCep)
	}
	if m.sum_gift_cep != nil {
		fields = append(fields, costaccount.FieldSumGiftCep)
	}
	if m.frozen_gift_cep != nil {
		fields = append(fields, costaccount.FieldFrozenGiftCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case costaccount.FieldCreatedBy:
		return m.CreatedBy()
	case costaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case costaccount.FieldCreatedAt:
		return m.CreatedAt()
	case costaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case costaccount.FieldDeletedAt:
		return m.DeletedAt()
	case costaccount.FieldUserID:
		return m.UserID()
	case costaccount.FieldTotalCep:
		return m.TotalCep()
	case costaccount.FieldSumTotalCep:
		return m.SumTotalCep()
	case costaccount.FieldFrozenTotalCep:
		return m.FrozenTotalCep()
	case costaccount.FieldPureCep:
		return m.PureCep()
	case costaccount.FieldSumPureCep:
		return m.SumPureCep()
	case costaccount.FieldFrozenPureCep:
		return m.FrozenPureCep()
	case costaccount.FieldGiftCep:
		return m.GiftCep()
	case costaccount.FieldSumGiftCep:
		return m.SumGiftCep()
	case costaccount.FieldFrozenGiftCep:
		return m.FrozenGiftCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case costaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case costaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case costaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case costaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case costaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case costaccount.FieldUserID:
		return m.OldUserID(ctx)
	case costaccount.FieldTotalCep:
		return m.OldTotalCep(ctx)
	case costaccount.FieldSumTotalCep:
		return m.OldSumTotalCep(ctx)
	case costaccount.FieldFrozenTotalCep:
		return m.OldFrozenTotalCep(ctx)
	case costaccount.FieldPureCep:
		return m.OldPureCep(ctx)
	case costaccount.FieldSumPureCep:
		return m.OldSumPureCep(ctx)
	case costaccount.FieldFrozenPureCep:
		return m.OldFrozenPureCep(ctx)
	case costaccount.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case costaccount.FieldSumGiftCep:
		return m.OldSumGiftCep(ctx)
	case costaccount.FieldFrozenGiftCep:
		return m.OldFrozenGiftCep(ctx)
	}
	return nil, fmt.Errorf("unknown CostAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case costaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case costaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case costaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case costaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case costaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case costaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case costaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCep(v)
		return nil
	case costaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumTotalCep(v)
		return nil
	case costaccount.FieldFrozenTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenTotalCep(v)
		return nil
	case costaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case costaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumPureCep(v)
		return nil
	case costaccount.FieldFrozenPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenPureCep(v)
		return nil
	case costaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case costaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumGiftCep(v)
		return nil
	case costaccount.FieldFrozenGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown CostAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, costaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, costaccount.FieldUpdatedBy)
	}
	if m.addtotal_cep != nil {
		fields = append(fields, costaccount.FieldTotalCep)
	}
	if m.addsum_total_cep != nil {
		fields = append(fields, costaccount.FieldSumTotalCep)
	}
	if m.addfrozen_total_cep != nil {
		fields = append(fields, costaccount.FieldFrozenTotalCep)
	}
	if m.addpure_cep != nil {
		fields = append(fields, costaccount.FieldPureCep)
	}
	if m.addsum_pure_cep != nil {
		fields = append(fields, costaccount.FieldSumPureCep)
	}
	if m.addfrozen_pure_cep != nil {
		fields = append(fields, costaccount.FieldFrozenPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, costaccount.FieldGiftCep)
	}
	if m.addsum_gift_cep != nil {
		fields = append(fields, costaccount.FieldSumGiftCep)
	}
	if m.addfrozen_gift_cep != nil {
		fields = append(fields, costaccount.FieldFrozenGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case costaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case costaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case costaccount.FieldTotalCep:
		return m.AddedTotalCep()
	case costaccount.FieldSumTotalCep:
		return m.AddedSumTotalCep()
	case costaccount.FieldFrozenTotalCep:
		return m.AddedFrozenTotalCep()
	case costaccount.FieldPureCep:
		return m.AddedPureCep()
	case costaccount.FieldSumPureCep:
		return m.AddedSumPureCep()
	case costaccount.FieldFrozenPureCep:
		return m.AddedFrozenPureCep()
	case costaccount.FieldGiftCep:
		return m.AddedGiftCep()
	case costaccount.FieldSumGiftCep:
		return m.AddedSumGiftCep()
	case costaccount.FieldFrozenGiftCep:
		return m.AddedFrozenGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case costaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case costaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case costaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCep(v)
		return nil
	case costaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumTotalCep(v)
		return nil
	case costaccount.FieldFrozenTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenTotalCep(v)
		return nil
	case costaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case costaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumPureCep(v)
		return nil
	case costaccount.FieldFrozenPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenPureCep(v)
		return nil
	case costaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case costaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumGiftCep(v)
		return nil
	case costaccount.FieldFrozenGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown CostAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CostAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostAccountMutation) ResetField(name string) error {
	switch name {
	case costaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case costaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case costaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case costaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case costaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case costaccount.FieldUserID:
		m.ResetUserID()
		return nil
	case costaccount.FieldTotalCep:
		m.ResetTotalCep()
		return nil
	case costaccount.FieldSumTotalCep:
		m.ResetSumTotalCep()
		return nil
	case costaccount.FieldFrozenTotalCep:
		m.ResetFrozenTotalCep()
		return nil
	case costaccount.FieldPureCep:
		m.ResetPureCep()
		return nil
	case costaccount.FieldSumPureCep:
		m.ResetSumPureCep()
		return nil
	case costaccount.FieldFrozenPureCep:
		m.ResetFrozenPureCep()
		return nil
	case costaccount.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case costaccount.FieldSumGiftCep:
		m.ResetSumGiftCep()
		return nil
	case costaccount.FieldFrozenGiftCep:
		m.ResetFrozenGiftCep()
		return nil
	}
	return fmt.Errorf("unknown CostAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, costaccount.EdgeUser)
	}
	if m.cost_bills != nil {
		edges = append(edges, costaccount.EdgeCostBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case costaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case costaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcost_bills != nil {
		edges = append(edges, costaccount.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case costaccount.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, costaccount.EdgeUser)
	}
	if m.clearedcost_bills {
		edges = append(edges, costaccount.EdgeCostBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case costaccount.EdgeUser:
		return m.cleareduser
	case costaccount.EdgeCostBills:
		return m.clearedcost_bills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostAccountMutation) ClearEdge(name string) error {
	switch name {
	case costaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CostAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostAccountMutation) ResetEdge(name string) error {
	switch name {
	case costaccount.EdgeUser:
		m.ResetUser()
		return nil
	case costaccount.EdgeCostBills:
		m.ResetCostBills()
		return nil
	}
	return fmt.Errorf("unknown CostAccount edge %s", name)
}

// CostBillMutation represents an operation that mutates the CostBill nodes in the graph.
type CostBillMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_by                   *int64
	addcreated_by                *int64
	updated_by                   *int64
	addupdated_by                *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	_type                        *costbill.Type
	is_add                       *bool
	serial_number                *string
	pure_cep                     *int64
	addpure_cep                  *int64
	gift_cep                     *int64
	addgift_cep                  *int64
	status                       *enums.BillStatus
	market_bill_id               *int64
	addmarket_bill_id            *int64
	clearedFields                map[string]struct{}
	user                         *int64
	cleareduser                  bool
	cost_account                 *int64
	clearedcost_account          bool
	recharge_order               *int64
	clearedrecharge_order        bool
	mission_consume_order        *int64
	clearedmission_consume_order bool
	done                         bool
	oldValue                     func(context.Context) (*CostBill, error)
	predicates                   []predicate.CostBill
}

var _ ent.Mutation = (*CostBillMutation)(nil)

// costbillOption allows management of the mutation configuration using functional options.
type costbillOption func(*CostBillMutation)

// newCostBillMutation creates new mutation for the CostBill entity.
func newCostBillMutation(c config, op Op, opts ...costbillOption) *CostBillMutation {
	m := &CostBillMutation{
		config:        c,
		op:            op,
		typ:           TypeCostBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostBillID sets the ID field of the mutation.
func withCostBillID(id int64) costbillOption {
	return func(m *CostBillMutation) {
		var (
			err   error
			once  sync.Once
			value *CostBill
		)
		m.oldValue = func(ctx context.Context) (*CostBill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CostBill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCostBill sets the old CostBill of the mutation.
func withCostBill(node *CostBill) costbillOption {
	return func(m *CostBillMutation) {
		m.oldValue = func(context.Context) (*CostBill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostBillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostBillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CostBill entities.
func (m *CostBillMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostBillMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CostBillMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CostBill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *CostBillMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CostBillMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *CostBillMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *CostBillMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CostBillMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CostBillMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CostBillMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CostBillMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CostBillMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CostBillMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CostBillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CostBillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CostBillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CostBillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CostBillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CostBillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CostBillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CostBillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CostBillMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *CostBillMutation) SetType(c costbill.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CostBillMutation) GetType() (r costbill.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldType(ctx context.Context) (v costbill.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CostBillMutation) ResetType() {
	m._type = nil
}

// SetIsAdd sets the "is_add" field.
func (m *CostBillMutation) SetIsAdd(b bool) {
	m.is_add = &b
}

// IsAdd returns the value of the "is_add" field in the mutation.
func (m *CostBillMutation) IsAdd() (r bool, exists bool) {
	v := m.is_add
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdd returns the old "is_add" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldIsAdd(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdd: %w", err)
	}
	return oldValue.IsAdd, nil
}

// ResetIsAdd resets all changes to the "is_add" field.
func (m *CostBillMutation) ResetIsAdd() {
	m.is_add = nil
}

// SetUserID sets the "user_id" field.
func (m *CostBillMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CostBillMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CostBillMutation) ResetUserID() {
	m.user = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *CostBillMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *CostBillMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *CostBillMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetCostAccountID sets the "cost_account_id" field.
func (m *CostBillMutation) SetCostAccountID(i int64) {
	m.cost_account = &i
}

// CostAccountID returns the value of the "cost_account_id" field in the mutation.
func (m *CostBillMutation) CostAccountID() (r int64, exists bool) {
	v := m.cost_account
	if v == nil {
		return
	}
	return *v, true
}

// OldCostAccountID returns the old "cost_account_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldCostAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostAccountID: %w", err)
	}
	return oldValue.CostAccountID, nil
}

// ResetCostAccountID resets all changes to the "cost_account_id" field.
func (m *CostBillMutation) ResetCostAccountID() {
	m.cost_account = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *CostBillMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *CostBillMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *CostBillMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *CostBillMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *CostBillMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *CostBillMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *CostBillMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *CostBillMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *CostBillMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *CostBillMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetReasonID sets the "reason_id" field.
func (m *CostBillMutation) SetReasonID(i int64) {
	m.recharge_order = &i
}

// ReasonID returns the value of the "reason_id" field in the mutation.
func (m *CostBillMutation) ReasonID() (r int64, exists bool) {
	v := m.recharge_order
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonID returns the old "reason_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldReasonID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonID: %w", err)
	}
	return oldValue.ReasonID, nil
}

// ClearReasonID clears the value of the "reason_id" field.
func (m *CostBillMutation) ClearReasonID() {
	m.recharge_order = nil
	m.clearedFields[costbill.FieldReasonID] = struct{}{}
}

// ReasonIDCleared returns if the "reason_id" field was cleared in this mutation.
func (m *CostBillMutation) ReasonIDCleared() bool {
	_, ok := m.clearedFields[costbill.FieldReasonID]
	return ok
}

// ResetReasonID resets all changes to the "reason_id" field.
func (m *CostBillMutation) ResetReasonID() {
	m.recharge_order = nil
	delete(m.clearedFields, costbill.FieldReasonID)
}

// SetStatus sets the "status" field.
func (m *CostBillMutation) SetStatus(es enums.BillStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *CostBillMutation) Status() (r enums.BillStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldStatus(ctx context.Context) (v enums.BillStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CostBillMutation) ResetStatus() {
	m.status = nil
}

// SetMarketBillID sets the "market_bill_id" field.
func (m *CostBillMutation) SetMarketBillID(i int64) {
	m.market_bill_id = &i
	m.addmarket_bill_id = nil
}

// MarketBillID returns the value of the "market_bill_id" field in the mutation.
func (m *CostBillMutation) MarketBillID() (r int64, exists bool) {
	v := m.market_bill_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketBillID returns the old "market_bill_id" field's value of the CostBill entity.
// If the CostBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostBillMutation) OldMarketBillID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketBillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketBillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketBillID: %w", err)
	}
	return oldValue.MarketBillID, nil
}

// AddMarketBillID adds i to the "market_bill_id" field.
func (m *CostBillMutation) AddMarketBillID(i int64) {
	if m.addmarket_bill_id != nil {
		*m.addmarket_bill_id += i
	} else {
		m.addmarket_bill_id = &i
	}
}

// AddedMarketBillID returns the value that was added to the "market_bill_id" field in this mutation.
func (m *CostBillMutation) AddedMarketBillID() (r int64, exists bool) {
	v := m.addmarket_bill_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMarketBillID resets all changes to the "market_bill_id" field.
func (m *CostBillMutation) ResetMarketBillID() {
	m.market_bill_id = nil
	m.addmarket_bill_id = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CostBillMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[costbill.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CostBillMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CostBillMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCostAccount clears the "cost_account" edge to the CostAccount entity.
func (m *CostBillMutation) ClearCostAccount() {
	m.clearedcost_account = true
	m.clearedFields[costbill.FieldCostAccountID] = struct{}{}
}

// CostAccountCleared reports if the "cost_account" edge to the CostAccount entity was cleared.
func (m *CostBillMutation) CostAccountCleared() bool {
	return m.clearedcost_account
}

// CostAccountIDs returns the "cost_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CostAccountID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) CostAccountIDs() (ids []int64) {
	if id := m.cost_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCostAccount resets all changes to the "cost_account" edge.
func (m *CostBillMutation) ResetCostAccount() {
	m.cost_account = nil
	m.clearedcost_account = false
}

// SetRechargeOrderID sets the "recharge_order" edge to the RechargeOrder entity by id.
func (m *CostBillMutation) SetRechargeOrderID(id int64) {
	m.recharge_order = &id
}

// ClearRechargeOrder clears the "recharge_order" edge to the RechargeOrder entity.
func (m *CostBillMutation) ClearRechargeOrder() {
	m.clearedrecharge_order = true
	m.clearedFields[costbill.FieldReasonID] = struct{}{}
}

// RechargeOrderCleared reports if the "recharge_order" edge to the RechargeOrder entity was cleared.
func (m *CostBillMutation) RechargeOrderCleared() bool {
	return m.ReasonIDCleared() || m.clearedrecharge_order
}

// RechargeOrderID returns the "recharge_order" edge ID in the mutation.
func (m *CostBillMutation) RechargeOrderID() (id int64, exists bool) {
	if m.recharge_order != nil {
		return *m.recharge_order, true
	}
	return
}

// RechargeOrderIDs returns the "recharge_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RechargeOrderID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) RechargeOrderIDs() (ids []int64) {
	if id := m.recharge_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRechargeOrder resets all changes to the "recharge_order" edge.
func (m *CostBillMutation) ResetRechargeOrder() {
	m.recharge_order = nil
	m.clearedrecharge_order = false
}

// SetMissionConsumeOrderID sets the "mission_consume_order" edge to the MissionConsumeOrder entity by id.
func (m *CostBillMutation) SetMissionConsumeOrderID(id int64) {
	m.mission_consume_order = &id
}

// ClearMissionConsumeOrder clears the "mission_consume_order" edge to the MissionConsumeOrder entity.
func (m *CostBillMutation) ClearMissionConsumeOrder() {
	m.clearedmission_consume_order = true
	m.clearedFields[costbill.FieldReasonID] = struct{}{}
}

// MissionConsumeOrderCleared reports if the "mission_consume_order" edge to the MissionConsumeOrder entity was cleared.
func (m *CostBillMutation) MissionConsumeOrderCleared() bool {
	return m.ReasonIDCleared() || m.clearedmission_consume_order
}

// MissionConsumeOrderID returns the "mission_consume_order" edge ID in the mutation.
func (m *CostBillMutation) MissionConsumeOrderID() (id int64, exists bool) {
	if m.mission_consume_order != nil {
		return *m.mission_consume_order, true
	}
	return
}

// MissionConsumeOrderIDs returns the "mission_consume_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionConsumeOrderID instead. It exists only for internal usage by the builders.
func (m *CostBillMutation) MissionConsumeOrderIDs() (ids []int64) {
	if id := m.mission_consume_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionConsumeOrder resets all changes to the "mission_consume_order" edge.
func (m *CostBillMutation) ResetMissionConsumeOrder() {
	m.mission_consume_order = nil
	m.clearedmission_consume_order = false
}

// Where appends a list predicates to the CostBillMutation builder.
func (m *CostBillMutation) Where(ps ...predicate.CostBill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CostBillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CostBillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CostBill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CostBillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CostBillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CostBill).
func (m *CostBillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostBillMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, costbill.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, costbill.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, costbill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, costbill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, costbill.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, costbill.FieldType)
	}
	if m.is_add != nil {
		fields = append(fields, costbill.FieldIsAdd)
	}
	if m.user != nil {
		fields = append(fields, costbill.FieldUserID)
	}
	if m.serial_number != nil {
		fields = append(fields, costbill.FieldSerialNumber)
	}
	if m.cost_account != nil {
		fields = append(fields, costbill.FieldCostAccountID)
	}
	if m.pure_cep != nil {
		fields = append(fields, costbill.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, costbill.FieldGiftCep)
	}
	if m.recharge_order != nil {
		fields = append(fields, costbill.FieldReasonID)
	}
	if m.status != nil {
		fields = append(fields, costbill.FieldStatus)
	}
	if m.market_bill_id != nil {
		fields = append(fields, costbill.FieldMarketBillID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostBillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case costbill.FieldCreatedBy:
		return m.CreatedBy()
	case costbill.FieldUpdatedBy:
		return m.UpdatedBy()
	case costbill.FieldCreatedAt:
		return m.CreatedAt()
	case costbill.FieldUpdatedAt:
		return m.UpdatedAt()
	case costbill.FieldDeletedAt:
		return m.DeletedAt()
	case costbill.FieldType:
		return m.GetType()
	case costbill.FieldIsAdd:
		return m.IsAdd()
	case costbill.FieldUserID:
		return m.UserID()
	case costbill.FieldSerialNumber:
		return m.SerialNumber()
	case costbill.FieldCostAccountID:
		return m.CostAccountID()
	case costbill.FieldPureCep:
		return m.PureCep()
	case costbill.FieldGiftCep:
		return m.GiftCep()
	case costbill.FieldReasonID:
		return m.ReasonID()
	case costbill.FieldStatus:
		return m.Status()
	case costbill.FieldMarketBillID:
		return m.MarketBillID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostBillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case costbill.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case costbill.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case costbill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case costbill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case costbill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case costbill.FieldType:
		return m.OldType(ctx)
	case costbill.FieldIsAdd:
		return m.OldIsAdd(ctx)
	case costbill.FieldUserID:
		return m.OldUserID(ctx)
	case costbill.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case costbill.FieldCostAccountID:
		return m.OldCostAccountID(ctx)
	case costbill.FieldPureCep:
		return m.OldPureCep(ctx)
	case costbill.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case costbill.FieldReasonID:
		return m.OldReasonID(ctx)
	case costbill.FieldStatus:
		return m.OldStatus(ctx)
	case costbill.FieldMarketBillID:
		return m.OldMarketBillID(ctx)
	}
	return nil, fmt.Errorf("unknown CostBill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostBillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case costbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case costbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case costbill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case costbill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case costbill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case costbill.FieldType:
		v, ok := value.(costbill.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case costbill.FieldIsAdd:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdd(v)
		return nil
	case costbill.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case costbill.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case costbill.FieldCostAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostAccountID(v)
		return nil
	case costbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case costbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case costbill.FieldReasonID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonID(v)
		return nil
	case costbill.FieldStatus:
		v, ok := value.(enums.BillStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case costbill.FieldMarketBillID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketBillID(v)
		return nil
	}
	return fmt.Errorf("unknown CostBill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostBillMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, costbill.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, costbill.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, costbill.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, costbill.FieldGiftCep)
	}
	if m.addmarket_bill_id != nil {
		fields = append(fields, costbill.FieldMarketBillID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostBillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case costbill.FieldCreatedBy:
		return m.AddedCreatedBy()
	case costbill.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case costbill.FieldPureCep:
		return m.AddedPureCep()
	case costbill.FieldGiftCep:
		return m.AddedGiftCep()
	case costbill.FieldMarketBillID:
		return m.AddedMarketBillID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostBillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case costbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case costbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case costbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case costbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case costbill.FieldMarketBillID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMarketBillID(v)
		return nil
	}
	return fmt.Errorf("unknown CostBill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostBillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(costbill.FieldReasonID) {
		fields = append(fields, costbill.FieldReasonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostBillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostBillMutation) ClearField(name string) error {
	switch name {
	case costbill.FieldReasonID:
		m.ClearReasonID()
		return nil
	}
	return fmt.Errorf("unknown CostBill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostBillMutation) ResetField(name string) error {
	switch name {
	case costbill.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case costbill.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case costbill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case costbill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case costbill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case costbill.FieldType:
		m.ResetType()
		return nil
	case costbill.FieldIsAdd:
		m.ResetIsAdd()
		return nil
	case costbill.FieldUserID:
		m.ResetUserID()
		return nil
	case costbill.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case costbill.FieldCostAccountID:
		m.ResetCostAccountID()
		return nil
	case costbill.FieldPureCep:
		m.ResetPureCep()
		return nil
	case costbill.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case costbill.FieldReasonID:
		m.ResetReasonID()
		return nil
	case costbill.FieldStatus:
		m.ResetStatus()
		return nil
	case costbill.FieldMarketBillID:
		m.ResetMarketBillID()
		return nil
	}
	return fmt.Errorf("unknown CostBill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostBillMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, costbill.EdgeUser)
	}
	if m.cost_account != nil {
		edges = append(edges, costbill.EdgeCostAccount)
	}
	if m.recharge_order != nil {
		edges = append(edges, costbill.EdgeRechargeOrder)
	}
	if m.mission_consume_order != nil {
		edges = append(edges, costbill.EdgeMissionConsumeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostBillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case costbill.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeCostAccount:
		if id := m.cost_account; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeRechargeOrder:
		if id := m.recharge_order; id != nil {
			return []ent.Value{*id}
		}
	case costbill.EdgeMissionConsumeOrder:
		if id := m.mission_consume_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostBillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostBillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostBillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, costbill.EdgeUser)
	}
	if m.clearedcost_account {
		edges = append(edges, costbill.EdgeCostAccount)
	}
	if m.clearedrecharge_order {
		edges = append(edges, costbill.EdgeRechargeOrder)
	}
	if m.clearedmission_consume_order {
		edges = append(edges, costbill.EdgeMissionConsumeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostBillMutation) EdgeCleared(name string) bool {
	switch name {
	case costbill.EdgeUser:
		return m.cleareduser
	case costbill.EdgeCostAccount:
		return m.clearedcost_account
	case costbill.EdgeRechargeOrder:
		return m.clearedrecharge_order
	case costbill.EdgeMissionConsumeOrder:
		return m.clearedmission_consume_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostBillMutation) ClearEdge(name string) error {
	switch name {
	case costbill.EdgeUser:
		m.ClearUser()
		return nil
	case costbill.EdgeCostAccount:
		m.ClearCostAccount()
		return nil
	case costbill.EdgeRechargeOrder:
		m.ClearRechargeOrder()
		return nil
	case costbill.EdgeMissionConsumeOrder:
		m.ClearMissionConsumeOrder()
		return nil
	}
	return fmt.Errorf("unknown CostBill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostBillMutation) ResetEdge(name string) error {
	switch name {
	case costbill.EdgeUser:
		m.ResetUser()
		return nil
	case costbill.EdgeCostAccount:
		m.ResetCostAccount()
		return nil
	case costbill.EdgeRechargeOrder:
		m.ResetRechargeOrder()
		return nil
	case costbill.EdgeMissionConsumeOrder:
		m.ResetMissionConsumeOrder()
		return nil
	}
	return fmt.Errorf("unknown CostBill edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	serial_number                 *string
	state                         *device.State
	sum_cep                       *int64
	addsum_cep                    *int64
	linking                       *bool
	binding_status                *enums.DeviceBindingStatus
	status                        *device.Status
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	mission_produce_orders        map[int64]struct{}
	removedmission_produce_orders map[int64]struct{}
	clearedmission_produce_orders bool
	user_devices                  map[int64]struct{}
	removeduser_devices           map[int64]struct{}
	cleareduser_devices           bool
	device_gpu_missions           map[int64]struct{}
	removeddevice_gpu_missions    map[int64]struct{}
	cleareddevice_gpu_missions    bool
	done                          bool
	oldValue                      func(context.Context) (*Device, error)
	predicates                    []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int64) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeviceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeviceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeviceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeviceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *DeviceMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceMutation) ResetUserID() {
	m.user = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *DeviceMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *DeviceMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *DeviceMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetState sets the "state" field.
func (m *DeviceMutation) SetState(d device.State) {
	m.state = &d
}

// State returns the value of the "state" field in the mutation.
func (m *DeviceMutation) State() (r device.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldState(ctx context.Context) (v device.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *DeviceMutation) ResetState() {
	m.state = nil
}

// SetSumCep sets the "sum_cep" field.
func (m *DeviceMutation) SetSumCep(i int64) {
	m.sum_cep = &i
	m.addsum_cep = nil
}

// SumCep returns the value of the "sum_cep" field in the mutation.
func (m *DeviceMutation) SumCep() (r int64, exists bool) {
	v := m.sum_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumCep returns the old "sum_cep" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSumCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumCep: %w", err)
	}
	return oldValue.SumCep, nil
}

// AddSumCep adds i to the "sum_cep" field.
func (m *DeviceMutation) AddSumCep(i int64) {
	if m.addsum_cep != nil {
		*m.addsum_cep += i
	} else {
		m.addsum_cep = &i
	}
}

// AddedSumCep returns the value that was added to the "sum_cep" field in this mutation.
func (m *DeviceMutation) AddedSumCep() (r int64, exists bool) {
	v := m.addsum_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumCep resets all changes to the "sum_cep" field.
func (m *DeviceMutation) ResetSumCep() {
	m.sum_cep = nil
	m.addsum_cep = nil
}

// SetLinking sets the "linking" field.
func (m *DeviceMutation) SetLinking(b bool) {
	m.linking = &b
}

// Linking returns the value of the "linking" field in the mutation.
func (m *DeviceMutation) Linking() (r bool, exists bool) {
	v := m.linking
	if v == nil {
		return
	}
	return *v, true
}

// OldLinking returns the old "linking" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldLinking(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinking: %w", err)
	}
	return oldValue.Linking, nil
}

// ResetLinking resets all changes to the "linking" field.
func (m *DeviceMutation) ResetLinking() {
	m.linking = nil
}

// SetBindingStatus sets the "binding_status" field.
func (m *DeviceMutation) SetBindingStatus(ebs enums.DeviceBindingStatus) {
	m.binding_status = &ebs
}

// BindingStatus returns the value of the "binding_status" field in the mutation.
func (m *DeviceMutation) BindingStatus() (r enums.DeviceBindingStatus, exists bool) {
	v := m.binding_status
	if v == nil {
		return
	}
	return *v, true
}

// OldBindingStatus returns the old "binding_status" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldBindingStatus(ctx context.Context) (v enums.DeviceBindingStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindingStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindingStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindingStatus: %w", err)
	}
	return oldValue.BindingStatus, nil
}

// ResetBindingStatus resets all changes to the "binding_status" field.
func (m *DeviceMutation) ResetBindingStatus() {
	m.binding_status = nil
}

// SetStatus sets the "status" field.
func (m *DeviceMutation) SetStatus(d device.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DeviceMutation) Status() (r device.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldStatus(ctx context.Context) (v device.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DeviceMutation) ResetStatus() {
	m.status = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[device.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *DeviceMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *DeviceMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *DeviceMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *DeviceMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *DeviceMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *DeviceMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *DeviceMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// AddUserDeviceIDs adds the "user_devices" edge to the UserDevice entity by ids.
func (m *DeviceMutation) AddUserDeviceIDs(ids ...int64) {
	if m.user_devices == nil {
		m.user_devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_devices[ids[i]] = struct{}{}
	}
}

// ClearUserDevices clears the "user_devices" edge to the UserDevice entity.
func (m *DeviceMutation) ClearUserDevices() {
	m.cleareduser_devices = true
}

// UserDevicesCleared reports if the "user_devices" edge to the UserDevice entity was cleared.
func (m *DeviceMutation) UserDevicesCleared() bool {
	return m.cleareduser_devices
}

// RemoveUserDeviceIDs removes the "user_devices" edge to the UserDevice entity by IDs.
func (m *DeviceMutation) RemoveUserDeviceIDs(ids ...int64) {
	if m.removeduser_devices == nil {
		m.removeduser_devices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_devices, ids[i])
		m.removeduser_devices[ids[i]] = struct{}{}
	}
}

// RemovedUserDevices returns the removed IDs of the "user_devices" edge to the UserDevice entity.
func (m *DeviceMutation) RemovedUserDevicesIDs() (ids []int64) {
	for id := range m.removeduser_devices {
		ids = append(ids, id)
	}
	return
}

// UserDevicesIDs returns the "user_devices" edge IDs in the mutation.
func (m *DeviceMutation) UserDevicesIDs() (ids []int64) {
	for id := range m.user_devices {
		ids = append(ids, id)
	}
	return
}

// ResetUserDevices resets all changes to the "user_devices" edge.
func (m *DeviceMutation) ResetUserDevices() {
	m.user_devices = nil
	m.cleareduser_devices = false
	m.removeduser_devices = nil
}

// AddDeviceGpuMissionIDs adds the "device_gpu_missions" edge to the DeviceGpuMission entity by ids.
func (m *DeviceMutation) AddDeviceGpuMissionIDs(ids ...int64) {
	if m.device_gpu_missions == nil {
		m.device_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_gpu_missions[ids[i]] = struct{}{}
	}
}

// ClearDeviceGpuMissions clears the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *DeviceMutation) ClearDeviceGpuMissions() {
	m.cleareddevice_gpu_missions = true
}

// DeviceGpuMissionsCleared reports if the "device_gpu_missions" edge to the DeviceGpuMission entity was cleared.
func (m *DeviceMutation) DeviceGpuMissionsCleared() bool {
	return m.cleareddevice_gpu_missions
}

// RemoveDeviceGpuMissionIDs removes the "device_gpu_missions" edge to the DeviceGpuMission entity by IDs.
func (m *DeviceMutation) RemoveDeviceGpuMissionIDs(ids ...int64) {
	if m.removeddevice_gpu_missions == nil {
		m.removeddevice_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_gpu_missions, ids[i])
		m.removeddevice_gpu_missions[ids[i]] = struct{}{}
	}
}

// RemovedDeviceGpuMissions returns the removed IDs of the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *DeviceMutation) RemovedDeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.removeddevice_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// DeviceGpuMissionsIDs returns the "device_gpu_missions" edge IDs in the mutation.
func (m *DeviceMutation) DeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.device_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceGpuMissions resets all changes to the "device_gpu_missions" edge.
func (m *DeviceMutation) ResetDeviceGpuMissions() {
	m.device_gpu_missions = nil
	m.cleareddevice_gpu_missions = false
	m.removeddevice_gpu_missions = nil
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, device.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, device.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, device.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, device.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, device.FieldUserID)
	}
	if m.serial_number != nil {
		fields = append(fields, device.FieldSerialNumber)
	}
	if m.state != nil {
		fields = append(fields, device.FieldState)
	}
	if m.sum_cep != nil {
		fields = append(fields, device.FieldSumCep)
	}
	if m.linking != nil {
		fields = append(fields, device.FieldLinking)
	}
	if m.binding_status != nil {
		fields = append(fields, device.FieldBindingStatus)
	}
	if m.status != nil {
		fields = append(fields, device.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedBy:
		return m.CreatedBy()
	case device.FieldUpdatedBy:
		return m.UpdatedBy()
	case device.FieldCreatedAt:
		return m.CreatedAt()
	case device.FieldUpdatedAt:
		return m.UpdatedAt()
	case device.FieldDeletedAt:
		return m.DeletedAt()
	case device.FieldUserID:
		return m.UserID()
	case device.FieldSerialNumber:
		return m.SerialNumber()
	case device.FieldState:
		return m.State()
	case device.FieldSumCep:
		return m.SumCep()
	case device.FieldLinking:
		return m.Linking()
	case device.FieldBindingStatus:
		return m.BindingStatus()
	case device.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case device.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case device.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case device.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case device.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case device.FieldUserID:
		return m.OldUserID(ctx)
	case device.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case device.FieldState:
		return m.OldState(ctx)
	case device.FieldSumCep:
		return m.OldSumCep(ctx)
	case device.FieldLinking:
		return m.OldLinking(ctx)
	case device.FieldBindingStatus:
		return m.OldBindingStatus(ctx)
	case device.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case device.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case device.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case device.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case device.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case device.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case device.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case device.FieldState:
		v, ok := value.(device.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case device.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumCep(v)
		return nil
	case device.FieldLinking:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinking(v)
		return nil
	case device.FieldBindingStatus:
		v, ok := value.(enums.DeviceBindingStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindingStatus(v)
		return nil
	case device.FieldStatus:
		v, ok := value.(device.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, device.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, device.FieldUpdatedBy)
	}
	if m.addsum_cep != nil {
		fields = append(fields, device.FieldSumCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedBy:
		return m.AddedCreatedBy()
	case device.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case device.FieldSumCep:
		return m.AddedSumCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case device.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case device.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumCep(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case device.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case device.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case device.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case device.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case device.FieldUserID:
		m.ResetUserID()
		return nil
	case device.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case device.FieldState:
		m.ResetState()
		return nil
	case device.FieldSumCep:
		m.ResetSumCep()
		return nil
	case device.FieldLinking:
		m.ResetLinking()
		return nil
	case device.FieldBindingStatus:
		m.ResetBindingStatus()
		return nil
	case device.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, device.EdgeUser)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, device.EdgeMissionProduceOrders)
	}
	if m.user_devices != nil {
		edges = append(edges, device.EdgeUserDevices)
	}
	if m.device_gpu_missions != nil {
		edges = append(edges, device.EdgeDeviceGpuMissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.user_devices))
		for id := range m.user_devices {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.device_gpu_missions))
		for id := range m.device_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmission_produce_orders != nil {
		edges = append(edges, device.EdgeMissionProduceOrders)
	}
	if m.removeduser_devices != nil {
		edges = append(edges, device.EdgeUserDevices)
	}
	if m.removeddevice_gpu_missions != nil {
		edges = append(edges, device.EdgeDeviceGpuMissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.removeduser_devices))
		for id := range m.removeduser_devices {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.removeddevice_gpu_missions))
		for id := range m.removeddevice_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, device.EdgeUser)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, device.EdgeMissionProduceOrders)
	}
	if m.cleareduser_devices {
		edges = append(edges, device.EdgeUserDevices)
	}
	if m.cleareddevice_gpu_missions {
		edges = append(edges, device.EdgeDeviceGpuMissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeUser:
		return m.cleareduser
	case device.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case device.EdgeUserDevices:
		return m.cleareduser_devices
	case device.EdgeDeviceGpuMissions:
		return m.cleareddevice_gpu_missions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ResetUser()
		return nil
	case device.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case device.EdgeUserDevices:
		m.ResetUserDevices()
		return nil
	case device.EdgeDeviceGpuMissions:
		m.ResetDeviceGpuMissions()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DeviceGpuMissionMutation represents an operation that mutates the DeviceGpuMission nodes in the graph.
type DeviceGpuMissionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_by          *int64
	addcreated_by       *int64
	updated_by          *int64
	addupdated_by       *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	device              *int64
	cleareddevice       bool
	mission_kind        *int64
	clearedmission_kind bool
	gpu                 *int64
	clearedgpu          bool
	done                bool
	oldValue            func(context.Context) (*DeviceGpuMission, error)
	predicates          []predicate.DeviceGpuMission
}

var _ ent.Mutation = (*DeviceGpuMissionMutation)(nil)

// devicegpumissionOption allows management of the mutation configuration using functional options.
type devicegpumissionOption func(*DeviceGpuMissionMutation)

// newDeviceGpuMissionMutation creates new mutation for the DeviceGpuMission entity.
func newDeviceGpuMissionMutation(c config, op Op, opts ...devicegpumissionOption) *DeviceGpuMissionMutation {
	m := &DeviceGpuMissionMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceGpuMission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceGpuMissionID sets the ID field of the mutation.
func withDeviceGpuMissionID(id int64) devicegpumissionOption {
	return func(m *DeviceGpuMissionMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceGpuMission
		)
		m.oldValue = func(ctx context.Context) (*DeviceGpuMission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceGpuMission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceGpuMission sets the old DeviceGpuMission of the mutation.
func withDeviceGpuMission(node *DeviceGpuMission) devicegpumissionOption {
	return func(m *DeviceGpuMissionMutation) {
		m.oldValue = func(context.Context) (*DeviceGpuMission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceGpuMissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceGpuMissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceGpuMission entities.
func (m *DeviceGpuMissionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceGpuMissionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceGpuMissionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceGpuMission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceGpuMissionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceGpuMissionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeviceGpuMissionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceGpuMissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceGpuMissionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceGpuMissionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeviceGpuMissionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeviceGpuMissionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceGpuMissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceGpuMissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceGpuMissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceGpuMissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceGpuMissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceGpuMissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceGpuMissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceGpuMissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceGpuMissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceGpuMissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceGpuMissionMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceGpuMissionMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceGpuMissionMutation) ResetDeviceID() {
	m.device = nil
}

// SetGpuID sets the "gpu_id" field.
func (m *DeviceGpuMissionMutation) SetGpuID(i int64) {
	m.gpu = &i
}

// GpuID returns the value of the "gpu_id" field in the mutation.
func (m *DeviceGpuMissionMutation) GpuID() (r int64, exists bool) {
	v := m.gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuID returns the old "gpu_id" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldGpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuID: %w", err)
	}
	return oldValue.GpuID, nil
}

// ResetGpuID resets all changes to the "gpu_id" field.
func (m *DeviceGpuMissionMutation) ResetGpuID() {
	m.gpu = nil
}

// SetMissionKindID sets the "mission_kind_id" field.
func (m *DeviceGpuMissionMutation) SetMissionKindID(i int64) {
	m.mission_kind = &i
}

// MissionKindID returns the value of the "mission_kind_id" field in the mutation.
func (m *DeviceGpuMissionMutation) MissionKindID() (r int64, exists bool) {
	v := m.mission_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionKindID returns the old "mission_kind_id" field's value of the DeviceGpuMission entity.
// If the DeviceGpuMission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceGpuMissionMutation) OldMissionKindID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionKindID: %w", err)
	}
	return oldValue.MissionKindID, nil
}

// ResetMissionKindID resets all changes to the "mission_kind_id" field.
func (m *DeviceGpuMissionMutation) ResetMissionKindID() {
	m.mission_kind = nil
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *DeviceGpuMissionMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[devicegpumission.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *DeviceGpuMissionMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceGpuMissionMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceGpuMissionMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// ClearMissionKind clears the "mission_kind" edge to the MissionKind entity.
func (m *DeviceGpuMissionMutation) ClearMissionKind() {
	m.clearedmission_kind = true
	m.clearedFields[devicegpumission.FieldMissionKindID] = struct{}{}
}

// MissionKindCleared reports if the "mission_kind" edge to the MissionKind entity was cleared.
func (m *DeviceGpuMissionMutation) MissionKindCleared() bool {
	return m.clearedmission_kind
}

// MissionKindIDs returns the "mission_kind" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionKindID instead. It exists only for internal usage by the builders.
func (m *DeviceGpuMissionMutation) MissionKindIDs() (ids []int64) {
	if id := m.mission_kind; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionKind resets all changes to the "mission_kind" edge.
func (m *DeviceGpuMissionMutation) ResetMissionKind() {
	m.mission_kind = nil
	m.clearedmission_kind = false
}

// ClearGpu clears the "gpu" edge to the Gpu entity.
func (m *DeviceGpuMissionMutation) ClearGpu() {
	m.clearedgpu = true
	m.clearedFields[devicegpumission.FieldGpuID] = struct{}{}
}

// GpuCleared reports if the "gpu" edge to the Gpu entity was cleared.
func (m *DeviceGpuMissionMutation) GpuCleared() bool {
	return m.clearedgpu
}

// GpuIDs returns the "gpu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GpuID instead. It exists only for internal usage by the builders.
func (m *DeviceGpuMissionMutation) GpuIDs() (ids []int64) {
	if id := m.gpu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGpu resets all changes to the "gpu" edge.
func (m *DeviceGpuMissionMutation) ResetGpu() {
	m.gpu = nil
	m.clearedgpu = false
}

// Where appends a list predicates to the DeviceGpuMissionMutation builder.
func (m *DeviceGpuMissionMutation) Where(ps ...predicate.DeviceGpuMission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceGpuMissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceGpuMissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceGpuMission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceGpuMissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceGpuMissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceGpuMission).
func (m *DeviceGpuMissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceGpuMissionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, devicegpumission.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, devicegpumission.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, devicegpumission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicegpumission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, devicegpumission.FieldDeletedAt)
	}
	if m.device != nil {
		fields = append(fields, devicegpumission.FieldDeviceID)
	}
	if m.gpu != nil {
		fields = append(fields, devicegpumission.FieldGpuID)
	}
	if m.mission_kind != nil {
		fields = append(fields, devicegpumission.FieldMissionKindID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceGpuMissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicegpumission.FieldCreatedBy:
		return m.CreatedBy()
	case devicegpumission.FieldUpdatedBy:
		return m.UpdatedBy()
	case devicegpumission.FieldCreatedAt:
		return m.CreatedAt()
	case devicegpumission.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicegpumission.FieldDeletedAt:
		return m.DeletedAt()
	case devicegpumission.FieldDeviceID:
		return m.DeviceID()
	case devicegpumission.FieldGpuID:
		return m.GpuID()
	case devicegpumission.FieldMissionKindID:
		return m.MissionKindID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceGpuMissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicegpumission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case devicegpumission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case devicegpumission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicegpumission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicegpumission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case devicegpumission.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case devicegpumission.FieldGpuID:
		return m.OldGpuID(ctx)
	case devicegpumission.FieldMissionKindID:
		return m.OldMissionKindID(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceGpuMission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceGpuMissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicegpumission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case devicegpumission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case devicegpumission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicegpumission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicegpumission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case devicegpumission.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case devicegpumission.FieldGpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuID(v)
		return nil
	case devicegpumission.FieldMissionKindID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionKindID(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceGpuMissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, devicegpumission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, devicegpumission.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceGpuMissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicegpumission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case devicegpumission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceGpuMissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicegpumission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case devicegpumission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceGpuMissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceGpuMissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceGpuMissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceGpuMission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceGpuMissionMutation) ResetField(name string) error {
	switch name {
	case devicegpumission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case devicegpumission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case devicegpumission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicegpumission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicegpumission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case devicegpumission.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case devicegpumission.FieldGpuID:
		m.ResetGpuID()
		return nil
	case devicegpumission.FieldMissionKindID:
		m.ResetMissionKindID()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceGpuMissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.device != nil {
		edges = append(edges, devicegpumission.EdgeDevice)
	}
	if m.mission_kind != nil {
		edges = append(edges, devicegpumission.EdgeMissionKind)
	}
	if m.gpu != nil {
		edges = append(edges, devicegpumission.EdgeGpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceGpuMissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicegpumission.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case devicegpumission.EdgeMissionKind:
		if id := m.mission_kind; id != nil {
			return []ent.Value{*id}
		}
	case devicegpumission.EdgeGpu:
		if id := m.gpu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceGpuMissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceGpuMissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceGpuMissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddevice {
		edges = append(edges, devicegpumission.EdgeDevice)
	}
	if m.clearedmission_kind {
		edges = append(edges, devicegpumission.EdgeMissionKind)
	}
	if m.clearedgpu {
		edges = append(edges, devicegpumission.EdgeGpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceGpuMissionMutation) EdgeCleared(name string) bool {
	switch name {
	case devicegpumission.EdgeDevice:
		return m.cleareddevice
	case devicegpumission.EdgeMissionKind:
		return m.clearedmission_kind
	case devicegpumission.EdgeGpu:
		return m.clearedgpu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceGpuMissionMutation) ClearEdge(name string) error {
	switch name {
	case devicegpumission.EdgeDevice:
		m.ClearDevice()
		return nil
	case devicegpumission.EdgeMissionKind:
		m.ClearMissionKind()
		return nil
	case devicegpumission.EdgeGpu:
		m.ClearGpu()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceGpuMissionMutation) ResetEdge(name string) error {
	switch name {
	case devicegpumission.EdgeDevice:
		m.ResetDevice()
		return nil
	case devicegpumission.EdgeMissionKind:
		m.ResetMissionKind()
		return nil
	case devicegpumission.EdgeGpu:
		m.ResetGpu()
		return nil
	}
	return fmt.Errorf("unknown DeviceGpuMission edge %s", name)
}

// EarnBillMutation represents an operation that mutates the EarnBill nodes in the graph.
type EarnBillMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	_type                         *earnbill.Type
	is_minus                      *bool
	serial_number                 *string
	pure_cep                      *int64
	addpure_cep                   *int64
	gift_cep                      *int64
	addgift_cep                   *int64
	platform_pure_cep             *int64
	addplatform_pure_cep          *int64
	platform_gift_cep             *int64
	addplatform_gift_cep          *int64
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	profit_account                *int64
	clearedprofit_account         bool
	platform_account              *int64
	clearedplatform_account       bool
	mission_produce_orders        *int64
	clearedmission_produce_orders bool
	done                          bool
	oldValue                      func(context.Context) (*EarnBill, error)
	predicates                    []predicate.EarnBill
}

var _ ent.Mutation = (*EarnBillMutation)(nil)

// earnbillOption allows management of the mutation configuration using functional options.
type earnbillOption func(*EarnBillMutation)

// newEarnBillMutation creates new mutation for the EarnBill entity.
func newEarnBillMutation(c config, op Op, opts ...earnbillOption) *EarnBillMutation {
	m := &EarnBillMutation{
		config:        c,
		op:            op,
		typ:           TypeEarnBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEarnBillID sets the ID field of the mutation.
func withEarnBillID(id int64) earnbillOption {
	return func(m *EarnBillMutation) {
		var (
			err   error
			once  sync.Once
			value *EarnBill
		)
		m.oldValue = func(ctx context.Context) (*EarnBill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EarnBill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEarnBill sets the old EarnBill of the mutation.
func withEarnBill(node *EarnBill) earnbillOption {
	return func(m *EarnBillMutation) {
		m.oldValue = func(context.Context) (*EarnBill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EarnBillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EarnBillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EarnBill entities.
func (m *EarnBillMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EarnBillMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EarnBillMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EarnBill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *EarnBillMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EarnBillMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EarnBillMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EarnBillMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EarnBillMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EarnBillMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EarnBillMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EarnBillMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EarnBillMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EarnBillMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EarnBillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EarnBillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EarnBillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EarnBillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EarnBillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EarnBillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EarnBillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EarnBillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EarnBillMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *EarnBillMutation) SetType(e earnbill.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *EarnBillMutation) GetType() (r earnbill.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldType(ctx context.Context) (v earnbill.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EarnBillMutation) ResetType() {
	m._type = nil
}

// SetIsMinus sets the "is_minus" field.
func (m *EarnBillMutation) SetIsMinus(b bool) {
	m.is_minus = &b
}

// IsMinus returns the value of the "is_minus" field in the mutation.
func (m *EarnBillMutation) IsMinus() (r bool, exists bool) {
	v := m.is_minus
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMinus returns the old "is_minus" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldIsMinus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMinus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMinus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMinus: %w", err)
	}
	return oldValue.IsMinus, nil
}

// ResetIsMinus resets all changes to the "is_minus" field.
func (m *EarnBillMutation) ResetIsMinus() {
	m.is_minus = nil
}

// SetUserID sets the "user_id" field.
func (m *EarnBillMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EarnBillMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EarnBillMutation) ResetUserID() {
	m.user = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *EarnBillMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *EarnBillMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *EarnBillMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetProfitAccountID sets the "profit_account_id" field.
func (m *EarnBillMutation) SetProfitAccountID(i int64) {
	m.profit_account = &i
}

// ProfitAccountID returns the value of the "profit_account_id" field in the mutation.
func (m *EarnBillMutation) ProfitAccountID() (r int64, exists bool) {
	v := m.profit_account
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAccountID returns the old "profit_account_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldProfitAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAccountID: %w", err)
	}
	return oldValue.ProfitAccountID, nil
}

// ResetProfitAccountID resets all changes to the "profit_account_id" field.
func (m *EarnBillMutation) ResetProfitAccountID() {
	m.profit_account = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *EarnBillMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *EarnBillMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *EarnBillMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *EarnBillMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *EarnBillMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *EarnBillMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *EarnBillMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *EarnBillMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *EarnBillMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *EarnBillMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetPlatformAccountID sets the "platform_account_id" field.
func (m *EarnBillMutation) SetPlatformAccountID(i int64) {
	m.platform_account = &i
}

// PlatformAccountID returns the value of the "platform_account_id" field in the mutation.
func (m *EarnBillMutation) PlatformAccountID() (r int64, exists bool) {
	v := m.platform_account
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformAccountID returns the old "platform_account_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPlatformAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformAccountID: %w", err)
	}
	return oldValue.PlatformAccountID, nil
}

// ResetPlatformAccountID resets all changes to the "platform_account_id" field.
func (m *EarnBillMutation) ResetPlatformAccountID() {
	m.platform_account = nil
}

// SetPlatformPureCep sets the "platform_pure_cep" field.
func (m *EarnBillMutation) SetPlatformPureCep(i int64) {
	m.platform_pure_cep = &i
	m.addplatform_pure_cep = nil
}

// PlatformPureCep returns the value of the "platform_pure_cep" field in the mutation.
func (m *EarnBillMutation) PlatformPureCep() (r int64, exists bool) {
	v := m.platform_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformPureCep returns the old "platform_pure_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPlatformPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformPureCep: %w", err)
	}
	return oldValue.PlatformPureCep, nil
}

// AddPlatformPureCep adds i to the "platform_pure_cep" field.
func (m *EarnBillMutation) AddPlatformPureCep(i int64) {
	if m.addplatform_pure_cep != nil {
		*m.addplatform_pure_cep += i
	} else {
		m.addplatform_pure_cep = &i
	}
}

// AddedPlatformPureCep returns the value that was added to the "platform_pure_cep" field in this mutation.
func (m *EarnBillMutation) AddedPlatformPureCep() (r int64, exists bool) {
	v := m.addplatform_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformPureCep resets all changes to the "platform_pure_cep" field.
func (m *EarnBillMutation) ResetPlatformPureCep() {
	m.platform_pure_cep = nil
	m.addplatform_pure_cep = nil
}

// SetPlatformGiftCep sets the "platform_gift_cep" field.
func (m *EarnBillMutation) SetPlatformGiftCep(i int64) {
	m.platform_gift_cep = &i
	m.addplatform_gift_cep = nil
}

// PlatformGiftCep returns the value of the "platform_gift_cep" field in the mutation.
func (m *EarnBillMutation) PlatformGiftCep() (r int64, exists bool) {
	v := m.platform_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformGiftCep returns the old "platform_gift_cep" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldPlatformGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformGiftCep: %w", err)
	}
	return oldValue.PlatformGiftCep, nil
}

// AddPlatformGiftCep adds i to the "platform_gift_cep" field.
func (m *EarnBillMutation) AddPlatformGiftCep(i int64) {
	if m.addplatform_gift_cep != nil {
		*m.addplatform_gift_cep += i
	} else {
		m.addplatform_gift_cep = &i
	}
}

// AddedPlatformGiftCep returns the value that was added to the "platform_gift_cep" field in this mutation.
func (m *EarnBillMutation) AddedPlatformGiftCep() (r int64, exists bool) {
	v := m.addplatform_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformGiftCep resets all changes to the "platform_gift_cep" field.
func (m *EarnBillMutation) ResetPlatformGiftCep() {
	m.platform_gift_cep = nil
	m.addplatform_gift_cep = nil
}

// SetReasonID sets the "reason_id" field.
func (m *EarnBillMutation) SetReasonID(i int64) {
	m.mission_produce_orders = &i
}

// ReasonID returns the value of the "reason_id" field in the mutation.
func (m *EarnBillMutation) ReasonID() (r int64, exists bool) {
	v := m.mission_produce_orders
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonID returns the old "reason_id" field's value of the EarnBill entity.
// If the EarnBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarnBillMutation) OldReasonID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonID: %w", err)
	}
	return oldValue.ReasonID, nil
}

// ClearReasonID clears the value of the "reason_id" field.
func (m *EarnBillMutation) ClearReasonID() {
	m.mission_produce_orders = nil
	m.clearedFields[earnbill.FieldReasonID] = struct{}{}
}

// ReasonIDCleared returns if the "reason_id" field was cleared in this mutation.
func (m *EarnBillMutation) ReasonIDCleared() bool {
	_, ok := m.clearedFields[earnbill.FieldReasonID]
	return ok
}

// ResetReasonID resets all changes to the "reason_id" field.
func (m *EarnBillMutation) ResetReasonID() {
	m.mission_produce_orders = nil
	delete(m.clearedFields, earnbill.FieldReasonID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *EarnBillMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[earnbill.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EarnBillMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EarnBillMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProfitAccount clears the "profit_account" edge to the ProfitAccount entity.
func (m *EarnBillMutation) ClearProfitAccount() {
	m.clearedprofit_account = true
	m.clearedFields[earnbill.FieldProfitAccountID] = struct{}{}
}

// ProfitAccountCleared reports if the "profit_account" edge to the ProfitAccount entity was cleared.
func (m *EarnBillMutation) ProfitAccountCleared() bool {
	return m.clearedprofit_account
}

// ProfitAccountIDs returns the "profit_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfitAccountID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) ProfitAccountIDs() (ids []int64) {
	if id := m.profit_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfitAccount resets all changes to the "profit_account" edge.
func (m *EarnBillMutation) ResetProfitAccount() {
	m.profit_account = nil
	m.clearedprofit_account = false
}

// ClearPlatformAccount clears the "platform_account" edge to the PlatformAccount entity.
func (m *EarnBillMutation) ClearPlatformAccount() {
	m.clearedplatform_account = true
	m.clearedFields[earnbill.FieldPlatformAccountID] = struct{}{}
}

// PlatformAccountCleared reports if the "platform_account" edge to the PlatformAccount entity was cleared.
func (m *EarnBillMutation) PlatformAccountCleared() bool {
	return m.clearedplatform_account
}

// PlatformAccountIDs returns the "platform_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlatformAccountID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) PlatformAccountIDs() (ids []int64) {
	if id := m.platform_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlatformAccount resets all changes to the "platform_account" edge.
func (m *EarnBillMutation) ResetPlatformAccount() {
	m.platform_account = nil
	m.clearedplatform_account = false
}

// SetMissionProduceOrdersID sets the "mission_produce_orders" edge to the MissionProduceOrder entity by id.
func (m *EarnBillMutation) SetMissionProduceOrdersID(id int64) {
	m.mission_produce_orders = &id
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *EarnBillMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
	m.clearedFields[earnbill.FieldReasonID] = struct{}{}
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *EarnBillMutation) MissionProduceOrdersCleared() bool {
	return m.ReasonIDCleared() || m.clearedmission_produce_orders
}

// MissionProduceOrdersID returns the "mission_produce_orders" edge ID in the mutation.
func (m *EarnBillMutation) MissionProduceOrdersID() (id int64, exists bool) {
	if m.mission_produce_orders != nil {
		return *m.mission_produce_orders, true
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionProduceOrdersID instead. It exists only for internal usage by the builders.
func (m *EarnBillMutation) MissionProduceOrdersIDs() (ids []int64) {
	if id := m.mission_produce_orders; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *EarnBillMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
}

// Where appends a list predicates to the EarnBillMutation builder.
func (m *EarnBillMutation) Where(ps ...predicate.EarnBill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EarnBillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EarnBillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EarnBill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EarnBillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EarnBillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EarnBill).
func (m *EarnBillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EarnBillMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, earnbill.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, earnbill.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, earnbill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, earnbill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, earnbill.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, earnbill.FieldType)
	}
	if m.is_minus != nil {
		fields = append(fields, earnbill.FieldIsMinus)
	}
	if m.user != nil {
		fields = append(fields, earnbill.FieldUserID)
	}
	if m.serial_number != nil {
		fields = append(fields, earnbill.FieldSerialNumber)
	}
	if m.profit_account != nil {
		fields = append(fields, earnbill.FieldProfitAccountID)
	}
	if m.pure_cep != nil {
		fields = append(fields, earnbill.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, earnbill.FieldGiftCep)
	}
	if m.platform_account != nil {
		fields = append(fields, earnbill.FieldPlatformAccountID)
	}
	if m.platform_pure_cep != nil {
		fields = append(fields, earnbill.FieldPlatformPureCep)
	}
	if m.platform_gift_cep != nil {
		fields = append(fields, earnbill.FieldPlatformGiftCep)
	}
	if m.mission_produce_orders != nil {
		fields = append(fields, earnbill.FieldReasonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EarnBillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case earnbill.FieldCreatedBy:
		return m.CreatedBy()
	case earnbill.FieldUpdatedBy:
		return m.UpdatedBy()
	case earnbill.FieldCreatedAt:
		return m.CreatedAt()
	case earnbill.FieldUpdatedAt:
		return m.UpdatedAt()
	case earnbill.FieldDeletedAt:
		return m.DeletedAt()
	case earnbill.FieldType:
		return m.GetType()
	case earnbill.FieldIsMinus:
		return m.IsMinus()
	case earnbill.FieldUserID:
		return m.UserID()
	case earnbill.FieldSerialNumber:
		return m.SerialNumber()
	case earnbill.FieldProfitAccountID:
		return m.ProfitAccountID()
	case earnbill.FieldPureCep:
		return m.PureCep()
	case earnbill.FieldGiftCep:
		return m.GiftCep()
	case earnbill.FieldPlatformAccountID:
		return m.PlatformAccountID()
	case earnbill.FieldPlatformPureCep:
		return m.PlatformPureCep()
	case earnbill.FieldPlatformGiftCep:
		return m.PlatformGiftCep()
	case earnbill.FieldReasonID:
		return m.ReasonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EarnBillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case earnbill.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case earnbill.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case earnbill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case earnbill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case earnbill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case earnbill.FieldType:
		return m.OldType(ctx)
	case earnbill.FieldIsMinus:
		return m.OldIsMinus(ctx)
	case earnbill.FieldUserID:
		return m.OldUserID(ctx)
	case earnbill.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case earnbill.FieldProfitAccountID:
		return m.OldProfitAccountID(ctx)
	case earnbill.FieldPureCep:
		return m.OldPureCep(ctx)
	case earnbill.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case earnbill.FieldPlatformAccountID:
		return m.OldPlatformAccountID(ctx)
	case earnbill.FieldPlatformPureCep:
		return m.OldPlatformPureCep(ctx)
	case earnbill.FieldPlatformGiftCep:
		return m.OldPlatformGiftCep(ctx)
	case earnbill.FieldReasonID:
		return m.OldReasonID(ctx)
	}
	return nil, fmt.Errorf("unknown EarnBill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarnBillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case earnbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case earnbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case earnbill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case earnbill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case earnbill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case earnbill.FieldType:
		v, ok := value.(earnbill.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case earnbill.FieldIsMinus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMinus(v)
		return nil
	case earnbill.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case earnbill.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case earnbill.FieldProfitAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAccountID(v)
		return nil
	case earnbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case earnbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case earnbill.FieldPlatformAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformAccountID(v)
		return nil
	case earnbill.FieldPlatformPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformPureCep(v)
		return nil
	case earnbill.FieldPlatformGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformGiftCep(v)
		return nil
	case earnbill.FieldReasonID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonID(v)
		return nil
	}
	return fmt.Errorf("unknown EarnBill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EarnBillMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, earnbill.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, earnbill.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, earnbill.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, earnbill.FieldGiftCep)
	}
	if m.addplatform_pure_cep != nil {
		fields = append(fields, earnbill.FieldPlatformPureCep)
	}
	if m.addplatform_gift_cep != nil {
		fields = append(fields, earnbill.FieldPlatformGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EarnBillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case earnbill.FieldCreatedBy:
		return m.AddedCreatedBy()
	case earnbill.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case earnbill.FieldPureCep:
		return m.AddedPureCep()
	case earnbill.FieldGiftCep:
		return m.AddedGiftCep()
	case earnbill.FieldPlatformPureCep:
		return m.AddedPlatformPureCep()
	case earnbill.FieldPlatformGiftCep:
		return m.AddedPlatformGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarnBillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case earnbill.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case earnbill.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case earnbill.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case earnbill.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	case earnbill.FieldPlatformPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatformPureCep(v)
		return nil
	case earnbill.FieldPlatformGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatformGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown EarnBill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EarnBillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(earnbill.FieldReasonID) {
		fields = append(fields, earnbill.FieldReasonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EarnBillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EarnBillMutation) ClearField(name string) error {
	switch name {
	case earnbill.FieldReasonID:
		m.ClearReasonID()
		return nil
	}
	return fmt.Errorf("unknown EarnBill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EarnBillMutation) ResetField(name string) error {
	switch name {
	case earnbill.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case earnbill.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case earnbill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case earnbill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case earnbill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case earnbill.FieldType:
		m.ResetType()
		return nil
	case earnbill.FieldIsMinus:
		m.ResetIsMinus()
		return nil
	case earnbill.FieldUserID:
		m.ResetUserID()
		return nil
	case earnbill.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case earnbill.FieldProfitAccountID:
		m.ResetProfitAccountID()
		return nil
	case earnbill.FieldPureCep:
		m.ResetPureCep()
		return nil
	case earnbill.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case earnbill.FieldPlatformAccountID:
		m.ResetPlatformAccountID()
		return nil
	case earnbill.FieldPlatformPureCep:
		m.ResetPlatformPureCep()
		return nil
	case earnbill.FieldPlatformGiftCep:
		m.ResetPlatformGiftCep()
		return nil
	case earnbill.FieldReasonID:
		m.ResetReasonID()
		return nil
	}
	return fmt.Errorf("unknown EarnBill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EarnBillMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, earnbill.EdgeUser)
	}
	if m.profit_account != nil {
		edges = append(edges, earnbill.EdgeProfitAccount)
	}
	if m.platform_account != nil {
		edges = append(edges, earnbill.EdgePlatformAccount)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, earnbill.EdgeMissionProduceOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EarnBillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case earnbill.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case earnbill.EdgeProfitAccount:
		if id := m.profit_account; id != nil {
			return []ent.Value{*id}
		}
	case earnbill.EdgePlatformAccount:
		if id := m.platform_account; id != nil {
			return []ent.Value{*id}
		}
	case earnbill.EdgeMissionProduceOrders:
		if id := m.mission_produce_orders; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EarnBillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EarnBillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EarnBillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, earnbill.EdgeUser)
	}
	if m.clearedprofit_account {
		edges = append(edges, earnbill.EdgeProfitAccount)
	}
	if m.clearedplatform_account {
		edges = append(edges, earnbill.EdgePlatformAccount)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, earnbill.EdgeMissionProduceOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EarnBillMutation) EdgeCleared(name string) bool {
	switch name {
	case earnbill.EdgeUser:
		return m.cleareduser
	case earnbill.EdgeProfitAccount:
		return m.clearedprofit_account
	case earnbill.EdgePlatformAccount:
		return m.clearedplatform_account
	case earnbill.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EarnBillMutation) ClearEdge(name string) error {
	switch name {
	case earnbill.EdgeUser:
		m.ClearUser()
		return nil
	case earnbill.EdgeProfitAccount:
		m.ClearProfitAccount()
		return nil
	case earnbill.EdgePlatformAccount:
		m.ClearPlatformAccount()
		return nil
	case earnbill.EdgeMissionProduceOrders:
		m.ClearMissionProduceOrders()
		return nil
	}
	return fmt.Errorf("unknown EarnBill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EarnBillMutation) ResetEdge(name string) error {
	switch name {
	case earnbill.EdgeUser:
		m.ResetUser()
		return nil
	case earnbill.EdgeProfitAccount:
		m.ResetProfitAccount()
		return nil
	case earnbill.EdgePlatformAccount:
		m.ResetPlatformAccount()
		return nil
	case earnbill.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	}
	return fmt.Errorf("unknown EarnBill edge %s", name)
}

// EnumConditionMutation represents an operation that mutates the EnumCondition nodes in the graph.
type EnumConditionMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_by       *int64
	addcreated_by    *int64
	updated_by       *int64
	addupdated_by    *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	front_type       *string
	mission_type     *string
	mission_call_way *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*EnumCondition, error)
	predicates       []predicate.EnumCondition
}

var _ ent.Mutation = (*EnumConditionMutation)(nil)

// enumconditionOption allows management of the mutation configuration using functional options.
type enumconditionOption func(*EnumConditionMutation)

// newEnumConditionMutation creates new mutation for the EnumCondition entity.
func newEnumConditionMutation(c config, op Op, opts ...enumconditionOption) *EnumConditionMutation {
	m := &EnumConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeEnumCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnumConditionID sets the ID field of the mutation.
func withEnumConditionID(id int64) enumconditionOption {
	return func(m *EnumConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *EnumCondition
		)
		m.oldValue = func(ctx context.Context) (*EnumCondition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnumCondition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnumCondition sets the old EnumCondition of the mutation.
func withEnumCondition(node *EnumCondition) enumconditionOption {
	return func(m *EnumConditionMutation) {
		m.oldValue = func(context.Context) (*EnumCondition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnumConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnumConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnumCondition entities.
func (m *EnumConditionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnumConditionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnumConditionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnumCondition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *EnumConditionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EnumConditionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EnumConditionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EnumConditionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EnumConditionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EnumConditionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EnumConditionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EnumConditionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EnumConditionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EnumConditionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EnumConditionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnumConditionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnumConditionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnumConditionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnumConditionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnumConditionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnumConditionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnumConditionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnumConditionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetFrontType sets the "front_type" field.
func (m *EnumConditionMutation) SetFrontType(s string) {
	m.front_type = &s
}

// FrontType returns the value of the "front_type" field in the mutation.
func (m *EnumConditionMutation) FrontType() (r string, exists bool) {
	v := m.front_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFrontType returns the old "front_type" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldFrontType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrontType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrontType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrontType: %w", err)
	}
	return oldValue.FrontType, nil
}

// ResetFrontType resets all changes to the "front_type" field.
func (m *EnumConditionMutation) ResetFrontType() {
	m.front_type = nil
}

// SetMissionType sets the "mission_type" field.
func (m *EnumConditionMutation) SetMissionType(s string) {
	m.mission_type = &s
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *EnumConditionMutation) MissionType() (r string, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldMissionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *EnumConditionMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionCallWay sets the "mission_call_way" field.
func (m *EnumConditionMutation) SetMissionCallWay(s string) {
	m.mission_call_way = &s
}

// MissionCallWay returns the value of the "mission_call_way" field in the mutation.
func (m *EnumConditionMutation) MissionCallWay() (r string, exists bool) {
	v := m.mission_call_way
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionCallWay returns the old "mission_call_way" field's value of the EnumCondition entity.
// If the EnumCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumConditionMutation) OldMissionCallWay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionCallWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionCallWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionCallWay: %w", err)
	}
	return oldValue.MissionCallWay, nil
}

// ResetMissionCallWay resets all changes to the "mission_call_way" field.
func (m *EnumConditionMutation) ResetMissionCallWay() {
	m.mission_call_way = nil
}

// Where appends a list predicates to the EnumConditionMutation builder.
func (m *EnumConditionMutation) Where(ps ...predicate.EnumCondition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnumConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnumConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnumCondition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnumConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnumConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnumCondition).
func (m *EnumConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnumConditionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, enumcondition.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, enumcondition.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, enumcondition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enumcondition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enumcondition.FieldDeletedAt)
	}
	if m.front_type != nil {
		fields = append(fields, enumcondition.FieldFrontType)
	}
	if m.mission_type != nil {
		fields = append(fields, enumcondition.FieldMissionType)
	}
	if m.mission_call_way != nil {
		fields = append(fields, enumcondition.FieldMissionCallWay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnumConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enumcondition.FieldCreatedBy:
		return m.CreatedBy()
	case enumcondition.FieldUpdatedBy:
		return m.UpdatedBy()
	case enumcondition.FieldCreatedAt:
		return m.CreatedAt()
	case enumcondition.FieldUpdatedAt:
		return m.UpdatedAt()
	case enumcondition.FieldDeletedAt:
		return m.DeletedAt()
	case enumcondition.FieldFrontType:
		return m.FrontType()
	case enumcondition.FieldMissionType:
		return m.MissionType()
	case enumcondition.FieldMissionCallWay:
		return m.MissionCallWay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnumConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enumcondition.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case enumcondition.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case enumcondition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enumcondition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enumcondition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enumcondition.FieldFrontType:
		return m.OldFrontType(ctx)
	case enumcondition.FieldMissionType:
		return m.OldMissionType(ctx)
	case enumcondition.FieldMissionCallWay:
		return m.OldMissionCallWay(ctx)
	}
	return nil, fmt.Errorf("unknown EnumCondition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enumcondition.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case enumcondition.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case enumcondition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enumcondition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enumcondition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enumcondition.FieldFrontType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrontType(v)
		return nil
	case enumcondition.FieldMissionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case enumcondition.FieldMissionCallWay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionCallWay(v)
		return nil
	}
	return fmt.Errorf("unknown EnumCondition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnumConditionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, enumcondition.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, enumcondition.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnumConditionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enumcondition.FieldCreatedBy:
		return m.AddedCreatedBy()
	case enumcondition.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enumcondition.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case enumcondition.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown EnumCondition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnumConditionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnumConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnumConditionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnumCondition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnumConditionMutation) ResetField(name string) error {
	switch name {
	case enumcondition.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case enumcondition.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case enumcondition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enumcondition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enumcondition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enumcondition.FieldFrontType:
		m.ResetFrontType()
		return nil
	case enumcondition.FieldMissionType:
		m.ResetMissionType()
		return nil
	case enumcondition.FieldMissionCallWay:
		m.ResetMissionCallWay()
		return nil
	}
	return fmt.Errorf("unknown EnumCondition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnumConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnumConditionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnumConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnumConditionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnumConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnumConditionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnumConditionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EnumCondition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnumConditionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EnumCondition edge %s", name)
}

// EnumMissionStatusMutation represents an operation that mutates the EnumMissionStatus nodes in the graph.
type EnumMissionStatusMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_by     *int64
	addcreated_by  *int64
	updated_by     *int64
	addupdated_by  *int64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	front_status   *string
	mission_type   *string
	mission_status *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*EnumMissionStatus, error)
	predicates     []predicate.EnumMissionStatus
}

var _ ent.Mutation = (*EnumMissionStatusMutation)(nil)

// enummissionstatusOption allows management of the mutation configuration using functional options.
type enummissionstatusOption func(*EnumMissionStatusMutation)

// newEnumMissionStatusMutation creates new mutation for the EnumMissionStatus entity.
func newEnumMissionStatusMutation(c config, op Op, opts ...enummissionstatusOption) *EnumMissionStatusMutation {
	m := &EnumMissionStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeEnumMissionStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnumMissionStatusID sets the ID field of the mutation.
func withEnumMissionStatusID(id int64) enummissionstatusOption {
	return func(m *EnumMissionStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *EnumMissionStatus
		)
		m.oldValue = func(ctx context.Context) (*EnumMissionStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnumMissionStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnumMissionStatus sets the old EnumMissionStatus of the mutation.
func withEnumMissionStatus(node *EnumMissionStatus) enummissionstatusOption {
	return func(m *EnumMissionStatusMutation) {
		m.oldValue = func(context.Context) (*EnumMissionStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnumMissionStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnumMissionStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnumMissionStatus entities.
func (m *EnumMissionStatusMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnumMissionStatusMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnumMissionStatusMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnumMissionStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *EnumMissionStatusMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EnumMissionStatusMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EnumMissionStatusMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EnumMissionStatusMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EnumMissionStatusMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EnumMissionStatusMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EnumMissionStatusMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EnumMissionStatusMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EnumMissionStatusMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EnumMissionStatusMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EnumMissionStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnumMissionStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnumMissionStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnumMissionStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnumMissionStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnumMissionStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnumMissionStatusMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnumMissionStatusMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnumMissionStatusMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetFrontStatus sets the "front_status" field.
func (m *EnumMissionStatusMutation) SetFrontStatus(s string) {
	m.front_status = &s
}

// FrontStatus returns the value of the "front_status" field in the mutation.
func (m *EnumMissionStatusMutation) FrontStatus() (r string, exists bool) {
	v := m.front_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFrontStatus returns the old "front_status" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldFrontStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrontStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrontStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrontStatus: %w", err)
	}
	return oldValue.FrontStatus, nil
}

// ResetFrontStatus resets all changes to the "front_status" field.
func (m *EnumMissionStatusMutation) ResetFrontStatus() {
	m.front_status = nil
}

// SetMissionType sets the "mission_type" field.
func (m *EnumMissionStatusMutation) SetMissionType(s string) {
	m.mission_type = &s
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *EnumMissionStatusMutation) MissionType() (r string, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldMissionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *EnumMissionStatusMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionStatus sets the "mission_status" field.
func (m *EnumMissionStatusMutation) SetMissionStatus(s string) {
	m.mission_status = &s
}

// MissionStatus returns the value of the "mission_status" field in the mutation.
func (m *EnumMissionStatusMutation) MissionStatus() (r string, exists bool) {
	v := m.mission_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionStatus returns the old "mission_status" field's value of the EnumMissionStatus entity.
// If the EnumMissionStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumMissionStatusMutation) OldMissionStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionStatus: %w", err)
	}
	return oldValue.MissionStatus, nil
}

// ResetMissionStatus resets all changes to the "mission_status" field.
func (m *EnumMissionStatusMutation) ResetMissionStatus() {
	m.mission_status = nil
}

// Where appends a list predicates to the EnumMissionStatusMutation builder.
func (m *EnumMissionStatusMutation) Where(ps ...predicate.EnumMissionStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnumMissionStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnumMissionStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnumMissionStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnumMissionStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnumMissionStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnumMissionStatus).
func (m *EnumMissionStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnumMissionStatusMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, enummissionstatus.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, enummissionstatus.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, enummissionstatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enummissionstatus.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enummissionstatus.FieldDeletedAt)
	}
	if m.front_status != nil {
		fields = append(fields, enummissionstatus.FieldFrontStatus)
	}
	if m.mission_type != nil {
		fields = append(fields, enummissionstatus.FieldMissionType)
	}
	if m.mission_status != nil {
		fields = append(fields, enummissionstatus.FieldMissionStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnumMissionStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		return m.CreatedBy()
	case enummissionstatus.FieldUpdatedBy:
		return m.UpdatedBy()
	case enummissionstatus.FieldCreatedAt:
		return m.CreatedAt()
	case enummissionstatus.FieldUpdatedAt:
		return m.UpdatedAt()
	case enummissionstatus.FieldDeletedAt:
		return m.DeletedAt()
	case enummissionstatus.FieldFrontStatus:
		return m.FrontStatus()
	case enummissionstatus.FieldMissionType:
		return m.MissionType()
	case enummissionstatus.FieldMissionStatus:
		return m.MissionStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnumMissionStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case enummissionstatus.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case enummissionstatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enummissionstatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enummissionstatus.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enummissionstatus.FieldFrontStatus:
		return m.OldFrontStatus(ctx)
	case enummissionstatus.FieldMissionType:
		return m.OldMissionType(ctx)
	case enummissionstatus.FieldMissionStatus:
		return m.OldMissionStatus(ctx)
	}
	return nil, fmt.Errorf("unknown EnumMissionStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumMissionStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case enummissionstatus.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case enummissionstatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enummissionstatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enummissionstatus.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enummissionstatus.FieldFrontStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrontStatus(v)
		return nil
	case enummissionstatus.FieldMissionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case enummissionstatus.FieldMissionStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EnumMissionStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnumMissionStatusMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, enummissionstatus.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, enummissionstatus.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnumMissionStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		return m.AddedCreatedBy()
	case enummissionstatus.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumMissionStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case enummissionstatus.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown EnumMissionStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnumMissionStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnumMissionStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnumMissionStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnumMissionStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnumMissionStatusMutation) ResetField(name string) error {
	switch name {
	case enummissionstatus.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case enummissionstatus.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case enummissionstatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enummissionstatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enummissionstatus.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enummissionstatus.FieldFrontStatus:
		m.ResetFrontStatus()
		return nil
	case enummissionstatus.FieldMissionType:
		m.ResetMissionType()
		return nil
	case enummissionstatus.FieldMissionStatus:
		m.ResetMissionStatus()
		return nil
	}
	return fmt.Errorf("unknown EnumMissionStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnumMissionStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnumMissionStatusMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnumMissionStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnumMissionStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnumMissionStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnumMissionStatusMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnumMissionStatusMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EnumMissionStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnumMissionStatusMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EnumMissionStatus edge %s", name)
}

// GpuMutation represents an operation that mutates the Gpu nodes in the graph.
type GpuMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	version                    *enums.GpuVersion
	power                      *int
	addpower                   *int
	clearedFields              map[string]struct{}
	device_gpu_missions        map[int64]struct{}
	removeddevice_gpu_missions map[int64]struct{}
	cleareddevice_gpu_missions bool
	done                       bool
	oldValue                   func(context.Context) (*Gpu, error)
	predicates                 []predicate.Gpu
}

var _ ent.Mutation = (*GpuMutation)(nil)

// gpuOption allows management of the mutation configuration using functional options.
type gpuOption func(*GpuMutation)

// newGpuMutation creates new mutation for the Gpu entity.
func newGpuMutation(c config, op Op, opts ...gpuOption) *GpuMutation {
	m := &GpuMutation{
		config:        c,
		op:            op,
		typ:           TypeGpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGpuID sets the ID field of the mutation.
func withGpuID(id int64) gpuOption {
	return func(m *GpuMutation) {
		var (
			err   error
			once  sync.Once
			value *Gpu
		)
		m.oldValue = func(ctx context.Context) (*Gpu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gpu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGpu sets the old Gpu of the mutation.
func withGpu(node *Gpu) gpuOption {
	return func(m *GpuMutation) {
		m.oldValue = func(context.Context) (*Gpu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GpuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GpuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Gpu entities.
func (m *GpuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GpuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GpuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Gpu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *GpuMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GpuMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *GpuMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *GpuMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GpuMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GpuMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GpuMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *GpuMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *GpuMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GpuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GpuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GpuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GpuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GpuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GpuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GpuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GpuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GpuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GpuMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetVersion sets the "version" field.
func (m *GpuMutation) SetVersion(ev enums.GpuVersion) {
	m.version = &ev
}

// Version returns the value of the "version" field in the mutation.
func (m *GpuMutation) Version() (r enums.GpuVersion, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *GpuMutation) ResetVersion() {
	m.version = nil
}

// SetPower sets the "power" field.
func (m *GpuMutation) SetPower(i int) {
	m.power = &i
	m.addpower = nil
}

// Power returns the value of the "power" field in the mutation.
func (m *GpuMutation) Power() (r int, exists bool) {
	v := m.power
	if v == nil {
		return
	}
	return *v, true
}

// OldPower returns the old "power" field's value of the Gpu entity.
// If the Gpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GpuMutation) OldPower(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPower is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPower requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPower: %w", err)
	}
	return oldValue.Power, nil
}

// AddPower adds i to the "power" field.
func (m *GpuMutation) AddPower(i int) {
	if m.addpower != nil {
		*m.addpower += i
	} else {
		m.addpower = &i
	}
}

// AddedPower returns the value that was added to the "power" field in this mutation.
func (m *GpuMutation) AddedPower() (r int, exists bool) {
	v := m.addpower
	if v == nil {
		return
	}
	return *v, true
}

// ResetPower resets all changes to the "power" field.
func (m *GpuMutation) ResetPower() {
	m.power = nil
	m.addpower = nil
}

// AddDeviceGpuMissionIDs adds the "device_gpu_missions" edge to the DeviceGpuMission entity by ids.
func (m *GpuMutation) AddDeviceGpuMissionIDs(ids ...int64) {
	if m.device_gpu_missions == nil {
		m.device_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_gpu_missions[ids[i]] = struct{}{}
	}
}

// ClearDeviceGpuMissions clears the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *GpuMutation) ClearDeviceGpuMissions() {
	m.cleareddevice_gpu_missions = true
}

// DeviceGpuMissionsCleared reports if the "device_gpu_missions" edge to the DeviceGpuMission entity was cleared.
func (m *GpuMutation) DeviceGpuMissionsCleared() bool {
	return m.cleareddevice_gpu_missions
}

// RemoveDeviceGpuMissionIDs removes the "device_gpu_missions" edge to the DeviceGpuMission entity by IDs.
func (m *GpuMutation) RemoveDeviceGpuMissionIDs(ids ...int64) {
	if m.removeddevice_gpu_missions == nil {
		m.removeddevice_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_gpu_missions, ids[i])
		m.removeddevice_gpu_missions[ids[i]] = struct{}{}
	}
}

// RemovedDeviceGpuMissions returns the removed IDs of the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *GpuMutation) RemovedDeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.removeddevice_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// DeviceGpuMissionsIDs returns the "device_gpu_missions" edge IDs in the mutation.
func (m *GpuMutation) DeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.device_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceGpuMissions resets all changes to the "device_gpu_missions" edge.
func (m *GpuMutation) ResetDeviceGpuMissions() {
	m.device_gpu_missions = nil
	m.cleareddevice_gpu_missions = false
	m.removeddevice_gpu_missions = nil
}

// Where appends a list predicates to the GpuMutation builder.
func (m *GpuMutation) Where(ps ...predicate.Gpu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GpuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GpuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Gpu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GpuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GpuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Gpu).
func (m *GpuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GpuMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, gpu.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, gpu.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, gpu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gpu.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, gpu.FieldDeletedAt)
	}
	if m.version != nil {
		fields = append(fields, gpu.FieldVersion)
	}
	if m.power != nil {
		fields = append(fields, gpu.FieldPower)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GpuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gpu.FieldCreatedBy:
		return m.CreatedBy()
	case gpu.FieldUpdatedBy:
		return m.UpdatedBy()
	case gpu.FieldCreatedAt:
		return m.CreatedAt()
	case gpu.FieldUpdatedAt:
		return m.UpdatedAt()
	case gpu.FieldDeletedAt:
		return m.DeletedAt()
	case gpu.FieldVersion:
		return m.Version()
	case gpu.FieldPower:
		return m.Power()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GpuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gpu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case gpu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case gpu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gpu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case gpu.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case gpu.FieldVersion:
		return m.OldVersion(ctx)
	case gpu.FieldPower:
		return m.OldPower(ctx)
	}
	return nil, fmt.Errorf("unknown Gpu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GpuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gpu.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case gpu.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case gpu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gpu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case gpu.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case gpu.FieldVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case gpu.FieldPower:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPower(v)
		return nil
	}
	return fmt.Errorf("unknown Gpu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GpuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, gpu.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, gpu.FieldUpdatedBy)
	}
	if m.addpower != nil {
		fields = append(fields, gpu.FieldPower)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GpuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gpu.FieldCreatedBy:
		return m.AddedCreatedBy()
	case gpu.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case gpu.FieldPower:
		return m.AddedPower()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GpuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gpu.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case gpu.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case gpu.FieldPower:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPower(v)
		return nil
	}
	return fmt.Errorf("unknown Gpu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GpuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GpuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GpuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gpu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GpuMutation) ResetField(name string) error {
	switch name {
	case gpu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case gpu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case gpu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gpu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case gpu.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case gpu.FieldVersion:
		m.ResetVersion()
		return nil
	case gpu.FieldPower:
		m.ResetPower()
		return nil
	}
	return fmt.Errorf("unknown Gpu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GpuMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device_gpu_missions != nil {
		edges = append(edges, gpu.EdgeDeviceGpuMissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GpuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.device_gpu_missions))
		for id := range m.device_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GpuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddevice_gpu_missions != nil {
		edges = append(edges, gpu.EdgeDeviceGpuMissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GpuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.removeddevice_gpu_missions))
		for id := range m.removeddevice_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GpuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice_gpu_missions {
		edges = append(edges, gpu.EdgeDeviceGpuMissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GpuMutation) EdgeCleared(name string) bool {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		return m.cleareddevice_gpu_missions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GpuMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gpu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GpuMutation) ResetEdge(name string) error {
	switch name {
	case gpu.EdgeDeviceGpuMissions:
		m.ResetDeviceGpuMissions()
		return nil
	}
	return fmt.Errorf("unknown Gpu edge %s", name)
}

// HmacKeyPairMutation represents an operation that mutates the HmacKeyPair nodes in the graph.
type HmacKeyPairMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_by               *int64
	addcreated_by            *int64
	updated_by               *int64
	addupdated_by            *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	key                      *string
	secret                   *string
	caller                   *string
	clearedFields            map[string]struct{}
	mission_key_pairs        map[int64]struct{}
	removedmission_key_pairs map[int64]struct{}
	clearedmission_key_pairs bool
	created_missions         map[int64]struct{}
	removedcreated_missions  map[int64]struct{}
	clearedcreated_missions  bool
	done                     bool
	oldValue                 func(context.Context) (*HmacKeyPair, error)
	predicates               []predicate.HmacKeyPair
}

var _ ent.Mutation = (*HmacKeyPairMutation)(nil)

// hmackeypairOption allows management of the mutation configuration using functional options.
type hmackeypairOption func(*HmacKeyPairMutation)

// newHmacKeyPairMutation creates new mutation for the HmacKeyPair entity.
func newHmacKeyPairMutation(c config, op Op, opts ...hmackeypairOption) *HmacKeyPairMutation {
	m := &HmacKeyPairMutation{
		config:        c,
		op:            op,
		typ:           TypeHmacKeyPair,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHmacKeyPairID sets the ID field of the mutation.
func withHmacKeyPairID(id int64) hmackeypairOption {
	return func(m *HmacKeyPairMutation) {
		var (
			err   error
			once  sync.Once
			value *HmacKeyPair
		)
		m.oldValue = func(ctx context.Context) (*HmacKeyPair, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HmacKeyPair.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHmacKeyPair sets the old HmacKeyPair of the mutation.
func withHmacKeyPair(node *HmacKeyPair) hmackeypairOption {
	return func(m *HmacKeyPairMutation) {
		m.oldValue = func(context.Context) (*HmacKeyPair, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HmacKeyPairMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HmacKeyPairMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HmacKeyPair entities.
func (m *HmacKeyPairMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HmacKeyPairMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HmacKeyPairMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HmacKeyPair.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *HmacKeyPairMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HmacKeyPairMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *HmacKeyPairMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *HmacKeyPairMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HmacKeyPairMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HmacKeyPairMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HmacKeyPairMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *HmacKeyPairMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *HmacKeyPairMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HmacKeyPairMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HmacKeyPairMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HmacKeyPairMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HmacKeyPairMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HmacKeyPairMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HmacKeyPairMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HmacKeyPairMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HmacKeyPairMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HmacKeyPairMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HmacKeyPairMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetKey sets the "key" field.
func (m *HmacKeyPairMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *HmacKeyPairMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *HmacKeyPairMutation) ResetKey() {
	m.key = nil
}

// SetSecret sets the "secret" field.
func (m *HmacKeyPairMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *HmacKeyPairMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *HmacKeyPairMutation) ResetSecret() {
	m.secret = nil
}

// SetCaller sets the "caller" field.
func (m *HmacKeyPairMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *HmacKeyPairMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the HmacKeyPair entity.
// If the HmacKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HmacKeyPairMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *HmacKeyPairMutation) ResetCaller() {
	m.caller = nil
}

// AddMissionKeyPairIDs adds the "mission_key_pairs" edge to the MissionKeyPair entity by ids.
func (m *HmacKeyPairMutation) AddMissionKeyPairIDs(ids ...int64) {
	if m.mission_key_pairs == nil {
		m.mission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_key_pairs[ids[i]] = struct{}{}
	}
}

// ClearMissionKeyPairs clears the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *HmacKeyPairMutation) ClearMissionKeyPairs() {
	m.clearedmission_key_pairs = true
}

// MissionKeyPairsCleared reports if the "mission_key_pairs" edge to the MissionKeyPair entity was cleared.
func (m *HmacKeyPairMutation) MissionKeyPairsCleared() bool {
	return m.clearedmission_key_pairs
}

// RemoveMissionKeyPairIDs removes the "mission_key_pairs" edge to the MissionKeyPair entity by IDs.
func (m *HmacKeyPairMutation) RemoveMissionKeyPairIDs(ids ...int64) {
	if m.removedmission_key_pairs == nil {
		m.removedmission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_key_pairs, ids[i])
		m.removedmission_key_pairs[ids[i]] = struct{}{}
	}
}

// RemovedMissionKeyPairs returns the removed IDs of the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *HmacKeyPairMutation) RemovedMissionKeyPairsIDs() (ids []int64) {
	for id := range m.removedmission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// MissionKeyPairsIDs returns the "mission_key_pairs" edge IDs in the mutation.
func (m *HmacKeyPairMutation) MissionKeyPairsIDs() (ids []int64) {
	for id := range m.mission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// ResetMissionKeyPairs resets all changes to the "mission_key_pairs" edge.
func (m *HmacKeyPairMutation) ResetMissionKeyPairs() {
	m.mission_key_pairs = nil
	m.clearedmission_key_pairs = false
	m.removedmission_key_pairs = nil
}

// AddCreatedMissionIDs adds the "created_missions" edge to the Mission entity by ids.
func (m *HmacKeyPairMutation) AddCreatedMissionIDs(ids ...int64) {
	if m.created_missions == nil {
		m.created_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.created_missions[ids[i]] = struct{}{}
	}
}

// ClearCreatedMissions clears the "created_missions" edge to the Mission entity.
func (m *HmacKeyPairMutation) ClearCreatedMissions() {
	m.clearedcreated_missions = true
}

// CreatedMissionsCleared reports if the "created_missions" edge to the Mission entity was cleared.
func (m *HmacKeyPairMutation) CreatedMissionsCleared() bool {
	return m.clearedcreated_missions
}

// RemoveCreatedMissionIDs removes the "created_missions" edge to the Mission entity by IDs.
func (m *HmacKeyPairMutation) RemoveCreatedMissionIDs(ids ...int64) {
	if m.removedcreated_missions == nil {
		m.removedcreated_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.created_missions, ids[i])
		m.removedcreated_missions[ids[i]] = struct{}{}
	}
}

// RemovedCreatedMissions returns the removed IDs of the "created_missions" edge to the Mission entity.
func (m *HmacKeyPairMutation) RemovedCreatedMissionsIDs() (ids []int64) {
	for id := range m.removedcreated_missions {
		ids = append(ids, id)
	}
	return
}

// CreatedMissionsIDs returns the "created_missions" edge IDs in the mutation.
func (m *HmacKeyPairMutation) CreatedMissionsIDs() (ids []int64) {
	for id := range m.created_missions {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedMissions resets all changes to the "created_missions" edge.
func (m *HmacKeyPairMutation) ResetCreatedMissions() {
	m.created_missions = nil
	m.clearedcreated_missions = false
	m.removedcreated_missions = nil
}

// Where appends a list predicates to the HmacKeyPairMutation builder.
func (m *HmacKeyPairMutation) Where(ps ...predicate.HmacKeyPair) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HmacKeyPairMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HmacKeyPairMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HmacKeyPair, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HmacKeyPairMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HmacKeyPairMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HmacKeyPair).
func (m *HmacKeyPairMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HmacKeyPairMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, hmackeypair.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, hmackeypair.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, hmackeypair.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hmackeypair.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hmackeypair.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, hmackeypair.FieldKey)
	}
	if m.secret != nil {
		fields = append(fields, hmackeypair.FieldSecret)
	}
	if m.caller != nil {
		fields = append(fields, hmackeypair.FieldCaller)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HmacKeyPairMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hmackeypair.FieldCreatedBy:
		return m.CreatedBy()
	case hmackeypair.FieldUpdatedBy:
		return m.UpdatedBy()
	case hmackeypair.FieldCreatedAt:
		return m.CreatedAt()
	case hmackeypair.FieldUpdatedAt:
		return m.UpdatedAt()
	case hmackeypair.FieldDeletedAt:
		return m.DeletedAt()
	case hmackeypair.FieldKey:
		return m.Key()
	case hmackeypair.FieldSecret:
		return m.Secret()
	case hmackeypair.FieldCaller:
		return m.Caller()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HmacKeyPairMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hmackeypair.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hmackeypair.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case hmackeypair.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hmackeypair.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hmackeypair.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hmackeypair.FieldKey:
		return m.OldKey(ctx)
	case hmackeypair.FieldSecret:
		return m.OldSecret(ctx)
	case hmackeypair.FieldCaller:
		return m.OldCaller(ctx)
	}
	return nil, fmt.Errorf("unknown HmacKeyPair field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HmacKeyPairMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hmackeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hmackeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case hmackeypair.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hmackeypair.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hmackeypair.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hmackeypair.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case hmackeypair.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case hmackeypair.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HmacKeyPairMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, hmackeypair.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, hmackeypair.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HmacKeyPairMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hmackeypair.FieldCreatedBy:
		return m.AddedCreatedBy()
	case hmackeypair.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HmacKeyPairMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hmackeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case hmackeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HmacKeyPairMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HmacKeyPairMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HmacKeyPairMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HmacKeyPair nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HmacKeyPairMutation) ResetField(name string) error {
	switch name {
	case hmackeypair.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hmackeypair.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case hmackeypair.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hmackeypair.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hmackeypair.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hmackeypair.FieldKey:
		m.ResetKey()
		return nil
	case hmackeypair.FieldSecret:
		m.ResetSecret()
		return nil
	case hmackeypair.FieldCaller:
		m.ResetCaller()
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HmacKeyPairMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mission_key_pairs != nil {
		edges = append(edges, hmackeypair.EdgeMissionKeyPairs)
	}
	if m.created_missions != nil {
		edges = append(edges, hmackeypair.EdgeCreatedMissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HmacKeyPairMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.mission_key_pairs))
		for id := range m.mission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case hmackeypair.EdgeCreatedMissions:
		ids := make([]ent.Value, 0, len(m.created_missions))
		for id := range m.created_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HmacKeyPairMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmission_key_pairs != nil {
		edges = append(edges, hmackeypair.EdgeMissionKeyPairs)
	}
	if m.removedcreated_missions != nil {
		edges = append(edges, hmackeypair.EdgeCreatedMissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HmacKeyPairMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.removedmission_key_pairs))
		for id := range m.removedmission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case hmackeypair.EdgeCreatedMissions:
		ids := make([]ent.Value, 0, len(m.removedcreated_missions))
		for id := range m.removedcreated_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HmacKeyPairMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmission_key_pairs {
		edges = append(edges, hmackeypair.EdgeMissionKeyPairs)
	}
	if m.clearedcreated_missions {
		edges = append(edges, hmackeypair.EdgeCreatedMissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HmacKeyPairMutation) EdgeCleared(name string) bool {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		return m.clearedmission_key_pairs
	case hmackeypair.EdgeCreatedMissions:
		return m.clearedcreated_missions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HmacKeyPairMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HmacKeyPair unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HmacKeyPairMutation) ResetEdge(name string) error {
	switch name {
	case hmackeypair.EdgeMissionKeyPairs:
		m.ResetMissionKeyPairs()
		return nil
	case hmackeypair.EdgeCreatedMissions:
		m.ResetCreatedMissions()
		return nil
	}
	return fmt.Errorf("unknown HmacKeyPair edge %s", name)
}

// InputLogMutation represents an operation that mutates the InputLog nodes in the graph.
type InputLogMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	trace_id      *int64
	addtrace_id   *int64
	headers       *string
	body          *string
	query         *string
	url           *string
	ip            *string
	caller        *string
	method        *inputlog.Method
	hmac_key      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*InputLog, error)
	predicates    []predicate.InputLog
}

var _ ent.Mutation = (*InputLogMutation)(nil)

// inputlogOption allows management of the mutation configuration using functional options.
type inputlogOption func(*InputLogMutation)

// newInputLogMutation creates new mutation for the InputLog entity.
func newInputLogMutation(c config, op Op, opts ...inputlogOption) *InputLogMutation {
	m := &InputLogMutation{
		config:        c,
		op:            op,
		typ:           TypeInputLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInputLogID sets the ID field of the mutation.
func withInputLogID(id int64) inputlogOption {
	return func(m *InputLogMutation) {
		var (
			err   error
			once  sync.Once
			value *InputLog
		)
		m.oldValue = func(ctx context.Context) (*InputLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InputLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInputLog sets the old InputLog of the mutation.
func withInputLog(node *InputLog) inputlogOption {
	return func(m *InputLogMutation) {
		m.oldValue = func(context.Context) (*InputLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InputLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InputLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InputLog entities.
func (m *InputLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InputLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InputLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InputLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *InputLogMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InputLogMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *InputLogMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *InputLogMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InputLogMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InputLogMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InputLogMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *InputLogMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *InputLogMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InputLogMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InputLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InputLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InputLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InputLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InputLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InputLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InputLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InputLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InputLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTraceID sets the "trace_id" field.
func (m *InputLogMutation) SetTraceID(i int64) {
	m.trace_id = &i
	m.addtrace_id = nil
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *InputLogMutation) TraceID() (r int64, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldTraceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// AddTraceID adds i to the "trace_id" field.
func (m *InputLogMutation) AddTraceID(i int64) {
	if m.addtrace_id != nil {
		*m.addtrace_id += i
	} else {
		m.addtrace_id = &i
	}
}

// AddedTraceID returns the value that was added to the "trace_id" field in this mutation.
func (m *InputLogMutation) AddedTraceID() (r int64, exists bool) {
	v := m.addtrace_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *InputLogMutation) ResetTraceID() {
	m.trace_id = nil
	m.addtrace_id = nil
}

// SetHeaders sets the "headers" field.
func (m *InputLogMutation) SetHeaders(s string) {
	m.headers = &s
}

// Headers returns the value of the "headers" field in the mutation.
func (m *InputLogMutation) Headers() (r string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldHeaders(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ResetHeaders resets all changes to the "headers" field.
func (m *InputLogMutation) ResetHeaders() {
	m.headers = nil
}

// SetBody sets the "body" field.
func (m *InputLogMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *InputLogMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *InputLogMutation) ClearBody() {
	m.body = nil
	m.clearedFields[inputlog.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *InputLogMutation) BodyCleared() bool {
	_, ok := m.clearedFields[inputlog.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *InputLogMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, inputlog.FieldBody)
}

// SetQuery sets the "query" field.
func (m *InputLogMutation) SetQuery(s string) {
	m.query = &s
}

// Query returns the value of the "query" field in the mutation.
func (m *InputLogMutation) Query() (r string, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ClearQuery clears the value of the "query" field.
func (m *InputLogMutation) ClearQuery() {
	m.query = nil
	m.clearedFields[inputlog.FieldQuery] = struct{}{}
}

// QueryCleared returns if the "query" field was cleared in this mutation.
func (m *InputLogMutation) QueryCleared() bool {
	_, ok := m.clearedFields[inputlog.FieldQuery]
	return ok
}

// ResetQuery resets all changes to the "query" field.
func (m *InputLogMutation) ResetQuery() {
	m.query = nil
	delete(m.clearedFields, inputlog.FieldQuery)
}

// SetURL sets the "url" field.
func (m *InputLogMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *InputLogMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *InputLogMutation) ResetURL() {
	m.url = nil
}

// SetIP sets the "ip" field.
func (m *InputLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *InputLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *InputLogMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[inputlog.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *InputLogMutation) IPCleared() bool {
	_, ok := m.clearedFields[inputlog.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *InputLogMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, inputlog.FieldIP)
}

// SetCaller sets the "caller" field.
func (m *InputLogMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *InputLogMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *InputLogMutation) ResetCaller() {
	m.caller = nil
}

// SetMethod sets the "method" field.
func (m *InputLogMutation) SetMethod(i inputlog.Method) {
	m.method = &i
}

// Method returns the value of the "method" field in the mutation.
func (m *InputLogMutation) Method() (r inputlog.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldMethod(ctx context.Context) (v inputlog.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *InputLogMutation) ResetMethod() {
	m.method = nil
}

// SetHmacKey sets the "hmac_key" field.
func (m *InputLogMutation) SetHmacKey(s string) {
	m.hmac_key = &s
}

// HmacKey returns the value of the "hmac_key" field in the mutation.
func (m *InputLogMutation) HmacKey() (r string, exists bool) {
	v := m.hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHmacKey returns the old "hmac_key" field's value of the InputLog entity.
// If the InputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InputLogMutation) OldHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHmacKey: %w", err)
	}
	return oldValue.HmacKey, nil
}

// ResetHmacKey resets all changes to the "hmac_key" field.
func (m *InputLogMutation) ResetHmacKey() {
	m.hmac_key = nil
}

// Where appends a list predicates to the InputLogMutation builder.
func (m *InputLogMutation) Where(ps ...predicate.InputLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InputLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InputLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InputLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InputLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InputLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InputLog).
func (m *InputLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InputLogMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, inputlog.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, inputlog.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, inputlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inputlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inputlog.FieldDeletedAt)
	}
	if m.trace_id != nil {
		fields = append(fields, inputlog.FieldTraceID)
	}
	if m.headers != nil {
		fields = append(fields, inputlog.FieldHeaders)
	}
	if m.body != nil {
		fields = append(fields, inputlog.FieldBody)
	}
	if m.query != nil {
		fields = append(fields, inputlog.FieldQuery)
	}
	if m.url != nil {
		fields = append(fields, inputlog.FieldURL)
	}
	if m.ip != nil {
		fields = append(fields, inputlog.FieldIP)
	}
	if m.caller != nil {
		fields = append(fields, inputlog.FieldCaller)
	}
	if m.method != nil {
		fields = append(fields, inputlog.FieldMethod)
	}
	if m.hmac_key != nil {
		fields = append(fields, inputlog.FieldHmacKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InputLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inputlog.FieldCreatedBy:
		return m.CreatedBy()
	case inputlog.FieldUpdatedBy:
		return m.UpdatedBy()
	case inputlog.FieldCreatedAt:
		return m.CreatedAt()
	case inputlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case inputlog.FieldDeletedAt:
		return m.DeletedAt()
	case inputlog.FieldTraceID:
		return m.TraceID()
	case inputlog.FieldHeaders:
		return m.Headers()
	case inputlog.FieldBody:
		return m.Body()
	case inputlog.FieldQuery:
		return m.Query()
	case inputlog.FieldURL:
		return m.URL()
	case inputlog.FieldIP:
		return m.IP()
	case inputlog.FieldCaller:
		return m.Caller()
	case inputlog.FieldMethod:
		return m.Method()
	case inputlog.FieldHmacKey:
		return m.HmacKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InputLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inputlog.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case inputlog.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case inputlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inputlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inputlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inputlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case inputlog.FieldHeaders:
		return m.OldHeaders(ctx)
	case inputlog.FieldBody:
		return m.OldBody(ctx)
	case inputlog.FieldQuery:
		return m.OldQuery(ctx)
	case inputlog.FieldURL:
		return m.OldURL(ctx)
	case inputlog.FieldIP:
		return m.OldIP(ctx)
	case inputlog.FieldCaller:
		return m.OldCaller(ctx)
	case inputlog.FieldMethod:
		return m.OldMethod(ctx)
	case inputlog.FieldHmacKey:
		return m.OldHmacKey(ctx)
	}
	return nil, fmt.Errorf("unknown InputLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InputLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case inputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case inputlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inputlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inputlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case inputlog.FieldHeaders:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case inputlog.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case inputlog.FieldQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case inputlog.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case inputlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case inputlog.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case inputlog.FieldMethod:
		v, ok := value.(inputlog.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case inputlog.FieldHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHmacKey(v)
		return nil
	}
	return fmt.Errorf("unknown InputLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InputLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, inputlog.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, inputlog.FieldUpdatedBy)
	}
	if m.addtrace_id != nil {
		fields = append(fields, inputlog.FieldTraceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InputLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inputlog.FieldCreatedBy:
		return m.AddedCreatedBy()
	case inputlog.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case inputlog.FieldTraceID:
		return m.AddedTraceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InputLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case inputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case inputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraceID(v)
		return nil
	}
	return fmt.Errorf("unknown InputLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InputLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inputlog.FieldBody) {
		fields = append(fields, inputlog.FieldBody)
	}
	if m.FieldCleared(inputlog.FieldQuery) {
		fields = append(fields, inputlog.FieldQuery)
	}
	if m.FieldCleared(inputlog.FieldIP) {
		fields = append(fields, inputlog.FieldIP)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InputLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InputLogMutation) ClearField(name string) error {
	switch name {
	case inputlog.FieldBody:
		m.ClearBody()
		return nil
	case inputlog.FieldQuery:
		m.ClearQuery()
		return nil
	case inputlog.FieldIP:
		m.ClearIP()
		return nil
	}
	return fmt.Errorf("unknown InputLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InputLogMutation) ResetField(name string) error {
	switch name {
	case inputlog.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case inputlog.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case inputlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inputlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inputlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inputlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case inputlog.FieldHeaders:
		m.ResetHeaders()
		return nil
	case inputlog.FieldBody:
		m.ResetBody()
		return nil
	case inputlog.FieldQuery:
		m.ResetQuery()
		return nil
	case inputlog.FieldURL:
		m.ResetURL()
		return nil
	case inputlog.FieldIP:
		m.ResetIP()
		return nil
	case inputlog.FieldCaller:
		m.ResetCaller()
		return nil
	case inputlog.FieldMethod:
		m.ResetMethod()
		return nil
	case inputlog.FieldHmacKey:
		m.ResetHmacKey()
		return nil
	}
	return fmt.Errorf("unknown InputLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InputLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InputLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InputLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InputLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InputLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InputLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InputLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InputLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InputLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InputLog edge %s", name)
}

// MissionMutation represents an operation that mutates the Mission nodes in the graph.
type MissionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_by                   *int64
	addcreated_by                *int64
	updated_by                   *int64
	addupdated_by                *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	_type                        *enums.MissionType
	body                         *string
	call_back_url                *string
	status                       *enums.MissionStatus
	result                       *enums.MissionResult
	result_urls                  *[]string
	appendresult_urls            []string
	mission_batch_number         *string
	gpu_version                  *enums.GpuVersion
	unit_cep                     *int64
	addunit_cep                  *int64
	resp_status_code             *int32
	addresp_status_code          *int32
	resp_body                    *string
	sd_api                       *string
	clearedFields                map[string]struct{}
	mission_key_pairs            map[int64]struct{}
	removedmission_key_pairs     map[int64]struct{}
	clearedmission_key_pairs     bool
	key_pair                     *int64
	clearedkey_pair              bool
	mission_consume_order        *int64
	clearedmission_consume_order bool
	done                         bool
	oldValue                     func(context.Context) (*Mission, error)
	predicates                   []predicate.Mission
}

var _ ent.Mutation = (*MissionMutation)(nil)

// missionOption allows management of the mutation configuration using functional options.
type missionOption func(*MissionMutation)

// newMissionMutation creates new mutation for the Mission entity.
func newMissionMutation(c config, op Op, opts ...missionOption) *MissionMutation {
	m := &MissionMutation{
		config:        c,
		op:            op,
		typ:           TypeMission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionID sets the ID field of the mutation.
func withMissionID(id int64) missionOption {
	return func(m *MissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Mission
		)
		m.oldValue = func(ctx context.Context) (*Mission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMission sets the old Mission of the mutation.
func withMission(node *Mission) missionOption {
	return func(m *MissionMutation) {
		m.oldValue = func(context.Context) (*Mission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mission entities.
func (m *MissionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *MissionMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionMutation) ResetType() {
	m._type = nil
}

// SetBody sets the "body" field.
func (m *MissionMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *MissionMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *MissionMutation) ResetBody() {
	m.body = nil
}

// SetCallBackURL sets the "call_back_url" field.
func (m *MissionMutation) SetCallBackURL(s string) {
	m.call_back_url = &s
}

// CallBackURL returns the value of the "call_back_url" field in the mutation.
func (m *MissionMutation) CallBackURL() (r string, exists bool) {
	v := m.call_back_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCallBackURL returns the old "call_back_url" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldCallBackURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallBackURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallBackURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallBackURL: %w", err)
	}
	return oldValue.CallBackURL, nil
}

// ResetCallBackURL resets all changes to the "call_back_url" field.
func (m *MissionMutation) ResetCallBackURL() {
	m.call_back_url = nil
}

// SetStatus sets the "status" field.
func (m *MissionMutation) SetStatus(es enums.MissionStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionMutation) Status() (r enums.MissionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldStatus(ctx context.Context) (v enums.MissionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionMutation) ResetStatus() {
	m.status = nil
}

// SetResult sets the "result" field.
func (m *MissionMutation) SetResult(er enums.MissionResult) {
	m.result = &er
}

// Result returns the value of the "result" field in the mutation.
func (m *MissionMutation) Result() (r enums.MissionResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldResult(ctx context.Context) (v enums.MissionResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *MissionMutation) ResetResult() {
	m.result = nil
}

// SetResultUrls sets the "result_urls" field.
func (m *MissionMutation) SetResultUrls(s []string) {
	m.result_urls = &s
	m.appendresult_urls = nil
}

// ResultUrls returns the value of the "result_urls" field in the mutation.
func (m *MissionMutation) ResultUrls() (r []string, exists bool) {
	v := m.result_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldResultUrls returns the old "result_urls" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldResultUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultUrls: %w", err)
	}
	return oldValue.ResultUrls, nil
}

// AppendResultUrls adds s to the "result_urls" field.
func (m *MissionMutation) AppendResultUrls(s []string) {
	m.appendresult_urls = append(m.appendresult_urls, s...)
}

// AppendedResultUrls returns the list of values that were appended to the "result_urls" field in this mutation.
func (m *MissionMutation) AppendedResultUrls() ([]string, bool) {
	if len(m.appendresult_urls) == 0 {
		return nil, false
	}
	return m.appendresult_urls, true
}

// ClearResultUrls clears the value of the "result_urls" field.
func (m *MissionMutation) ClearResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	m.clearedFields[mission.FieldResultUrls] = struct{}{}
}

// ResultUrlsCleared returns if the "result_urls" field was cleared in this mutation.
func (m *MissionMutation) ResultUrlsCleared() bool {
	_, ok := m.clearedFields[mission.FieldResultUrls]
	return ok
}

// ResetResultUrls resets all changes to the "result_urls" field.
func (m *MissionMutation) ResetResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	delete(m.clearedFields, mission.FieldResultUrls)
}

// SetKeyPairID sets the "key_pair_id" field.
func (m *MissionMutation) SetKeyPairID(i int64) {
	m.key_pair = &i
}

// KeyPairID returns the value of the "key_pair_id" field in the mutation.
func (m *MissionMutation) KeyPairID() (r int64, exists bool) {
	v := m.key_pair
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPairID returns the old "key_pair_id" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldKeyPairID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPairID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPairID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPairID: %w", err)
	}
	return oldValue.KeyPairID, nil
}

// ResetKeyPairID resets all changes to the "key_pair_id" field.
func (m *MissionMutation) ResetKeyPairID() {
	m.key_pair = nil
}

// SetMissionBatchNumber sets the "mission_batch_number" field.
func (m *MissionMutation) SetMissionBatchNumber(s string) {
	m.mission_batch_number = &s
}

// MissionBatchNumber returns the value of the "mission_batch_number" field in the mutation.
func (m *MissionMutation) MissionBatchNumber() (r string, exists bool) {
	v := m.mission_batch_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchNumber returns the old "mission_batch_number" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldMissionBatchNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchNumber: %w", err)
	}
	return oldValue.MissionBatchNumber, nil
}

// ResetMissionBatchNumber resets all changes to the "mission_batch_number" field.
func (m *MissionMutation) ResetMissionBatchNumber() {
	m.mission_batch_number = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *MissionMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *MissionMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *MissionMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetUnitCep sets the "unit_cep" field.
func (m *MissionMutation) SetUnitCep(i int64) {
	m.unit_cep = &i
	m.addunit_cep = nil
}

// UnitCep returns the value of the "unit_cep" field in the mutation.
func (m *MissionMutation) UnitCep() (r int64, exists bool) {
	v := m.unit_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCep returns the old "unit_cep" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldUnitCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCep: %w", err)
	}
	return oldValue.UnitCep, nil
}

// AddUnitCep adds i to the "unit_cep" field.
func (m *MissionMutation) AddUnitCep(i int64) {
	if m.addunit_cep != nil {
		*m.addunit_cep += i
	} else {
		m.addunit_cep = &i
	}
}

// AddedUnitCep returns the value that was added to the "unit_cep" field in this mutation.
func (m *MissionMutation) AddedUnitCep() (r int64, exists bool) {
	v := m.addunit_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitCep resets all changes to the "unit_cep" field.
func (m *MissionMutation) ResetUnitCep() {
	m.unit_cep = nil
	m.addunit_cep = nil
}

// SetRespStatusCode sets the "resp_status_code" field.
func (m *MissionMutation) SetRespStatusCode(i int32) {
	m.resp_status_code = &i
	m.addresp_status_code = nil
}

// RespStatusCode returns the value of the "resp_status_code" field in the mutation.
func (m *MissionMutation) RespStatusCode() (r int32, exists bool) {
	v := m.resp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRespStatusCode returns the old "resp_status_code" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldRespStatusCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespStatusCode: %w", err)
	}
	return oldValue.RespStatusCode, nil
}

// AddRespStatusCode adds i to the "resp_status_code" field.
func (m *MissionMutation) AddRespStatusCode(i int32) {
	if m.addresp_status_code != nil {
		*m.addresp_status_code += i
	} else {
		m.addresp_status_code = &i
	}
}

// AddedRespStatusCode returns the value that was added to the "resp_status_code" field in this mutation.
func (m *MissionMutation) AddedRespStatusCode() (r int32, exists bool) {
	v := m.addresp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetRespStatusCode resets all changes to the "resp_status_code" field.
func (m *MissionMutation) ResetRespStatusCode() {
	m.resp_status_code = nil
	m.addresp_status_code = nil
}

// SetRespBody sets the "resp_body" field.
func (m *MissionMutation) SetRespBody(s string) {
	m.resp_body = &s
}

// RespBody returns the value of the "resp_body" field in the mutation.
func (m *MissionMutation) RespBody() (r string, exists bool) {
	v := m.resp_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRespBody returns the old "resp_body" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldRespBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespBody: %w", err)
	}
	return oldValue.RespBody, nil
}

// ResetRespBody resets all changes to the "resp_body" field.
func (m *MissionMutation) ResetRespBody() {
	m.resp_body = nil
}

// SetSdAPI sets the "sd_api" field.
func (m *MissionMutation) SetSdAPI(s string) {
	m.sd_api = &s
}

// SdAPI returns the value of the "sd_api" field in the mutation.
func (m *MissionMutation) SdAPI() (r string, exists bool) {
	v := m.sd_api
	if v == nil {
		return
	}
	return *v, true
}

// OldSdAPI returns the old "sd_api" field's value of the Mission entity.
// If the Mission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionMutation) OldSdAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSdAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSdAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSdAPI: %w", err)
	}
	return oldValue.SdAPI, nil
}

// ResetSdAPI resets all changes to the "sd_api" field.
func (m *MissionMutation) ResetSdAPI() {
	m.sd_api = nil
}

// AddMissionKeyPairIDs adds the "mission_key_pairs" edge to the MissionKeyPair entity by ids.
func (m *MissionMutation) AddMissionKeyPairIDs(ids ...int64) {
	if m.mission_key_pairs == nil {
		m.mission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_key_pairs[ids[i]] = struct{}{}
	}
}

// ClearMissionKeyPairs clears the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *MissionMutation) ClearMissionKeyPairs() {
	m.clearedmission_key_pairs = true
}

// MissionKeyPairsCleared reports if the "mission_key_pairs" edge to the MissionKeyPair entity was cleared.
func (m *MissionMutation) MissionKeyPairsCleared() bool {
	return m.clearedmission_key_pairs
}

// RemoveMissionKeyPairIDs removes the "mission_key_pairs" edge to the MissionKeyPair entity by IDs.
func (m *MissionMutation) RemoveMissionKeyPairIDs(ids ...int64) {
	if m.removedmission_key_pairs == nil {
		m.removedmission_key_pairs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_key_pairs, ids[i])
		m.removedmission_key_pairs[ids[i]] = struct{}{}
	}
}

// RemovedMissionKeyPairs returns the removed IDs of the "mission_key_pairs" edge to the MissionKeyPair entity.
func (m *MissionMutation) RemovedMissionKeyPairsIDs() (ids []int64) {
	for id := range m.removedmission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// MissionKeyPairsIDs returns the "mission_key_pairs" edge IDs in the mutation.
func (m *MissionMutation) MissionKeyPairsIDs() (ids []int64) {
	for id := range m.mission_key_pairs {
		ids = append(ids, id)
	}
	return
}

// ResetMissionKeyPairs resets all changes to the "mission_key_pairs" edge.
func (m *MissionMutation) ResetMissionKeyPairs() {
	m.mission_key_pairs = nil
	m.clearedmission_key_pairs = false
	m.removedmission_key_pairs = nil
}

// ClearKeyPair clears the "key_pair" edge to the HmacKeyPair entity.
func (m *MissionMutation) ClearKeyPair() {
	m.clearedkey_pair = true
	m.clearedFields[mission.FieldKeyPairID] = struct{}{}
}

// KeyPairCleared reports if the "key_pair" edge to the HmacKeyPair entity was cleared.
func (m *MissionMutation) KeyPairCleared() bool {
	return m.clearedkey_pair
}

// KeyPairIDs returns the "key_pair" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeyPairID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) KeyPairIDs() (ids []int64) {
	if id := m.key_pair; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeyPair resets all changes to the "key_pair" edge.
func (m *MissionMutation) ResetKeyPair() {
	m.key_pair = nil
	m.clearedkey_pair = false
}

// SetMissionConsumeOrderID sets the "mission_consume_order" edge to the MissionConsumeOrder entity by id.
func (m *MissionMutation) SetMissionConsumeOrderID(id int64) {
	m.mission_consume_order = &id
}

// ClearMissionConsumeOrder clears the "mission_consume_order" edge to the MissionConsumeOrder entity.
func (m *MissionMutation) ClearMissionConsumeOrder() {
	m.clearedmission_consume_order = true
}

// MissionConsumeOrderCleared reports if the "mission_consume_order" edge to the MissionConsumeOrder entity was cleared.
func (m *MissionMutation) MissionConsumeOrderCleared() bool {
	return m.clearedmission_consume_order
}

// MissionConsumeOrderID returns the "mission_consume_order" edge ID in the mutation.
func (m *MissionMutation) MissionConsumeOrderID() (id int64, exists bool) {
	if m.mission_consume_order != nil {
		return *m.mission_consume_order, true
	}
	return
}

// MissionConsumeOrderIDs returns the "mission_consume_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionConsumeOrderID instead. It exists only for internal usage by the builders.
func (m *MissionMutation) MissionConsumeOrderIDs() (ids []int64) {
	if id := m.mission_consume_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionConsumeOrder resets all changes to the "mission_consume_order" edge.
func (m *MissionMutation) ResetMissionConsumeOrder() {
	m.mission_consume_order = nil
	m.clearedmission_consume_order = false
}

// Where appends a list predicates to the MissionMutation builder.
func (m *MissionMutation) Where(ps ...predicate.Mission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mission).
func (m *MissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_by != nil {
		fields = append(fields, mission.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, mission.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, mission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, mission.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, mission.FieldType)
	}
	if m.body != nil {
		fields = append(fields, mission.FieldBody)
	}
	if m.call_back_url != nil {
		fields = append(fields, mission.FieldCallBackURL)
	}
	if m.status != nil {
		fields = append(fields, mission.FieldStatus)
	}
	if m.result != nil {
		fields = append(fields, mission.FieldResult)
	}
	if m.result_urls != nil {
		fields = append(fields, mission.FieldResultUrls)
	}
	if m.key_pair != nil {
		fields = append(fields, mission.FieldKeyPairID)
	}
	if m.mission_batch_number != nil {
		fields = append(fields, mission.FieldMissionBatchNumber)
	}
	if m.gpu_version != nil {
		fields = append(fields, mission.FieldGpuVersion)
	}
	if m.unit_cep != nil {
		fields = append(fields, mission.FieldUnitCep)
	}
	if m.resp_status_code != nil {
		fields = append(fields, mission.FieldRespStatusCode)
	}
	if m.resp_body != nil {
		fields = append(fields, mission.FieldRespBody)
	}
	if m.sd_api != nil {
		fields = append(fields, mission.FieldSdAPI)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mission.FieldCreatedBy:
		return m.CreatedBy()
	case mission.FieldUpdatedBy:
		return m.UpdatedBy()
	case mission.FieldCreatedAt:
		return m.CreatedAt()
	case mission.FieldUpdatedAt:
		return m.UpdatedAt()
	case mission.FieldDeletedAt:
		return m.DeletedAt()
	case mission.FieldType:
		return m.GetType()
	case mission.FieldBody:
		return m.Body()
	case mission.FieldCallBackURL:
		return m.CallBackURL()
	case mission.FieldStatus:
		return m.Status()
	case mission.FieldResult:
		return m.Result()
	case mission.FieldResultUrls:
		return m.ResultUrls()
	case mission.FieldKeyPairID:
		return m.KeyPairID()
	case mission.FieldMissionBatchNumber:
		return m.MissionBatchNumber()
	case mission.FieldGpuVersion:
		return m.GpuVersion()
	case mission.FieldUnitCep:
		return m.UnitCep()
	case mission.FieldRespStatusCode:
		return m.RespStatusCode()
	case mission.FieldRespBody:
		return m.RespBody()
	case mission.FieldSdAPI:
		return m.SdAPI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case mission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case mission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mission.FieldType:
		return m.OldType(ctx)
	case mission.FieldBody:
		return m.OldBody(ctx)
	case mission.FieldCallBackURL:
		return m.OldCallBackURL(ctx)
	case mission.FieldStatus:
		return m.OldStatus(ctx)
	case mission.FieldResult:
		return m.OldResult(ctx)
	case mission.FieldResultUrls:
		return m.OldResultUrls(ctx)
	case mission.FieldKeyPairID:
		return m.OldKeyPairID(ctx)
	case mission.FieldMissionBatchNumber:
		return m.OldMissionBatchNumber(ctx)
	case mission.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case mission.FieldUnitCep:
		return m.OldUnitCep(ctx)
	case mission.FieldRespStatusCode:
		return m.OldRespStatusCode(ctx)
	case mission.FieldRespBody:
		return m.OldRespBody(ctx)
	case mission.FieldSdAPI:
		return m.OldSdAPI(ctx)
	}
	return nil, fmt.Errorf("unknown Mission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case mission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case mission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mission.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case mission.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case mission.FieldCallBackURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallBackURL(v)
		return nil
	case mission.FieldStatus:
		v, ok := value.(enums.MissionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mission.FieldResult:
		v, ok := value.(enums.MissionResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case mission.FieldResultUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultUrls(v)
		return nil
	case mission.FieldKeyPairID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPairID(v)
		return nil
	case mission.FieldMissionBatchNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchNumber(v)
		return nil
	case mission.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case mission.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCep(v)
		return nil
	case mission.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespStatusCode(v)
		return nil
	case mission.FieldRespBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespBody(v)
		return nil
	case mission.FieldSdAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSdAPI(v)
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, mission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, mission.FieldUpdatedBy)
	}
	if m.addunit_cep != nil {
		fields = append(fields, mission.FieldUnitCep)
	}
	if m.addresp_status_code != nil {
		fields = append(fields, mission.FieldRespStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case mission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case mission.FieldUnitCep:
		return m.AddedUnitCep()
	case mission.FieldRespStatusCode:
		return m.AddedRespStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mission.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case mission.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case mission.FieldUnitCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCep(v)
		return nil
	case mission.FieldRespStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRespStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown Mission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mission.FieldResultUrls) {
		fields = append(fields, mission.FieldResultUrls)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionMutation) ClearField(name string) error {
	switch name {
	case mission.FieldResultUrls:
		m.ClearResultUrls()
		return nil
	}
	return fmt.Errorf("unknown Mission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionMutation) ResetField(name string) error {
	switch name {
	case mission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case mission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case mission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mission.FieldType:
		m.ResetType()
		return nil
	case mission.FieldBody:
		m.ResetBody()
		return nil
	case mission.FieldCallBackURL:
		m.ResetCallBackURL()
		return nil
	case mission.FieldStatus:
		m.ResetStatus()
		return nil
	case mission.FieldResult:
		m.ResetResult()
		return nil
	case mission.FieldResultUrls:
		m.ResetResultUrls()
		return nil
	case mission.FieldKeyPairID:
		m.ResetKeyPairID()
		return nil
	case mission.FieldMissionBatchNumber:
		m.ResetMissionBatchNumber()
		return nil
	case mission.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case mission.FieldUnitCep:
		m.ResetUnitCep()
		return nil
	case mission.FieldRespStatusCode:
		m.ResetRespStatusCode()
		return nil
	case mission.FieldRespBody:
		m.ResetRespBody()
		return nil
	case mission.FieldSdAPI:
		m.ResetSdAPI()
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.mission_key_pairs != nil {
		edges = append(edges, mission.EdgeMissionKeyPairs)
	}
	if m.key_pair != nil {
		edges = append(edges, mission.EdgeKeyPair)
	}
	if m.mission_consume_order != nil {
		edges = append(edges, mission.EdgeMissionConsumeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.mission_key_pairs))
		for id := range m.mission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeKeyPair:
		if id := m.key_pair; id != nil {
			return []ent.Value{*id}
		}
	case mission.EdgeMissionConsumeOrder:
		if id := m.mission_consume_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmission_key_pairs != nil {
		edges = append(edges, mission.EdgeMissionKeyPairs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeMissionKeyPairs:
		ids := make([]ent.Value, 0, len(m.removedmission_key_pairs))
		for id := range m.removedmission_key_pairs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmission_key_pairs {
		edges = append(edges, mission.EdgeMissionKeyPairs)
	}
	if m.clearedkey_pair {
		edges = append(edges, mission.EdgeKeyPair)
	}
	if m.clearedmission_consume_order {
		edges = append(edges, mission.EdgeMissionConsumeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionMutation) EdgeCleared(name string) bool {
	switch name {
	case mission.EdgeMissionKeyPairs:
		return m.clearedmission_key_pairs
	case mission.EdgeKeyPair:
		return m.clearedkey_pair
	case mission.EdgeMissionConsumeOrder:
		return m.clearedmission_consume_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionMutation) ClearEdge(name string) error {
	switch name {
	case mission.EdgeKeyPair:
		m.ClearKeyPair()
		return nil
	case mission.EdgeMissionConsumeOrder:
		m.ClearMissionConsumeOrder()
		return nil
	}
	return fmt.Errorf("unknown Mission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionMutation) ResetEdge(name string) error {
	switch name {
	case mission.EdgeMissionKeyPairs:
		m.ResetMissionKeyPairs()
		return nil
	case mission.EdgeKeyPair:
		m.ResetKeyPair()
		return nil
	case mission.EdgeMissionConsumeOrder:
		m.ResetMissionConsumeOrder()
		return nil
	}
	return fmt.Errorf("unknown Mission edge %s", name)
}

// MissionBatchMutation represents an operation that mutates the MissionBatch nodes in the graph.
type MissionBatchMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	number                        *string
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	mission_consume_orders        map[int64]struct{}
	removedmission_consume_orders map[int64]struct{}
	clearedmission_consume_orders bool
	done                          bool
	oldValue                      func(context.Context) (*MissionBatch, error)
	predicates                    []predicate.MissionBatch
}

var _ ent.Mutation = (*MissionBatchMutation)(nil)

// missionbatchOption allows management of the mutation configuration using functional options.
type missionbatchOption func(*MissionBatchMutation)

// newMissionBatchMutation creates new mutation for the MissionBatch entity.
func newMissionBatchMutation(c config, op Op, opts ...missionbatchOption) *MissionBatchMutation {
	m := &MissionBatchMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionBatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionBatchID sets the ID field of the mutation.
func withMissionBatchID(id int64) missionbatchOption {
	return func(m *MissionBatchMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionBatch
		)
		m.oldValue = func(ctx context.Context) (*MissionBatch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionBatch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionBatch sets the old MissionBatch of the mutation.
func withMissionBatch(node *MissionBatch) missionbatchOption {
	return func(m *MissionBatchMutation) {
		m.oldValue = func(context.Context) (*MissionBatch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionBatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionBatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionBatch entities.
func (m *MissionBatchMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionBatchMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionBatchMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionBatch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionBatchMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionBatchMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionBatchMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionBatchMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionBatchMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionBatchMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionBatchMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionBatchMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionBatchMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionBatchMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionBatchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionBatchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionBatchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionBatchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionBatchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionBatchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionBatchMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionBatchMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionBatchMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetNumber sets the "number" field.
func (m *MissionBatchMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *MissionBatchMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *MissionBatchMutation) ResetNumber() {
	m.number = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionBatchMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionBatchMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionBatch entity.
// If the MissionBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionBatchMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionBatchMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionBatchMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionbatch.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionBatchMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionBatchMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionBatchMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMissionConsumeOrderIDs adds the "mission_consume_orders" edge to the MissionConsumeOrder entity by ids.
func (m *MissionBatchMutation) AddMissionConsumeOrderIDs(ids ...int64) {
	if m.mission_consume_orders == nil {
		m.mission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_consume_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionConsumeOrders clears the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *MissionBatchMutation) ClearMissionConsumeOrders() {
	m.clearedmission_consume_orders = true
}

// MissionConsumeOrdersCleared reports if the "mission_consume_orders" edge to the MissionConsumeOrder entity was cleared.
func (m *MissionBatchMutation) MissionConsumeOrdersCleared() bool {
	return m.clearedmission_consume_orders
}

// RemoveMissionConsumeOrderIDs removes the "mission_consume_orders" edge to the MissionConsumeOrder entity by IDs.
func (m *MissionBatchMutation) RemoveMissionConsumeOrderIDs(ids ...int64) {
	if m.removedmission_consume_orders == nil {
		m.removedmission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_consume_orders, ids[i])
		m.removedmission_consume_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionConsumeOrders returns the removed IDs of the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *MissionBatchMutation) RemovedMissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.removedmission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// MissionConsumeOrdersIDs returns the "mission_consume_orders" edge IDs in the mutation.
func (m *MissionBatchMutation) MissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.mission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionConsumeOrders resets all changes to the "mission_consume_orders" edge.
func (m *MissionBatchMutation) ResetMissionConsumeOrders() {
	m.mission_consume_orders = nil
	m.clearedmission_consume_orders = false
	m.removedmission_consume_orders = nil
}

// Where appends a list predicates to the MissionBatchMutation builder.
func (m *MissionBatchMutation) Where(ps ...predicate.MissionBatch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionBatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionBatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionBatch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionBatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionBatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionBatch).
func (m *MissionBatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionBatchMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, missionbatch.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionbatch.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionbatch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionbatch.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionbatch.FieldDeletedAt)
	}
	if m.number != nil {
		fields = append(fields, missionbatch.FieldNumber)
	}
	if m.user != nil {
		fields = append(fields, missionbatch.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionBatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionbatch.FieldCreatedBy:
		return m.CreatedBy()
	case missionbatch.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionbatch.FieldCreatedAt:
		return m.CreatedAt()
	case missionbatch.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionbatch.FieldDeletedAt:
		return m.DeletedAt()
	case missionbatch.FieldNumber:
		return m.Number()
	case missionbatch.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionBatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionbatch.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionbatch.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionbatch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionbatch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionbatch.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionbatch.FieldNumber:
		return m.OldNumber(ctx)
	case missionbatch.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown MissionBatch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionBatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionbatch.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionbatch.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionbatch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionbatch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionbatch.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionbatch.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case missionbatch.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionBatch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionBatchMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionbatch.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionbatch.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionBatchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionbatch.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionbatch.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionBatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionbatch.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionbatch.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MissionBatch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionBatchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionBatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionBatchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionBatch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionBatchMutation) ResetField(name string) error {
	switch name {
	case missionbatch.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionbatch.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionbatch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionbatch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionbatch.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionbatch.FieldNumber:
		m.ResetNumber()
		return nil
	case missionbatch.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown MissionBatch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionBatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, missionbatch.EdgeUser)
	}
	if m.mission_consume_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionConsumeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionBatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionbatch.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionbatch.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.mission_consume_orders))
		for id := range m.mission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionBatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmission_consume_orders != nil {
		edges = append(edges, missionbatch.EdgeMissionConsumeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionBatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionbatch.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_consume_orders))
		for id := range m.removedmission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionBatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, missionbatch.EdgeUser)
	}
	if m.clearedmission_consume_orders {
		edges = append(edges, missionbatch.EdgeMissionConsumeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionBatchMutation) EdgeCleared(name string) bool {
	switch name {
	case missionbatch.EdgeUser:
		return m.cleareduser
	case missionbatch.EdgeMissionConsumeOrders:
		return m.clearedmission_consume_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionBatchMutation) ClearEdge(name string) error {
	switch name {
	case missionbatch.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown MissionBatch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionBatchMutation) ResetEdge(name string) error {
	switch name {
	case missionbatch.EdgeUser:
		m.ResetUser()
		return nil
	case missionbatch.EdgeMissionConsumeOrders:
		m.ResetMissionConsumeOrders()
		return nil
	}
	return fmt.Errorf("unknown MissionBatch edge %s", name)
}

// MissionConsumeOrderMutation represents an operation that mutates the MissionConsumeOrder nodes in the graph.
type MissionConsumeOrderMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	status                        *enums.MissionOrderStatus
	pure_cep                      *int64
	addpure_cep                   *int64
	gift_cep                      *int64
	addgift_cep                   *int64
	_type                         *enums.MissionType
	is_time                       *bool
	call_way                      *enums.MissionCallWay
	serial_number                 *string
	started_at                    *time.Time
	finished_at                   *time.Time
	mission_batch_number          *string
	clearedFields                 map[string]struct{}
	user                          *int64
	cleareduser                   bool
	cost_bills                    map[int64]struct{}
	removedcost_bills             map[int64]struct{}
	clearedcost_bills             bool
	mission_produce_orders        map[int64]struct{}
	removedmission_produce_orders map[int64]struct{}
	clearedmission_produce_orders bool
	mission_batch                 *int64
	clearedmission_batch          bool
	mission                       *int64
	clearedmission                bool
	done                          bool
	oldValue                      func(context.Context) (*MissionConsumeOrder, error)
	predicates                    []predicate.MissionConsumeOrder
}

var _ ent.Mutation = (*MissionConsumeOrderMutation)(nil)

// missionconsumeorderOption allows management of the mutation configuration using functional options.
type missionconsumeorderOption func(*MissionConsumeOrderMutation)

// newMissionConsumeOrderMutation creates new mutation for the MissionConsumeOrder entity.
func newMissionConsumeOrderMutation(c config, op Op, opts ...missionconsumeorderOption) *MissionConsumeOrderMutation {
	m := &MissionConsumeOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionConsumeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionConsumeOrderID sets the ID field of the mutation.
func withMissionConsumeOrderID(id int64) missionconsumeorderOption {
	return func(m *MissionConsumeOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionConsumeOrder
		)
		m.oldValue = func(ctx context.Context) (*MissionConsumeOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionConsumeOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionConsumeOrder sets the old MissionConsumeOrder of the mutation.
func withMissionConsumeOrder(node *MissionConsumeOrder) missionconsumeorderOption {
	return func(m *MissionConsumeOrderMutation) {
		m.oldValue = func(context.Context) (*MissionConsumeOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionConsumeOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionConsumeOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionConsumeOrder entities.
func (m *MissionConsumeOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionConsumeOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionConsumeOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionConsumeOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionConsumeOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionConsumeOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionConsumeOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionConsumeOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionConsumeOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionConsumeOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionConsumeOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionConsumeOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionConsumeOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionConsumeOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionConsumeOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionConsumeOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionConsumeOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionConsumeOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionConsumeOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionConsumeOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionConsumeOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionConsumeOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionConsumeOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionConsumeOrderMutation) ResetUserID() {
	m.user = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionConsumeOrderMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionConsumeOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionConsumeOrderMutation) ResetMissionID() {
	m.mission = nil
}

// SetStatus sets the "status" field.
func (m *MissionConsumeOrderMutation) SetStatus(eos enums.MissionOrderStatus) {
	m.status = &eos
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionConsumeOrderMutation) Status() (r enums.MissionOrderStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldStatus(ctx context.Context) (v enums.MissionOrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionConsumeOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *MissionConsumeOrderMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *MissionConsumeOrderMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *MissionConsumeOrderMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *MissionConsumeOrderMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *MissionConsumeOrderMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *MissionConsumeOrderMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *MissionConsumeOrderMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *MissionConsumeOrderMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *MissionConsumeOrderMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetType sets the "type" field.
func (m *MissionConsumeOrderMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionConsumeOrderMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionConsumeOrderMutation) ResetType() {
	m._type = nil
}

// SetIsTime sets the "is_time" field.
func (m *MissionConsumeOrderMutation) SetIsTime(b bool) {
	m.is_time = &b
}

// IsTime returns the value of the "is_time" field in the mutation.
func (m *MissionConsumeOrderMutation) IsTime() (r bool, exists bool) {
	v := m.is_time
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTime returns the old "is_time" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldIsTime(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTime: %w", err)
	}
	return oldValue.IsTime, nil
}

// ResetIsTime resets all changes to the "is_time" field.
func (m *MissionConsumeOrderMutation) ResetIsTime() {
	m.is_time = nil
}

// SetCallWay sets the "call_way" field.
func (m *MissionConsumeOrderMutation) SetCallWay(ecw enums.MissionCallWay) {
	m.call_way = &ecw
}

// CallWay returns the value of the "call_way" field in the mutation.
func (m *MissionConsumeOrderMutation) CallWay() (r enums.MissionCallWay, exists bool) {
	v := m.call_way
	if v == nil {
		return
	}
	return *v, true
}

// OldCallWay returns the old "call_way" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldCallWay(ctx context.Context) (v enums.MissionCallWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallWay: %w", err)
	}
	return oldValue.CallWay, nil
}

// ResetCallWay resets all changes to the "call_way" field.
func (m *MissionConsumeOrderMutation) ResetCallWay() {
	m.call_way = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *MissionConsumeOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MissionConsumeOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MissionConsumeOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionConsumeOrderMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionConsumeOrderMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionConsumeOrderMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionConsumeOrderMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionConsumeOrderMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionConsumeOrderMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetMissionBatchID sets the "mission_batch_id" field.
func (m *MissionConsumeOrderMutation) SetMissionBatchID(i int64) {
	m.mission_batch = &i
}

// MissionBatchID returns the value of the "mission_batch_id" field in the mutation.
func (m *MissionConsumeOrderMutation) MissionBatchID() (r int64, exists bool) {
	v := m.mission_batch
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchID returns the old "mission_batch_id" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldMissionBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchID: %w", err)
	}
	return oldValue.MissionBatchID, nil
}

// ResetMissionBatchID resets all changes to the "mission_batch_id" field.
func (m *MissionConsumeOrderMutation) ResetMissionBatchID() {
	m.mission_batch = nil
}

// SetMissionBatchNumber sets the "mission_batch_number" field.
func (m *MissionConsumeOrderMutation) SetMissionBatchNumber(s string) {
	m.mission_batch_number = &s
}

// MissionBatchNumber returns the value of the "mission_batch_number" field in the mutation.
func (m *MissionConsumeOrderMutation) MissionBatchNumber() (r string, exists bool) {
	v := m.mission_batch_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBatchNumber returns the old "mission_batch_number" field's value of the MissionConsumeOrder entity.
// If the MissionConsumeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionConsumeOrderMutation) OldMissionBatchNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBatchNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBatchNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBatchNumber: %w", err)
	}
	return oldValue.MissionBatchNumber, nil
}

// ResetMissionBatchNumber resets all changes to the "mission_batch_number" field.
func (m *MissionConsumeOrderMutation) ResetMissionBatchNumber() {
	m.mission_batch_number = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionConsumeOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionconsumeorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionConsumeOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionConsumeOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionConsumeOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *MissionConsumeOrderMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *MissionConsumeOrderMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *MissionConsumeOrderMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *MissionConsumeOrderMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *MissionConsumeOrderMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *MissionConsumeOrderMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *MissionConsumeOrderMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *MissionConsumeOrderMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionConsumeOrderMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *MissionConsumeOrderMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *MissionConsumeOrderMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *MissionConsumeOrderMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *MissionConsumeOrderMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *MissionConsumeOrderMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// ClearMissionBatch clears the "mission_batch" edge to the MissionBatch entity.
func (m *MissionConsumeOrderMutation) ClearMissionBatch() {
	m.clearedmission_batch = true
	m.clearedFields[missionconsumeorder.FieldMissionBatchID] = struct{}{}
}

// MissionBatchCleared reports if the "mission_batch" edge to the MissionBatch entity was cleared.
func (m *MissionConsumeOrderMutation) MissionBatchCleared() bool {
	return m.clearedmission_batch
}

// MissionBatchIDs returns the "mission_batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionBatchID instead. It exists only for internal usage by the builders.
func (m *MissionConsumeOrderMutation) MissionBatchIDs() (ids []int64) {
	if id := m.mission_batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionBatch resets all changes to the "mission_batch" edge.
func (m *MissionConsumeOrderMutation) ResetMissionBatch() {
	m.mission_batch = nil
	m.clearedmission_batch = false
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionConsumeOrderMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionconsumeorder.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionConsumeOrderMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionConsumeOrderMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionConsumeOrderMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// Where appends a list predicates to the MissionConsumeOrderMutation builder.
func (m *MissionConsumeOrderMutation) Where(ps ...predicate.MissionConsumeOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionConsumeOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionConsumeOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionConsumeOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionConsumeOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionConsumeOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionConsumeOrder).
func (m *MissionConsumeOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionConsumeOrderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_by != nil {
		fields = append(fields, missionconsumeorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionconsumeorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionconsumeorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionconsumeorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionconsumeorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, missionconsumeorder.FieldUserID)
	}
	if m.mission != nil {
		fields = append(fields, missionconsumeorder.FieldMissionID)
	}
	if m.status != nil {
		fields = append(fields, missionconsumeorder.FieldStatus)
	}
	if m.pure_cep != nil {
		fields = append(fields, missionconsumeorder.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, missionconsumeorder.FieldGiftCep)
	}
	if m._type != nil {
		fields = append(fields, missionconsumeorder.FieldType)
	}
	if m.is_time != nil {
		fields = append(fields, missionconsumeorder.FieldIsTime)
	}
	if m.call_way != nil {
		fields = append(fields, missionconsumeorder.FieldCallWay)
	}
	if m.serial_number != nil {
		fields = append(fields, missionconsumeorder.FieldSerialNumber)
	}
	if m.started_at != nil {
		fields = append(fields, missionconsumeorder.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionconsumeorder.FieldFinishedAt)
	}
	if m.mission_batch != nil {
		fields = append(fields, missionconsumeorder.FieldMissionBatchID)
	}
	if m.mission_batch_number != nil {
		fields = append(fields, missionconsumeorder.FieldMissionBatchNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionConsumeOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		return m.CreatedBy()
	case missionconsumeorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionconsumeorder.FieldCreatedAt:
		return m.CreatedAt()
	case missionconsumeorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionconsumeorder.FieldDeletedAt:
		return m.DeletedAt()
	case missionconsumeorder.FieldUserID:
		return m.UserID()
	case missionconsumeorder.FieldMissionID:
		return m.MissionID()
	case missionconsumeorder.FieldStatus:
		return m.Status()
	case missionconsumeorder.FieldPureCep:
		return m.PureCep()
	case missionconsumeorder.FieldGiftCep:
		return m.GiftCep()
	case missionconsumeorder.FieldType:
		return m.GetType()
	case missionconsumeorder.FieldIsTime:
		return m.IsTime()
	case missionconsumeorder.FieldCallWay:
		return m.CallWay()
	case missionconsumeorder.FieldSerialNumber:
		return m.SerialNumber()
	case missionconsumeorder.FieldStartedAt:
		return m.StartedAt()
	case missionconsumeorder.FieldFinishedAt:
		return m.FinishedAt()
	case missionconsumeorder.FieldMissionBatchID:
		return m.MissionBatchID()
	case missionconsumeorder.FieldMissionBatchNumber:
		return m.MissionBatchNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionConsumeOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionconsumeorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionconsumeorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionconsumeorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionconsumeorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionconsumeorder.FieldUserID:
		return m.OldUserID(ctx)
	case missionconsumeorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionconsumeorder.FieldStatus:
		return m.OldStatus(ctx)
	case missionconsumeorder.FieldPureCep:
		return m.OldPureCep(ctx)
	case missionconsumeorder.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case missionconsumeorder.FieldType:
		return m.OldType(ctx)
	case missionconsumeorder.FieldIsTime:
		return m.OldIsTime(ctx)
	case missionconsumeorder.FieldCallWay:
		return m.OldCallWay(ctx)
	case missionconsumeorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case missionconsumeorder.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionconsumeorder.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionconsumeorder.FieldMissionBatchID:
		return m.OldMissionBatchID(ctx)
	case missionconsumeorder.FieldMissionBatchNumber:
		return m.OldMissionBatchNumber(ctx)
	}
	return nil, fmt.Errorf("unknown MissionConsumeOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionConsumeOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionconsumeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionconsumeorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionconsumeorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionconsumeorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionconsumeorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case missionconsumeorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionconsumeorder.FieldStatus:
		v, ok := value.(enums.MissionOrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case missionconsumeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case missionconsumeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case missionconsumeorder.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionconsumeorder.FieldIsTime:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTime(v)
		return nil
	case missionconsumeorder.FieldCallWay:
		v, ok := value.(enums.MissionCallWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallWay(v)
		return nil
	case missionconsumeorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case missionconsumeorder.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionconsumeorder.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionconsumeorder.FieldMissionBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchID(v)
		return nil
	case missionconsumeorder.FieldMissionBatchNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBatchNumber(v)
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionConsumeOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionconsumeorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionconsumeorder.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, missionconsumeorder.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, missionconsumeorder.FieldGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionConsumeOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionconsumeorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionconsumeorder.FieldPureCep:
		return m.AddedPureCep()
	case missionconsumeorder.FieldGiftCep:
		return m.AddedGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionConsumeOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionconsumeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionconsumeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case missionconsumeorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionConsumeOrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionConsumeOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionConsumeOrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionConsumeOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionConsumeOrderMutation) ResetField(name string) error {
	switch name {
	case missionconsumeorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionconsumeorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionconsumeorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionconsumeorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionconsumeorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionconsumeorder.FieldUserID:
		m.ResetUserID()
		return nil
	case missionconsumeorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionconsumeorder.FieldStatus:
		m.ResetStatus()
		return nil
	case missionconsumeorder.FieldPureCep:
		m.ResetPureCep()
		return nil
	case missionconsumeorder.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case missionconsumeorder.FieldType:
		m.ResetType()
		return nil
	case missionconsumeorder.FieldIsTime:
		m.ResetIsTime()
		return nil
	case missionconsumeorder.FieldCallWay:
		m.ResetCallWay()
		return nil
	case missionconsumeorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case missionconsumeorder.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionconsumeorder.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionconsumeorder.FieldMissionBatchID:
		m.ResetMissionBatchID()
		return nil
	case missionconsumeorder.FieldMissionBatchNumber:
		m.ResetMissionBatchNumber()
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionConsumeOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, missionconsumeorder.EdgeUser)
	}
	if m.cost_bills != nil {
		edges = append(edges, missionconsumeorder.EdgeCostBills)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, missionconsumeorder.EdgeMissionProduceOrders)
	}
	if m.mission_batch != nil {
		edges = append(edges, missionconsumeorder.EdgeMissionBatch)
	}
	if m.mission != nil {
		edges = append(edges, missionconsumeorder.EdgeMission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionConsumeOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionconsumeorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionconsumeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case missionconsumeorder.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case missionconsumeorder.EdgeMissionBatch:
		if id := m.mission_batch; id != nil {
			return []ent.Value{*id}
		}
	case missionconsumeorder.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionConsumeOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcost_bills != nil {
		edges = append(edges, missionconsumeorder.EdgeCostBills)
	}
	if m.removedmission_produce_orders != nil {
		edges = append(edges, missionconsumeorder.EdgeMissionProduceOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionConsumeOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionconsumeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	case missionconsumeorder.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionConsumeOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, missionconsumeorder.EdgeUser)
	}
	if m.clearedcost_bills {
		edges = append(edges, missionconsumeorder.EdgeCostBills)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, missionconsumeorder.EdgeMissionProduceOrders)
	}
	if m.clearedmission_batch {
		edges = append(edges, missionconsumeorder.EdgeMissionBatch)
	}
	if m.clearedmission {
		edges = append(edges, missionconsumeorder.EdgeMission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionConsumeOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case missionconsumeorder.EdgeUser:
		return m.cleareduser
	case missionconsumeorder.EdgeCostBills:
		return m.clearedcost_bills
	case missionconsumeorder.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case missionconsumeorder.EdgeMissionBatch:
		return m.clearedmission_batch
	case missionconsumeorder.EdgeMission:
		return m.clearedmission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionConsumeOrderMutation) ClearEdge(name string) error {
	switch name {
	case missionconsumeorder.EdgeUser:
		m.ClearUser()
		return nil
	case missionconsumeorder.EdgeMissionBatch:
		m.ClearMissionBatch()
		return nil
	case missionconsumeorder.EdgeMission:
		m.ClearMission()
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionConsumeOrderMutation) ResetEdge(name string) error {
	switch name {
	case missionconsumeorder.EdgeUser:
		m.ResetUser()
		return nil
	case missionconsumeorder.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case missionconsumeorder.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case missionconsumeorder.EdgeMissionBatch:
		m.ResetMissionBatch()
		return nil
	case missionconsumeorder.EdgeMission:
		m.ResetMission()
		return nil
	}
	return fmt.Errorf("unknown MissionConsumeOrder edge %s", name)
}

// MissionKeyPairMutation represents an operation that mutates the MissionKeyPair nodes in the graph.
type MissionKeyPairMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	started_at        *time.Time
	finished_at       *time.Time
	result            *enums.MissionResult
	device_id         *int64
	adddevice_id      *int64
	result_urls       *[]string
	appendresult_urls []string
	clearedFields     map[string]struct{}
	mission           *int64
	clearedmission    bool
	key_pair          *int64
	clearedkey_pair   bool
	done              bool
	oldValue          func(context.Context) (*MissionKeyPair, error)
	predicates        []predicate.MissionKeyPair
}

var _ ent.Mutation = (*MissionKeyPairMutation)(nil)

// missionkeypairOption allows management of the mutation configuration using functional options.
type missionkeypairOption func(*MissionKeyPairMutation)

// newMissionKeyPairMutation creates new mutation for the MissionKeyPair entity.
func newMissionKeyPairMutation(c config, op Op, opts ...missionkeypairOption) *MissionKeyPairMutation {
	m := &MissionKeyPairMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionKeyPair,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionKeyPairID sets the ID field of the mutation.
func withMissionKeyPairID(id int64) missionkeypairOption {
	return func(m *MissionKeyPairMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionKeyPair
		)
		m.oldValue = func(ctx context.Context) (*MissionKeyPair, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionKeyPair.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionKeyPair sets the old MissionKeyPair of the mutation.
func withMissionKeyPair(node *MissionKeyPair) missionkeypairOption {
	return func(m *MissionKeyPairMutation) {
		m.oldValue = func(context.Context) (*MissionKeyPair, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionKeyPairMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionKeyPairMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionKeyPair entities.
func (m *MissionKeyPairMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionKeyPairMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionKeyPairMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionKeyPair.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionKeyPairMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionKeyPairMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionKeyPairMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionKeyPairMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionKeyPairMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionKeyPairMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionKeyPairMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionKeyPairMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionKeyPairMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionKeyPairMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionKeyPairMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionKeyPairMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionKeyPairMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionKeyPairMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionKeyPairMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionKeyPairMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionKeyPairMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionKeyPairMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionKeyPairMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionKeyPairMutation) SetMissionID(i int64) {
	m.mission = &i
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionKeyPairMutation) MissionID() (r int64, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionKeyPairMutation) ResetMissionID() {
	m.mission = nil
}

// SetKeyPairID sets the "key_pair_id" field.
func (m *MissionKeyPairMutation) SetKeyPairID(i int64) {
	m.key_pair = &i
}

// KeyPairID returns the value of the "key_pair_id" field in the mutation.
func (m *MissionKeyPairMutation) KeyPairID() (r int64, exists bool) {
	v := m.key_pair
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPairID returns the old "key_pair_id" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldKeyPairID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPairID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPairID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPairID: %w", err)
	}
	return oldValue.KeyPairID, nil
}

// ResetKeyPairID resets all changes to the "key_pair_id" field.
func (m *MissionKeyPairMutation) ResetKeyPairID() {
	m.key_pair = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MissionKeyPairMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MissionKeyPairMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MissionKeyPairMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *MissionKeyPairMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *MissionKeyPairMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *MissionKeyPairMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetResult sets the "result" field.
func (m *MissionKeyPairMutation) SetResult(er enums.MissionResult) {
	m.result = &er
}

// Result returns the value of the "result" field in the mutation.
func (m *MissionKeyPairMutation) Result() (r enums.MissionResult, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldResult(ctx context.Context) (v enums.MissionResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *MissionKeyPairMutation) ResetResult() {
	m.result = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionKeyPairMutation) SetDeviceID(i int64) {
	m.device_id = &i
	m.adddevice_id = nil
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionKeyPairMutation) DeviceID() (r int64, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// AddDeviceID adds i to the "device_id" field.
func (m *MissionKeyPairMutation) AddDeviceID(i int64) {
	if m.adddevice_id != nil {
		*m.adddevice_id += i
	} else {
		m.adddevice_id = &i
	}
}

// AddedDeviceID returns the value that was added to the "device_id" field in this mutation.
func (m *MissionKeyPairMutation) AddedDeviceID() (r int64, exists bool) {
	v := m.adddevice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionKeyPairMutation) ResetDeviceID() {
	m.device_id = nil
	m.adddevice_id = nil
}

// SetResultUrls sets the "result_urls" field.
func (m *MissionKeyPairMutation) SetResultUrls(s []string) {
	m.result_urls = &s
	m.appendresult_urls = nil
}

// ResultUrls returns the value of the "result_urls" field in the mutation.
func (m *MissionKeyPairMutation) ResultUrls() (r []string, exists bool) {
	v := m.result_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldResultUrls returns the old "result_urls" field's value of the MissionKeyPair entity.
// If the MissionKeyPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKeyPairMutation) OldResultUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultUrls: %w", err)
	}
	return oldValue.ResultUrls, nil
}

// AppendResultUrls adds s to the "result_urls" field.
func (m *MissionKeyPairMutation) AppendResultUrls(s []string) {
	m.appendresult_urls = append(m.appendresult_urls, s...)
}

// AppendedResultUrls returns the list of values that were appended to the "result_urls" field in this mutation.
func (m *MissionKeyPairMutation) AppendedResultUrls() ([]string, bool) {
	if len(m.appendresult_urls) == 0 {
		return nil, false
	}
	return m.appendresult_urls, true
}

// ClearResultUrls clears the value of the "result_urls" field.
func (m *MissionKeyPairMutation) ClearResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	m.clearedFields[missionkeypair.FieldResultUrls] = struct{}{}
}

// ResultUrlsCleared returns if the "result_urls" field was cleared in this mutation.
func (m *MissionKeyPairMutation) ResultUrlsCleared() bool {
	_, ok := m.clearedFields[missionkeypair.FieldResultUrls]
	return ok
}

// ResetResultUrls resets all changes to the "result_urls" field.
func (m *MissionKeyPairMutation) ResetResultUrls() {
	m.result_urls = nil
	m.appendresult_urls = nil
	delete(m.clearedFields, missionkeypair.FieldResultUrls)
}

// ClearMission clears the "mission" edge to the Mission entity.
func (m *MissionKeyPairMutation) ClearMission() {
	m.clearedmission = true
	m.clearedFields[missionkeypair.FieldMissionID] = struct{}{}
}

// MissionCleared reports if the "mission" edge to the Mission entity was cleared.
func (m *MissionKeyPairMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionIDs returns the "mission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *MissionKeyPairMutation) MissionIDs() (ids []int64) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission resets all changes to the "mission" edge.
func (m *MissionKeyPairMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// ClearKeyPair clears the "key_pair" edge to the HmacKeyPair entity.
func (m *MissionKeyPairMutation) ClearKeyPair() {
	m.clearedkey_pair = true
	m.clearedFields[missionkeypair.FieldKeyPairID] = struct{}{}
}

// KeyPairCleared reports if the "key_pair" edge to the HmacKeyPair entity was cleared.
func (m *MissionKeyPairMutation) KeyPairCleared() bool {
	return m.clearedkey_pair
}

// KeyPairIDs returns the "key_pair" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeyPairID instead. It exists only for internal usage by the builders.
func (m *MissionKeyPairMutation) KeyPairIDs() (ids []int64) {
	if id := m.key_pair; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeyPair resets all changes to the "key_pair" edge.
func (m *MissionKeyPairMutation) ResetKeyPair() {
	m.key_pair = nil
	m.clearedkey_pair = false
}

// Where appends a list predicates to the MissionKeyPairMutation builder.
func (m *MissionKeyPairMutation) Where(ps ...predicate.MissionKeyPair) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionKeyPairMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionKeyPairMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionKeyPair, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionKeyPairMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionKeyPairMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionKeyPair).
func (m *MissionKeyPairMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionKeyPairMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, missionkeypair.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionkeypair.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionkeypair.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionkeypair.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionkeypair.FieldDeletedAt)
	}
	if m.mission != nil {
		fields = append(fields, missionkeypair.FieldMissionID)
	}
	if m.key_pair != nil {
		fields = append(fields, missionkeypair.FieldKeyPairID)
	}
	if m.started_at != nil {
		fields = append(fields, missionkeypair.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, missionkeypair.FieldFinishedAt)
	}
	if m.result != nil {
		fields = append(fields, missionkeypair.FieldResult)
	}
	if m.device_id != nil {
		fields = append(fields, missionkeypair.FieldDeviceID)
	}
	if m.result_urls != nil {
		fields = append(fields, missionkeypair.FieldResultUrls)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionKeyPairMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionkeypair.FieldCreatedBy:
		return m.CreatedBy()
	case missionkeypair.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionkeypair.FieldCreatedAt:
		return m.CreatedAt()
	case missionkeypair.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionkeypair.FieldDeletedAt:
		return m.DeletedAt()
	case missionkeypair.FieldMissionID:
		return m.MissionID()
	case missionkeypair.FieldKeyPairID:
		return m.KeyPairID()
	case missionkeypair.FieldStartedAt:
		return m.StartedAt()
	case missionkeypair.FieldFinishedAt:
		return m.FinishedAt()
	case missionkeypair.FieldResult:
		return m.Result()
	case missionkeypair.FieldDeviceID:
		return m.DeviceID()
	case missionkeypair.FieldResultUrls:
		return m.ResultUrls()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionKeyPairMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionkeypair.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionkeypair.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionkeypair.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionkeypair.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionkeypair.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionkeypair.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionkeypair.FieldKeyPairID:
		return m.OldKeyPairID(ctx)
	case missionkeypair.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case missionkeypair.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case missionkeypair.FieldResult:
		return m.OldResult(ctx)
	case missionkeypair.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionkeypair.FieldResultUrls:
		return m.OldResultUrls(ctx)
	}
	return nil, fmt.Errorf("unknown MissionKeyPair field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKeyPairMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionkeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionkeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionkeypair.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionkeypair.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionkeypair.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionkeypair.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionkeypair.FieldKeyPairID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPairID(v)
		return nil
	case missionkeypair.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case missionkeypair.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case missionkeypair.FieldResult:
		v, ok := value.(enums.MissionResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case missionkeypair.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionkeypair.FieldResultUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultUrls(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionKeyPairMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionkeypair.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionkeypair.FieldUpdatedBy)
	}
	if m.adddevice_id != nil {
		fields = append(fields, missionkeypair.FieldDeviceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionKeyPairMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionkeypair.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionkeypair.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionkeypair.FieldDeviceID:
		return m.AddedDeviceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKeyPairMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionkeypair.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionkeypair.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionkeypair.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionKeyPairMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(missionkeypair.FieldResultUrls) {
		fields = append(fields, missionkeypair.FieldResultUrls)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionKeyPairMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionKeyPairMutation) ClearField(name string) error {
	switch name {
	case missionkeypair.FieldResultUrls:
		m.ClearResultUrls()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionKeyPairMutation) ResetField(name string) error {
	switch name {
	case missionkeypair.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionkeypair.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionkeypair.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionkeypair.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionkeypair.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionkeypair.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionkeypair.FieldKeyPairID:
		m.ResetKeyPairID()
		return nil
	case missionkeypair.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case missionkeypair.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case missionkeypair.FieldResult:
		m.ResetResult()
		return nil
	case missionkeypair.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionkeypair.FieldResultUrls:
		m.ResetResultUrls()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionKeyPairMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mission != nil {
		edges = append(edges, missionkeypair.EdgeMission)
	}
	if m.key_pair != nil {
		edges = append(edges, missionkeypair.EdgeKeyPair)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionKeyPairMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionkeypair.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case missionkeypair.EdgeKeyPair:
		if id := m.key_pair; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionKeyPairMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionKeyPairMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionKeyPairMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmission {
		edges = append(edges, missionkeypair.EdgeMission)
	}
	if m.clearedkey_pair {
		edges = append(edges, missionkeypair.EdgeKeyPair)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionKeyPairMutation) EdgeCleared(name string) bool {
	switch name {
	case missionkeypair.EdgeMission:
		return m.clearedmission
	case missionkeypair.EdgeKeyPair:
		return m.clearedkey_pair
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionKeyPairMutation) ClearEdge(name string) error {
	switch name {
	case missionkeypair.EdgeMission:
		m.ClearMission()
		return nil
	case missionkeypair.EdgeKeyPair:
		m.ClearKeyPair()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionKeyPairMutation) ResetEdge(name string) error {
	switch name {
	case missionkeypair.EdgeMission:
		m.ResetMission()
		return nil
	case missionkeypair.EdgeKeyPair:
		m.ResetKeyPair()
		return nil
	}
	return fmt.Errorf("unknown MissionKeyPair edge %s", name)
}

// MissionKindMutation represents an operation that mutates the MissionKind nodes in the graph.
type MissionKindMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_by                 *int64
	addcreated_by              *int64
	updated_by                 *int64
	addupdated_by              *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	_type                      *enums.MissionType
	category                   *enums.MissionCategory
	billing_type               *enums.MissionBillingType
	clearedFields              map[string]struct{}
	device_gpu_missions        map[int64]struct{}
	removeddevice_gpu_missions map[int64]struct{}
	cleareddevice_gpu_missions bool
	done                       bool
	oldValue                   func(context.Context) (*MissionKind, error)
	predicates                 []predicate.MissionKind
}

var _ ent.Mutation = (*MissionKindMutation)(nil)

// missionkindOption allows management of the mutation configuration using functional options.
type missionkindOption func(*MissionKindMutation)

// newMissionKindMutation creates new mutation for the MissionKind entity.
func newMissionKindMutation(c config, op Op, opts ...missionkindOption) *MissionKindMutation {
	m := &MissionKindMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionKind,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionKindID sets the ID field of the mutation.
func withMissionKindID(id int64) missionkindOption {
	return func(m *MissionKindMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionKind
		)
		m.oldValue = func(ctx context.Context) (*MissionKind, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionKind.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionKind sets the old MissionKind of the mutation.
func withMissionKind(node *MissionKind) missionkindOption {
	return func(m *MissionKindMutation) {
		m.oldValue = func(context.Context) (*MissionKind, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionKindMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionKindMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionKind entities.
func (m *MissionKindMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionKindMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionKindMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionKind.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionKindMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionKindMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionKindMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionKindMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionKindMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionKindMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionKindMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionKindMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionKindMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionKindMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionKindMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionKindMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionKindMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionKindMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionKindMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionKindMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionKindMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionKindMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionKindMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *MissionKindMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionKindMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionKindMutation) ResetType() {
	m._type = nil
}

// SetCategory sets the "category" field.
func (m *MissionKindMutation) SetCategory(ec enums.MissionCategory) {
	m.category = &ec
}

// Category returns the value of the "category" field in the mutation.
func (m *MissionKindMutation) Category() (r enums.MissionCategory, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldCategory(ctx context.Context) (v enums.MissionCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MissionKindMutation) ResetCategory() {
	m.category = nil
}

// SetBillingType sets the "billing_type" field.
func (m *MissionKindMutation) SetBillingType(ebt enums.MissionBillingType) {
	m.billing_type = &ebt
}

// BillingType returns the value of the "billing_type" field in the mutation.
func (m *MissionKindMutation) BillingType() (r enums.MissionBillingType, exists bool) {
	v := m.billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingType returns the old "billing_type" field's value of the MissionKind entity.
// If the MissionKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionKindMutation) OldBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingType: %w", err)
	}
	return oldValue.BillingType, nil
}

// ResetBillingType resets all changes to the "billing_type" field.
func (m *MissionKindMutation) ResetBillingType() {
	m.billing_type = nil
}

// AddDeviceGpuMissionIDs adds the "device_gpu_missions" edge to the DeviceGpuMission entity by ids.
func (m *MissionKindMutation) AddDeviceGpuMissionIDs(ids ...int64) {
	if m.device_gpu_missions == nil {
		m.device_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		m.device_gpu_missions[ids[i]] = struct{}{}
	}
}

// ClearDeviceGpuMissions clears the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *MissionKindMutation) ClearDeviceGpuMissions() {
	m.cleareddevice_gpu_missions = true
}

// DeviceGpuMissionsCleared reports if the "device_gpu_missions" edge to the DeviceGpuMission entity was cleared.
func (m *MissionKindMutation) DeviceGpuMissionsCleared() bool {
	return m.cleareddevice_gpu_missions
}

// RemoveDeviceGpuMissionIDs removes the "device_gpu_missions" edge to the DeviceGpuMission entity by IDs.
func (m *MissionKindMutation) RemoveDeviceGpuMissionIDs(ids ...int64) {
	if m.removeddevice_gpu_missions == nil {
		m.removeddevice_gpu_missions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.device_gpu_missions, ids[i])
		m.removeddevice_gpu_missions[ids[i]] = struct{}{}
	}
}

// RemovedDeviceGpuMissions returns the removed IDs of the "device_gpu_missions" edge to the DeviceGpuMission entity.
func (m *MissionKindMutation) RemovedDeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.removeddevice_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// DeviceGpuMissionsIDs returns the "device_gpu_missions" edge IDs in the mutation.
func (m *MissionKindMutation) DeviceGpuMissionsIDs() (ids []int64) {
	for id := range m.device_gpu_missions {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceGpuMissions resets all changes to the "device_gpu_missions" edge.
func (m *MissionKindMutation) ResetDeviceGpuMissions() {
	m.device_gpu_missions = nil
	m.cleareddevice_gpu_missions = false
	m.removeddevice_gpu_missions = nil
}

// Where appends a list predicates to the MissionKindMutation builder.
func (m *MissionKindMutation) Where(ps ...predicate.MissionKind) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionKindMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionKindMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionKind, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionKindMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionKindMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionKind).
func (m *MissionKindMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionKindMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, missionkind.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionkind.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionkind.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionkind.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionkind.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, missionkind.FieldType)
	}
	if m.category != nil {
		fields = append(fields, missionkind.FieldCategory)
	}
	if m.billing_type != nil {
		fields = append(fields, missionkind.FieldBillingType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionKindMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionkind.FieldCreatedBy:
		return m.CreatedBy()
	case missionkind.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionkind.FieldCreatedAt:
		return m.CreatedAt()
	case missionkind.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionkind.FieldDeletedAt:
		return m.DeletedAt()
	case missionkind.FieldType:
		return m.GetType()
	case missionkind.FieldCategory:
		return m.Category()
	case missionkind.FieldBillingType:
		return m.BillingType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionKindMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionkind.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionkind.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionkind.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionkind.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionkind.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionkind.FieldType:
		return m.OldType(ctx)
	case missionkind.FieldCategory:
		return m.OldCategory(ctx)
	case missionkind.FieldBillingType:
		return m.OldBillingType(ctx)
	}
	return nil, fmt.Errorf("unknown MissionKind field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKindMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionkind.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionkind.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionkind.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionkind.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionkind.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionkind.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionkind.FieldCategory:
		v, ok := value.(enums.MissionCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case missionkind.FieldBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingType(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKind field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionKindMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionkind.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionkind.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionKindMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionkind.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionkind.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionKindMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionkind.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionkind.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MissionKind numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionKindMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionKindMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionKindMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionKind nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionKindMutation) ResetField(name string) error {
	switch name {
	case missionkind.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionkind.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionkind.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionkind.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionkind.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionkind.FieldType:
		m.ResetType()
		return nil
	case missionkind.FieldCategory:
		m.ResetCategory()
		return nil
	case missionkind.FieldBillingType:
		m.ResetBillingType()
		return nil
	}
	return fmt.Errorf("unknown MissionKind field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionKindMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device_gpu_missions != nil {
		edges = append(edges, missionkind.EdgeDeviceGpuMissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionKindMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionkind.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.device_gpu_missions))
		for id := range m.device_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionKindMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddevice_gpu_missions != nil {
		edges = append(edges, missionkind.EdgeDeviceGpuMissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionKindMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionkind.EdgeDeviceGpuMissions:
		ids := make([]ent.Value, 0, len(m.removeddevice_gpu_missions))
		for id := range m.removeddevice_gpu_missions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionKindMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice_gpu_missions {
		edges = append(edges, missionkind.EdgeDeviceGpuMissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionKindMutation) EdgeCleared(name string) bool {
	switch name {
	case missionkind.EdgeDeviceGpuMissions:
		return m.cleareddevice_gpu_missions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionKindMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MissionKind unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionKindMutation) ResetEdge(name string) error {
	switch name {
	case missionkind.EdgeDeviceGpuMissions:
		m.ResetDeviceGpuMissions()
		return nil
	}
	return fmt.Errorf("unknown MissionKind edge %s", name)
}

// MissionProduceOrderMutation represents an operation that mutates the MissionProduceOrder nodes in the graph.
type MissionProduceOrderMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_by                   *int64
	addcreated_by                *int64
	updated_by                   *int64
	addupdated_by                *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	mission_id                   *int64
	addmission_id                *int64
	status                       *enums.MissionOrderStatus
	pure_cep                     *int64
	addpure_cep                  *int64
	gift_cep                     *int64
	addgift_cep                  *int64
	_type                        *enums.MissionType
	is_time                      *bool
	serial_number                *string
	clearedFields                map[string]struct{}
	user                         *int64
	cleareduser                  bool
	earn_bills                   map[int64]struct{}
	removedearn_bills            map[int64]struct{}
	clearedearn_bills            bool
	device                       *int64
	cleareddevice                bool
	mission_consume_order        *int64
	clearedmission_consume_order bool
	done                         bool
	oldValue                     func(context.Context) (*MissionProduceOrder, error)
	predicates                   []predicate.MissionProduceOrder
}

var _ ent.Mutation = (*MissionProduceOrderMutation)(nil)

// missionproduceorderOption allows management of the mutation configuration using functional options.
type missionproduceorderOption func(*MissionProduceOrderMutation)

// newMissionProduceOrderMutation creates new mutation for the MissionProduceOrder entity.
func newMissionProduceOrderMutation(c config, op Op, opts ...missionproduceorderOption) *MissionProduceOrderMutation {
	m := &MissionProduceOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeMissionProduceOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionProduceOrderID sets the ID field of the mutation.
func withMissionProduceOrderID(id int64) missionproduceorderOption {
	return func(m *MissionProduceOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *MissionProduceOrder
		)
		m.oldValue = func(ctx context.Context) (*MissionProduceOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissionProduceOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissionProduceOrder sets the old MissionProduceOrder of the mutation.
func withMissionProduceOrder(node *MissionProduceOrder) missionproduceorderOption {
	return func(m *MissionProduceOrderMutation) {
		m.oldValue = func(context.Context) (*MissionProduceOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionProduceOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionProduceOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissionProduceOrder entities.
func (m *MissionProduceOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissionProduceOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissionProduceOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissionProduceOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *MissionProduceOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MissionProduceOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MissionProduceOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MissionProduceOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MissionProduceOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MissionProduceOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MissionProduceOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MissionProduceOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MissionProduceOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MissionProduceOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MissionProduceOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MissionProduceOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MissionProduceOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MissionProduceOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MissionProduceOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MissionProduceOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MissionProduceOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MissionProduceOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MissionProduceOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *MissionProduceOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MissionProduceOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MissionProduceOrderMutation) ResetUserID() {
	m.user = nil
}

// SetMissionID sets the "mission_id" field.
func (m *MissionProduceOrderMutation) SetMissionID(i int64) {
	m.mission_id = &i
	m.addmission_id = nil
}

// MissionID returns the value of the "mission_id" field in the mutation.
func (m *MissionProduceOrderMutation) MissionID() (r int64, exists bool) {
	v := m.mission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionID returns the old "mission_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldMissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionID: %w", err)
	}
	return oldValue.MissionID, nil
}

// AddMissionID adds i to the "mission_id" field.
func (m *MissionProduceOrderMutation) AddMissionID(i int64) {
	if m.addmission_id != nil {
		*m.addmission_id += i
	} else {
		m.addmission_id = &i
	}
}

// AddedMissionID returns the value that was added to the "mission_id" field in this mutation.
func (m *MissionProduceOrderMutation) AddedMissionID() (r int64, exists bool) {
	v := m.addmission_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMissionID resets all changes to the "mission_id" field.
func (m *MissionProduceOrderMutation) ResetMissionID() {
	m.mission_id = nil
	m.addmission_id = nil
}

// SetStatus sets the "status" field.
func (m *MissionProduceOrderMutation) SetStatus(eos enums.MissionOrderStatus) {
	m.status = &eos
}

// Status returns the value of the "status" field in the mutation.
func (m *MissionProduceOrderMutation) Status() (r enums.MissionOrderStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldStatus(ctx context.Context) (v enums.MissionOrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MissionProduceOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *MissionProduceOrderMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *MissionProduceOrderMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *MissionProduceOrderMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *MissionProduceOrderMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *MissionProduceOrderMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *MissionProduceOrderMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *MissionProduceOrderMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *MissionProduceOrderMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *MissionProduceOrderMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *MissionProduceOrderMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// SetType sets the "type" field.
func (m *MissionProduceOrderMutation) SetType(et enums.MissionType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *MissionProduceOrderMutation) GetType() (r enums.MissionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MissionProduceOrderMutation) ResetType() {
	m._type = nil
}

// SetIsTime sets the "is_time" field.
func (m *MissionProduceOrderMutation) SetIsTime(b bool) {
	m.is_time = &b
}

// IsTime returns the value of the "is_time" field in the mutation.
func (m *MissionProduceOrderMutation) IsTime() (r bool, exists bool) {
	v := m.is_time
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTime returns the old "is_time" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldIsTime(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTime: %w", err)
	}
	return oldValue.IsTime, nil
}

// ResetIsTime resets all changes to the "is_time" field.
func (m *MissionProduceOrderMutation) ResetIsTime() {
	m.is_time = nil
}

// SetDeviceID sets the "device_id" field.
func (m *MissionProduceOrderMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *MissionProduceOrderMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *MissionProduceOrderMutation) ResetDeviceID() {
	m.device = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *MissionProduceOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MissionProduceOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MissionProduceOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetMissionConsumeOrderID sets the "mission_consume_order_id" field.
func (m *MissionProduceOrderMutation) SetMissionConsumeOrderID(i int64) {
	m.mission_consume_order = &i
}

// MissionConsumeOrderID returns the value of the "mission_consume_order_id" field in the mutation.
func (m *MissionProduceOrderMutation) MissionConsumeOrderID() (r int64, exists bool) {
	v := m.mission_consume_order
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionConsumeOrderID returns the old "mission_consume_order_id" field's value of the MissionProduceOrder entity.
// If the MissionProduceOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissionProduceOrderMutation) OldMissionConsumeOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionConsumeOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionConsumeOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionConsumeOrderID: %w", err)
	}
	return oldValue.MissionConsumeOrderID, nil
}

// ResetMissionConsumeOrderID resets all changes to the "mission_consume_order_id" field.
func (m *MissionProduceOrderMutation) ResetMissionConsumeOrderID() {
	m.mission_consume_order = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MissionProduceOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[missionproduceorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MissionProduceOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MissionProduceOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *MissionProduceOrderMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *MissionProduceOrderMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *MissionProduceOrderMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *MissionProduceOrderMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *MissionProduceOrderMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *MissionProduceOrderMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *MissionProduceOrderMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *MissionProduceOrderMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[missionproduceorder.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *MissionProduceOrderMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *MissionProduceOrderMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// ClearMissionConsumeOrder clears the "mission_consume_order" edge to the MissionConsumeOrder entity.
func (m *MissionProduceOrderMutation) ClearMissionConsumeOrder() {
	m.clearedmission_consume_order = true
	m.clearedFields[missionproduceorder.FieldMissionConsumeOrderID] = struct{}{}
}

// MissionConsumeOrderCleared reports if the "mission_consume_order" edge to the MissionConsumeOrder entity was cleared.
func (m *MissionProduceOrderMutation) MissionConsumeOrderCleared() bool {
	return m.clearedmission_consume_order
}

// MissionConsumeOrderIDs returns the "mission_consume_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MissionConsumeOrderID instead. It exists only for internal usage by the builders.
func (m *MissionProduceOrderMutation) MissionConsumeOrderIDs() (ids []int64) {
	if id := m.mission_consume_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMissionConsumeOrder resets all changes to the "mission_consume_order" edge.
func (m *MissionProduceOrderMutation) ResetMissionConsumeOrder() {
	m.mission_consume_order = nil
	m.clearedmission_consume_order = false
}

// Where appends a list predicates to the MissionProduceOrderMutation builder.
func (m *MissionProduceOrderMutation) Where(ps ...predicate.MissionProduceOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissionProduceOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissionProduceOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissionProduceOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissionProduceOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissionProduceOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissionProduceOrder).
func (m *MissionProduceOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissionProduceOrderMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, missionproduceorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, missionproduceorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, missionproduceorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, missionproduceorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, missionproduceorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, missionproduceorder.FieldUserID)
	}
	if m.mission_id != nil {
		fields = append(fields, missionproduceorder.FieldMissionID)
	}
	if m.status != nil {
		fields = append(fields, missionproduceorder.FieldStatus)
	}
	if m.pure_cep != nil {
		fields = append(fields, missionproduceorder.FieldPureCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, missionproduceorder.FieldGiftCep)
	}
	if m._type != nil {
		fields = append(fields, missionproduceorder.FieldType)
	}
	if m.is_time != nil {
		fields = append(fields, missionproduceorder.FieldIsTime)
	}
	if m.device != nil {
		fields = append(fields, missionproduceorder.FieldDeviceID)
	}
	if m.serial_number != nil {
		fields = append(fields, missionproduceorder.FieldSerialNumber)
	}
	if m.mission_consume_order != nil {
		fields = append(fields, missionproduceorder.FieldMissionConsumeOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissionProduceOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		return m.CreatedBy()
	case missionproduceorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case missionproduceorder.FieldCreatedAt:
		return m.CreatedAt()
	case missionproduceorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case missionproduceorder.FieldDeletedAt:
		return m.DeletedAt()
	case missionproduceorder.FieldUserID:
		return m.UserID()
	case missionproduceorder.FieldMissionID:
		return m.MissionID()
	case missionproduceorder.FieldStatus:
		return m.Status()
	case missionproduceorder.FieldPureCep:
		return m.PureCep()
	case missionproduceorder.FieldGiftCep:
		return m.GiftCep()
	case missionproduceorder.FieldType:
		return m.GetType()
	case missionproduceorder.FieldIsTime:
		return m.IsTime()
	case missionproduceorder.FieldDeviceID:
		return m.DeviceID()
	case missionproduceorder.FieldSerialNumber:
		return m.SerialNumber()
	case missionproduceorder.FieldMissionConsumeOrderID:
		return m.MissionConsumeOrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissionProduceOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case missionproduceorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case missionproduceorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case missionproduceorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case missionproduceorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case missionproduceorder.FieldUserID:
		return m.OldUserID(ctx)
	case missionproduceorder.FieldMissionID:
		return m.OldMissionID(ctx)
	case missionproduceorder.FieldStatus:
		return m.OldStatus(ctx)
	case missionproduceorder.FieldPureCep:
		return m.OldPureCep(ctx)
	case missionproduceorder.FieldGiftCep:
		return m.OldGiftCep(ctx)
	case missionproduceorder.FieldType:
		return m.OldType(ctx)
	case missionproduceorder.FieldIsTime:
		return m.OldIsTime(ctx)
	case missionproduceorder.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case missionproduceorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case missionproduceorder.FieldMissionConsumeOrderID:
		return m.OldMissionConsumeOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown MissionProduceOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProduceOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case missionproduceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case missionproduceorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case missionproduceorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case missionproduceorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case missionproduceorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case missionproduceorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionID(v)
		return nil
	case missionproduceorder.FieldStatus:
		v, ok := value.(enums.MissionOrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case missionproduceorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case missionproduceorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	case missionproduceorder.FieldType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case missionproduceorder.FieldIsTime:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTime(v)
		return nil
	case missionproduceorder.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case missionproduceorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case missionproduceorder.FieldMissionConsumeOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionConsumeOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissionProduceOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, missionproduceorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, missionproduceorder.FieldUpdatedBy)
	}
	if m.addmission_id != nil {
		fields = append(fields, missionproduceorder.FieldMissionID)
	}
	if m.addpure_cep != nil {
		fields = append(fields, missionproduceorder.FieldPureCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, missionproduceorder.FieldGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissionProduceOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case missionproduceorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case missionproduceorder.FieldMissionID:
		return m.AddedMissionID()
	case missionproduceorder.FieldPureCep:
		return m.AddedPureCep()
	case missionproduceorder.FieldGiftCep:
		return m.AddedGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissionProduceOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case missionproduceorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case missionproduceorder.FieldMissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMissionID(v)
		return nil
	case missionproduceorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case missionproduceorder.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissionProduceOrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissionProduceOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionProduceOrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MissionProduceOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissionProduceOrderMutation) ResetField(name string) error {
	switch name {
	case missionproduceorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case missionproduceorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case missionproduceorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case missionproduceorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case missionproduceorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case missionproduceorder.FieldUserID:
		m.ResetUserID()
		return nil
	case missionproduceorder.FieldMissionID:
		m.ResetMissionID()
		return nil
	case missionproduceorder.FieldStatus:
		m.ResetStatus()
		return nil
	case missionproduceorder.FieldPureCep:
		m.ResetPureCep()
		return nil
	case missionproduceorder.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	case missionproduceorder.FieldType:
		m.ResetType()
		return nil
	case missionproduceorder.FieldIsTime:
		m.ResetIsTime()
		return nil
	case missionproduceorder.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case missionproduceorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case missionproduceorder.FieldMissionConsumeOrderID:
		m.ResetMissionConsumeOrderID()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissionProduceOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, missionproduceorder.EdgeUser)
	}
	if m.earn_bills != nil {
		edges = append(edges, missionproduceorder.EdgeEarnBills)
	}
	if m.device != nil {
		edges = append(edges, missionproduceorder.EdgeDevice)
	}
	if m.mission_consume_order != nil {
		edges = append(edges, missionproduceorder.EdgeMissionConsumeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissionProduceOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missionproduceorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case missionproduceorder.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	case missionproduceorder.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case missionproduceorder.EdgeMissionConsumeOrder:
		if id := m.mission_consume_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissionProduceOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedearn_bills != nil {
		edges = append(edges, missionproduceorder.EdgeEarnBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissionProduceOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case missionproduceorder.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissionProduceOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, missionproduceorder.EdgeUser)
	}
	if m.clearedearn_bills {
		edges = append(edges, missionproduceorder.EdgeEarnBills)
	}
	if m.cleareddevice {
		edges = append(edges, missionproduceorder.EdgeDevice)
	}
	if m.clearedmission_consume_order {
		edges = append(edges, missionproduceorder.EdgeMissionConsumeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissionProduceOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case missionproduceorder.EdgeUser:
		return m.cleareduser
	case missionproduceorder.EdgeEarnBills:
		return m.clearedearn_bills
	case missionproduceorder.EdgeDevice:
		return m.cleareddevice
	case missionproduceorder.EdgeMissionConsumeOrder:
		return m.clearedmission_consume_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissionProduceOrderMutation) ClearEdge(name string) error {
	switch name {
	case missionproduceorder.EdgeUser:
		m.ClearUser()
		return nil
	case missionproduceorder.EdgeDevice:
		m.ClearDevice()
		return nil
	case missionproduceorder.EdgeMissionConsumeOrder:
		m.ClearMissionConsumeOrder()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissionProduceOrderMutation) ResetEdge(name string) error {
	switch name {
	case missionproduceorder.EdgeUser:
		m.ResetUser()
		return nil
	case missionproduceorder.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	case missionproduceorder.EdgeDevice:
		m.ResetDevice()
		return nil
	case missionproduceorder.EdgeMissionConsumeOrder:
		m.ResetMissionConsumeOrder()
		return nil
	}
	return fmt.Errorf("unknown MissionProduceOrder edge %s", name)
}

// OutputLogMutation represents an operation that mutates the OutputLog nodes in the graph.
type OutputLogMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	trace_id      *int64
	addtrace_id   *int64
	headers       *string
	body          *string
	url           *string
	ip            *string
	caller        *string
	status        *int16
	addstatus     *int16
	hmac_key      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OutputLog, error)
	predicates    []predicate.OutputLog
}

var _ ent.Mutation = (*OutputLogMutation)(nil)

// outputlogOption allows management of the mutation configuration using functional options.
type outputlogOption func(*OutputLogMutation)

// newOutputLogMutation creates new mutation for the OutputLog entity.
func newOutputLogMutation(c config, op Op, opts ...outputlogOption) *OutputLogMutation {
	m := &OutputLogMutation{
		config:        c,
		op:            op,
		typ:           TypeOutputLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutputLogID sets the ID field of the mutation.
func withOutputLogID(id int64) outputlogOption {
	return func(m *OutputLogMutation) {
		var (
			err   error
			once  sync.Once
			value *OutputLog
		)
		m.oldValue = func(ctx context.Context) (*OutputLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutputLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutputLog sets the old OutputLog of the mutation.
func withOutputLog(node *OutputLog) outputlogOption {
	return func(m *OutputLogMutation) {
		m.oldValue = func(context.Context) (*OutputLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutputLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutputLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OutputLog entities.
func (m *OutputLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutputLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutputLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutputLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OutputLogMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OutputLogMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OutputLogMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OutputLogMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OutputLogMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OutputLogMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OutputLogMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OutputLogMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OutputLogMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OutputLogMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OutputLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OutputLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OutputLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OutputLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OutputLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OutputLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OutputLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OutputLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OutputLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetTraceID sets the "trace_id" field.
func (m *OutputLogMutation) SetTraceID(i int64) {
	m.trace_id = &i
	m.addtrace_id = nil
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *OutputLogMutation) TraceID() (r int64, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldTraceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// AddTraceID adds i to the "trace_id" field.
func (m *OutputLogMutation) AddTraceID(i int64) {
	if m.addtrace_id != nil {
		*m.addtrace_id += i
	} else {
		m.addtrace_id = &i
	}
}

// AddedTraceID returns the value that was added to the "trace_id" field in this mutation.
func (m *OutputLogMutation) AddedTraceID() (r int64, exists bool) {
	v := m.addtrace_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *OutputLogMutation) ResetTraceID() {
	m.trace_id = nil
	m.addtrace_id = nil
}

// SetHeaders sets the "headers" field.
func (m *OutputLogMutation) SetHeaders(s string) {
	m.headers = &s
}

// Headers returns the value of the "headers" field in the mutation.
func (m *OutputLogMutation) Headers() (r string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldHeaders(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ResetHeaders resets all changes to the "headers" field.
func (m *OutputLogMutation) ResetHeaders() {
	m.headers = nil
}

// SetBody sets the "body" field.
func (m *OutputLogMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *OutputLogMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *OutputLogMutation) ClearBody() {
	m.body = nil
	m.clearedFields[outputlog.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *OutputLogMutation) BodyCleared() bool {
	_, ok := m.clearedFields[outputlog.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *OutputLogMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, outputlog.FieldBody)
}

// SetURL sets the "url" field.
func (m *OutputLogMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *OutputLogMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *OutputLogMutation) ResetURL() {
	m.url = nil
}

// SetIP sets the "ip" field.
func (m *OutputLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *OutputLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *OutputLogMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[outputlog.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *OutputLogMutation) IPCleared() bool {
	_, ok := m.clearedFields[outputlog.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *OutputLogMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, outputlog.FieldIP)
}

// SetCaller sets the "caller" field.
func (m *OutputLogMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *OutputLogMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *OutputLogMutation) ResetCaller() {
	m.caller = nil
}

// SetStatus sets the "status" field.
func (m *OutputLogMutation) SetStatus(i int16) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OutputLogMutation) Status() (r int16, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldStatus(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OutputLogMutation) AddStatus(i int16) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OutputLogMutation) AddedStatus() (r int16, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OutputLogMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[outputlog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OutputLogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[outputlog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OutputLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, outputlog.FieldStatus)
}

// SetHmacKey sets the "hmac_key" field.
func (m *OutputLogMutation) SetHmacKey(s string) {
	m.hmac_key = &s
}

// HmacKey returns the value of the "hmac_key" field in the mutation.
func (m *OutputLogMutation) HmacKey() (r string, exists bool) {
	v := m.hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHmacKey returns the old "hmac_key" field's value of the OutputLog entity.
// If the OutputLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutputLogMutation) OldHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHmacKey: %w", err)
	}
	return oldValue.HmacKey, nil
}

// ResetHmacKey resets all changes to the "hmac_key" field.
func (m *OutputLogMutation) ResetHmacKey() {
	m.hmac_key = nil
}

// Where appends a list predicates to the OutputLogMutation builder.
func (m *OutputLogMutation) Where(ps ...predicate.OutputLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OutputLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OutputLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OutputLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OutputLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OutputLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OutputLog).
func (m *OutputLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutputLogMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, outputlog.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, outputlog.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, outputlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, outputlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, outputlog.FieldDeletedAt)
	}
	if m.trace_id != nil {
		fields = append(fields, outputlog.FieldTraceID)
	}
	if m.headers != nil {
		fields = append(fields, outputlog.FieldHeaders)
	}
	if m.body != nil {
		fields = append(fields, outputlog.FieldBody)
	}
	if m.url != nil {
		fields = append(fields, outputlog.FieldURL)
	}
	if m.ip != nil {
		fields = append(fields, outputlog.FieldIP)
	}
	if m.caller != nil {
		fields = append(fields, outputlog.FieldCaller)
	}
	if m.status != nil {
		fields = append(fields, outputlog.FieldStatus)
	}
	if m.hmac_key != nil {
		fields = append(fields, outputlog.FieldHmacKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutputLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outputlog.FieldCreatedBy:
		return m.CreatedBy()
	case outputlog.FieldUpdatedBy:
		return m.UpdatedBy()
	case outputlog.FieldCreatedAt:
		return m.CreatedAt()
	case outputlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case outputlog.FieldDeletedAt:
		return m.DeletedAt()
	case outputlog.FieldTraceID:
		return m.TraceID()
	case outputlog.FieldHeaders:
		return m.Headers()
	case outputlog.FieldBody:
		return m.Body()
	case outputlog.FieldURL:
		return m.URL()
	case outputlog.FieldIP:
		return m.IP()
	case outputlog.FieldCaller:
		return m.Caller()
	case outputlog.FieldStatus:
		return m.Status()
	case outputlog.FieldHmacKey:
		return m.HmacKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutputLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outputlog.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case outputlog.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case outputlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case outputlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case outputlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case outputlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case outputlog.FieldHeaders:
		return m.OldHeaders(ctx)
	case outputlog.FieldBody:
		return m.OldBody(ctx)
	case outputlog.FieldURL:
		return m.OldURL(ctx)
	case outputlog.FieldIP:
		return m.OldIP(ctx)
	case outputlog.FieldCaller:
		return m.OldCaller(ctx)
	case outputlog.FieldStatus:
		return m.OldStatus(ctx)
	case outputlog.FieldHmacKey:
		return m.OldHmacKey(ctx)
	}
	return nil, fmt.Errorf("unknown OutputLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutputLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case outputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case outputlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case outputlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case outputlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case outputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case outputlog.FieldHeaders:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case outputlog.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case outputlog.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case outputlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case outputlog.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case outputlog.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case outputlog.FieldHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHmacKey(v)
		return nil
	}
	return fmt.Errorf("unknown OutputLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutputLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, outputlog.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, outputlog.FieldUpdatedBy)
	}
	if m.addtrace_id != nil {
		fields = append(fields, outputlog.FieldTraceID)
	}
	if m.addstatus != nil {
		fields = append(fields, outputlog.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutputLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case outputlog.FieldCreatedBy:
		return m.AddedCreatedBy()
	case outputlog.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case outputlog.FieldTraceID:
		return m.AddedTraceID()
	case outputlog.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutputLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case outputlog.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case outputlog.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case outputlog.FieldTraceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraceID(v)
		return nil
	case outputlog.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OutputLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutputLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(outputlog.FieldBody) {
		fields = append(fields, outputlog.FieldBody)
	}
	if m.FieldCleared(outputlog.FieldIP) {
		fields = append(fields, outputlog.FieldIP)
	}
	if m.FieldCleared(outputlog.FieldStatus) {
		fields = append(fields, outputlog.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutputLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutputLogMutation) ClearField(name string) error {
	switch name {
	case outputlog.FieldBody:
		m.ClearBody()
		return nil
	case outputlog.FieldIP:
		m.ClearIP()
		return nil
	case outputlog.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown OutputLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutputLogMutation) ResetField(name string) error {
	switch name {
	case outputlog.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case outputlog.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case outputlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case outputlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case outputlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case outputlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case outputlog.FieldHeaders:
		m.ResetHeaders()
		return nil
	case outputlog.FieldBody:
		m.ResetBody()
		return nil
	case outputlog.FieldURL:
		m.ResetURL()
		return nil
	case outputlog.FieldIP:
		m.ResetIP()
		return nil
	case outputlog.FieldCaller:
		m.ResetCaller()
		return nil
	case outputlog.FieldStatus:
		m.ResetStatus()
		return nil
	case outputlog.FieldHmacKey:
		m.ResetHmacKey()
		return nil
	}
	return fmt.Errorf("unknown OutputLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutputLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutputLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutputLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutputLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutputLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutputLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutputLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OutputLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutputLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OutputLog edge %s", name)
}

// PlatformAccountMutation represents an operation that mutates the PlatformAccount nodes in the graph.
type PlatformAccountMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	_type             *platformaccount.Type
	sum_total_cep     *int64
	addsum_total_cep  *int64
	total_cep         *int64
	addtotal_cep      *int64
	sum_pure_cep      *int64
	addsum_pure_cep   *int64
	pure_cep          *int64
	addpure_cep       *int64
	sum_gift_cep      *int64
	addsum_gift_cep   *int64
	gift_cep          *int64
	addgift_cep       *int64
	clearedFields     map[string]struct{}
	earn_bills        map[int64]struct{}
	removedearn_bills map[int64]struct{}
	clearedearn_bills bool
	done              bool
	oldValue          func(context.Context) (*PlatformAccount, error)
	predicates        []predicate.PlatformAccount
}

var _ ent.Mutation = (*PlatformAccountMutation)(nil)

// platformaccountOption allows management of the mutation configuration using functional options.
type platformaccountOption func(*PlatformAccountMutation)

// newPlatformAccountMutation creates new mutation for the PlatformAccount entity.
func newPlatformAccountMutation(c config, op Op, opts ...platformaccountOption) *PlatformAccountMutation {
	m := &PlatformAccountMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformAccountID sets the ID field of the mutation.
func withPlatformAccountID(id int64) platformaccountOption {
	return func(m *PlatformAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformAccount
		)
		m.oldValue = func(ctx context.Context) (*PlatformAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformAccount sets the old PlatformAccount of the mutation.
func withPlatformAccount(node *PlatformAccount) platformaccountOption {
	return func(m *PlatformAccountMutation) {
		m.oldValue = func(context.Context) (*PlatformAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlatformAccount entities.
func (m *PlatformAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *PlatformAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PlatformAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PlatformAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PlatformAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PlatformAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PlatformAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PlatformAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PlatformAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PlatformAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PlatformAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlatformAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlatformAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlatformAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlatformAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlatformAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlatformAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlatformAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlatformAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlatformAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetType sets the "type" field.
func (m *PlatformAccountMutation) SetType(pl platformaccount.Type) {
	m._type = &pl
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlatformAccountMutation) GetType() (r platformaccount.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldType(ctx context.Context) (v platformaccount.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PlatformAccountMutation) ResetType() {
	m._type = nil
}

// SetSumTotalCep sets the "sum_total_cep" field.
func (m *PlatformAccountMutation) SetSumTotalCep(i int64) {
	m.sum_total_cep = &i
	m.addsum_total_cep = nil
}

// SumTotalCep returns the value of the "sum_total_cep" field in the mutation.
func (m *PlatformAccountMutation) SumTotalCep() (r int64, exists bool) {
	v := m.sum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumTotalCep returns the old "sum_total_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldSumTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumTotalCep: %w", err)
	}
	return oldValue.SumTotalCep, nil
}

// AddSumTotalCep adds i to the "sum_total_cep" field.
func (m *PlatformAccountMutation) AddSumTotalCep(i int64) {
	if m.addsum_total_cep != nil {
		*m.addsum_total_cep += i
	} else {
		m.addsum_total_cep = &i
	}
}

// AddedSumTotalCep returns the value that was added to the "sum_total_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedSumTotalCep() (r int64, exists bool) {
	v := m.addsum_total_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumTotalCep resets all changes to the "sum_total_cep" field.
func (m *PlatformAccountMutation) ResetSumTotalCep() {
	m.sum_total_cep = nil
	m.addsum_total_cep = nil
}

// SetTotalCep sets the "total_cep" field.
func (m *PlatformAccountMutation) SetTotalCep(i int64) {
	m.total_cep = &i
	m.addtotal_cep = nil
}

// TotalCep returns the value of the "total_cep" field in the mutation.
func (m *PlatformAccountMutation) TotalCep() (r int64, exists bool) {
	v := m.total_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCep returns the old "total_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldTotalCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCep: %w", err)
	}
	return oldValue.TotalCep, nil
}

// AddTotalCep adds i to the "total_cep" field.
func (m *PlatformAccountMutation) AddTotalCep(i int64) {
	if m.addtotal_cep != nil {
		*m.addtotal_cep += i
	} else {
		m.addtotal_cep = &i
	}
}

// AddedTotalCep returns the value that was added to the "total_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedTotalCep() (r int64, exists bool) {
	v := m.addtotal_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCep resets all changes to the "total_cep" field.
func (m *PlatformAccountMutation) ResetTotalCep() {
	m.total_cep = nil
	m.addtotal_cep = nil
}

// SetSumPureCep sets the "sum_pure_cep" field.
func (m *PlatformAccountMutation) SetSumPureCep(i int64) {
	m.sum_pure_cep = &i
	m.addsum_pure_cep = nil
}

// SumPureCep returns the value of the "sum_pure_cep" field in the mutation.
func (m *PlatformAccountMutation) SumPureCep() (r int64, exists bool) {
	v := m.sum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumPureCep returns the old "sum_pure_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldSumPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumPureCep: %w", err)
	}
	return oldValue.SumPureCep, nil
}

// AddSumPureCep adds i to the "sum_pure_cep" field.
func (m *PlatformAccountMutation) AddSumPureCep(i int64) {
	if m.addsum_pure_cep != nil {
		*m.addsum_pure_cep += i
	} else {
		m.addsum_pure_cep = &i
	}
}

// AddedSumPureCep returns the value that was added to the "sum_pure_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedSumPureCep() (r int64, exists bool) {
	v := m.addsum_pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumPureCep resets all changes to the "sum_pure_cep" field.
func (m *PlatformAccountMutation) ResetSumPureCep() {
	m.sum_pure_cep = nil
	m.addsum_pure_cep = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *PlatformAccountMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *PlatformAccountMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *PlatformAccountMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *PlatformAccountMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetSumGiftCep sets the "sum_gift_cep" field.
func (m *PlatformAccountMutation) SetSumGiftCep(i int64) {
	m.sum_gift_cep = &i
	m.addsum_gift_cep = nil
}

// SumGiftCep returns the value of the "sum_gift_cep" field in the mutation.
func (m *PlatformAccountMutation) SumGiftCep() (r int64, exists bool) {
	v := m.sum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumGiftCep returns the old "sum_gift_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldSumGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumGiftCep: %w", err)
	}
	return oldValue.SumGiftCep, nil
}

// AddSumGiftCep adds i to the "sum_gift_cep" field.
func (m *PlatformAccountMutation) AddSumGiftCep(i int64) {
	if m.addsum_gift_cep != nil {
		*m.addsum_gift_cep += i
	} else {
		m.addsum_gift_cep = &i
	}
}

// AddedSumGiftCep returns the value that was added to the "sum_gift_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedSumGiftCep() (r int64, exists bool) {
	v := m.addsum_gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumGiftCep resets all changes to the "sum_gift_cep" field.
func (m *PlatformAccountMutation) ResetSumGiftCep() {
	m.sum_gift_cep = nil
	m.addsum_gift_cep = nil
}

// SetGiftCep sets the "gift_cep" field.
func (m *PlatformAccountMutation) SetGiftCep(i int64) {
	m.gift_cep = &i
	m.addgift_cep = nil
}

// GiftCep returns the value of the "gift_cep" field in the mutation.
func (m *PlatformAccountMutation) GiftCep() (r int64, exists bool) {
	v := m.gift_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCep returns the old "gift_cep" field's value of the PlatformAccount entity.
// If the PlatformAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAccountMutation) OldGiftCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCep: %w", err)
	}
	return oldValue.GiftCep, nil
}

// AddGiftCep adds i to the "gift_cep" field.
func (m *PlatformAccountMutation) AddGiftCep(i int64) {
	if m.addgift_cep != nil {
		*m.addgift_cep += i
	} else {
		m.addgift_cep = &i
	}
}

// AddedGiftCep returns the value that was added to the "gift_cep" field in this mutation.
func (m *PlatformAccountMutation) AddedGiftCep() (r int64, exists bool) {
	v := m.addgift_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftCep resets all changes to the "gift_cep" field.
func (m *PlatformAccountMutation) ResetGiftCep() {
	m.gift_cep = nil
	m.addgift_cep = nil
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *PlatformAccountMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *PlatformAccountMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *PlatformAccountMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *PlatformAccountMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *PlatformAccountMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *PlatformAccountMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *PlatformAccountMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// Where appends a list predicates to the PlatformAccountMutation builder.
func (m *PlatformAccountMutation) Where(ps ...predicate.PlatformAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlatformAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlatformAccount).
func (m *PlatformAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformAccountMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, platformaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, platformaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, platformaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, platformaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, platformaccount.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, platformaccount.FieldType)
	}
	if m.sum_total_cep != nil {
		fields = append(fields, platformaccount.FieldSumTotalCep)
	}
	if m.total_cep != nil {
		fields = append(fields, platformaccount.FieldTotalCep)
	}
	if m.sum_pure_cep != nil {
		fields = append(fields, platformaccount.FieldSumPureCep)
	}
	if m.pure_cep != nil {
		fields = append(fields, platformaccount.FieldPureCep)
	}
	if m.sum_gift_cep != nil {
		fields = append(fields, platformaccount.FieldSumGiftCep)
	}
	if m.gift_cep != nil {
		fields = append(fields, platformaccount.FieldGiftCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformaccount.FieldCreatedBy:
		return m.CreatedBy()
	case platformaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case platformaccount.FieldCreatedAt:
		return m.CreatedAt()
	case platformaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case platformaccount.FieldDeletedAt:
		return m.DeletedAt()
	case platformaccount.FieldType:
		return m.GetType()
	case platformaccount.FieldSumTotalCep:
		return m.SumTotalCep()
	case platformaccount.FieldTotalCep:
		return m.TotalCep()
	case platformaccount.FieldSumPureCep:
		return m.SumPureCep()
	case platformaccount.FieldPureCep:
		return m.PureCep()
	case platformaccount.FieldSumGiftCep:
		return m.SumGiftCep()
	case platformaccount.FieldGiftCep:
		return m.GiftCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case platformaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case platformaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case platformaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case platformaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case platformaccount.FieldType:
		return m.OldType(ctx)
	case platformaccount.FieldSumTotalCep:
		return m.OldSumTotalCep(ctx)
	case platformaccount.FieldTotalCep:
		return m.OldTotalCep(ctx)
	case platformaccount.FieldSumPureCep:
		return m.OldSumPureCep(ctx)
	case platformaccount.FieldPureCep:
		return m.OldPureCep(ctx)
	case platformaccount.FieldSumGiftCep:
		return m.OldSumGiftCep(ctx)
	case platformaccount.FieldGiftCep:
		return m.OldGiftCep(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case platformaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case platformaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case platformaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case platformaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case platformaccount.FieldType:
		v, ok := value.(platformaccount.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case platformaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumTotalCep(v)
		return nil
	case platformaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCep(v)
		return nil
	case platformaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumPureCep(v)
		return nil
	case platformaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case platformaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumGiftCep(v)
		return nil
	case platformaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, platformaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, platformaccount.FieldUpdatedBy)
	}
	if m.addsum_total_cep != nil {
		fields = append(fields, platformaccount.FieldSumTotalCep)
	}
	if m.addtotal_cep != nil {
		fields = append(fields, platformaccount.FieldTotalCep)
	}
	if m.addsum_pure_cep != nil {
		fields = append(fields, platformaccount.FieldSumPureCep)
	}
	if m.addpure_cep != nil {
		fields = append(fields, platformaccount.FieldPureCep)
	}
	if m.addsum_gift_cep != nil {
		fields = append(fields, platformaccount.FieldSumGiftCep)
	}
	if m.addgift_cep != nil {
		fields = append(fields, platformaccount.FieldGiftCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case platformaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case platformaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case platformaccount.FieldSumTotalCep:
		return m.AddedSumTotalCep()
	case platformaccount.FieldTotalCep:
		return m.AddedTotalCep()
	case platformaccount.FieldSumPureCep:
		return m.AddedSumPureCep()
	case platformaccount.FieldPureCep:
		return m.AddedPureCep()
	case platformaccount.FieldSumGiftCep:
		return m.AddedSumGiftCep()
	case platformaccount.FieldGiftCep:
		return m.AddedGiftCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case platformaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case platformaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case platformaccount.FieldSumTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumTotalCep(v)
		return nil
	case platformaccount.FieldTotalCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCep(v)
		return nil
	case platformaccount.FieldSumPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumPureCep(v)
		return nil
	case platformaccount.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case platformaccount.FieldSumGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumGiftCep(v)
		return nil
	case platformaccount.FieldGiftCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftCep(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlatformAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformAccountMutation) ResetField(name string) error {
	switch name {
	case platformaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case platformaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case platformaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case platformaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case platformaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case platformaccount.FieldType:
		m.ResetType()
		return nil
	case platformaccount.FieldSumTotalCep:
		m.ResetSumTotalCep()
		return nil
	case platformaccount.FieldTotalCep:
		m.ResetTotalCep()
		return nil
	case platformaccount.FieldSumPureCep:
		m.ResetSumPureCep()
		return nil
	case platformaccount.FieldPureCep:
		m.ResetPureCep()
		return nil
	case platformaccount.FieldSumGiftCep:
		m.ResetSumGiftCep()
		return nil
	case platformaccount.FieldGiftCep:
		m.ResetGiftCep()
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earn_bills != nil {
		edges = append(edges, platformaccount.EdgeEarnBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedearn_bills != nil {
		edges = append(edges, platformaccount.EdgeEarnBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case platformaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearn_bills {
		edges = append(edges, platformaccount.EdgeEarnBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case platformaccount.EdgeEarnBills:
		return m.clearedearn_bills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformAccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformAccountMutation) ResetEdge(name string) error {
	switch name {
	case platformaccount.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	}
	return fmt.Errorf("unknown PlatformAccount edge %s", name)
}

// PriceMutation represents an operation that mutates the Price nodes in the graph.
type PriceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_by           *int64
	addcreated_by        *int64
	updated_by           *int64
	addupdated_by        *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	gpu_version          *enums.GpuVersion
	mission_type         *enums.MissionType
	mission_category     *enums.MissionCategory
	mission_billing_type *enums.MissionBillingType
	cep                  *int64
	addcep               *int64
	started_at           *time.Time
	finished_at          *time.Time
	is_deprecated        *bool
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Price, error)
	predicates           []predicate.Price
}

var _ ent.Mutation = (*PriceMutation)(nil)

// priceOption allows management of the mutation configuration using functional options.
type priceOption func(*PriceMutation)

// newPriceMutation creates new mutation for the Price entity.
func newPriceMutation(c config, op Op, opts ...priceOption) *PriceMutation {
	m := &PriceMutation{
		config:        c,
		op:            op,
		typ:           TypePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPriceID sets the ID field of the mutation.
func withPriceID(id int64) priceOption {
	return func(m *PriceMutation) {
		var (
			err   error
			once  sync.Once
			value *Price
		)
		m.oldValue = func(ctx context.Context) (*Price, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Price.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrice sets the old Price of the mutation.
func withPrice(node *Price) priceOption {
	return func(m *PriceMutation) {
		m.oldValue = func(context.Context) (*Price, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Price entities.
func (m *PriceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PriceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PriceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Price.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *PriceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PriceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PriceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PriceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PriceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PriceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PriceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PriceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PriceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PriceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetGpuVersion sets the "gpu_version" field.
func (m *PriceMutation) SetGpuVersion(ev enums.GpuVersion) {
	m.gpu_version = &ev
}

// GpuVersion returns the value of the "gpu_version" field in the mutation.
func (m *PriceMutation) GpuVersion() (r enums.GpuVersion, exists bool) {
	v := m.gpu_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVersion returns the old "gpu_version" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldGpuVersion(ctx context.Context) (v enums.GpuVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVersion: %w", err)
	}
	return oldValue.GpuVersion, nil
}

// ResetGpuVersion resets all changes to the "gpu_version" field.
func (m *PriceMutation) ResetGpuVersion() {
	m.gpu_version = nil
}

// SetMissionType sets the "mission_type" field.
func (m *PriceMutation) SetMissionType(et enums.MissionType) {
	m.mission_type = &et
}

// MissionType returns the value of the "mission_type" field in the mutation.
func (m *PriceMutation) MissionType() (r enums.MissionType, exists bool) {
	v := m.mission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old "mission_type" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldMissionType(ctx context.Context) (v enums.MissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType resets all changes to the "mission_type" field.
func (m *PriceMutation) ResetMissionType() {
	m.mission_type = nil
}

// SetMissionCategory sets the "mission_category" field.
func (m *PriceMutation) SetMissionCategory(ec enums.MissionCategory) {
	m.mission_category = &ec
}

// MissionCategory returns the value of the "mission_category" field in the mutation.
func (m *PriceMutation) MissionCategory() (r enums.MissionCategory, exists bool) {
	v := m.mission_category
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionCategory returns the old "mission_category" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldMissionCategory(ctx context.Context) (v enums.MissionCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionCategory: %w", err)
	}
	return oldValue.MissionCategory, nil
}

// ResetMissionCategory resets all changes to the "mission_category" field.
func (m *PriceMutation) ResetMissionCategory() {
	m.mission_category = nil
}

// SetMissionBillingType sets the "mission_billing_type" field.
func (m *PriceMutation) SetMissionBillingType(ebt enums.MissionBillingType) {
	m.mission_billing_type = &ebt
}

// MissionBillingType returns the value of the "mission_billing_type" field in the mutation.
func (m *PriceMutation) MissionBillingType() (r enums.MissionBillingType, exists bool) {
	v := m.mission_billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionBillingType returns the old "mission_billing_type" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldMissionBillingType(ctx context.Context) (v enums.MissionBillingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissionBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissionBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionBillingType: %w", err)
	}
	return oldValue.MissionBillingType, nil
}

// ResetMissionBillingType resets all changes to the "mission_billing_type" field.
func (m *PriceMutation) ResetMissionBillingType() {
	m.mission_billing_type = nil
}

// SetCep sets the "cep" field.
func (m *PriceMutation) SetCep(i int64) {
	m.cep = &i
	m.addcep = nil
}

// Cep returns the value of the "cep" field in the mutation.
func (m *PriceMutation) Cep() (r int64, exists bool) {
	v := m.cep
	if v == nil {
		return
	}
	return *v, true
}

// OldCep returns the old "cep" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCep: %w", err)
	}
	return oldValue.Cep, nil
}

// AddCep adds i to the "cep" field.
func (m *PriceMutation) AddCep(i int64) {
	if m.addcep != nil {
		*m.addcep += i
	} else {
		m.addcep = &i
	}
}

// AddedCep returns the value that was added to the "cep" field in this mutation.
func (m *PriceMutation) AddedCep() (r int64, exists bool) {
	v := m.addcep
	if v == nil {
		return
	}
	return *v, true
}

// ResetCep resets all changes to the "cep" field.
func (m *PriceMutation) ResetCep() {
	m.cep = nil
	m.addcep = nil
}

// SetStartedAt sets the "started_at" field.
func (m *PriceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *PriceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *PriceMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[price.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *PriceMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[price.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *PriceMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, price.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *PriceMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *PriceMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *PriceMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[price.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *PriceMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[price.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *PriceMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, price.FieldFinishedAt)
}

// SetIsDeprecated sets the "is_deprecated" field.
func (m *PriceMutation) SetIsDeprecated(b bool) {
	m.is_deprecated = &b
}

// IsDeprecated returns the value of the "is_deprecated" field in the mutation.
func (m *PriceMutation) IsDeprecated() (r bool, exists bool) {
	v := m.is_deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeprecated returns the old "is_deprecated" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldIsDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeprecated: %w", err)
	}
	return oldValue.IsDeprecated, nil
}

// ResetIsDeprecated resets all changes to the "is_deprecated" field.
func (m *PriceMutation) ResetIsDeprecated() {
	m.is_deprecated = nil
}

// Where appends a list predicates to the PriceMutation builder.
func (m *PriceMutation) Where(ps ...predicate.Price) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Price, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Price).
func (m *PriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PriceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, price.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, price.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, price.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, price.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, price.FieldDeletedAt)
	}
	if m.gpu_version != nil {
		fields = append(fields, price.FieldGpuVersion)
	}
	if m.mission_type != nil {
		fields = append(fields, price.FieldMissionType)
	}
	if m.mission_category != nil {
		fields = append(fields, price.FieldMissionCategory)
	}
	if m.mission_billing_type != nil {
		fields = append(fields, price.FieldMissionBillingType)
	}
	if m.cep != nil {
		fields = append(fields, price.FieldCep)
	}
	if m.started_at != nil {
		fields = append(fields, price.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, price.FieldFinishedAt)
	}
	if m.is_deprecated != nil {
		fields = append(fields, price.FieldIsDeprecated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case price.FieldCreatedBy:
		return m.CreatedBy()
	case price.FieldUpdatedBy:
		return m.UpdatedBy()
	case price.FieldCreatedAt:
		return m.CreatedAt()
	case price.FieldUpdatedAt:
		return m.UpdatedAt()
	case price.FieldDeletedAt:
		return m.DeletedAt()
	case price.FieldGpuVersion:
		return m.GpuVersion()
	case price.FieldMissionType:
		return m.MissionType()
	case price.FieldMissionCategory:
		return m.MissionCategory()
	case price.FieldMissionBillingType:
		return m.MissionBillingType()
	case price.FieldCep:
		return m.Cep()
	case price.FieldStartedAt:
		return m.StartedAt()
	case price.FieldFinishedAt:
		return m.FinishedAt()
	case price.FieldIsDeprecated:
		return m.IsDeprecated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case price.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case price.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case price.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case price.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case price.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case price.FieldGpuVersion:
		return m.OldGpuVersion(ctx)
	case price.FieldMissionType:
		return m.OldMissionType(ctx)
	case price.FieldMissionCategory:
		return m.OldMissionCategory(ctx)
	case price.FieldMissionBillingType:
		return m.OldMissionBillingType(ctx)
	case price.FieldCep:
		return m.OldCep(ctx)
	case price.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case price.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case price.FieldIsDeprecated:
		return m.OldIsDeprecated(ctx)
	}
	return nil, fmt.Errorf("unknown Price field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case price.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case price.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case price.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case price.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case price.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case price.FieldGpuVersion:
		v, ok := value.(enums.GpuVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVersion(v)
		return nil
	case price.FieldMissionType:
		v, ok := value.(enums.MissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	case price.FieldMissionCategory:
		v, ok := value.(enums.MissionCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionCategory(v)
		return nil
	case price.FieldMissionBillingType:
		v, ok := value.(enums.MissionBillingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionBillingType(v)
		return nil
	case price.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCep(v)
		return nil
	case price.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case price.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case price.FieldIsDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeprecated(v)
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PriceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, price.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, price.FieldUpdatedBy)
	}
	if m.addcep != nil {
		fields = append(fields, price.FieldCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case price.FieldCreatedBy:
		return m.AddedCreatedBy()
	case price.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case price.FieldCep:
		return m.AddedCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case price.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case price.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case price.FieldCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCep(v)
		return nil
	}
	return fmt.Errorf("unknown Price numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(price.FieldStartedAt) {
		fields = append(fields, price.FieldStartedAt)
	}
	if m.FieldCleared(price.FieldFinishedAt) {
		fields = append(fields, price.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PriceMutation) ClearField(name string) error {
	switch name {
	case price.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case price.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Price nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PriceMutation) ResetField(name string) error {
	switch name {
	case price.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case price.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case price.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case price.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case price.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case price.FieldGpuVersion:
		m.ResetGpuVersion()
		return nil
	case price.FieldMissionType:
		m.ResetMissionType()
		return nil
	case price.FieldMissionCategory:
		m.ResetMissionCategory()
		return nil
	case price.FieldMissionBillingType:
		m.ResetMissionBillingType()
		return nil
	case price.FieldCep:
		m.ResetCep()
		return nil
	case price.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case price.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case price.FieldIsDeprecated:
		m.ResetIsDeprecated()
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PriceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PriceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PriceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Price unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PriceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Price edge %s", name)
}

// ProfitAccountMutation represents an operation that mutates the ProfitAccount nodes in the graph.
type ProfitAccountMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_by        *int64
	addcreated_by     *int64
	updated_by        *int64
	addupdated_by     *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	sum_cep           *int64
	addsum_cep        *int64
	remain_cep        *int64
	addremain_cep     *int64
	clearedFields     map[string]struct{}
	user              *int64
	cleareduser       bool
	earn_bills        map[int64]struct{}
	removedearn_bills map[int64]struct{}
	clearedearn_bills bool
	done              bool
	oldValue          func(context.Context) (*ProfitAccount, error)
	predicates        []predicate.ProfitAccount
}

var _ ent.Mutation = (*ProfitAccountMutation)(nil)

// profitaccountOption allows management of the mutation configuration using functional options.
type profitaccountOption func(*ProfitAccountMutation)

// newProfitAccountMutation creates new mutation for the ProfitAccount entity.
func newProfitAccountMutation(c config, op Op, opts ...profitaccountOption) *ProfitAccountMutation {
	m := &ProfitAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeProfitAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfitAccountID sets the ID field of the mutation.
func withProfitAccountID(id int64) profitaccountOption {
	return func(m *ProfitAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfitAccount
		)
		m.oldValue = func(ctx context.Context) (*ProfitAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfitAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfitAccount sets the old ProfitAccount of the mutation.
func withProfitAccount(node *ProfitAccount) profitaccountOption {
	return func(m *ProfitAccountMutation) {
		m.oldValue = func(context.Context) (*ProfitAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfitAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfitAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfitAccount entities.
func (m *ProfitAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfitAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfitAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfitAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ProfitAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProfitAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProfitAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProfitAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProfitAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProfitAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProfitAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ProfitAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ProfitAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProfitAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfitAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfitAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfitAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfitAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfitAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfitAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProfitAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProfitAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProfitAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ProfitAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProfitAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProfitAccountMutation) ResetUserID() {
	m.user = nil
}

// SetSumCep sets the "sum_cep" field.
func (m *ProfitAccountMutation) SetSumCep(i int64) {
	m.sum_cep = &i
	m.addsum_cep = nil
}

// SumCep returns the value of the "sum_cep" field in the mutation.
func (m *ProfitAccountMutation) SumCep() (r int64, exists bool) {
	v := m.sum_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldSumCep returns the old "sum_cep" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldSumCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSumCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSumCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSumCep: %w", err)
	}
	return oldValue.SumCep, nil
}

// AddSumCep adds i to the "sum_cep" field.
func (m *ProfitAccountMutation) AddSumCep(i int64) {
	if m.addsum_cep != nil {
		*m.addsum_cep += i
	} else {
		m.addsum_cep = &i
	}
}

// AddedSumCep returns the value that was added to the "sum_cep" field in this mutation.
func (m *ProfitAccountMutation) AddedSumCep() (r int64, exists bool) {
	v := m.addsum_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSumCep resets all changes to the "sum_cep" field.
func (m *ProfitAccountMutation) ResetSumCep() {
	m.sum_cep = nil
	m.addsum_cep = nil
}

// SetRemainCep sets the "remain_cep" field.
func (m *ProfitAccountMutation) SetRemainCep(i int64) {
	m.remain_cep = &i
	m.addremain_cep = nil
}

// RemainCep returns the value of the "remain_cep" field in the mutation.
func (m *ProfitAccountMutation) RemainCep() (r int64, exists bool) {
	v := m.remain_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainCep returns the old "remain_cep" field's value of the ProfitAccount entity.
// If the ProfitAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitAccountMutation) OldRemainCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainCep: %w", err)
	}
	return oldValue.RemainCep, nil
}

// AddRemainCep adds i to the "remain_cep" field.
func (m *ProfitAccountMutation) AddRemainCep(i int64) {
	if m.addremain_cep != nil {
		*m.addremain_cep += i
	} else {
		m.addremain_cep = &i
	}
}

// AddedRemainCep returns the value that was added to the "remain_cep" field in this mutation.
func (m *ProfitAccountMutation) AddedRemainCep() (r int64, exists bool) {
	v := m.addremain_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainCep resets all changes to the "remain_cep" field.
func (m *ProfitAccountMutation) ResetRemainCep() {
	m.remain_cep = nil
	m.addremain_cep = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfitAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[profitaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfitAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfitAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfitAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *ProfitAccountMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *ProfitAccountMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *ProfitAccountMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *ProfitAccountMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *ProfitAccountMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *ProfitAccountMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *ProfitAccountMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// Where appends a list predicates to the ProfitAccountMutation builder.
func (m *ProfitAccountMutation) Where(ps ...predicate.ProfitAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfitAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfitAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfitAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfitAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfitAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfitAccount).
func (m *ProfitAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfitAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, profitaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, profitaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, profitaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profitaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, profitaccount.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, profitaccount.FieldUserID)
	}
	if m.sum_cep != nil {
		fields = append(fields, profitaccount.FieldSumCep)
	}
	if m.remain_cep != nil {
		fields = append(fields, profitaccount.FieldRemainCep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfitAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profitaccount.FieldCreatedBy:
		return m.CreatedBy()
	case profitaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case profitaccount.FieldCreatedAt:
		return m.CreatedAt()
	case profitaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case profitaccount.FieldDeletedAt:
		return m.DeletedAt()
	case profitaccount.FieldUserID:
		return m.UserID()
	case profitaccount.FieldSumCep:
		return m.SumCep()
	case profitaccount.FieldRemainCep:
		return m.RemainCep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfitAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profitaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case profitaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case profitaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profitaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profitaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case profitaccount.FieldUserID:
		return m.OldUserID(ctx)
	case profitaccount.FieldSumCep:
		return m.OldSumCep(ctx)
	case profitaccount.FieldRemainCep:
		return m.OldRemainCep(ctx)
	}
	return nil, fmt.Errorf("unknown ProfitAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profitaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case profitaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case profitaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profitaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profitaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case profitaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case profitaccount.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSumCep(v)
		return nil
	case profitaccount.FieldRemainCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainCep(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfitAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, profitaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, profitaccount.FieldUpdatedBy)
	}
	if m.addsum_cep != nil {
		fields = append(fields, profitaccount.FieldSumCep)
	}
	if m.addremain_cep != nil {
		fields = append(fields, profitaccount.FieldRemainCep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfitAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profitaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case profitaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case profitaccount.FieldSumCep:
		return m.AddedSumCep()
	case profitaccount.FieldRemainCep:
		return m.AddedRemainCep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profitaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case profitaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case profitaccount.FieldSumCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSumCep(v)
		return nil
	case profitaccount.FieldRemainCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainCep(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfitAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfitAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfitAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfitAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfitAccountMutation) ResetField(name string) error {
	switch name {
	case profitaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case profitaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case profitaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profitaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profitaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case profitaccount.FieldUserID:
		m.ResetUserID()
		return nil
	case profitaccount.FieldSumCep:
		m.ResetSumCep()
		return nil
	case profitaccount.FieldRemainCep:
		m.ResetRemainCep()
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfitAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, profitaccount.EdgeUser)
	}
	if m.earn_bills != nil {
		edges = append(edges, profitaccount.EdgeEarnBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfitAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profitaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case profitaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfitAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedearn_bills != nil {
		edges = append(edges, profitaccount.EdgeEarnBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfitAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profitaccount.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfitAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, profitaccount.EdgeUser)
	}
	if m.clearedearn_bills {
		edges = append(edges, profitaccount.EdgeEarnBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfitAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case profitaccount.EdgeUser:
		return m.cleareduser
	case profitaccount.EdgeEarnBills:
		return m.clearedearn_bills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfitAccountMutation) ClearEdge(name string) error {
	switch name {
	case profitaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfitAccountMutation) ResetEdge(name string) error {
	switch name {
	case profitaccount.EdgeUser:
		m.ResetUser()
		return nil
	case profitaccount.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	}
	return fmt.Errorf("unknown ProfitAccount edge %s", name)
}

// ProfitSettingMutation represents an operation that mutates the ProfitSetting nodes in the graph.
type ProfitSettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	ratio         *int64
	addratio      *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ProfitSetting, error)
	predicates    []predicate.ProfitSetting
}

var _ ent.Mutation = (*ProfitSettingMutation)(nil)

// profitsettingOption allows management of the mutation configuration using functional options.
type profitsettingOption func(*ProfitSettingMutation)

// newProfitSettingMutation creates new mutation for the ProfitSetting entity.
func newProfitSettingMutation(c config, op Op, opts ...profitsettingOption) *ProfitSettingMutation {
	m := &ProfitSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeProfitSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfitSettingID sets the ID field of the mutation.
func withProfitSettingID(id int64) profitsettingOption {
	return func(m *ProfitSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfitSetting
		)
		m.oldValue = func(ctx context.Context) (*ProfitSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfitSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfitSetting sets the old ProfitSetting of the mutation.
func withProfitSetting(node *ProfitSetting) profitsettingOption {
	return func(m *ProfitSettingMutation) {
		m.oldValue = func(context.Context) (*ProfitSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfitSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfitSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfitSetting entities.
func (m *ProfitSettingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfitSettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfitSettingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfitSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ProfitSettingMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProfitSettingMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProfitSettingMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProfitSettingMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProfitSettingMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProfitSettingMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProfitSettingMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ProfitSettingMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ProfitSettingMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProfitSettingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfitSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfitSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfitSettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfitSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfitSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfitSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProfitSettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProfitSettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProfitSettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ProfitSettingMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProfitSettingMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProfitSettingMutation) ResetUserID() {
	m.user = nil
}

// SetRatio sets the "ratio" field.
func (m *ProfitSettingMutation) SetRatio(i int64) {
	m.ratio = &i
	m.addratio = nil
}

// Ratio returns the value of the "ratio" field in the mutation.
func (m *ProfitSettingMutation) Ratio() (r int64, exists bool) {
	v := m.ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldRatio returns the old "ratio" field's value of the ProfitSetting entity.
// If the ProfitSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitSettingMutation) OldRatio(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatio: %w", err)
	}
	return oldValue.Ratio, nil
}

// AddRatio adds i to the "ratio" field.
func (m *ProfitSettingMutation) AddRatio(i int64) {
	if m.addratio != nil {
		*m.addratio += i
	} else {
		m.addratio = &i
	}
}

// AddedRatio returns the value that was added to the "ratio" field in this mutation.
func (m *ProfitSettingMutation) AddedRatio() (r int64, exists bool) {
	v := m.addratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatio resets all changes to the "ratio" field.
func (m *ProfitSettingMutation) ResetRatio() {
	m.ratio = nil
	m.addratio = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfitSettingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[profitsetting.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfitSettingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfitSettingMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfitSettingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProfitSettingMutation builder.
func (m *ProfitSettingMutation) Where(ps ...predicate.ProfitSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfitSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfitSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfitSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfitSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfitSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfitSetting).
func (m *ProfitSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfitSettingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, profitsetting.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, profitsetting.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, profitsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profitsetting.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, profitsetting.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, profitsetting.FieldUserID)
	}
	if m.ratio != nil {
		fields = append(fields, profitsetting.FieldRatio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfitSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profitsetting.FieldCreatedBy:
		return m.CreatedBy()
	case profitsetting.FieldUpdatedBy:
		return m.UpdatedBy()
	case profitsetting.FieldCreatedAt:
		return m.CreatedAt()
	case profitsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case profitsetting.FieldDeletedAt:
		return m.DeletedAt()
	case profitsetting.FieldUserID:
		return m.UserID()
	case profitsetting.FieldRatio:
		return m.Ratio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfitSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profitsetting.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case profitsetting.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case profitsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profitsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profitsetting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case profitsetting.FieldUserID:
		return m.OldUserID(ctx)
	case profitsetting.FieldRatio:
		return m.OldRatio(ctx)
	}
	return nil, fmt.Errorf("unknown ProfitSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profitsetting.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case profitsetting.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case profitsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profitsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profitsetting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case profitsetting.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case profitsetting.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatio(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfitSettingMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, profitsetting.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, profitsetting.FieldUpdatedBy)
	}
	if m.addratio != nil {
		fields = append(fields, profitsetting.FieldRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfitSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profitsetting.FieldCreatedBy:
		return m.AddedCreatedBy()
	case profitsetting.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case profitsetting.FieldRatio:
		return m.AddedRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profitsetting.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case profitsetting.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case profitsetting.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatio(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfitSettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfitSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfitSettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfitSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfitSettingMutation) ResetField(name string) error {
	switch name {
	case profitsetting.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case profitsetting.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case profitsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profitsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profitsetting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case profitsetting.FieldUserID:
		m.ResetUserID()
		return nil
	case profitsetting.FieldRatio:
		m.ResetRatio()
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfitSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, profitsetting.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfitSettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profitsetting.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfitSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfitSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfitSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, profitsetting.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfitSettingMutation) EdgeCleared(name string) bool {
	switch name {
	case profitsetting.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfitSettingMutation) ClearEdge(name string) error {
	switch name {
	case profitsetting.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfitSettingMutation) ResetEdge(name string) error {
	switch name {
	case profitsetting.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ProfitSetting edge %s", name)
}

// RechargeOrderMutation represents an operation that mutates the RechargeOrder nodes in the graph.
type RechargeOrderMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_by         *int64
	addcreated_by      *int64
	updated_by         *int64
	addupdated_by      *int64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	status             *rechargeorder.Status
	pure_cep           *int64
	addpure_cep        *int64
	_type              *rechargeorder.Type
	serial_number      *string
	third_api_resp     *string
	from_user_id       *int64
	addfrom_user_id    *int64
	out_transaction_id *string
	clearedFields      map[string]struct{}
	user               *int64
	cleareduser        bool
	cost_bills         map[int64]struct{}
	removedcost_bills  map[int64]struct{}
	clearedcost_bills  bool
	vx_social          *int64
	clearedvx_social   bool
	done               bool
	oldValue           func(context.Context) (*RechargeOrder, error)
	predicates         []predicate.RechargeOrder
}

var _ ent.Mutation = (*RechargeOrderMutation)(nil)

// rechargeorderOption allows management of the mutation configuration using functional options.
type rechargeorderOption func(*RechargeOrderMutation)

// newRechargeOrderMutation creates new mutation for the RechargeOrder entity.
func newRechargeOrderMutation(c config, op Op, opts ...rechargeorderOption) *RechargeOrderMutation {
	m := &RechargeOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeRechargeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRechargeOrderID sets the ID field of the mutation.
func withRechargeOrderID(id int64) rechargeorderOption {
	return func(m *RechargeOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *RechargeOrder
		)
		m.oldValue = func(ctx context.Context) (*RechargeOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RechargeOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRechargeOrder sets the old RechargeOrder of the mutation.
func withRechargeOrder(node *RechargeOrder) rechargeorderOption {
	return func(m *RechargeOrderMutation) {
		m.oldValue = func(context.Context) (*RechargeOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RechargeOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RechargeOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RechargeOrder entities.
func (m *RechargeOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RechargeOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RechargeOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RechargeOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *RechargeOrderMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RechargeOrderMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RechargeOrderMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RechargeOrderMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RechargeOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RechargeOrderMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RechargeOrderMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RechargeOrderMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RechargeOrderMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RechargeOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RechargeOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RechargeOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RechargeOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RechargeOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RechargeOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RechargeOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RechargeOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RechargeOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RechargeOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *RechargeOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RechargeOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RechargeOrderMutation) ResetUserID() {
	m.user = nil
}

// SetStatus sets the "status" field.
func (m *RechargeOrderMutation) SetStatus(r rechargeorder.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RechargeOrderMutation) Status() (r rechargeorder.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldStatus(ctx context.Context) (v rechargeorder.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RechargeOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPureCep sets the "pure_cep" field.
func (m *RechargeOrderMutation) SetPureCep(i int64) {
	m.pure_cep = &i
	m.addpure_cep = nil
}

// PureCep returns the value of the "pure_cep" field in the mutation.
func (m *RechargeOrderMutation) PureCep() (r int64, exists bool) {
	v := m.pure_cep
	if v == nil {
		return
	}
	return *v, true
}

// OldPureCep returns the old "pure_cep" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldPureCep(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPureCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPureCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPureCep: %w", err)
	}
	return oldValue.PureCep, nil
}

// AddPureCep adds i to the "pure_cep" field.
func (m *RechargeOrderMutation) AddPureCep(i int64) {
	if m.addpure_cep != nil {
		*m.addpure_cep += i
	} else {
		m.addpure_cep = &i
	}
}

// AddedPureCep returns the value that was added to the "pure_cep" field in this mutation.
func (m *RechargeOrderMutation) AddedPureCep() (r int64, exists bool) {
	v := m.addpure_cep
	if v == nil {
		return
	}
	return *v, true
}

// ResetPureCep resets all changes to the "pure_cep" field.
func (m *RechargeOrderMutation) ResetPureCep() {
	m.pure_cep = nil
	m.addpure_cep = nil
}

// SetSocialID sets the "social_id" field.
func (m *RechargeOrderMutation) SetSocialID(i int64) {
	m.vx_social = &i
}

// SocialID returns the value of the "social_id" field in the mutation.
func (m *RechargeOrderMutation) SocialID() (r int64, exists bool) {
	v := m.vx_social
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialID returns the old "social_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldSocialID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialID: %w", err)
	}
	return oldValue.SocialID, nil
}

// ClearSocialID clears the value of the "social_id" field.
func (m *RechargeOrderMutation) ClearSocialID() {
	m.vx_social = nil
	m.clearedFields[rechargeorder.FieldSocialID] = struct{}{}
}

// SocialIDCleared returns if the "social_id" field was cleared in this mutation.
func (m *RechargeOrderMutation) SocialIDCleared() bool {
	_, ok := m.clearedFields[rechargeorder.FieldSocialID]
	return ok
}

// ResetSocialID resets all changes to the "social_id" field.
func (m *RechargeOrderMutation) ResetSocialID() {
	m.vx_social = nil
	delete(m.clearedFields, rechargeorder.FieldSocialID)
}

// SetType sets the "type" field.
func (m *RechargeOrderMutation) SetType(r rechargeorder.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RechargeOrderMutation) GetType() (r rechargeorder.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldType(ctx context.Context) (v rechargeorder.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RechargeOrderMutation) ResetType() {
	m._type = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *RechargeOrderMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *RechargeOrderMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *RechargeOrderMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetThirdAPIResp sets the "third_api_resp" field.
func (m *RechargeOrderMutation) SetThirdAPIResp(s string) {
	m.third_api_resp = &s
}

// ThirdAPIResp returns the value of the "third_api_resp" field in the mutation.
func (m *RechargeOrderMutation) ThirdAPIResp() (r string, exists bool) {
	v := m.third_api_resp
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdAPIResp returns the old "third_api_resp" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldThirdAPIResp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdAPIResp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdAPIResp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdAPIResp: %w", err)
	}
	return oldValue.ThirdAPIResp, nil
}

// ResetThirdAPIResp resets all changes to the "third_api_resp" field.
func (m *RechargeOrderMutation) ResetThirdAPIResp() {
	m.third_api_resp = nil
}

// SetFromUserID sets the "from_user_id" field.
func (m *RechargeOrderMutation) SetFromUserID(i int64) {
	m.from_user_id = &i
	m.addfrom_user_id = nil
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *RechargeOrderMutation) FromUserID() (r int64, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldFromUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// AddFromUserID adds i to the "from_user_id" field.
func (m *RechargeOrderMutation) AddFromUserID(i int64) {
	if m.addfrom_user_id != nil {
		*m.addfrom_user_id += i
	} else {
		m.addfrom_user_id = &i
	}
}

// AddedFromUserID returns the value that was added to the "from_user_id" field in this mutation.
func (m *RechargeOrderMutation) AddedFromUserID() (r int64, exists bool) {
	v := m.addfrom_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *RechargeOrderMutation) ResetFromUserID() {
	m.from_user_id = nil
	m.addfrom_user_id = nil
}

// SetOutTransactionID sets the "out_transaction_id" field.
func (m *RechargeOrderMutation) SetOutTransactionID(s string) {
	m.out_transaction_id = &s
}

// OutTransactionID returns the value of the "out_transaction_id" field in the mutation.
func (m *RechargeOrderMutation) OutTransactionID() (r string, exists bool) {
	v := m.out_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTransactionID returns the old "out_transaction_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldOutTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTransactionID: %w", err)
	}
	return oldValue.OutTransactionID, nil
}

// ResetOutTransactionID resets all changes to the "out_transaction_id" field.
func (m *RechargeOrderMutation) ResetOutTransactionID() {
	m.out_transaction_id = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RechargeOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[rechargeorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RechargeOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RechargeOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RechargeOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *RechargeOrderMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *RechargeOrderMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *RechargeOrderMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *RechargeOrderMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *RechargeOrderMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *RechargeOrderMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *RechargeOrderMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// SetVxSocialID sets the "vx_social" edge to the VXSocial entity by id.
func (m *RechargeOrderMutation) SetVxSocialID(id int64) {
	m.vx_social = &id
}

// ClearVxSocial clears the "vx_social" edge to the VXSocial entity.
func (m *RechargeOrderMutation) ClearVxSocial() {
	m.clearedvx_social = true
	m.clearedFields[rechargeorder.FieldSocialID] = struct{}{}
}

// VxSocialCleared reports if the "vx_social" edge to the VXSocial entity was cleared.
func (m *RechargeOrderMutation) VxSocialCleared() bool {
	return m.SocialIDCleared() || m.clearedvx_social
}

// VxSocialID returns the "vx_social" edge ID in the mutation.
func (m *RechargeOrderMutation) VxSocialID() (id int64, exists bool) {
	if m.vx_social != nil {
		return *m.vx_social, true
	}
	return
}

// VxSocialIDs returns the "vx_social" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VxSocialID instead. It exists only for internal usage by the builders.
func (m *RechargeOrderMutation) VxSocialIDs() (ids []int64) {
	if id := m.vx_social; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVxSocial resets all changes to the "vx_social" edge.
func (m *RechargeOrderMutation) ResetVxSocial() {
	m.vx_social = nil
	m.clearedvx_social = false
}

// Where appends a list predicates to the RechargeOrderMutation builder.
func (m *RechargeOrderMutation) Where(ps ...predicate.RechargeOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RechargeOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RechargeOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RechargeOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RechargeOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RechargeOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RechargeOrder).
func (m *RechargeOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RechargeOrderMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, rechargeorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, rechargeorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, rechargeorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rechargeorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rechargeorder.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, rechargeorder.FieldUserID)
	}
	if m.status != nil {
		fields = append(fields, rechargeorder.FieldStatus)
	}
	if m.pure_cep != nil {
		fields = append(fields, rechargeorder.FieldPureCep)
	}
	if m.vx_social != nil {
		fields = append(fields, rechargeorder.FieldSocialID)
	}
	if m._type != nil {
		fields = append(fields, rechargeorder.FieldType)
	}
	if m.serial_number != nil {
		fields = append(fields, rechargeorder.FieldSerialNumber)
	}
	if m.third_api_resp != nil {
		fields = append(fields, rechargeorder.FieldThirdAPIResp)
	}
	if m.from_user_id != nil {
		fields = append(fields, rechargeorder.FieldFromUserID)
	}
	if m.out_transaction_id != nil {
		fields = append(fields, rechargeorder.FieldOutTransactionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RechargeOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rechargeorder.FieldCreatedBy:
		return m.CreatedBy()
	case rechargeorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case rechargeorder.FieldCreatedAt:
		return m.CreatedAt()
	case rechargeorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case rechargeorder.FieldDeletedAt:
		return m.DeletedAt()
	case rechargeorder.FieldUserID:
		return m.UserID()
	case rechargeorder.FieldStatus:
		return m.Status()
	case rechargeorder.FieldPureCep:
		return m.PureCep()
	case rechargeorder.FieldSocialID:
		return m.SocialID()
	case rechargeorder.FieldType:
		return m.GetType()
	case rechargeorder.FieldSerialNumber:
		return m.SerialNumber()
	case rechargeorder.FieldThirdAPIResp:
		return m.ThirdAPIResp()
	case rechargeorder.FieldFromUserID:
		return m.FromUserID()
	case rechargeorder.FieldOutTransactionID:
		return m.OutTransactionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RechargeOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rechargeorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rechargeorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rechargeorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rechargeorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rechargeorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rechargeorder.FieldUserID:
		return m.OldUserID(ctx)
	case rechargeorder.FieldStatus:
		return m.OldStatus(ctx)
	case rechargeorder.FieldPureCep:
		return m.OldPureCep(ctx)
	case rechargeorder.FieldSocialID:
		return m.OldSocialID(ctx)
	case rechargeorder.FieldType:
		return m.OldType(ctx)
	case rechargeorder.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case rechargeorder.FieldThirdAPIResp:
		return m.OldThirdAPIResp(ctx)
	case rechargeorder.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case rechargeorder.FieldOutTransactionID:
		return m.OldOutTransactionID(ctx)
	}
	return nil, fmt.Errorf("unknown RechargeOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rechargeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rechargeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rechargeorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rechargeorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rechargeorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rechargeorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case rechargeorder.FieldStatus:
		v, ok := value.(rechargeorder.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rechargeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPureCep(v)
		return nil
	case rechargeorder.FieldSocialID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialID(v)
		return nil
	case rechargeorder.FieldType:
		v, ok := value.(rechargeorder.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case rechargeorder.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case rechargeorder.FieldThirdAPIResp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdAPIResp(v)
		return nil
	case rechargeorder.FieldFromUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case rechargeorder.FieldOutTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTransactionID(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RechargeOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, rechargeorder.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, rechargeorder.FieldUpdatedBy)
	}
	if m.addpure_cep != nil {
		fields = append(fields, rechargeorder.FieldPureCep)
	}
	if m.addfrom_user_id != nil {
		fields = append(fields, rechargeorder.FieldFromUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RechargeOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rechargeorder.FieldCreatedBy:
		return m.AddedCreatedBy()
	case rechargeorder.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case rechargeorder.FieldPureCep:
		return m.AddedPureCep()
	case rechargeorder.FieldFromUserID:
		return m.AddedFromUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rechargeorder.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case rechargeorder.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case rechargeorder.FieldPureCep:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPureCep(v)
		return nil
	case rechargeorder.FieldFromUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromUserID(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RechargeOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rechargeorder.FieldSocialID) {
		fields = append(fields, rechargeorder.FieldSocialID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RechargeOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RechargeOrderMutation) ClearField(name string) error {
	switch name {
	case rechargeorder.FieldSocialID:
		m.ClearSocialID()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RechargeOrderMutation) ResetField(name string) error {
	switch name {
	case rechargeorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rechargeorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rechargeorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rechargeorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rechargeorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rechargeorder.FieldUserID:
		m.ResetUserID()
		return nil
	case rechargeorder.FieldStatus:
		m.ResetStatus()
		return nil
	case rechargeorder.FieldPureCep:
		m.ResetPureCep()
		return nil
	case rechargeorder.FieldSocialID:
		m.ResetSocialID()
		return nil
	case rechargeorder.FieldType:
		m.ResetType()
		return nil
	case rechargeorder.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case rechargeorder.FieldThirdAPIResp:
		m.ResetThirdAPIResp()
		return nil
	case rechargeorder.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case rechargeorder.FieldOutTransactionID:
		m.ResetOutTransactionID()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RechargeOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, rechargeorder.EdgeUser)
	}
	if m.cost_bills != nil {
		edges = append(edges, rechargeorder.EdgeCostBills)
	}
	if m.vx_social != nil {
		edges = append(edges, rechargeorder.EdgeVxSocial)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RechargeOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rechargeorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case rechargeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case rechargeorder.EdgeVxSocial:
		if id := m.vx_social; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RechargeOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcost_bills != nil {
		edges = append(edges, rechargeorder.EdgeCostBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RechargeOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rechargeorder.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RechargeOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, rechargeorder.EdgeUser)
	}
	if m.clearedcost_bills {
		edges = append(edges, rechargeorder.EdgeCostBills)
	}
	if m.clearedvx_social {
		edges = append(edges, rechargeorder.EdgeVxSocial)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RechargeOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case rechargeorder.EdgeUser:
		return m.cleareduser
	case rechargeorder.EdgeCostBills:
		return m.clearedcost_bills
	case rechargeorder.EdgeVxSocial:
		return m.clearedvx_social
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RechargeOrderMutation) ClearEdge(name string) error {
	switch name {
	case rechargeorder.EdgeUser:
		m.ClearUser()
		return nil
	case rechargeorder.EdgeVxSocial:
		m.ClearVxSocial()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RechargeOrderMutation) ResetEdge(name string) error {
	switch name {
	case rechargeorder.EdgeUser:
		m.ResetUser()
		return nil
	case rechargeorder.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case rechargeorder.EdgeVxSocial:
		m.ResetVxSocial()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_by                    *int64
	addcreated_by                 *int64
	updated_by                    *int64
	addupdated_by                 *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	name                          *string
	jpg_url                       *string
	key                           *string
	secret                        *string
	phone                         *string
	password                      *string
	is_frozen                     *bool
	user_type                     *user.UserType
	clearedFields                 map[string]struct{}
	vx_accounts                   map[int64]struct{}
	removedvx_accounts            map[int64]struct{}
	clearedvx_accounts            bool
	collects                      map[int64]struct{}
	removedcollects               map[int64]struct{}
	clearedcollects               bool
	devices                       map[int64]struct{}
	removeddevices                map[int64]struct{}
	cleareddevices                bool
	profit_settings               map[int64]struct{}
	removedprofit_settings        map[int64]struct{}
	clearedprofit_settings        bool
	cost_account                  *int64
	clearedcost_account           bool
	profit_account                *int64
	clearedprofit_account         bool
	cost_bills                    map[int64]struct{}
	removedcost_bills             map[int64]struct{}
	clearedcost_bills             bool
	earn_bills                    map[int64]struct{}
	removedearn_bills             map[int64]struct{}
	clearedearn_bills             bool
	mission_consume_orders        map[int64]struct{}
	removedmission_consume_orders map[int64]struct{}
	clearedmission_consume_orders bool
	mission_produce_orders        map[int64]struct{}
	removedmission_produce_orders map[int64]struct{}
	clearedmission_produce_orders bool
	recharge_orders               map[int64]struct{}
	removedrecharge_orders        map[int64]struct{}
	clearedrecharge_orders        bool
	vx_socials                    map[int64]struct{}
	removedvx_socials             map[int64]struct{}
	clearedvx_socials             bool
	mission_batches               map[int64]struct{}
	removedmission_batches        map[int64]struct{}
	clearedmission_batches        bool
	user_devices                  map[int64]struct{}
	removeduser_devices           map[int64]struct{}
	cleareduser_devices           bool
	parent                        *int64
	clearedparent                 bool
	children                      map[int64]struct{}
	removedchildren               map[int64]struct{}
	clearedchildren               bool
	done                          bool
	oldValue                      func(context.Context) (*User, error)
	predicates                    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetJpgURL sets the "jpg_url" field.
func (m *UserMutation) SetJpgURL(s string) {
	m.jpg_url = &s
}

// JpgURL returns the value of the "jpg_url" field in the mutation.
func (m *UserMutation) JpgURL() (r string, exists bool) {
	v := m.jpg_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJpgURL returns the old "jpg_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJpgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJpgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJpgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJpgURL: %w", err)
	}
	return oldValue.JpgURL, nil
}

// ResetJpgURL resets all changes to the "jpg_url" field.
func (m *UserMutation) ResetJpgURL() {
	m.jpg_url = nil
}

// SetKey sets the "key" field.
func (m *UserMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UserMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UserMutation) ResetKey() {
	m.key = nil
}

// SetSecret sets the "secret" field.
func (m *UserMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *UserMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *UserMutation) ResetSecret() {
	m.secret = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetIsFrozen sets the "is_frozen" field.
func (m *UserMutation) SetIsFrozen(b bool) {
	m.is_frozen = &b
}

// IsFrozen returns the value of the "is_frozen" field in the mutation.
func (m *UserMutation) IsFrozen() (r bool, exists bool) {
	v := m.is_frozen
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFrozen returns the old "is_frozen" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsFrozen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFrozen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFrozen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFrozen: %w", err)
	}
	return oldValue.IsFrozen, nil
}

// ResetIsFrozen resets all changes to the "is_frozen" field.
func (m *UserMutation) ResetIsFrozen() {
	m.is_frozen = nil
}

// SetUserType sets the "user_type" field.
func (m *UserMutation) SetUserType(ut user.UserType) {
	m.user_type = &ut
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *UserMutation) UserType() (r user.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserType(ctx context.Context) (v user.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ResetUserType resets all changes to the "user_type" field.
func (m *UserMutation) ResetUserType() {
	m.user_type = nil
}

// SetParentID sets the "parent_id" field.
func (m *UserMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *UserMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *UserMutation) ResetParentID() {
	m.parent = nil
}

// AddVxAccountIDs adds the "vx_accounts" edge to the VXAccount entity by ids.
func (m *UserMutation) AddVxAccountIDs(ids ...int64) {
	if m.vx_accounts == nil {
		m.vx_accounts = make(map[int64]struct{})
	}
	for i := range ids {
		m.vx_accounts[ids[i]] = struct{}{}
	}
}

// ClearVxAccounts clears the "vx_accounts" edge to the VXAccount entity.
func (m *UserMutation) ClearVxAccounts() {
	m.clearedvx_accounts = true
}

// VxAccountsCleared reports if the "vx_accounts" edge to the VXAccount entity was cleared.
func (m *UserMutation) VxAccountsCleared() bool {
	return m.clearedvx_accounts
}

// RemoveVxAccountIDs removes the "vx_accounts" edge to the VXAccount entity by IDs.
func (m *UserMutation) RemoveVxAccountIDs(ids ...int64) {
	if m.removedvx_accounts == nil {
		m.removedvx_accounts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.vx_accounts, ids[i])
		m.removedvx_accounts[ids[i]] = struct{}{}
	}
}

// RemovedVxAccounts returns the removed IDs of the "vx_accounts" edge to the VXAccount entity.
func (m *UserMutation) RemovedVxAccountsIDs() (ids []int64) {
	for id := range m.removedvx_accounts {
		ids = append(ids, id)
	}
	return
}

// VxAccountsIDs returns the "vx_accounts" edge IDs in the mutation.
func (m *UserMutation) VxAccountsIDs() (ids []int64) {
	for id := range m.vx_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetVxAccounts resets all changes to the "vx_accounts" edge.
func (m *UserMutation) ResetVxAccounts() {
	m.vx_accounts = nil
	m.clearedvx_accounts = false
	m.removedvx_accounts = nil
}

// AddCollectIDs adds the "collects" edge to the Collect entity by ids.
func (m *UserMutation) AddCollectIDs(ids ...int64) {
	if m.collects == nil {
		m.collects = make(map[int64]struct{})
	}
	for i := range ids {
		m.collects[ids[i]] = struct{}{}
	}
}

// ClearCollects clears the "collects" edge to the Collect entity.
func (m *UserMutation) ClearCollects() {
	m.clearedcollects = true
}

// CollectsCleared reports if the "collects" edge to the Collect entity was cleared.
func (m *UserMutation) CollectsCleared() bool {
	return m.clearedcollects
}

// RemoveCollectIDs removes the "collects" edge to the Collect entity by IDs.
func (m *UserMutation) RemoveCollectIDs(ids ...int64) {
	if m.removedcollects == nil {
		m.removedcollects = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.collects, ids[i])
		m.removedcollects[ids[i]] = struct{}{}
	}
}

// RemovedCollects returns the removed IDs of the "collects" edge to the Collect entity.
func (m *UserMutation) RemovedCollectsIDs() (ids []int64) {
	for id := range m.removedcollects {
		ids = append(ids, id)
	}
	return
}

// CollectsIDs returns the "collects" edge IDs in the mutation.
func (m *UserMutation) CollectsIDs() (ids []int64) {
	for id := range m.collects {
		ids = append(ids, id)
	}
	return
}

// ResetCollects resets all changes to the "collects" edge.
func (m *UserMutation) ResetCollects() {
	m.collects = nil
	m.clearedcollects = false
	m.removedcollects = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...int64) {
	if m.devices == nil {
		m.devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *UserMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *UserMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...int64) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *UserMutation) RemovedDevicesIDs() (ids []int64) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *UserMutation) DevicesIDs() (ids []int64) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *UserMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddProfitSettingIDs adds the "profit_settings" edge to the ProfitSetting entity by ids.
func (m *UserMutation) AddProfitSettingIDs(ids ...int64) {
	if m.profit_settings == nil {
		m.profit_settings = make(map[int64]struct{})
	}
	for i := range ids {
		m.profit_settings[ids[i]] = struct{}{}
	}
}

// ClearProfitSettings clears the "profit_settings" edge to the ProfitSetting entity.
func (m *UserMutation) ClearProfitSettings() {
	m.clearedprofit_settings = true
}

// ProfitSettingsCleared reports if the "profit_settings" edge to the ProfitSetting entity was cleared.
func (m *UserMutation) ProfitSettingsCleared() bool {
	return m.clearedprofit_settings
}

// RemoveProfitSettingIDs removes the "profit_settings" edge to the ProfitSetting entity by IDs.
func (m *UserMutation) RemoveProfitSettingIDs(ids ...int64) {
	if m.removedprofit_settings == nil {
		m.removedprofit_settings = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.profit_settings, ids[i])
		m.removedprofit_settings[ids[i]] = struct{}{}
	}
}

// RemovedProfitSettings returns the removed IDs of the "profit_settings" edge to the ProfitSetting entity.
func (m *UserMutation) RemovedProfitSettingsIDs() (ids []int64) {
	for id := range m.removedprofit_settings {
		ids = append(ids, id)
	}
	return
}

// ProfitSettingsIDs returns the "profit_settings" edge IDs in the mutation.
func (m *UserMutation) ProfitSettingsIDs() (ids []int64) {
	for id := range m.profit_settings {
		ids = append(ids, id)
	}
	return
}

// ResetProfitSettings resets all changes to the "profit_settings" edge.
func (m *UserMutation) ResetProfitSettings() {
	m.profit_settings = nil
	m.clearedprofit_settings = false
	m.removedprofit_settings = nil
}

// SetCostAccountID sets the "cost_account" edge to the CostAccount entity by id.
func (m *UserMutation) SetCostAccountID(id int64) {
	m.cost_account = &id
}

// ClearCostAccount clears the "cost_account" edge to the CostAccount entity.
func (m *UserMutation) ClearCostAccount() {
	m.clearedcost_account = true
}

// CostAccountCleared reports if the "cost_account" edge to the CostAccount entity was cleared.
func (m *UserMutation) CostAccountCleared() bool {
	return m.clearedcost_account
}

// CostAccountID returns the "cost_account" edge ID in the mutation.
func (m *UserMutation) CostAccountID() (id int64, exists bool) {
	if m.cost_account != nil {
		return *m.cost_account, true
	}
	return
}

// CostAccountIDs returns the "cost_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CostAccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CostAccountIDs() (ids []int64) {
	if id := m.cost_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCostAccount resets all changes to the "cost_account" edge.
func (m *UserMutation) ResetCostAccount() {
	m.cost_account = nil
	m.clearedcost_account = false
}

// SetProfitAccountID sets the "profit_account" edge to the ProfitAccount entity by id.
func (m *UserMutation) SetProfitAccountID(id int64) {
	m.profit_account = &id
}

// ClearProfitAccount clears the "profit_account" edge to the ProfitAccount entity.
func (m *UserMutation) ClearProfitAccount() {
	m.clearedprofit_account = true
}

// ProfitAccountCleared reports if the "profit_account" edge to the ProfitAccount entity was cleared.
func (m *UserMutation) ProfitAccountCleared() bool {
	return m.clearedprofit_account
}

// ProfitAccountID returns the "profit_account" edge ID in the mutation.
func (m *UserMutation) ProfitAccountID() (id int64, exists bool) {
	if m.profit_account != nil {
		return *m.profit_account, true
	}
	return
}

// ProfitAccountIDs returns the "profit_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfitAccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfitAccountIDs() (ids []int64) {
	if id := m.profit_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfitAccount resets all changes to the "profit_account" edge.
func (m *UserMutation) ResetProfitAccount() {
	m.profit_account = nil
	m.clearedprofit_account = false
}

// AddCostBillIDs adds the "cost_bills" edge to the CostBill entity by ids.
func (m *UserMutation) AddCostBillIDs(ids ...int64) {
	if m.cost_bills == nil {
		m.cost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.cost_bills[ids[i]] = struct{}{}
	}
}

// ClearCostBills clears the "cost_bills" edge to the CostBill entity.
func (m *UserMutation) ClearCostBills() {
	m.clearedcost_bills = true
}

// CostBillsCleared reports if the "cost_bills" edge to the CostBill entity was cleared.
func (m *UserMutation) CostBillsCleared() bool {
	return m.clearedcost_bills
}

// RemoveCostBillIDs removes the "cost_bills" edge to the CostBill entity by IDs.
func (m *UserMutation) RemoveCostBillIDs(ids ...int64) {
	if m.removedcost_bills == nil {
		m.removedcost_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cost_bills, ids[i])
		m.removedcost_bills[ids[i]] = struct{}{}
	}
}

// RemovedCostBills returns the removed IDs of the "cost_bills" edge to the CostBill entity.
func (m *UserMutation) RemovedCostBillsIDs() (ids []int64) {
	for id := range m.removedcost_bills {
		ids = append(ids, id)
	}
	return
}

// CostBillsIDs returns the "cost_bills" edge IDs in the mutation.
func (m *UserMutation) CostBillsIDs() (ids []int64) {
	for id := range m.cost_bills {
		ids = append(ids, id)
	}
	return
}

// ResetCostBills resets all changes to the "cost_bills" edge.
func (m *UserMutation) ResetCostBills() {
	m.cost_bills = nil
	m.clearedcost_bills = false
	m.removedcost_bills = nil
}

// AddEarnBillIDs adds the "earn_bills" edge to the EarnBill entity by ids.
func (m *UserMutation) AddEarnBillIDs(ids ...int64) {
	if m.earn_bills == nil {
		m.earn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		m.earn_bills[ids[i]] = struct{}{}
	}
}

// ClearEarnBills clears the "earn_bills" edge to the EarnBill entity.
func (m *UserMutation) ClearEarnBills() {
	m.clearedearn_bills = true
}

// EarnBillsCleared reports if the "earn_bills" edge to the EarnBill entity was cleared.
func (m *UserMutation) EarnBillsCleared() bool {
	return m.clearedearn_bills
}

// RemoveEarnBillIDs removes the "earn_bills" edge to the EarnBill entity by IDs.
func (m *UserMutation) RemoveEarnBillIDs(ids ...int64) {
	if m.removedearn_bills == nil {
		m.removedearn_bills = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.earn_bills, ids[i])
		m.removedearn_bills[ids[i]] = struct{}{}
	}
}

// RemovedEarnBills returns the removed IDs of the "earn_bills" edge to the EarnBill entity.
func (m *UserMutation) RemovedEarnBillsIDs() (ids []int64) {
	for id := range m.removedearn_bills {
		ids = append(ids, id)
	}
	return
}

// EarnBillsIDs returns the "earn_bills" edge IDs in the mutation.
func (m *UserMutation) EarnBillsIDs() (ids []int64) {
	for id := range m.earn_bills {
		ids = append(ids, id)
	}
	return
}

// ResetEarnBills resets all changes to the "earn_bills" edge.
func (m *UserMutation) ResetEarnBills() {
	m.earn_bills = nil
	m.clearedearn_bills = false
	m.removedearn_bills = nil
}

// AddMissionConsumeOrderIDs adds the "mission_consume_orders" edge to the MissionConsumeOrder entity by ids.
func (m *UserMutation) AddMissionConsumeOrderIDs(ids ...int64) {
	if m.mission_consume_orders == nil {
		m.mission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_consume_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionConsumeOrders clears the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *UserMutation) ClearMissionConsumeOrders() {
	m.clearedmission_consume_orders = true
}

// MissionConsumeOrdersCleared reports if the "mission_consume_orders" edge to the MissionConsumeOrder entity was cleared.
func (m *UserMutation) MissionConsumeOrdersCleared() bool {
	return m.clearedmission_consume_orders
}

// RemoveMissionConsumeOrderIDs removes the "mission_consume_orders" edge to the MissionConsumeOrder entity by IDs.
func (m *UserMutation) RemoveMissionConsumeOrderIDs(ids ...int64) {
	if m.removedmission_consume_orders == nil {
		m.removedmission_consume_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_consume_orders, ids[i])
		m.removedmission_consume_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionConsumeOrders returns the removed IDs of the "mission_consume_orders" edge to the MissionConsumeOrder entity.
func (m *UserMutation) RemovedMissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.removedmission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// MissionConsumeOrdersIDs returns the "mission_consume_orders" edge IDs in the mutation.
func (m *UserMutation) MissionConsumeOrdersIDs() (ids []int64) {
	for id := range m.mission_consume_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionConsumeOrders resets all changes to the "mission_consume_orders" edge.
func (m *UserMutation) ResetMissionConsumeOrders() {
	m.mission_consume_orders = nil
	m.clearedmission_consume_orders = false
	m.removedmission_consume_orders = nil
}

// AddMissionProduceOrderIDs adds the "mission_produce_orders" edge to the MissionProduceOrder entity by ids.
func (m *UserMutation) AddMissionProduceOrderIDs(ids ...int64) {
	if m.mission_produce_orders == nil {
		m.mission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_produce_orders[ids[i]] = struct{}{}
	}
}

// ClearMissionProduceOrders clears the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *UserMutation) ClearMissionProduceOrders() {
	m.clearedmission_produce_orders = true
}

// MissionProduceOrdersCleared reports if the "mission_produce_orders" edge to the MissionProduceOrder entity was cleared.
func (m *UserMutation) MissionProduceOrdersCleared() bool {
	return m.clearedmission_produce_orders
}

// RemoveMissionProduceOrderIDs removes the "mission_produce_orders" edge to the MissionProduceOrder entity by IDs.
func (m *UserMutation) RemoveMissionProduceOrderIDs(ids ...int64) {
	if m.removedmission_produce_orders == nil {
		m.removedmission_produce_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_produce_orders, ids[i])
		m.removedmission_produce_orders[ids[i]] = struct{}{}
	}
}

// RemovedMissionProduceOrders returns the removed IDs of the "mission_produce_orders" edge to the MissionProduceOrder entity.
func (m *UserMutation) RemovedMissionProduceOrdersIDs() (ids []int64) {
	for id := range m.removedmission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// MissionProduceOrdersIDs returns the "mission_produce_orders" edge IDs in the mutation.
func (m *UserMutation) MissionProduceOrdersIDs() (ids []int64) {
	for id := range m.mission_produce_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMissionProduceOrders resets all changes to the "mission_produce_orders" edge.
func (m *UserMutation) ResetMissionProduceOrders() {
	m.mission_produce_orders = nil
	m.clearedmission_produce_orders = false
	m.removedmission_produce_orders = nil
}

// AddRechargeOrderIDs adds the "recharge_orders" edge to the RechargeOrder entity by ids.
func (m *UserMutation) AddRechargeOrderIDs(ids ...int64) {
	if m.recharge_orders == nil {
		m.recharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.recharge_orders[ids[i]] = struct{}{}
	}
}

// ClearRechargeOrders clears the "recharge_orders" edge to the RechargeOrder entity.
func (m *UserMutation) ClearRechargeOrders() {
	m.clearedrecharge_orders = true
}

// RechargeOrdersCleared reports if the "recharge_orders" edge to the RechargeOrder entity was cleared.
func (m *UserMutation) RechargeOrdersCleared() bool {
	return m.clearedrecharge_orders
}

// RemoveRechargeOrderIDs removes the "recharge_orders" edge to the RechargeOrder entity by IDs.
func (m *UserMutation) RemoveRechargeOrderIDs(ids ...int64) {
	if m.removedrecharge_orders == nil {
		m.removedrecharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.recharge_orders, ids[i])
		m.removedrecharge_orders[ids[i]] = struct{}{}
	}
}

// RemovedRechargeOrders returns the removed IDs of the "recharge_orders" edge to the RechargeOrder entity.
func (m *UserMutation) RemovedRechargeOrdersIDs() (ids []int64) {
	for id := range m.removedrecharge_orders {
		ids = append(ids, id)
	}
	return
}

// RechargeOrdersIDs returns the "recharge_orders" edge IDs in the mutation.
func (m *UserMutation) RechargeOrdersIDs() (ids []int64) {
	for id := range m.recharge_orders {
		ids = append(ids, id)
	}
	return
}

// ResetRechargeOrders resets all changes to the "recharge_orders" edge.
func (m *UserMutation) ResetRechargeOrders() {
	m.recharge_orders = nil
	m.clearedrecharge_orders = false
	m.removedrecharge_orders = nil
}

// AddVxSocialIDs adds the "vx_socials" edge to the VXSocial entity by ids.
func (m *UserMutation) AddVxSocialIDs(ids ...int64) {
	if m.vx_socials == nil {
		m.vx_socials = make(map[int64]struct{})
	}
	for i := range ids {
		m.vx_socials[ids[i]] = struct{}{}
	}
}

// ClearVxSocials clears the "vx_socials" edge to the VXSocial entity.
func (m *UserMutation) ClearVxSocials() {
	m.clearedvx_socials = true
}

// VxSocialsCleared reports if the "vx_socials" edge to the VXSocial entity was cleared.
func (m *UserMutation) VxSocialsCleared() bool {
	return m.clearedvx_socials
}

// RemoveVxSocialIDs removes the "vx_socials" edge to the VXSocial entity by IDs.
func (m *UserMutation) RemoveVxSocialIDs(ids ...int64) {
	if m.removedvx_socials == nil {
		m.removedvx_socials = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.vx_socials, ids[i])
		m.removedvx_socials[ids[i]] = struct{}{}
	}
}

// RemovedVxSocials returns the removed IDs of the "vx_socials" edge to the VXSocial entity.
func (m *UserMutation) RemovedVxSocialsIDs() (ids []int64) {
	for id := range m.removedvx_socials {
		ids = append(ids, id)
	}
	return
}

// VxSocialsIDs returns the "vx_socials" edge IDs in the mutation.
func (m *UserMutation) VxSocialsIDs() (ids []int64) {
	for id := range m.vx_socials {
		ids = append(ids, id)
	}
	return
}

// ResetVxSocials resets all changes to the "vx_socials" edge.
func (m *UserMutation) ResetVxSocials() {
	m.vx_socials = nil
	m.clearedvx_socials = false
	m.removedvx_socials = nil
}

// AddMissionBatchIDs adds the "mission_batches" edge to the MissionBatch entity by ids.
func (m *UserMutation) AddMissionBatchIDs(ids ...int64) {
	if m.mission_batches == nil {
		m.mission_batches = make(map[int64]struct{})
	}
	for i := range ids {
		m.mission_batches[ids[i]] = struct{}{}
	}
}

// ClearMissionBatches clears the "mission_batches" edge to the MissionBatch entity.
func (m *UserMutation) ClearMissionBatches() {
	m.clearedmission_batches = true
}

// MissionBatchesCleared reports if the "mission_batches" edge to the MissionBatch entity was cleared.
func (m *UserMutation) MissionBatchesCleared() bool {
	return m.clearedmission_batches
}

// RemoveMissionBatchIDs removes the "mission_batches" edge to the MissionBatch entity by IDs.
func (m *UserMutation) RemoveMissionBatchIDs(ids ...int64) {
	if m.removedmission_batches == nil {
		m.removedmission_batches = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.mission_batches, ids[i])
		m.removedmission_batches[ids[i]] = struct{}{}
	}
}

// RemovedMissionBatches returns the removed IDs of the "mission_batches" edge to the MissionBatch entity.
func (m *UserMutation) RemovedMissionBatchesIDs() (ids []int64) {
	for id := range m.removedmission_batches {
		ids = append(ids, id)
	}
	return
}

// MissionBatchesIDs returns the "mission_batches" edge IDs in the mutation.
func (m *UserMutation) MissionBatchesIDs() (ids []int64) {
	for id := range m.mission_batches {
		ids = append(ids, id)
	}
	return
}

// ResetMissionBatches resets all changes to the "mission_batches" edge.
func (m *UserMutation) ResetMissionBatches() {
	m.mission_batches = nil
	m.clearedmission_batches = false
	m.removedmission_batches = nil
}

// AddUserDeviceIDs adds the "user_devices" edge to the UserDevice entity by ids.
func (m *UserMutation) AddUserDeviceIDs(ids ...int64) {
	if m.user_devices == nil {
		m.user_devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_devices[ids[i]] = struct{}{}
	}
}

// ClearUserDevices clears the "user_devices" edge to the UserDevice entity.
func (m *UserMutation) ClearUserDevices() {
	m.cleareduser_devices = true
}

// UserDevicesCleared reports if the "user_devices" edge to the UserDevice entity was cleared.
func (m *UserMutation) UserDevicesCleared() bool {
	return m.cleareduser_devices
}

// RemoveUserDeviceIDs removes the "user_devices" edge to the UserDevice entity by IDs.
func (m *UserMutation) RemoveUserDeviceIDs(ids ...int64) {
	if m.removeduser_devices == nil {
		m.removeduser_devices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_devices, ids[i])
		m.removeduser_devices[ids[i]] = struct{}{}
	}
}

// RemovedUserDevices returns the removed IDs of the "user_devices" edge to the UserDevice entity.
func (m *UserMutation) RemovedUserDevicesIDs() (ids []int64) {
	for id := range m.removeduser_devices {
		ids = append(ids, id)
	}
	return
}

// UserDevicesIDs returns the "user_devices" edge IDs in the mutation.
func (m *UserMutation) UserDevicesIDs() (ids []int64) {
	for id := range m.user_devices {
		ids = append(ids, id)
	}
	return
}

// ResetUserDevices resets all changes to the "user_devices" edge.
func (m *UserMutation) ResetUserDevices() {
	m.user_devices = nil
	m.cleareduser_devices = false
	m.removeduser_devices = nil
}

// ClearParent clears the "parent" edge to the User entity.
func (m *UserMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[user.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the User entity was cleared.
func (m *UserMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *UserMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the User entity by ids.
func (m *UserMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the User entity.
func (m *UserMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the User entity was cleared.
func (m *UserMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the User entity by IDs.
func (m *UserMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the User entity.
func (m *UserMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *UserMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *UserMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.jpg_url != nil {
		fields = append(fields, user.FieldJpgURL)
	}
	if m.key != nil {
		fields = append(fields, user.FieldKey)
	}
	if m.secret != nil {
		fields = append(fields, user.FieldSecret)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.is_frozen != nil {
		fields = append(fields, user.FieldIsFrozen)
	}
	if m.user_type != nil {
		fields = append(fields, user.FieldUserType)
	}
	if m.parent != nil {
		fields = append(fields, user.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldJpgURL:
		return m.JpgURL()
	case user.FieldKey:
		return m.Key()
	case user.FieldSecret:
		return m.Secret()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPassword:
		return m.Password()
	case user.FieldIsFrozen:
		return m.IsFrozen()
	case user.FieldUserType:
		return m.UserType()
	case user.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldJpgURL:
		return m.OldJpgURL(ctx)
	case user.FieldKey:
		return m.OldKey(ctx)
	case user.FieldSecret:
		return m.OldSecret(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldIsFrozen:
		return m.OldIsFrozen(ctx)
	case user.FieldUserType:
		return m.OldUserType(ctx)
	case user.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldJpgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJpgURL(v)
		return nil
	case user.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case user.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldIsFrozen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFrozen(v)
		return nil
	case user.FieldUserType:
		v, ok := value.(user.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case user.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldJpgURL:
		m.ResetJpgURL()
		return nil
	case user.FieldKey:
		m.ResetKey()
		return nil
	case user.FieldSecret:
		m.ResetSecret()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldIsFrozen:
		m.ResetIsFrozen()
		return nil
	case user.FieldUserType:
		m.ResetUserType()
		return nil
	case user.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.vx_accounts != nil {
		edges = append(edges, user.EdgeVxAccounts)
	}
	if m.collects != nil {
		edges = append(edges, user.EdgeCollects)
	}
	if m.devices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.profit_settings != nil {
		edges = append(edges, user.EdgeProfitSettings)
	}
	if m.cost_account != nil {
		edges = append(edges, user.EdgeCostAccount)
	}
	if m.profit_account != nil {
		edges = append(edges, user.EdgeProfitAccount)
	}
	if m.cost_bills != nil {
		edges = append(edges, user.EdgeCostBills)
	}
	if m.earn_bills != nil {
		edges = append(edges, user.EdgeEarnBills)
	}
	if m.mission_consume_orders != nil {
		edges = append(edges, user.EdgeMissionConsumeOrders)
	}
	if m.mission_produce_orders != nil {
		edges = append(edges, user.EdgeMissionProduceOrders)
	}
	if m.recharge_orders != nil {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.vx_socials != nil {
		edges = append(edges, user.EdgeVxSocials)
	}
	if m.mission_batches != nil {
		edges = append(edges, user.EdgeMissionBatches)
	}
	if m.user_devices != nil {
		edges = append(edges, user.EdgeUserDevices)
	}
	if m.parent != nil {
		edges = append(edges, user.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, user.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVxAccounts:
		ids := make([]ent.Value, 0, len(m.vx_accounts))
		for id := range m.vx_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCollects:
		ids := make([]ent.Value, 0, len(m.collects))
		for id := range m.collects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfitSettings:
		ids := make([]ent.Value, 0, len(m.profit_settings))
		for id := range m.profit_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCostAccount:
		if id := m.cost_account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeProfitAccount:
		if id := m.profit_account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.cost_bills))
		for id := range m.cost_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.earn_bills))
		for id := range m.earn_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.mission_consume_orders))
		for id := range m.mission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.mission_produce_orders))
		for id := range m.mission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.recharge_orders))
		for id := range m.recharge_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVxSocials:
		ids := make([]ent.Value, 0, len(m.vx_socials))
		for id := range m.vx_socials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionBatches:
		ids := make([]ent.Value, 0, len(m.mission_batches))
		for id := range m.mission_batches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.user_devices))
		for id := range m.user_devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedvx_accounts != nil {
		edges = append(edges, user.EdgeVxAccounts)
	}
	if m.removedcollects != nil {
		edges = append(edges, user.EdgeCollects)
	}
	if m.removeddevices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.removedprofit_settings != nil {
		edges = append(edges, user.EdgeProfitSettings)
	}
	if m.removedcost_bills != nil {
		edges = append(edges, user.EdgeCostBills)
	}
	if m.removedearn_bills != nil {
		edges = append(edges, user.EdgeEarnBills)
	}
	if m.removedmission_consume_orders != nil {
		edges = append(edges, user.EdgeMissionConsumeOrders)
	}
	if m.removedmission_produce_orders != nil {
		edges = append(edges, user.EdgeMissionProduceOrders)
	}
	if m.removedrecharge_orders != nil {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.removedvx_socials != nil {
		edges = append(edges, user.EdgeVxSocials)
	}
	if m.removedmission_batches != nil {
		edges = append(edges, user.EdgeMissionBatches)
	}
	if m.removeduser_devices != nil {
		edges = append(edges, user.EdgeUserDevices)
	}
	if m.removedchildren != nil {
		edges = append(edges, user.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVxAccounts:
		ids := make([]ent.Value, 0, len(m.removedvx_accounts))
		for id := range m.removedvx_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCollects:
		ids := make([]ent.Value, 0, len(m.removedcollects))
		for id := range m.removedcollects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfitSettings:
		ids := make([]ent.Value, 0, len(m.removedprofit_settings))
		for id := range m.removedprofit_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCostBills:
		ids := make([]ent.Value, 0, len(m.removedcost_bills))
		for id := range m.removedcost_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEarnBills:
		ids := make([]ent.Value, 0, len(m.removedearn_bills))
		for id := range m.removedearn_bills {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionConsumeOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_consume_orders))
		for id := range m.removedmission_consume_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionProduceOrders:
		ids := make([]ent.Value, 0, len(m.removedmission_produce_orders))
		for id := range m.removedmission_produce_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.removedrecharge_orders))
		for id := range m.removedrecharge_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVxSocials:
		ids := make([]ent.Value, 0, len(m.removedvx_socials))
		for id := range m.removedvx_socials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMissionBatches:
		ids := make([]ent.Value, 0, len(m.removedmission_batches))
		for id := range m.removedmission_batches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDevices:
		ids := make([]ent.Value, 0, len(m.removeduser_devices))
		for id := range m.removeduser_devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedvx_accounts {
		edges = append(edges, user.EdgeVxAccounts)
	}
	if m.clearedcollects {
		edges = append(edges, user.EdgeCollects)
	}
	if m.cleareddevices {
		edges = append(edges, user.EdgeDevices)
	}
	if m.clearedprofit_settings {
		edges = append(edges, user.EdgeProfitSettings)
	}
	if m.clearedcost_account {
		edges = append(edges, user.EdgeCostAccount)
	}
	if m.clearedprofit_account {
		edges = append(edges, user.EdgeProfitAccount)
	}
	if m.clearedcost_bills {
		edges = append(edges, user.EdgeCostBills)
	}
	if m.clearedearn_bills {
		edges = append(edges, user.EdgeEarnBills)
	}
	if m.clearedmission_consume_orders {
		edges = append(edges, user.EdgeMissionConsumeOrders)
	}
	if m.clearedmission_produce_orders {
		edges = append(edges, user.EdgeMissionProduceOrders)
	}
	if m.clearedrecharge_orders {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.clearedvx_socials {
		edges = append(edges, user.EdgeVxSocials)
	}
	if m.clearedmission_batches {
		edges = append(edges, user.EdgeMissionBatches)
	}
	if m.cleareduser_devices {
		edges = append(edges, user.EdgeUserDevices)
	}
	if m.clearedparent {
		edges = append(edges, user.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, user.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeVxAccounts:
		return m.clearedvx_accounts
	case user.EdgeCollects:
		return m.clearedcollects
	case user.EdgeDevices:
		return m.cleareddevices
	case user.EdgeProfitSettings:
		return m.clearedprofit_settings
	case user.EdgeCostAccount:
		return m.clearedcost_account
	case user.EdgeProfitAccount:
		return m.clearedprofit_account
	case user.EdgeCostBills:
		return m.clearedcost_bills
	case user.EdgeEarnBills:
		return m.clearedearn_bills
	case user.EdgeMissionConsumeOrders:
		return m.clearedmission_consume_orders
	case user.EdgeMissionProduceOrders:
		return m.clearedmission_produce_orders
	case user.EdgeRechargeOrders:
		return m.clearedrecharge_orders
	case user.EdgeVxSocials:
		return m.clearedvx_socials
	case user.EdgeMissionBatches:
		return m.clearedmission_batches
	case user.EdgeUserDevices:
		return m.cleareduser_devices
	case user.EdgeParent:
		return m.clearedparent
	case user.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCostAccount:
		m.ClearCostAccount()
		return nil
	case user.EdgeProfitAccount:
		m.ClearProfitAccount()
		return nil
	case user.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeVxAccounts:
		m.ResetVxAccounts()
		return nil
	case user.EdgeCollects:
		m.ResetCollects()
		return nil
	case user.EdgeDevices:
		m.ResetDevices()
		return nil
	case user.EdgeProfitSettings:
		m.ResetProfitSettings()
		return nil
	case user.EdgeCostAccount:
		m.ResetCostAccount()
		return nil
	case user.EdgeProfitAccount:
		m.ResetProfitAccount()
		return nil
	case user.EdgeCostBills:
		m.ResetCostBills()
		return nil
	case user.EdgeEarnBills:
		m.ResetEarnBills()
		return nil
	case user.EdgeMissionConsumeOrders:
		m.ResetMissionConsumeOrders()
		return nil
	case user.EdgeMissionProduceOrders:
		m.ResetMissionProduceOrders()
		return nil
	case user.EdgeRechargeOrders:
		m.ResetRechargeOrders()
		return nil
	case user.EdgeVxSocials:
		m.ResetVxSocials()
		return nil
	case user.EdgeMissionBatches:
		m.ResetMissionBatches()
		return nil
	case user.EdgeUserDevices:
		m.ResetUserDevices()
		return nil
	case user.EdgeParent:
		m.ResetParent()
		return nil
	case user.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDeviceMutation represents an operation that mutates the UserDevice nodes in the graph.
type UserDeviceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	device        *int64
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*UserDevice, error)
	predicates    []predicate.UserDevice
}

var _ ent.Mutation = (*UserDeviceMutation)(nil)

// userdeviceOption allows management of the mutation configuration using functional options.
type userdeviceOption func(*UserDeviceMutation)

// newUserDeviceMutation creates new mutation for the UserDevice entity.
func newUserDeviceMutation(c config, op Op, opts ...userdeviceOption) *UserDeviceMutation {
	m := &UserDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDeviceID sets the ID field of the mutation.
func withUserDeviceID(id int64) userdeviceOption {
	return func(m *UserDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDevice
		)
		m.oldValue = func(ctx context.Context) (*UserDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDevice sets the old UserDevice of the mutation.
func withUserDevice(node *UserDevice) userdeviceOption {
	return func(m *UserDeviceMutation) {
		m.oldValue = func(context.Context) (*UserDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserDevice entities.
func (m *UserDeviceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDeviceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserDeviceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserDeviceMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserDeviceMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserDeviceMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserDeviceMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserDeviceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserDeviceMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserDeviceMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserDeviceMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserDeviceMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserDeviceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserDeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserDeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserDeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserDeviceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserDeviceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserDeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserDeviceMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserDeviceMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserDeviceMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceID sets the "device_id" field.
func (m *UserDeviceMutation) SetDeviceID(i int64) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *UserDeviceMutation) DeviceID() (r int64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *UserDeviceMutation) ResetDeviceID() {
	m.device = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserDeviceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userdevice.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserDeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserDeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *UserDeviceMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[userdevice.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *UserDeviceMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) DeviceIDs() (ids []int64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *UserDeviceMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the UserDeviceMutation builder.
func (m *UserDeviceMutation) Where(ps ...predicate.UserDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserDevice).
func (m *UserDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDeviceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userdevice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userdevice.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.device != nil {
		fields = append(fields, userdevice.FieldDeviceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.CreatedBy()
	case userdevice.FieldUpdatedBy:
		return m.UpdatedBy()
	case userdevice.FieldCreatedAt:
		return m.CreatedAt()
	case userdevice.FieldUpdatedAt:
		return m.UpdatedAt()
	case userdevice.FieldDeletedAt:
		return m.DeletedAt()
	case userdevice.FieldUserID:
		return m.UserID()
	case userdevice.FieldDeviceID:
		return m.DeviceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userdevice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userdevice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userdevice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userdevice.FieldUserID:
		return m.OldUserID(ctx)
	case userdevice.FieldDeviceID:
		return m.OldDeviceID(ctx)
	}
	return nil, fmt.Errorf("unknown UserDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userdevice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userdevice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userdevice.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdevice.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userdevice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDeviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDeviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDeviceMutation) ResetField(name string) error {
	switch name {
	case userdevice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userdevice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userdevice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userdevice.FieldUserID:
		m.ResetUserID()
		return nil
	case userdevice.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userdevice.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, userdevice.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userdevice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userdevice.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userdevice.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, userdevice.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case userdevice.EdgeUser:
		return m.cleareduser
	case userdevice.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDeviceMutation) ClearEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ClearUser()
		return nil
	case userdevice.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown UserDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDeviceMutation) ResetEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ResetUser()
		return nil
	case userdevice.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown UserDevice edge %s", name)
}

// VXAccountMutation represents an operation that mutates the VXAccount nodes in the graph.
type VXAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	open_id       *string
	union_id      *string
	scope         *string
	session_key   *string
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*VXAccount, error)
	predicates    []predicate.VXAccount
}

var _ ent.Mutation = (*VXAccountMutation)(nil)

// vxaccountOption allows management of the mutation configuration using functional options.
type vxaccountOption func(*VXAccountMutation)

// newVXAccountMutation creates new mutation for the VXAccount entity.
func newVXAccountMutation(c config, op Op, opts ...vxaccountOption) *VXAccountMutation {
	m := &VXAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeVXAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVXAccountID sets the ID field of the mutation.
func withVXAccountID(id int64) vxaccountOption {
	return func(m *VXAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *VXAccount
		)
		m.oldValue = func(ctx context.Context) (*VXAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VXAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVXAccount sets the old VXAccount of the mutation.
func withVXAccount(node *VXAccount) vxaccountOption {
	return func(m *VXAccountMutation) {
		m.oldValue = func(context.Context) (*VXAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VXAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VXAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VXAccount entities.
func (m *VXAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VXAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VXAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VXAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *VXAccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VXAccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VXAccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VXAccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VXAccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VXAccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VXAccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VXAccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VXAccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VXAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VXAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VXAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VXAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VXAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VXAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VXAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VXAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VXAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VXAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetOpenID sets the "open_id" field.
func (m *VXAccountMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *VXAccountMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *VXAccountMutation) ResetOpenID() {
	m.open_id = nil
}

// SetUnionID sets the "union_id" field.
func (m *VXAccountMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *VXAccountMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *VXAccountMutation) ResetUnionID() {
	m.union_id = nil
}

// SetScope sets the "scope" field.
func (m *VXAccountMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *VXAccountMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *VXAccountMutation) ResetScope() {
	m.scope = nil
}

// SetSessionKey sets the "session_key" field.
func (m *VXAccountMutation) SetSessionKey(s string) {
	m.session_key = &s
}

// SessionKey returns the value of the "session_key" field in the mutation.
func (m *VXAccountMutation) SessionKey() (r string, exists bool) {
	v := m.session_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionKey returns the old "session_key" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldSessionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionKey: %w", err)
	}
	return oldValue.SessionKey, nil
}

// ResetSessionKey resets all changes to the "session_key" field.
func (m *VXAccountMutation) ResetSessionKey() {
	m.session_key = nil
}

// SetUserID sets the "user_id" field.
func (m *VXAccountMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VXAccountMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VXAccount entity.
// If the VXAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXAccountMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VXAccountMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *VXAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[vxaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VXAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VXAccountMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VXAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VXAccountMutation builder.
func (m *VXAccountMutation) Where(ps ...predicate.VXAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VXAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VXAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VXAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VXAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VXAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VXAccount).
func (m *VXAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VXAccountMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, vxaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, vxaccount.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, vxaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vxaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vxaccount.FieldDeletedAt)
	}
	if m.open_id != nil {
		fields = append(fields, vxaccount.FieldOpenID)
	}
	if m.union_id != nil {
		fields = append(fields, vxaccount.FieldUnionID)
	}
	if m.scope != nil {
		fields = append(fields, vxaccount.FieldScope)
	}
	if m.session_key != nil {
		fields = append(fields, vxaccount.FieldSessionKey)
	}
	if m.user != nil {
		fields = append(fields, vxaccount.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VXAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vxaccount.FieldCreatedBy:
		return m.CreatedBy()
	case vxaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case vxaccount.FieldCreatedAt:
		return m.CreatedAt()
	case vxaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case vxaccount.FieldDeletedAt:
		return m.DeletedAt()
	case vxaccount.FieldOpenID:
		return m.OpenID()
	case vxaccount.FieldUnionID:
		return m.UnionID()
	case vxaccount.FieldScope:
		return m.Scope()
	case vxaccount.FieldSessionKey:
		return m.SessionKey()
	case vxaccount.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VXAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vxaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vxaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vxaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vxaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vxaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vxaccount.FieldOpenID:
		return m.OldOpenID(ctx)
	case vxaccount.FieldUnionID:
		return m.OldUnionID(ctx)
	case vxaccount.FieldScope:
		return m.OldScope(ctx)
	case vxaccount.FieldSessionKey:
		return m.OldSessionKey(ctx)
	case vxaccount.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown VXAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vxaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vxaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vxaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vxaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vxaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vxaccount.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case vxaccount.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	case vxaccount.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case vxaccount.FieldSessionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionKey(v)
		return nil
	case vxaccount.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown VXAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VXAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vxaccount.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vxaccount.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VXAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vxaccount.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vxaccount.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vxaccount.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vxaccount.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VXAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VXAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VXAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VXAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VXAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VXAccountMutation) ResetField(name string) error {
	switch name {
	case vxaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vxaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vxaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vxaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vxaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vxaccount.FieldOpenID:
		m.ResetOpenID()
		return nil
	case vxaccount.FieldUnionID:
		m.ResetUnionID()
		return nil
	case vxaccount.FieldScope:
		m.ResetScope()
		return nil
	case vxaccount.FieldSessionKey:
		m.ResetSessionKey()
		return nil
	case vxaccount.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown VXAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VXAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, vxaccount.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VXAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vxaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VXAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VXAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VXAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, vxaccount.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VXAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case vxaccount.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VXAccountMutation) ClearEdge(name string) error {
	switch name {
	case vxaccount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown VXAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VXAccountMutation) ResetEdge(name string) error {
	switch name {
	case vxaccount.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown VXAccount edge %s", name)
}

// VXSocialMutation represents an operation that mutates the VXSocial nodes in the graph.
type VXSocialMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_by             *int64
	addcreated_by          *int64
	updated_by             *int64
	addupdated_by          *int64
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	app_id                 *string
	open_id                *string
	union_id               *string
	scope                  *vxsocial.Scope
	session_key            *string
	access_token           *string
	refresh_token          *string
	clearedFields          map[string]struct{}
	user                   *int64
	cleareduser            bool
	recharge_orders        map[int64]struct{}
	removedrecharge_orders map[int64]struct{}
	clearedrecharge_orders bool
	done                   bool
	oldValue               func(context.Context) (*VXSocial, error)
	predicates             []predicate.VXSocial
}

var _ ent.Mutation = (*VXSocialMutation)(nil)

// vxsocialOption allows management of the mutation configuration using functional options.
type vxsocialOption func(*VXSocialMutation)

// newVXSocialMutation creates new mutation for the VXSocial entity.
func newVXSocialMutation(c config, op Op, opts ...vxsocialOption) *VXSocialMutation {
	m := &VXSocialMutation{
		config:        c,
		op:            op,
		typ:           TypeVXSocial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVXSocialID sets the ID field of the mutation.
func withVXSocialID(id int64) vxsocialOption {
	return func(m *VXSocialMutation) {
		var (
			err   error
			once  sync.Once
			value *VXSocial
		)
		m.oldValue = func(ctx context.Context) (*VXSocial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VXSocial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVXSocial sets the old VXSocial of the mutation.
func withVXSocial(node *VXSocial) vxsocialOption {
	return func(m *VXSocialMutation) {
		m.oldValue = func(context.Context) (*VXSocial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VXSocialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VXSocialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("cep_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VXSocial entities.
func (m *VXSocialMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VXSocialMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VXSocialMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VXSocial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *VXSocialMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VXSocialMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VXSocialMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VXSocialMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VXSocialMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VXSocialMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VXSocialMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VXSocialMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VXSocialMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VXSocialMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VXSocialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VXSocialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VXSocialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VXSocialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VXSocialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VXSocialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VXSocialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VXSocialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VXSocialMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *VXSocialMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *VXSocialMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *VXSocialMutation) ResetAppID() {
	m.app_id = nil
}

// SetOpenID sets the "open_id" field.
func (m *VXSocialMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *VXSocialMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *VXSocialMutation) ResetOpenID() {
	m.open_id = nil
}

// SetUnionID sets the "union_id" field.
func (m *VXSocialMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *VXSocialMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *VXSocialMutation) ResetUnionID() {
	m.union_id = nil
}

// SetScope sets the "scope" field.
func (m *VXSocialMutation) SetScope(v vxsocial.Scope) {
	m.scope = &v
}

// Scope returns the value of the "scope" field in the mutation.
func (m *VXSocialMutation) Scope() (r vxsocial.Scope, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldScope(ctx context.Context) (v vxsocial.Scope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *VXSocialMutation) ResetScope() {
	m.scope = nil
}

// SetSessionKey sets the "session_key" field.
func (m *VXSocialMutation) SetSessionKey(s string) {
	m.session_key = &s
}

// SessionKey returns the value of the "session_key" field in the mutation.
func (m *VXSocialMutation) SessionKey() (r string, exists bool) {
	v := m.session_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionKey returns the old "session_key" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldSessionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionKey: %w", err)
	}
	return oldValue.SessionKey, nil
}

// ResetSessionKey resets all changes to the "session_key" field.
func (m *VXSocialMutation) ResetSessionKey() {
	m.session_key = nil
}

// SetAccessToken sets the "access_token" field.
func (m *VXSocialMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *VXSocialMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *VXSocialMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *VXSocialMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *VXSocialMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *VXSocialMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetUserID sets the "user_id" field.
func (m *VXSocialMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VXSocialMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VXSocial entity.
// If the VXSocial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VXSocialMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VXSocialMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *VXSocialMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[vxsocial.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VXSocialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VXSocialMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VXSocialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddRechargeOrderIDs adds the "recharge_orders" edge to the RechargeOrder entity by ids.
func (m *VXSocialMutation) AddRechargeOrderIDs(ids ...int64) {
	if m.recharge_orders == nil {
		m.recharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.recharge_orders[ids[i]] = struct{}{}
	}
}

// ClearRechargeOrders clears the "recharge_orders" edge to the RechargeOrder entity.
func (m *VXSocialMutation) ClearRechargeOrders() {
	m.clearedrecharge_orders = true
}

// RechargeOrdersCleared reports if the "recharge_orders" edge to the RechargeOrder entity was cleared.
func (m *VXSocialMutation) RechargeOrdersCleared() bool {
	return m.clearedrecharge_orders
}

// RemoveRechargeOrderIDs removes the "recharge_orders" edge to the RechargeOrder entity by IDs.
func (m *VXSocialMutation) RemoveRechargeOrderIDs(ids ...int64) {
	if m.removedrecharge_orders == nil {
		m.removedrecharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.recharge_orders, ids[i])
		m.removedrecharge_orders[ids[i]] = struct{}{}
	}
}

// RemovedRechargeOrders returns the removed IDs of the "recharge_orders" edge to the RechargeOrder entity.
func (m *VXSocialMutation) RemovedRechargeOrdersIDs() (ids []int64) {
	for id := range m.removedrecharge_orders {
		ids = append(ids, id)
	}
	return
}

// RechargeOrdersIDs returns the "recharge_orders" edge IDs in the mutation.
func (m *VXSocialMutation) RechargeOrdersIDs() (ids []int64) {
	for id := range m.recharge_orders {
		ids = append(ids, id)
	}
	return
}

// ResetRechargeOrders resets all changes to the "recharge_orders" edge.
func (m *VXSocialMutation) ResetRechargeOrders() {
	m.recharge_orders = nil
	m.clearedrecharge_orders = false
	m.removedrecharge_orders = nil
}

// Where appends a list predicates to the VXSocialMutation builder.
func (m *VXSocialMutation) Where(ps ...predicate.VXSocial) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VXSocialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VXSocialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VXSocial, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VXSocialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VXSocialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VXSocial).
func (m *VXSocialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VXSocialMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, vxsocial.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, vxsocial.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, vxsocial.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vxsocial.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vxsocial.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, vxsocial.FieldAppID)
	}
	if m.open_id != nil {
		fields = append(fields, vxsocial.FieldOpenID)
	}
	if m.union_id != nil {
		fields = append(fields, vxsocial.FieldUnionID)
	}
	if m.scope != nil {
		fields = append(fields, vxsocial.FieldScope)
	}
	if m.session_key != nil {
		fields = append(fields, vxsocial.FieldSessionKey)
	}
	if m.access_token != nil {
		fields = append(fields, vxsocial.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, vxsocial.FieldRefreshToken)
	}
	if m.user != nil {
		fields = append(fields, vxsocial.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VXSocialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vxsocial.FieldCreatedBy:
		return m.CreatedBy()
	case vxsocial.FieldUpdatedBy:
		return m.UpdatedBy()
	case vxsocial.FieldCreatedAt:
		return m.CreatedAt()
	case vxsocial.FieldUpdatedAt:
		return m.UpdatedAt()
	case vxsocial.FieldDeletedAt:
		return m.DeletedAt()
	case vxsocial.FieldAppID:
		return m.AppID()
	case vxsocial.FieldOpenID:
		return m.OpenID()
	case vxsocial.FieldUnionID:
		return m.UnionID()
	case vxsocial.FieldScope:
		return m.Scope()
	case vxsocial.FieldSessionKey:
		return m.SessionKey()
	case vxsocial.FieldAccessToken:
		return m.AccessToken()
	case vxsocial.FieldRefreshToken:
		return m.RefreshToken()
	case vxsocial.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VXSocialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vxsocial.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vxsocial.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vxsocial.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vxsocial.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vxsocial.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vxsocial.FieldAppID:
		return m.OldAppID(ctx)
	case vxsocial.FieldOpenID:
		return m.OldOpenID(ctx)
	case vxsocial.FieldUnionID:
		return m.OldUnionID(ctx)
	case vxsocial.FieldScope:
		return m.OldScope(ctx)
	case vxsocial.FieldSessionKey:
		return m.OldSessionKey(ctx)
	case vxsocial.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case vxsocial.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case vxsocial.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown VXSocial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXSocialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vxsocial.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vxsocial.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vxsocial.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vxsocial.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vxsocial.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vxsocial.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case vxsocial.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case vxsocial.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	case vxsocial.FieldScope:
		v, ok := value.(vxsocial.Scope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case vxsocial.FieldSessionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionKey(v)
		return nil
	case vxsocial.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case vxsocial.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case vxsocial.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown VXSocial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VXSocialMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vxsocial.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vxsocial.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VXSocialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vxsocial.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vxsocial.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VXSocialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vxsocial.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vxsocial.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VXSocial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VXSocialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VXSocialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VXSocialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VXSocial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VXSocialMutation) ResetField(name string) error {
	switch name {
	case vxsocial.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vxsocial.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vxsocial.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vxsocial.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vxsocial.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vxsocial.FieldAppID:
		m.ResetAppID()
		return nil
	case vxsocial.FieldOpenID:
		m.ResetOpenID()
		return nil
	case vxsocial.FieldUnionID:
		m.ResetUnionID()
		return nil
	case vxsocial.FieldScope:
		m.ResetScope()
		return nil
	case vxsocial.FieldSessionKey:
		m.ResetSessionKey()
		return nil
	case vxsocial.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case vxsocial.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case vxsocial.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown VXSocial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VXSocialMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, vxsocial.EdgeUser)
	}
	if m.recharge_orders != nil {
		edges = append(edges, vxsocial.EdgeRechargeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VXSocialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vxsocial.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case vxsocial.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.recharge_orders))
		for id := range m.recharge_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VXSocialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrecharge_orders != nil {
		edges = append(edges, vxsocial.EdgeRechargeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VXSocialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vxsocial.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.removedrecharge_orders))
		for id := range m.removedrecharge_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VXSocialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, vxsocial.EdgeUser)
	}
	if m.clearedrecharge_orders {
		edges = append(edges, vxsocial.EdgeRechargeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VXSocialMutation) EdgeCleared(name string) bool {
	switch name {
	case vxsocial.EdgeUser:
		return m.cleareduser
	case vxsocial.EdgeRechargeOrders:
		return m.clearedrecharge_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VXSocialMutation) ClearEdge(name string) error {
	switch name {
	case vxsocial.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown VXSocial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VXSocialMutation) ResetEdge(name string) error {
	switch name {
	case vxsocial.EdgeUser:
		m.ResetUser()
		return nil
	case vxsocial.EdgeRechargeOrders:
		m.ResetRechargeOrders()
		return nil
	}
	return fmt.Errorf("unknown VXSocial edge %s", name)
}
